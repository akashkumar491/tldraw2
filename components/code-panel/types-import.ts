/* eslint-disable */

// HEY! DO NOT MODIFY THIS FILE. THE CONTENTS OF THIS FILE
// ARE AUTO-GENERATED BY A SCRIPT AT: /scripts/type-gen.js
// ANY CHANGES WILL BE LOST WHEN THE SCRIPT RUNS AGAIN!

export default {
  name: 'types.ts',
  content: `

type DeepPartial<T> = {
  [P in keyof T]?: DeepPartial<T[P]>;
};



enum ShapeType {
  Dot = 'dot',
  Ellipse = 'ellipse',
  Line = 'line',
  Ray = 'ray',
  Polyline = 'polyline',
  Rectangle = 'rectangle',
  Draw = 'draw',
  Arrow = 'arrow',
  Text = 'text',
  Group = 'group',
}

enum ColorStyle {
  White = 'White',
  LightGray = 'LightGray',
  Gray = 'Gray',
  Black = 'Black',
  Green = 'Green',
  Cyan = 'Cyan',
  Blue = 'Blue',
  Indigo = 'Indigo',
  Violet = 'Violet',
  Red = 'Red',
  Orange = 'Orange',
  Yellow = 'Yellow',
}

enum SizeStyle {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
}

enum DashStyle {
  Draw = 'Draw',
  Solid = 'Solid',
  Dashed = 'Dashed',
  Dotted = 'Dotted',
}

enum FontSize {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
  ExtraLarge = 'ExtraLarge',
}

type ShapeStyles = {
  color: ColorStyle
  size: SizeStyle
  dash: DashStyle
  isFilled: boolean
}

interface BaseShape {
  id: string
  type: ShapeType
  parentId: string
  childIndex: number
  name: string
  point: number[]
  style: ShapeStyles
  rotation: number
  children?: string[]
  points?: number[][]
  handles?: Record<string, ShapeHandle<ShapeBinding>>
  isLocked?: boolean
  isHidden?: boolean
  isEditing?: boolean
  isGenerated?: boolean
  isAspectRatioLocked?: boolean
}

interface DotShape extends BaseShape {
  type: ShapeType.Dot
}

interface EllipseShape extends BaseShape {
  type: ShapeType.Ellipse
  radiusX: number
  radiusY: number
}

interface LineShape extends BaseShape {
  type: ShapeType.Line
  direction: number[]
}

interface RayShape extends BaseShape {
  type: ShapeType.Ray
  direction: number[]
}

interface PolylineShape extends BaseShape {
  type: ShapeType.Polyline
  points: number[][]
}

interface RectangleShape extends BaseShape {
  type: ShapeType.Rectangle
  size: number[]
  radius: number
}

interface DrawShape extends BaseShape {
  type: ShapeType.Draw
  points: number[][]
}

interface ArrowShape extends BaseShape {
  type: ShapeType.Arrow
  bend: number
  handles: {
    start: ShapeHandle<DirectionShapeBinding>
    bend: ShapeHandle
    end: ShapeHandle<DirectionShapeBinding>
  }
  decorations?: {
    start: Decoration
    end: Decoration
    middle: Decoration
  }
}

interface TextShape extends BaseShape {
  type: ShapeType.Text
  text: string
  scale: number
}

interface GroupShape extends BaseShape {
  type: ShapeType.Group
  children: string[]
  size: number[]
}

type Shape =
  | DotShape
  | EllipseShape
  | LineShape
  | RayShape
  | PolylineShape
  | RectangleShape
  | DrawShape
  | ArrowShape
  | TextShape
  | GroupShape

interface RectangleShape extends BaseShape {
  type: ShapeType.Rectangle
  size: number[]
  radius: number
}

interface DrawShape extends BaseShape {
  type: ShapeType.Draw
  points: number[][]
}

type MappedByType<U extends string, T extends { type: U }> = {
  [P in T['type']]: T extends any ? (P extends T['type'] ? T : never) : never
}

type MutableShapes = MappedByType<ShapeType, Shape>

type ReadonlyMap<T> = { [P in keyof T]: Readonly<T[P]> }

type Shapes = ReadonlyMap<MutableShapes>

type ShapeByType<T extends keyof Shapes> = Shapes[T]

type ShapeProps<T extends Shape> = {
  [P in keyof T]?: P extends 'style' ? Partial<T[P]> : T[P]
}

/* -------- Decorations, Handles and Bindings ------- */

enum Decoration {
  Arrow = 'Arrow',
}

enum BindingType {
  Direction = 'Direction',
  Pin = 'Pin',
}

interface DirectionShapeBinding {
  type: BindingType.Direction
  shapeId?: string
  opposite: string
}

interface PointShapeBinding {
  type: BindingType.Pin
  shapeId?: string
}

interface ShapeHandle<Binding extends ShapeBinding = any> {
  id: string
  index: number
  point: number[]
  binding?: Binding
}

type ShapeBinding = DirectionShapeBinding | PointShapeBinding

/* ------------------ Types by Prop ----------------- */

type RequiredKeys<T> = {
  [K in keyof T]-?: Difference<Record<string, unknown>, Pick<T, K>, K>
}[keyof T]

type MembersWithRequiredKey<T, U> = {
  [P in keyof T]: Intersection<U, RequiredKeys<T[P]>, T[P]>
}[keyof T]

type ShapesWithProp<U> = MembersWithRequiredKey<MutableShapes, U>

type ShapesWithHandles = ShapesWithProp<'handles'>

type ShapesWithPoints = ShapesWithProp<'points'>

type ParentShape = ShapesWithProp<'children'>

type ParentTypes = ParentShape['type'] | 'page'

/* -------------------------------------------------- */
/*                      Editor UI                     */
/* -------------------------------------------------- */

interface PointerInfo<T extends string = any> {
  target: T
  pointerId: number
  origin: number[]
  point: number[]
  pressure: number
  shiftKey: boolean
  ctrlKey: boolean
  metaKey: boolean
  altKey: boolean
}

interface KeyboardInfo {
  key: string
  keys: string[]
  shiftKey: boolean
  ctrlKey: boolean
  metaKey: boolean
  altKey: boolean
}

enum Edge {
  Top = 'top_edge',
  Right = 'right_edge',
  Bottom = 'bottom_edge',
  Left = 'left_edge',
}

enum Corner {
  TopLeft = 'top_left_corner',
  TopRight = 'top_right_corner',
  BottomRight = 'bottom_right_corner',
  BottomLeft = 'bottom_left_corner',
}

interface Bounds {
  minX: number
  minY: number
  maxX: number
  maxY: number
  width: number
  height: number
  rotation?: number
}

interface RotatedBounds extends Bounds {
  rotation: number
}

interface ShapeBounds extends Bounds {
  id: string
}

interface PointSnapshot extends Bounds {
  nx: number
  nmx: number
  ny: number
  nmy: number
}

interface BoundsSnapshot extends PointSnapshot {
  nw: number
  nh: number
}

type ShapeSpecificProps<T extends Shape> = Pick<
  T,
  Difference<keyof T, keyof BaseShape>
>

type ShapeIndicatorProps<T extends Shape> = ShapeSpecificProps<T>

enum MoveType {
  Backward,
  Forward,
  ToFront,
  ToBack,
}

enum AlignType {
  Top,
  CenterVertical,
  Bottom,
  Left,
  CenterHorizontal,
  Right,
}

enum StretchType {
  Horizontal,
  Vertical,
}

enum DistributeType {
  Horizontal,
  Vertical,
}

interface BezierCurveSegment {
  start: number[]
  tangentStart: number[]
  normalStart: number[]
  pressureStart: number
  end: number[]
  tangentEnd: number[]
  normalEnd: number[]
  pressureEnd: number
}

/* -------------------------------------------------- */
/*                     Code Editor                    */
/* -------------------------------------------------- */

enum ControlType {
  Number = 'number',
  Vector = 'vector',
  Text = 'text',
  Select = 'select',
}

interface BaseCodeControl {
  id: string
  type: ControlType
  label: string
}

interface NumberCodeControl extends BaseCodeControl {
  type: ControlType.Number
  value: number
  min?: number
  max?: number
  step?: number
  format?: (value: number) => number
}

interface VectorCodeControl extends BaseCodeControl {
  type: ControlType.Vector
  value: number[]
  min?: number
  max?: number
  step?: number
  isNormalized?: boolean
  format?: (value: number[]) => number[]
}

interface TextCodeControl extends BaseCodeControl {
  type: ControlType.Text
  value: string
  format?: (value: string) => string
}

interface SelectCodeControl<T extends string = ''>
  extends BaseCodeControl {
  type: ControlType.Select
  value: T
  options: T[]
  format?: (string: T) => string
}

type CodeControl =
  | NumberCodeControl
  | VectorCodeControl
  | TextCodeControl

type PropsOfType<T extends Shape, U> = {
  [K in keyof T]: T[K] extends any ? (T[K] extends U ? K : never) : never
}[keyof T]

type Mutable<T extends Shape> = { -readonly [K in keyof T]: T[K] }

interface ShapeUtility<K extends Shape> {
  // Default properties when creating a new shape
  defaultProps: K

  // A cache for the computed bounds of this kind of shape.
  boundsCache: WeakMap<K, Bounds>

  // Whether to show transform controls when this shape is selected.
  canTransform: boolean

  // Whether the shape's aspect ratio can change.
  canChangeAspectRatio: boolean

  // Whether the shape's style can be filled.
  canStyleFill: boolean

  // Whether the shape may be bound to.
  canBind: boolean

  // Whether the shape may be edited in an editing mode
  canEdit: boolean

  // Whether the shape is a foreign object.
  isForeignObject: boolean

  // Whether the shape can contain other shapes.
  isParent: boolean

  // Whether the shape is only shown when on hovered.
  isShy: boolean

  // Create a new shape.
  create(this: ShapeUtility<K>, props: Partial<K>): K

  // Update a shape's styles
  applyStyles(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    style: Partial<ShapeStyles>
  ): ShapeUtility<K>

  translateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  translateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  rotateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number
  ): ShapeUtility<K>

  rotateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number,
    delta: number
  ): ShapeUtility<K>

  // Transform to fit a new bounding box when more than one shape is selected.
  transform(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  // Transform a single shape to fit a new bounding box.
  transformSingle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  setProperty<P extends keyof K>(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    prop: P,
    value: K[P]
  ): ShapeUtility<K>

  // Respond when any child of this shape changes.
  onChildrenChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    children: Shape[]
  ): ShapeUtility<K>

  // Given a point and a direction, return the shape's bound point.
  getBindingPoint(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[],
    direction: number[]
  ): number[] | undefined

  // Respond when a user moves one of the shape's bound elements.
  onBindingChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bindings: Record<string, ShapeBinding>
  ): ShapeUtility<K>

  // Respond when a user moves one of the shape's handles.
  onHandleChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: Partial<K['handles']>,
    info?: Partial<{
      delta: number[]
      shiftKey: boolean
      altKey: boolean
      metaKey: boolean
    }>
  ): ShapeUtility<K>

  onDoublePointHandle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: keyof K['handles'],
    info: PointerInfo
  ): ShapeUtility<K>

  // Respond when a user double clicks the shape's bounds.
  onBoundsReset(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Respond when a user double clicks the center of the shape.
  onDoubleFocus(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Clean up changes when a session ends.
  onSessionComplete(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Render a shape to JSX.
  render(
    this: ShapeUtility<K>,
    shape: K,
    info?: {
      isEditing?: boolean
      isHovered?: boolean
      isSelected?: boolean
      isCurrentParent?: boolean
      isDarkMode?: boolean
      ref?: React.MutableRefObject<HTMLTextAreaElement>
    }
  ): JSX.Element

  invalidate(this: ShapeUtility<K>, shape: K): ShapeUtility<K>

  // Get the bounds of the a shape.
  getBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the routated bounds of the a shape.
  getRotatedBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the center of the shape
  getCenter(this: ShapeUtility<K>, shape: K): number[]

  // Test whether a point lies within a shape.
  hitTest(this: ShapeUtility<K>, shape: K, test: number[]): boolean

  // Test whether bounds collide with or contain a shape.
  hitTestBounds(this: ShapeUtility<K>, shape: K, bounds: Bounds): boolean

  // Get whether the shape should delete
  shouldDelete(this: ShapeUtility<K>, shape: K): boolean

  // Get whether the shape should render
  shouldRender(this: ShapeUtility<K>, shape: K, previous: K): boolean
}




enum ShapeType {
  Dot = 'dot',
  Ellipse = 'ellipse',
  Line = 'line',
  Ray = 'ray',
  Polyline = 'polyline',
  Rectangle = 'rectangle',
  Draw = 'draw',
  Arrow = 'arrow',
  Text = 'text',
  Group = 'group',
}

enum ColorStyle {
  White = 'White',
  LightGray = 'LightGray',
  Gray = 'Gray',
  Black = 'Black',
  Green = 'Green',
  Cyan = 'Cyan',
  Blue = 'Blue',
  Indigo = 'Indigo',
  Violet = 'Violet',
  Red = 'Red',
  Orange = 'Orange',
  Yellow = 'Yellow',
}

enum SizeStyle {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
}

enum DashStyle {
  Draw = 'Draw',
  Solid = 'Solid',
  Dashed = 'Dashed',
  Dotted = 'Dotted',
}

enum FontSize {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
  ExtraLarge = 'ExtraLarge',
}

type ShapeStyles = {
  color: ColorStyle
  size: SizeStyle
  dash: DashStyle
  isFilled: boolean
}

interface BaseShape {
  id: string
  type: ShapeType
  parentId: string
  childIndex: number
  name: string
  point: number[]
  style: ShapeStyles
  rotation: number
  children?: string[]
  points?: number[][]
  handles?: Record<string, ShapeHandle<ShapeBinding>>
  isLocked?: boolean
  isHidden?: boolean
  isEditing?: boolean
  isGenerated?: boolean
  isAspectRatioLocked?: boolean
}

interface DotShape extends BaseShape {
  type: ShapeType.Dot
}

interface EllipseShape extends BaseShape {
  type: ShapeType.Ellipse
  radiusX: number
  radiusY: number
}

interface LineShape extends BaseShape {
  type: ShapeType.Line
  direction: number[]
}

interface RayShape extends BaseShape {
  type: ShapeType.Ray
  direction: number[]
}

interface PolylineShape extends BaseShape {
  type: ShapeType.Polyline
  points: number[][]
}

interface RectangleShape extends BaseShape {
  type: ShapeType.Rectangle
  size: number[]
  radius: number
}

interface DrawShape extends BaseShape {
  type: ShapeType.Draw
  points: number[][]
}

interface ArrowShape extends BaseShape {
  type: ShapeType.Arrow
  bend: number
  handles: {
    start: ShapeHandle<DirectionShapeBinding>
    bend: ShapeHandle
    end: ShapeHandle<DirectionShapeBinding>
  }
  decorations?: {
    start: Decoration
    end: Decoration
    middle: Decoration
  }
}

interface TextShape extends BaseShape {
  type: ShapeType.Text
  text: string
  scale: number
}

interface GroupShape extends BaseShape {
  type: ShapeType.Group
  children: string[]
  size: number[]
}

type Shape =
  | DotShape
  | EllipseShape
  | LineShape
  | RayShape
  | PolylineShape
  | RectangleShape
  | DrawShape
  | ArrowShape
  | TextShape
  | GroupShape

interface RectangleShape extends BaseShape {
  type: ShapeType.Rectangle
  size: number[]
  radius: number
}

interface DrawShape extends BaseShape {
  type: ShapeType.Draw
  points: number[][]
}

type MappedByType<U extends string, T extends { type: U }> = {
  [P in T['type']]: T extends any ? (P extends T['type'] ? T : never) : never
}

type MutableShapes = MappedByType<ShapeType, Shape>

type ReadonlyMap<T> = { [P in keyof T]: Readonly<T[P]> }

type Shapes = ReadonlyMap<MutableShapes>

type ShapeByType<T extends keyof Shapes> = Shapes[T]

type ShapeProps<T extends Shape> = {
  [P in keyof T]?: P extends 'style' ? Partial<T[P]> : T[P]
}

/* -------- Decorations, Handles and Bindings ------- */

enum Decoration {
  Arrow = 'Arrow',
}

enum BindingType {
  Direction = 'Direction',
  Pin = 'Pin',
}

interface DirectionShapeBinding {
  type: BindingType.Direction
  shapeId?: string
  opposite: string
}

interface PointShapeBinding {
  type: BindingType.Pin
  shapeId?: string
}

interface ShapeHandle<Binding extends ShapeBinding = any> {
  id: string
  index: number
  point: number[]
  binding?: Binding
}

type ShapeBinding = DirectionShapeBinding | PointShapeBinding

/* ------------------ Types by Prop ----------------- */

type RequiredKeys<T> = {
  [K in keyof T]-?: Difference<Record<string, unknown>, Pick<T, K>, K>
}[keyof T]

type MembersWithRequiredKey<T, U> = {
  [P in keyof T]: Intersection<U, RequiredKeys<T[P]>, T[P]>
}[keyof T]

type ShapesWithProp<U> = MembersWithRequiredKey<MutableShapes, U>

type ShapesWithHandles = ShapesWithProp<'handles'>

type ShapesWithPoints = ShapesWithProp<'points'>

type ParentShape = ShapesWithProp<'children'>

type ParentTypes = ParentShape['type'] | 'page'

/* -------------------------------------------------- */
/*                      Editor UI                     */
/* -------------------------------------------------- */

interface PointerInfo<T extends string = any> {
  target: T
  pointerId: number
  origin: number[]
  point: number[]
  pressure: number
  shiftKey: boolean
  ctrlKey: boolean
  metaKey: boolean
  altKey: boolean
}

interface KeyboardInfo {
  key: string
  keys: string[]
  shiftKey: boolean
  ctrlKey: boolean
  metaKey: boolean
  altKey: boolean
}

enum Edge {
  Top = 'top_edge',
  Right = 'right_edge',
  Bottom = 'bottom_edge',
  Left = 'left_edge',
}

enum Corner {
  TopLeft = 'top_left_corner',
  TopRight = 'top_right_corner',
  BottomRight = 'bottom_right_corner',
  BottomLeft = 'bottom_left_corner',
}

interface Bounds {
  minX: number
  minY: number
  maxX: number
  maxY: number
  width: number
  height: number
  rotation?: number
}

interface RotatedBounds extends Bounds {
  rotation: number
}

interface ShapeBounds extends Bounds {
  id: string
}

interface PointSnapshot extends Bounds {
  nx: number
  nmx: number
  ny: number
  nmy: number
}

interface BoundsSnapshot extends PointSnapshot {
  nw: number
  nh: number
}

type ShapeSpecificProps<T extends Shape> = Pick<
  T,
  Difference<keyof T, keyof BaseShape>
>

type ShapeIndicatorProps<T extends Shape> = ShapeSpecificProps<T>

enum MoveType {
  Backward,
  Forward,
  ToFront,
  ToBack,
}

enum AlignType {
  Top,
  CenterVertical,
  Bottom,
  Left,
  CenterHorizontal,
  Right,
}

enum StretchType {
  Horizontal,
  Vertical,
}

enum DistributeType {
  Horizontal,
  Vertical,
}

interface BezierCurveSegment {
  start: number[]
  tangentStart: number[]
  normalStart: number[]
  pressureStart: number
  end: number[]
  tangentEnd: number[]
  normalEnd: number[]
  pressureEnd: number
}

/* -------------------------------------------------- */
/*                     Code Editor                    */
/* -------------------------------------------------- */

enum ControlType {
  Number = 'number',
  Vector = 'vector',
  Text = 'text',
  Select = 'select',
}

interface BaseCodeControl {
  id: string
  type: ControlType
  label: string
}

interface NumberCodeControl extends BaseCodeControl {
  type: ControlType.Number
  value: number
  min?: number
  max?: number
  step?: number
  format?: (value: number) => number
}

interface VectorCodeControl extends BaseCodeControl {
  type: ControlType.Vector
  value: number[]
  min?: number
  max?: number
  step?: number
  isNormalized?: boolean
  format?: (value: number[]) => number[]
}

interface TextCodeControl extends BaseCodeControl {
  type: ControlType.Text
  value: string
  format?: (value: string) => string
}

interface SelectCodeControl<T extends string = ''>
  extends BaseCodeControl {
  type: ControlType.Select
  value: T
  options: T[]
  format?: (string: T) => string
}

type CodeControl =
  | NumberCodeControl
  | VectorCodeControl
  | TextCodeControl

type PropsOfType<T extends Shape, U> = {
  [K in keyof T]: T[K] extends any ? (T[K] extends U ? K : never) : never
}[keyof T]

type Mutable<T extends Shape> = { -readonly [K in keyof T]: T[K] }

interface ShapeUtility<K extends Shape> {
  // Default properties when creating a new shape
  defaultProps: K

  // A cache for the computed bounds of this kind of shape.
  boundsCache: WeakMap<K, Bounds>

  // Whether to show transform controls when this shape is selected.
  canTransform: boolean

  // Whether the shape's aspect ratio can change.
  canChangeAspectRatio: boolean

  // Whether the shape's style can be filled.
  canStyleFill: boolean

  // Whether the shape may be bound to.
  canBind: boolean

  // Whether the shape may be edited in an editing mode
  canEdit: boolean

  // Whether the shape is a foreign object.
  isForeignObject: boolean

  // Whether the shape can contain other shapes.
  isParent: boolean

  // Whether the shape is only shown when on hovered.
  isShy: boolean

  // Create a new shape.
  create(this: ShapeUtility<K>, props: Partial<K>): K

  // Update a shape's styles
  applyStyles(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    style: Partial<ShapeStyles>
  ): ShapeUtility<K>

  translateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  translateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  rotateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number
  ): ShapeUtility<K>

  rotateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number,
    delta: number
  ): ShapeUtility<K>

  // Transform to fit a new bounding box when more than one shape is selected.
  transform(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  // Transform a single shape to fit a new bounding box.
  transformSingle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  setProperty<P extends keyof K>(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    prop: P,
    value: K[P]
  ): ShapeUtility<K>

  // Respond when any child of this shape changes.
  onChildrenChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    children: Shape[]
  ): ShapeUtility<K>

  // Given a point and a direction, return the shape's bound point.
  getBindingPoint(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[],
    direction: number[]
  ): number[] | undefined

  // Respond when a user moves one of the shape's bound elements.
  onBindingChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bindings: Record<string, ShapeBinding>
  ): ShapeUtility<K>

  // Respond when a user moves one of the shape's handles.
  onHandleChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: Partial<K['handles']>,
    info?: Partial<{
      delta: number[]
      shiftKey: boolean
      altKey: boolean
      metaKey: boolean
    }>
  ): ShapeUtility<K>

  onDoublePointHandle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: keyof K['handles'],
    info: PointerInfo
  ): ShapeUtility<K>

  // Respond when a user double clicks the shape's bounds.
  onBoundsReset(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Respond when a user double clicks the center of the shape.
  onDoubleFocus(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Clean up changes when a session ends.
  onSessionComplete(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Render a shape to JSX.
  render(
    this: ShapeUtility<K>,
    shape: K,
    info?: {
      isEditing?: boolean
      isHovered?: boolean
      isSelected?: boolean
      isCurrentParent?: boolean
      isDarkMode?: boolean
      ref?: React.MutableRefObject<HTMLTextAreaElement>
    }
  ): JSX.Element

  invalidate(this: ShapeUtility<K>, shape: K): ShapeUtility<K>

  // Get the bounds of the a shape.
  getBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the routated bounds of the a shape.
  getRotatedBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the center of the shape
  getCenter(this: ShapeUtility<K>, shape: K): number[]

  // Test whether a point lies within a shape.
  hitTest(this: ShapeUtility<K>, shape: K, test: number[]): boolean

  // Test whether bounds collide with or contain a shape.
  hitTestBounds(this: ShapeUtility<K>, shape: K, bounds: Bounds): boolean

  // Get whether the shape should delete
  shouldDelete(this: ShapeUtility<K>, shape: K): boolean

  // Get whether the shape should render
  shouldRender(this: ShapeUtility<K>, shape: K, previous: K): boolean
}




 class Vec {
  /**
   * Clamp a value into a range.
   * @param n
   * @param min
   */
  static clamp(n: number, min: number): number
  static clamp(n: number, min: number, max: number): number
  static clamp(n: number, min: number, max?: number): number {
    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)
  }

  /**
   * Negate a vector.
   * @param A
   */
  static neg = (A: number[]): number[] => {
    return [-A[0], -A[1]]
  }

  /**
   * Add vectors.
   * @param A
   * @param B
   */
  static add = (A: number[], B: number[]): number[] => {
    return [A[0] + B[0], A[1] + B[1]]
  }

  /**
   * Add scalar to vector.
   * @param A
   * @param B
   */
  static addScalar = (A: number[], n: number): number[] => {
    return [A[0] + n, A[1] + n]
  }

  /**
   * Subtract vectors.
   * @param A
   * @param B
   */
  static sub = (A: number[], B: number[]): number[] => {
    return [A[0] - B[0], A[1] - B[1]]
  }

  /**
   * Subtract scalar from vector.
   * @param A
   * @param B
   */
  static subScalar = (A: number[], n: number): number[] => {
    return [A[0] - n, A[1] - n]
  }

  /**
   * Get the vector from vectors A to B.
   * @param A
   * @param B
   */
  static vec = (A: number[], B: number[]): number[] => {
    // A, B as vectors get the vector from A to B
    return [B[0] - A[0], B[1] - A[1]]
  }

  /**
   * Vector multiplication by scalar
   * @param A
   * @param n
   */
  static mul = (A: number[], n: number): number[] => {
    return [A[0] * n, A[1] * n]
  }

  static mulV = (A: number[], B: number[]): number[] => {
    return [A[0] * B[0], A[1] * B[1]]
  }

  /**
   * Vector division by scalar.
   * @param A
   * @param n
   */
  static div = (A: number[], n: number): number[] => {
    return [A[0] / n, A[1] / n]
  }

  /**
   * Vector division by vector.
   * @param A
   * @param n
   */
  static divV = (A: number[], B: number[]): number[] => {
    return [A[0] / B[0], A[1] / B[1]]
  }

  /**
   * Perpendicular rotation of a vector A
   * @param A
   */
  static per = (A: number[]): number[] => {
    return [A[1], -A[0]]
  }

  /**
   * Dot product
   * @param A
   * @param B
   */
  static dpr = (A: number[], B: number[]): number => {
    return A[0] * B[0] + A[1] * B[1]
  }

  /**
   * Cross product (outer product) | A X B |
   * @param A
   * @param B
   */
  static cpr = (A: number[], B: number[]): number => {
    return A[0] * B[1] - B[0] * A[1]
  }

  /**
   * Length of the vector squared
   * @param A
   */
  static len2 = (A: number[]): number => {
    return A[0] * A[0] + A[1] * A[1]
  }

  /**
   * Length of the vector
   * @param A
   */
  static len = (A: number[]): number => {
    return Math.hypot(A[0], A[1])
  }

  /**
   * Project A over B
   * @param A
   * @param B
   */
  static pry = (A: number[], B: number[]): number => {
    return Vec.dpr(A, B) / Vec.len(B)
  }

  /**
   * Get normalized / unit vector.
   * @param A
   */
  static uni = (A: number[]): number[] => {
    return Vec.div(A, Vec.len(A))
  }

  /**
   * Get normalized / unit vector.
   * @param A
   */
  static normalize = (A: number[]): number[] => {
    return Vec.uni(A)
  }

  /**
   * Get the tangent between two vectors.
   * @param A
   * @param B
   * @returns
   */
  static tangent = (A: number[], B: number[]): number[] => {
    return Vec.normalize(Vec.sub(A, B))
  }

  /**
   * Dist length from A to B squared.
   * @param A
   * @param B
   */
  static dist2 = (A: number[], B: number[]): number => {
    return Vec.len2(Vec.sub(A, B))
  }

  /**
   * Dist length from A to B
   * @param A
   * @param B
   */
  static dist = (A: number[], B: number[]): number => {
    return Math.hypot(A[1] - B[1], A[0] - B[0])
  }

  /**
   * A faster, though less accurate method for testing distances. Maybe faster?
   * @param A
   * @param B
   * @returns
   */
  static fastDist = (A: number[], B: number[]): number[] => {
    const V = [B[0] - A[0], B[1] - A[1]]
    const aV = [Math.abs(V[0]), Math.abs(V[1])]
    let r = 1 / Math.max(aV[0], aV[1])
    r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289)
    return [V[0] * r, V[1] * r]
  }

  /**
   * Angle between vector A and vector B in radians
   * @param A
   * @param B
   */
  static ang = (A: number[], B: number[]): number => {
    return Math.atan2(Vec.cpr(A, B), Vec.dpr(A, B))
  }

  /**
   * Angle between vector A and vector B in radians
   * @param A
   * @param B
   */
  static angle = (A: number[], B: number[]): number => {
    return Math.atan2(B[1] - A[1], B[0] - A[0])
  }

  /**
   * Mean between two vectors or mid vector between two vectors
   * @param A
   * @param B
   */
  static med = (A: number[], B: number[]): number[] => {
    return Vec.mul(Vec.add(A, B), 0.5)
  }

  /**
   * Vector rotation by r (radians)
   * @param A
   * @param r rotation in radians
   */
  static rot = (A: number[], r: number): number[] => {
    return [
      A[0] * Math.cos(r) - A[1] * Math.sin(r),
      A[0] * Math.sin(r) + A[1] * Math.cos(r),
    ]
  }

  /**
   * Rotate a vector around another vector by r (radians)
   * @param A vector
   * @param C center
   * @param r rotation in radians
   */
  static rotWith = (A: number[], C: number[], r: number): number[] => {
    if (r === 0) return A

    const s = Math.sin(r)
    const c = Math.cos(r)

    const px = A[0] - C[0]
    const py = A[1] - C[1]

    const nx = px * c - py * s
    const ny = px * s + py * c

    return [nx + C[0], ny + C[1]]
  }

  /**
   * Check of two vectors are identical.
   * @param A
   * @param B
   */
  static isEqual = (A: number[], B: number[]): boolean => {
    return A[0] === B[0] && A[1] === B[1]
  }

  /**
   * Interpolate vector A to B with a scalar t
   * @param A
   * @param B
   * @param t scalar
   */
  static lrp = (A: number[], B: number[], t: number): number[] => {
    return Vec.add(A, Vec.mul(Vec.vec(A, B), t))
  }

  /**
   * Interpolate from A to B when curVAL goes fromVAL: number[] => to
   * @param A
   * @param B
   * @param from Starting value
   * @param to Ending value
   * @param s Strength
   */
  static int = (
    A: number[],
    B: number[],
    from: number,
    to: number,
    s = 1
  ): number[] => {
    const t = (Vec.clamp(from, to) - from) / (to - from)
    return Vec.add(Vec.mul(A, 1 - t), Vec.mul(B, s))
  }

  /**
   * Get the angle between the three vectors A, B, and C.
   * @param p1
   * @param pc
   * @param p2
   */
  static ang3 = (p1: number[], pc: number[], p2: number[]): number => {
    // this,
    const v1 = Vec.vec(pc, p1)
    const v2 = Vec.vec(pc, p2)
    return Vec.ang(v1, v2)
  }

  /**
   * Absolute value of a vector.
   * @param A
   * @returns
   */
  static abs = (A: number[]): number[] => {
    return [Math.abs(A[0]), Math.abs(A[1])]
  }

  static rescale = (a: number[], n: number): number[] => {
    const l = Vec.len(a)
    return [(n * a[0]) / l, (n * a[1]) / l]
  }

  /**
   * Get whether p1 is left of p2, relative to pc.
   * @param p1
   * @param pc
   * @param p2
   */
  static isLeft = (p1: number[], pc: number[], p2: number[]): number => {
    //  isLeft: >0 for counterclockwise
    //          =0 for none (degenerate)
    //          <0 for clockwise
    return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1])
  }

  static clockwise = (p1: number[], pc: number[], p2: number[]): boolean => {
    return Vec.isLeft(p1, pc, p2) > 0
  }

  static round = (a: number[], d = 5): number[] => {
    return a.map((v) => +v.toPrecision(d))
  }

  /**
   * Get the minimum distance from a point P to a line with a segment AB.
   * @param A The start of the line.
   * @param B The end of the line.
   * @param P A point.
   * @returns
   */
  // static distanceToLine(A: number[], B: number[], P: number[]) {
  //   const delta = sub(B, A)
  //   const angle = Math.atan2(delta[1], delta[0])
  //   const dir = rot(sub(P, A), -angle)
  //   return dir[1]
  // }

  /**
   * Get the nearest point on a line segment AB.
   * @param A The start of the line.
   * @param B The end of the line.
   * @param P A point.
   * @param clamp Whether to clamp the resulting point to the segment.
   * @returns
   */
  // static nearestPointOnLine(
  //   A: number[],
  //   B: number[],
  //   P: number[],
  //   clamp = true
  // ) {
  //   const delta = sub(B, A)
  //   const length = len(delta)
  //   const angle = Math.atan2(delta[1], delta[0])
  //   const dir = rot(sub(P, A), -angle)

  //   if (clamp) {
  //     if (dir[0] < 0) return A
  //     if (dir[0] > length) return B
  //   }

  //   return add(A, div(mul(delta, dir[0]), length))
  // }

  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   * @param A Any point on the line
   * @param u The unit vector for the line.
   * @param P A point not on the line to test.
   * @returns
   */
  static nearestPointOnLineThroughPoint = (
    A: number[],
    u: number[],
    P: number[]
  ): number[] => {
    return Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))
  }

  /**
   * Distance between a point and a line with a known unit vector that passes through a point.
   * @param A Any point on the line
   * @param u The unit vector for the line.
   * @param P A point not on the line to test.
   * @returns
   */
  static distanceToLineThroughPoint = (
    A: number[],
    u: number[],
    P: number[]
  ): number => {
    return Vec.dist(P, Vec.nearestPointOnLineThroughPoint(A, u, P))
  }

  /**
   * Get the nearest point on a line segment between A and B
   * @param A The start of the line segment
   * @param B The end of the line segment
   * @param P The off-line point
   * @param clamp Whether to clamp the point between A and B.
   * @returns
   */
  static nearestPointOnLineSegment = (
    A: number[],
    B: number[],
    P: number[],
    clamp = true
  ): number[] => {
    const delta = Vec.sub(B, A)
    const length = Vec.len(delta)
    const u = Vec.div(delta, length)

    const pt = Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))

    if (clamp) {
      const da = Vec.dist(A, pt)
      const db = Vec.dist(B, pt)

      if (db < da && da > length) return B
      if (da < db && db > length) return A
    }

    return pt
  }

  /**
   * Distance between a point and the nearest point on a line segment between A and B
   * @param A The start of the line segment
   * @param B The end of the line segment
   * @param P The off-line point
   * @param clamp Whether to clamp the point between A and B.
   * @returns
   */
  static distanceToLineSegment = (
    A: number[],
    B: number[],
    P: number[],
    clamp = true
  ): number => {
    return Vec.dist(P, Vec.nearestPointOnLineSegment(A, B, P, clamp))
  }

  /**
   * Push a point A towards point B by a given distance.
   * @param A
   * @param B
   * @param d
   * @returns
   */
  static nudge = (A: number[], B: number[], d: number): number[] => {
    return Vec.add(A, Vec.mul(Vec.uni(Vec.vec(A, B)), d))
  }

  /**
   * Push a point in a given angle by a given distance.
   * @param A
   * @param B
   * @param d
   */
  static nudgeAtAngle = (A: number[], a: number, d: number): number[] => {
    return [Math.cos(a) * d + A[0], Math.sin(a) * d + A[1]]
  }

  /**
   * Round a vector to a precision length.
   * @param a
   * @param n
   */
  static toPrecision = (a: number[], n = 4): number[] => {
    return [+a[0].toPrecision(n), +a[1].toPrecision(n)]
  }

  /**
   * Get a number of points between two points.
   * @param a
   * @param b
   * @param steps
   */
  static pointsBetween = (a: number[], b: number[], steps = 6): number[][] => {
    return Array.from(Array(steps))
      .map((_, i) => {
        const t = i / steps
        return t * t * t
      })
      .map((t) => Vec.round([...Vec.lrp(a, b, t), (1 - t) / 2]))
  }
}




class Intersection {
  didIntersect: boolean
  message: string
  points: number[][]

  constructor(message: string, ...points: number[][]) {
    this.didIntersect = points.length > 0
    this.message = message
    this.points = points
  }
}

 class Intersect {
  static ray = {
    // Intersect a ray with a ray.
    ray(p0: number[], n0: number[], p1: number[], n1: number[]): Intersection {
      const dx = p1[0] - p0[0]
      const dy = p1[1] - p0[1]
      const det = n1[0] * n0[1] - n1[1] * n0[0]
      const u = (dy * n1[0] - dx * n1[1]) / det
      const v = (dy * n0[0] - dx * n0[1]) / det
      if (u < 0 || v < 0) return new Intersection('miss')

      const m0 = n0[1] / n0[0]
      const m1 = n1[1] / n1[0]
      const b0 = p0[1] - m0 * p0[0]
      const b1 = p1[1] - m1 * p1[0]
      const x = (b1 - b0) / (m0 - m1)
      const y = m0 * x + b0

      return Number.isFinite(x)
        ? new Intersection('intersection', [x, y])
        : new Intersection('parallel')
    },

    // Interseg a ray with a line segment.
    lineSegment(
      origin: number[],
      direction: number[],
      a1: number[],
      a2: number[]
    ): Intersection {
      const [x, y] = origin
      const [dx, dy] = direction
      const [x1, y1] = a1
      const [x2, y2] = a2

      if (dy / dx != (y2 - y1) / (x2 - x1)) {
        const d = dx * (y2 - y1) - dy * (x2 - x1)
        if (d != 0) {
          const r = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / d
          const s = ((y - y1) * dx - (x - x1) * dy) / d
          if (r >= 0 && s >= 0 && s <= 1) {
            return new Intersection('intersection', [x + r * dx, y + r * dy])
          }
        }
      }
      return new Intersection('no intersection')
    },

    // Intersect a ray with a rectangle.
    rectangle(
      origin: number[],
      direction: number[],
      point: number[],
      size: number[]
    ): Intersection[] {
      return Intersect.rectangle.ray(point, size, origin, direction)
    },

    // Intersect a ray with a bounding box.
    bounds(
      origin: number[],
      direction: number[],
      bounds: Bounds
    ): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.ray.rectangle(
        origin,
        direction,
        [minX, minY],
        [width, height]
      )
    },
  }

  static lineSegment = {
    // Intersect a line segment with a ray.
    ray(
      a1: number[],
      a2: number[],
      origin: number[],
      direction: number[]
    ): Intersection {
      return Intersect.ray.lineSegment(origin, direction, a1, a2)
    },

    // Intersect a line segment with a line segment.
    lineSegment(
      a1: number[],
      a2: number[],
      b1: number[],
      b2: number[]
    ): Intersection {
      const AB = Vec.sub(a1, b1)
      const BV = Vec.sub(b2, b1)
      const AV = Vec.sub(a2, a1)

      const ua_t = BV[0] * AB[1] - BV[1] * AB[0]
      const ub_t = AV[0] * AB[1] - AV[1] * AB[0]
      const u_b = BV[1] * AV[0] - BV[0] * AV[1]

      if (ua_t === 0 || ub_t === 0) {
        return new Intersection('coincident')
      }

      if (u_b === 0) {
        return new Intersection('parallel')
      }

      if (u_b != 0) {
        const ua = ua_t / u_b
        const ub = ub_t / u_b
        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
          return new Intersection('intersection', Vec.add(a1, Vec.mul(AV, ua)))
        }
      }

      return new Intersection('no intersection')
    },

    // Intersect a line segment with a rectangle
    rectangle(
      a1: number[],
      a2: number[],
      point: number[],
      size: number[]
    ): Intersection[] {
      return Intersect.rectangle.lineSegment(point, size, a1, a2)
    },

    // Intersect a line segment with an arc.
    arc(
      a1: number[],
      a2: number[],
      center: number[],
      radius: number,
      start: number[],
      end: number[]
    ): Intersection {
      const sa = Vec.angle(center, start)
      const ea = Vec.angle(center, end)
      const ellipseTest = Intersect.ellipse.lineSegment(
        center,
        radius,
        radius,
        0,
        a1,
        a2
      )

      if (!ellipseTest.didIntersect) return new Intersection('No intersection')

      const points = ellipseTest.points.filter((point) =>
        isAngleBetween(sa, ea, Vec.angle(center, point))
      )

      if (points.length === 0) {
        return new Intersection('No intersection')
      }

      return new Intersection('intersection', ...points)
    },

    // Intersect a line segment with a circle.
    circle(a1: number[], a2: number[], c: number[], r: number): Intersection {
      const a =
        (a2[0] - a1[0]) * (a2[0] - a1[0]) + (a2[1] - a1[1]) * (a2[1] - a1[1])
      const b =
        2 *
        ((a2[0] - a1[0]) * (a1[0] - c[0]) + (a2[1] - a1[1]) * (a1[1] - c[1]))
      const cc =
        c[0] * c[0] +
        c[1] * c[1] +
        a1[0] * a1[0] +
        a1[1] * a1[1] -
        2 * (c[0] * a1[0] + c[1] * a1[1]) -
        r * r

      const deter = b * b - 4 * a * cc

      if (deter < 0) {
        return new Intersection('outside')
      }

      if (deter === 0) {
        return new Intersection('tangent')
      }

      const e = Math.sqrt(deter)
      const u1 = (-b + e) / (2 * a)
      const u2 = (-b - e) / (2 * a)
      if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
        if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {
          return new Intersection('outside')
        } else {
          return new Intersection('inside')
        }
      }

      const results: number[][] = []
      if (0 <= u1 && u1 <= 1) results.push(Vec.lrp(a1, a2, u1))
      if (0 <= u2 && u2 <= 1) results.push(Vec.lrp(a1, a2, u2))

      return new Intersection('intersection', ...results)
    },

    // Intersect a line segment with an ellipse.
    ellipse(
      a1: number[],
      a2: number[],
      center: number[],
      rx: number,
      ry: number,
      rotation = 0
    ): Intersection {
      // If the ellipse or line segment are empty, return no tValues.
      if (rx === 0 || ry === 0 || Vec.isEqual(a1, a2)) {
        return new Intersection('No intersection')
      }

      // Get the semimajor and semiminor axes.
      rx = rx < 0 ? rx : -rx
      ry = ry < 0 ? ry : -ry

      // Rotate points and translate so the ellipse is centered at the origin.
      a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center)
      a2 = Vec.sub(Vec.rotWith(a2, center, -rotation), center)

      // Calculate the quadratic parameters.
      const diff = Vec.sub(a2, a1)

      const A = (diff[0] * diff[0]) / rx / rx + (diff[1] * diff[1]) / ry / ry
      const B =
        (2 * a1[0] * diff[0]) / rx / rx + (2 * a1[1] * diff[1]) / ry / ry
      const C = (a1[0] * a1[0]) / rx / rx + (a1[1] * a1[1]) / ry / ry - 1

      // Make a list of t values (normalized points on the line where intersections occur).
      const tValues: number[] = []

      // Calculate the discriminant.
      const discriminant = B * B - 4 * A * C

      if (discriminant === 0) {
        // One real solution.
        tValues.push(-B / 2 / A)
      } else if (discriminant > 0) {
        const root = Math.sqrt(discriminant)
        // Two real solutions.
        tValues.push((-B + root) / 2 / A)
        tValues.push((-B - root) / 2 / A)
      }

      // Filter to only points that are on the segment.
      // Solve for points, then counter-rotate points.
      const points = tValues
        .filter((t) => t >= 0 && t <= 1)
        .map((t) => Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a2, a1), t))))
        .map((p) => Vec.rotWith(p, center, rotation))

      return new Intersection('intersection', ...points)
    },

    // Intersect a line segment with a bounding box.
    bounds(a1: number[], a2: number[], bounds: Bounds): Intersection[] {
      return Intersect.bounds.lineSegment(bounds, a1, a2)
    },

    // Intersect a line segment with a polyline
    polyline(a1: number[], a2: number[], points: number[][]): Intersection[] {
      const intersections: Intersection[] = []

      for (let i = 1; i < points.length; i++) {
        const int = Intersect.lineSegment.lineSegment(
          a1,
          a2,
          points[i - 1],
          points[i]
        )

        if (int) {
          intersections.push(int)
        }
      }

      return intersections
    },
  }

  static rectangle = {
    // Intersect a rectangle with a ray.
    ray(
      point: number[],
      size: number[],
      origin: number[],
      direction: number[]
    ): Intersection[] {
      const sideIntersections = getRectangleSides(point, size).reduce<
        Intersection[]
      >((acc, [message, [a1, a2]]) => {
        const intersection = Intersect.ray.lineSegment(
          origin,
          direction,
          a1,
          a2
        )

        if (intersection) {
          acc.push(new Intersection(message, ...intersection.points))
        }

        return acc
      }, [])

      return sideIntersections.filter((int) => int.didIntersect)
    },

    // Intersect a rectangle with a line segment.
    lineSegment(
      point: number[],
      size: number[],
      a1: number[],
      a2: number[]
    ): Intersection[] {
      const sideIntersections = getRectangleSides(point, size).reduce<
        Intersection[]
      >((acc, [message, [b1, b2]]) => {
        const intersection = Intersect.lineSegment.lineSegment(a1, a2, b1, b2)

        if (intersection) {
          acc.push(new Intersection(message, ...intersection.points))
        }

        return acc
      }, [])

      return sideIntersections.filter((int) => int.didIntersect)
    },

    // Intersect a rectangle with a rectangle.
    rectangle(
      point1: number[],
      size1: number[],
      point2: number[],
      size2: number[]
    ): Intersection[] {
      const sideIntersections = getRectangleSides(point1, size1).reduce<
        Intersection[]
      >((acc, [message, [a1, a2]]) => {
        const intersections = Intersect.rectangle.lineSegment(
          point2,
          size2,
          a1,
          a2
        )

        acc.push(
          ...intersections.map(
            (int) =>
              new Intersection(\`\${message} \${int.message}\`, ...int.points)
          )
        )

        return acc
      }, [])

      return sideIntersections.filter((int) => int.didIntersect)
    },

    // Intersect a rectangle with an arc.
    arc(
      point: number[],
      size: number[],
      center: number[],
      radius: number,
      start: number[],
      end: number[]
    ): Intersection[] {
      const sideIntersections = getRectangleSides(point, size).reduce<
        Intersection[]
      >((acc, [message, [a1, a2]]) => {
        const intersection = Intersect.arc.lineSegment(
          center,
          radius,
          start,
          end,
          a1,
          a2
        )

        if (intersection) {
          acc.push({ ...intersection, message })
        }

        return acc
      }, [])

      return sideIntersections.filter((int) => int.didIntersect)
    },

    // Intersect a rectangle with a circle.
    circle(
      point: number[],
      size: number[],
      c: number[],
      r: number
    ): Intersection[] {
      const sideIntersections = getRectangleSides(point, size).reduce<
        Intersection[]
      >((acc, [message, [a1, a2]]) => {
        const intersection = Intersect.lineSegment.circle(a1, a2, c, r)

        if (intersection) {
          acc.push({ ...intersection, message })
        }

        return acc
      }, [])

      return sideIntersections.filter((int) => int.didIntersect)
    },

    // Intersect a rectangle with an ellipse.
    ellipse(
      point: number[],
      size: number[],
      c: number[],
      rx: number,
      ry: number,
      rotation = 0
    ): Intersection[] {
      const sideIntersections = getRectangleSides(point, size).reduce<
        Intersection[]
      >((acc, [message, [a1, a2]]) => {
        const intersection = Intersect.lineSegment.ellipse(
          a1,
          a2,
          c,
          rx,
          ry,
          rotation
        )

        if (intersection) {
          acc.push({ ...intersection, message })
        }

        return acc
      }, [])

      return sideIntersections.filter((int) => int.didIntersect)
    },

    // Intersect a rectangle with a bounding box.
    bounds(point: number[], size: number[], bounds: Bounds): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.rectangle.rectangle(
        point,
        size,
        [minX, minY],
        [width, height]
      )
    },

    // Intersect a rectangle with a polyline
    polyline(
      point: number[],
      size: number[],
      points: number[][]
    ): Intersection[] {
      const sideIntersections = getRectangleSides(point, size).reduce<
        Intersection[]
      >((acc, [message, [a1, a2]]) => {
        const intersections = Intersect.lineSegment.polyline(a1, a2, points)

        if (intersections.length > 0) {
          acc.push(
            new Intersection(message, ...intersections.flatMap((i) => i.points))
          )
        }

        return acc
      }, [])

      return sideIntersections.filter((int) => int.didIntersect)
    },
  }

  static arc = {
    // Intersect an arc with a line segment.
    lineSegment(
      center: number[],
      radius: number,
      start: number[],
      end: number[],
      a1: number[],
      a2: number[]
    ): Intersection {
      return Intersect.lineSegment.arc(a1, a2, center, radius, start, end)
    },

    // Intersect an arc with a rectangle.
    rectangle(
      center: number[],
      radius: number,
      start: number[],
      end: number[],
      point: number[],
      size: number[]
    ): Intersection[] {
      return Intersect.rectangle.arc(point, size, center, radius, start, end)
    },

    // Intersect an arc with a bounding box.
    bounds(
      center: number[],
      radius: number,
      start: number[],
      end: number[],
      bounds: Bounds
    ): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.arc.rectangle(
        center,
        radius,
        start,
        end,
        [minX, minY],
        [width, height]
      )
    },
  }

  static circle = {
    // Intersect a circle with a line segment.
    lineSegment(
      c: number[],
      r: number,
      a1: number[],
      a2: number[]
    ): Intersection {
      return Intersect.lineSegment.circle(a1, a2, c, r)
    },

    // Intersect a circle with a circle.
    circle(c1: number[], r1: number, c2: number[], r2: number): Intersection {
      let dx = c2[0] - c1[0],
        dy = c2[1] - c1[1]

      const d = Math.sqrt(dx * dx + dy * dy),
        x = (d * d - r2 * r2 + r1 * r1) / (2 * d),
        y = Math.sqrt(r1 * r1 - x * x)

      dx /= d
      dy /= d

      return new Intersection(
        'intersection',
        [c1[0] + dx * x - dy * y, c1[1] + dy * x + dx * y],
        [c1[0] + dx * x + dy * y, c1[1] + dy * x - dx * y]
      )
    },

    // Intersect a circle with a rectangle.
    rectangle(
      c: number[],
      r: number,
      point: number[],
      size: number[]
    ): Intersection[] {
      return Intersect.rectangle.circle(point, size, c, r)
    },

    // Intersect a circle with a bounding box.
    bounds(c: number[], r: number, bounds: Bounds): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.circle.rectangle(c, r, [minX, minY], [width, height])
    },
  }

  static ellipse = {
    // Intersect an ellipse with a line segment
    lineSegment(
      center: number[],
      rx: number,
      ry: number,
      rotation = 0,
      a1: number[],
      a2: number[]
    ): Intersection {
      if (rx === ry) {
        return Intersect.lineSegment.circle(a1, a2, center, rx)
      }

      return Intersect.lineSegment.ellipse(a1, a2, center, rx, ry, rotation)
    },

    // Intersect an ellipse with a rectangle.
    rectangle(
      center: number[],
      rx: number,
      ry: number,
      rotation = 0,
      point: number[],
      size: number[]
    ): Intersection[] {
      if (rx === ry) {
        return Intersect.rectangle.circle(point, size, center, rx)
      }

      return Intersect.rectangle.ellipse(point, size, center, rx, ry, rotation)
    },

    // Get an intersection between an ellipse and a second ellipse.
    // Adapted from https://gist.github.com/drawable/92792f59b6ff8869d8b1
    ellipse(
      c1: number[],
      rx1: number,
      ry1: number,
      c2: number[],
      rx2: number,
      ry2: number
    ): Intersection {
      const a = [
        ry1 * ry1,
        0,
        rx1 * rx1,
        -2 * ry1 * ry1 * c1[0],
        -2 * rx1 * rx1 * c1[1],
        ry1 * ry1 * c1[0] * c1[0] +
          rx1 * rx1 * c1[1] * c1[1] -
          rx1 * rx1 * ry1 * ry1,
      ]
      const b = [
        ry2 * ry2,
        0,
        rx2 * rx2,
        -2 * ry2 * ry2 * c2[0],
        -2 * rx2 * rx2 * c2[1],
        ry2 * ry2 * c2[0] * c2[0] +
          rx2 * rx2 * c2[1] * c2[1] -
          rx2 * rx2 * ry2 * ry2,
      ]
      const yPoly = bezout(a, b)
      const yRoots = getPolynomialRoots(yPoly)
      const epsilon = 1e-3
      const norm0 = (a[0] * a[0] + 2 * a[1] * a[1] + a[2] * a[2]) * epsilon
      const norm1 = (b[0] * b[0] + 2 * b[1] * b[1] + b[2] * b[2]) * epsilon
      const result: number[][] = []
      for (let y = 0; y < yRoots.length; y++) {
        const xRoots = getPolynomialRoots([
          a[0],
          a[3] + yRoots[y] * a[1],
          a[5] + yRoots[y] * (a[4] + yRoots[y] * a[2]),
        ])
        for (let x = 0; x < xRoots.length; x++) {
          let test =
            (a[0] * xRoots[x] + a[1] * yRoots[y] + a[3]) * xRoots[x] +
            (a[2] * yRoots[y] + a[4]) * yRoots[y] +
            a[5]
          if (Math.abs(test) < norm0) {
            test =
              (b[0] * xRoots[x] + b[1] * yRoots[y] + b[3]) * xRoots[x] +
              (b[2] * yRoots[y] + b[4]) * yRoots[y] +
              b[5]
            if (Math.abs(test) < norm1) {
              result.push([xRoots[x], yRoots[y]])
            }
          }
        }
      }
      if (result.length > 0) {
        return new Intersection('no intersection')
      }

      return new Intersection('intersection', ...result)
    },

    circle(
      c: number[],
      rx: number,
      ry: number,
      rotation: number,
      c2: number[],
      r2: number
    ): Intersection {
      return Intersect.ellipse.ellipse(c, rx, ry, rotation, c2, r2, r2, 0)
    },

    // Intersect an ellipse with a bounding box.
    bounds(
      c: number[],
      rx: number,
      ry: number,
      rotation: number,
      bounds: Bounds
    ): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.ellipse.rectangle(
        c,
        rx,
        ry,
        rotation,
        [minX, minY],
        [width, height]
      )
    },
  }

  static bounds = {
    ray(bounds: Bounds, origin: number[], direction: number[]): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.ray.rectangle(
        origin,
        direction,
        [minX, minY],
        [width, height]
      )
    },

    lineSegment(bounds: Bounds, a1: number[], a2: number[]): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.lineSegment.rectangle(
        a1,
        a2,
        [minX, minY],
        [width, height]
      )
    },

    rectangle(bounds: Bounds, point: number[], size: number[]): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.rectangle.rectangle(
        point,
        size,
        [minX, minY],
        [width, height]
      )
    },

    bounds(bounds1: Bounds, bounds2: Bounds): Intersection[] {
      return Intersect.rectangle.rectangle(
        [bounds1.minX, bounds1.minY],
        [bounds1.width, bounds1.height],
        [bounds2.minX, bounds2.minY],
        [bounds2.width, bounds2.height]
      )
    },

    arc(
      bounds: Bounds,
      center: number[],
      radius: number,
      start: number[],
      end: number[]
    ): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.arc.rectangle(
        center,
        radius,
        start,
        end,
        [minX, minY],
        [width, height]
      )
    },

    circle(bounds: Bounds, c: number[], r: number): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.circle.rectangle(c, r, [minX, minY], [width, height])
    },

    ellipse(
      bounds: Bounds,
      c: number[],
      rx: number,
      ry: number,
      rotation = 0
    ): Intersection[] {
      const { minX, minY, width, height } = bounds
      return Intersect.ellipse.rectangle(
        c,
        rx,
        ry,
        rotation,
        [minX, minY],
        [width, height]
      )
    },

    polyline(bounds: Bounds, points: number[][]): Intersection[] {
      return Intersect.polyline.bounds(points, bounds)
    },
  }

  static polyline = {
    // Intersect a polyline with a line segment.
    lineSegment(
      points: number[][],
      a1: number[],
      a2: number[]
    ): Intersection[] {
      return Intersect.lineSegment.polyline(a1, a2, points)
    },

    // Interesct a polyline with a rectangle.
    rectangle(
      points: number[][],
      point: number[],
      size: number[]
    ): Intersection[] {
      return Intersect.rectangle.polyline(point, size, points)
    },

    // Intersect a polyline with a bounding box.
    bounds(points: number[][], bounds: Bounds): Intersection[] {
      return Intersect.rectangle.polyline(
        [bounds.minX, bounds.minY],
        [bounds.width, bounds.height],
        points
      )
    },
  }
}

// function intersectPolylineBounds(
//   points: number[][],
//   bounds: Bounds
// ): Intersection[] {
//   const { minX, minY, width, height } = bounds
//   const intersections: Intersection[] = []

//   for (let i = 1; i < points.length; i++) {
//     intersections.push(
//       ...intersectRectangleLineSegment(
//         [minX, minY],
//         [width, height],
//         points[i - 1],
//         points[i]
//       )
//     )
//   }

//   return intersections
// }

/* --------------------- Helpers -------------------- */

function getRectangleSides(
  point: number[],
  size: number[]
): [string, number[][]][] {
  const tl = point
  const tr = Vec.add(point, [size[0], 0])
  const br = Vec.add(point, size)
  const bl = Vec.add(point, [0, size[1]])

  return [
    ['top', [tl, tr]],
    ['right', [tr, br]],
    ['bottom', [br, bl]],
    ['left', [bl, tl]],
  ]
}

// /* -------------- Rotated Ellipses Math ------------- */

// // Calculates the line that runs through the intersection points of two congruent ellipses with the same rotation.
// function getEELine(
//   o1: number[],
//   rx: number,
//   ry: number,
//   rotation: number,
//   o2: number[]
// ): number[][] {
//   const A = Math.cos(rotation)
//   const B = Math.sin(rotation)
//   const b = rx * rx
//   const d = ry * ry
//   const a = o1[0]
//   const c = o1[1]
//   const o = o2[0]
//   const p = o2[1]

//   const AA = (A * A) / b + (B * B) / d
//   const BB = (-2 * A * B) / b + (2 * A * B) / d
//   const CC = (B * B) / b + (A * A) / d

//   const U = -2 * AA * a + BB * c
//   const V = AA * a * a + BB * a * c + CC * c * c
//   const W = BB * a + 2 * CC * c

//   const X = -2 * AA * o + BB * p
//   const Y = BB * o + 2 * CC * p
//   const Z = AA * o * o + BB * o * p + CC * p * p

//   const a1 = [U - X, Y - W]
//   const a2 = Vec.mul(a1, Z - V)

//   return [a1, a2]
// }

// // Create a general quadratic function for the ellipse a x^2 + b x y + c y^2 + d x + e y + c = 0
// function getEEQuadradic(
//   center: number[],
//   rx: number,
//   ry: number,
//   rotation: number
// ): number[] {
//   const a = center[0]
//   const b = rx * rx
//   const c = center[1]
//   const d = ry * ry
//   const A = Math.cos(-rotation)
//   const B = Math.sin(-rotation)

//   return [
//     (A * A) / b + (B * B) / d, // x^2
//     (2 * A * B) / d - (2 * A * B) / b, // x * y
//     (A * A) / d + (B * B) / b, // y^2

//     (2 * A * B * c - 2 * a * A * A) / b + (-2 * a * B * B - 2 * A * B * c) / d, // x

//     (2 * a * A * B - 2 * B * B * c) / b + (-2 * a * A * B - 2 * A * A * c) / d, // y

//     (a * a * A * A - 2 * a * A * B * c + B * B * c * c) / b +
//       (a * a * B * B + 2 * a * A * B * c + A * A * c * c) / d -
//       1, // Const
//   ]
// }

// function getEEQuartics(q1: number[], q2: number[]) {
//   const [a1, b1, c1, d1, e1, f1] = q1

//   const [a2, b2, c2, d2, e2, f2] = q2

//   return [
//     f1 * a1 * d2 * d2 +
//       a1 * a1 * f2 * f2 -
//       d1 * a1 * d2 * f2 +
//       a2 * a2 * f1 * f1 -
//       2 * a1 * f2 * a2 * f1 -
//       d1 * d2 * a2 * f1 +
//       a2 * d1 * d1 * f2,
//     e2 * d1 * d1 * a2 -
//       f2 * d2 * a1 * b1 -
//       2 * a1 * f2 * a2 * e1 -
//       f1 * a2 * b2 * d1 +
//       2 * d2 * b2 * a1 * f1 +
//       2 * e2 * f2 * a1 * a1 +
//       d2 * d2 * a1 * e1 -
//       e2 * d2 * a1 * d1 -
//       2 * a1 * e2 * a2 * f1 -
//       f1 * a2 * d2 * b1 +
//       2 * f1 * e1 * a2 * a2 -
//       f2 * b2 * a1 * d1 -
//       e1 * a2 * d2 * d1 +
//       2 * f2 * b1 * a2 * d1,
//     e2 * e2 * a1 * a1 +
//       2 * c2 * f2 * a1 * a1 -
//       e1 * a2 * d2 * b1 +
//       f2 * a2 * b1 * b1 -
//       e1 * a2 * b2 * d1 -
//       f2 * b2 * a1 * b1 -
//       2 * a1 * e2 * a2 * e1 +
//       2 * d2 * b2 * a1 * e1 -
//       c2 * d2 * a1 * d1 -
//       2 * a1 * c2 * a2 * f1 +
//       b2 * b2 * a1 * f1 +
//       2 * e2 * b1 * a2 * d1 +
//       e1 * e1 * a2 * a2 -
//       c1 * a2 * d2 * d1 -
//       e2 * b2 * a1 * d1 +
//       2 * f1 * c1 * a2 * a2 -
//       f1 * a2 * b2 * b1 +
//       c2 * d1 * d1 * a2 +
//       d2 * d2 * a1 * c1 -
//       e2 * d2 * a1 * b1 -
//       2 * a1 * f2 * a2 * c1,
//     -2 * a1 * a2 * c1 * e2 +
//       e2 * a2 * b1 * b1 +
//       2 * c2 * b1 * a2 * d1 -
//       c1 * a2 * b2 * d1 +
//       b2 * b2 * a1 * e1 -
//       e2 * b2 * a1 * b1 -
//       2 * a1 * c2 * a2 * e1 -
//       e1 * a2 * b2 * b1 -
//       c2 * b2 * a1 * d1 +
//       2 * e2 * c2 * a1 * a1 +
//       2 * e1 * c1 * a2 * a2 -
//       c1 * a2 * d2 * b1 +
//       2 * d2 * b2 * a1 * c1 -
//       c2 * d2 * a1 * b1,
//     a1 * a1 * c2 * c2 -
//       2 * a1 * c2 * a2 * c1 +
//       a2 * a2 * c1 * c1 -
//       b1 * a1 * b2 * c2 -
//       b1 * b2 * a2 * c1 +
//       b1 * b1 * a2 * c2 +
//       c1 * a1 * b2 * b2,
//   ]
// }

// function getYFromQuartics(quartics: number[]) {
//   const [e, d, c, b, a] = quartics

//   const d0 = c * c - 3 * b * d + 12 * a * e
//   const d1 =
//     2 * c * c * c -
//     9 * b * c * d +
//     27 * b * b * e +
//     27 * a * d * d -
//     72 * a * c * e

//   const p = (8 * a * c - 3 * b * b) / (8 * a * a)
//   const q = (b * b * b - 4 * a * b * c + 8 * a * a * d) / (8 * a * a * a)

//   let Q: number, S: number

//   const phi = Math.acos(d1 / (2 * Math.sqrt(d0 * d0 * d0)))

//   if (Number.isNaN(phi) && d1 === 0) {
//     Q = d1 + Math.sqrt(d1 * d1 - 4 * d0 * d0 * d0)
//     Q = Q / 2
//     Q = Math.pow(Q, 1 / 3)
//     S = 0.5 * Math.sqrt((-2 / 3) * p + (1 / (3 * a)) * (Q + d0 / Q))
//   } else {
//     S =
//       0.5 *
//       Math.sqrt(
//         (-2 / 3) * p + (2 / (3 * a)) * Math.sqrt(d0) * Math.cos(phi / 3)
//       )
//   }

//   const y = []

//   if (S !== 0) {
//     let R = -4 * S * S - 2 * p + q / S
//     if (R === 0) {
//       R = 0
//     }

//     if (R > 0) {
//       R = 0.5 * Math.sqrt(R)
//       y.push(-b / (4 * a) - S + R)
//       y.push(-b / (4 * a) - S - R)
//     } else if (R === 0) {
//       y.push(-b / (4 * a) - S)
//     }

//     R = -4 * S * S - 2 * p - q / S
//     if (R === 0) {
//       R = 0
//     }
//     if (R > 0) {
//       R = 0.5 * Math.sqrt(R)
//       y.push(-b / (4 * a) + S + R)
//       y.push(-b / (4 * a) + S - R)
//     } else if (R === 0) {
//       y.push(-b / (4 * a) + S)
//     }
//   }

//   return y
// }

// function calculatePointsFromQuartics(
//   y: number[],
//   eq1: number[],
//   eq2: number[]
// ): number[][] {
//   const [a1, b1, c1, d1, e1, f1] = eq1
//   const [a2, b2, c2, d2, e2, f2] = eq2

//   const r: number[][] = []

//   for (let i = 0; i < y.length; i++) {
//     const x =
//       -(
//         a1 * f2 +
//         a1 * c2 * y[i] * y[i] -
//         a2 * c1 * y[i] * y[i] +
//         a1 * e2 * y[i] -
//         a2 * e1 * y[i] -
//         a2 * f1
//       ) /
//       (a1 * b2 * y[i] + a1 * d2 - a2 * b1 * y[i] - a2 * d1)

//     r.push([x, y[i]])
//   }

//   return r
// }

// ?
function bezout(e1: number[], e2: number[]) {
  const AB = e1[0] * e2[1] - e2[0] * e1[1]
  const AC = e1[0] * e2[2] - e2[0] * e1[2]
  const AD = e1[0] * e2[3] - e2[0] * e1[3]
  const AE = e1[0] * e2[4] - e2[0] * e1[4]
  const AF = e1[0] * e2[5] - e2[0] * e1[5]
  const BC = e1[1] * e2[2] - e2[1] * e1[2]
  const BE = e1[1] * e2[4] - e2[1] * e1[4]
  const BF = e1[1] * e2[5] - e2[1] * e1[5]
  const CD = e1[2] * e2[3] - e2[2] * e1[3]
  const DE = e1[3] * e2[4] - e2[3] * e1[4]
  const DF = e1[3] * e2[5] - e2[3] * e1[5]
  const BFpDE = BF + DE
  const BEmCD = BE - CD

  return [
    AB * BC - AC * AC,
    AB * BEmCD + AD * BC - 2 * AC * AE,
    AB * BFpDE + AD * BEmCD - AE * AE - 2 * AC * AF,
    AB * DF + AD * BFpDE - 2 * AE * AF,
    AD * DF - AF * AF,
  ]
}

function getPolyDegree(poly: number[]) {
  return poly.length - 1
}

function getPolynomialRoots(poly: number[]): number[] {
  const coefs = [...poly]

  // Simplify coefs
  for (let i = getPolyDegree(coefs); i >= 0; i--) {
    if (Math.abs(coefs[i]) <= 1e-6) coefs.pop()
    else break
  }

  // Return roots based on degree
  switch (getPolyDegree(coefs)) {
    case 1: {
      return getLinearPolymonialRoots(coefs)
    }
    case 2: {
      return getQuadradicPolynomialRoots(coefs)
    }
    case 3: {
      return getCubicPolymonialRoots(coefs)
    }
    case 4: {
      return getQuarticPolymomialRoots(coefs)
    }
  }

  return []
}

function getLinearPolymonialRoots(poly: number[]): number[] {
  const results: number[] = []
  const a = poly[1]

  if (a !== 0) results.push(-poly[0] / a)

  return results
}

function getQuadradicPolynomialRoots(poly: number[]): number[] {
  const results: number[] = []

  if (getPolyDegree(poly) === 2) {
    const a = poly[2]
    const b = poly[1] / a
    const c = poly[0] / a
    const d = b * b - 4 * c

    if (d > 0) {
      const e = Math.sqrt(d)
      results.push(0.5 * (-b + e))
      results.push(0.5 * (-b - e))
    } else if (d == 0) {
      results.push(0.5 * -b)
    }
  }
  return results
}

function getCubicPolymonialRoots(poly: number[]): number[] {
  const results: number[] = []

  if (getPolyDegree(poly) == 3) {
    const c3 = poly[3]
    const c2 = poly[2] / c3
    const c1 = poly[1] / c3
    const c0 = poly[0] / c3
    const a = (3 * c1 - c2 * c2) / 3
    const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27
    const offset = c2 / 3
    const halfB = b / 2
    let discrim = (b * b) / 4 + (a * a * a) / 27

    if (Math.abs(discrim) <= 1e-6) discrim = 0

    if (discrim > 0) {
      const e = Math.sqrt(discrim)
      let tmp: number
      let root: number
      tmp = -halfB + e
      if (tmp >= 0) root = Math.pow(tmp, 1 / 3)
      else root = -Math.pow(-tmp, 1 / 3)
      tmp = -halfB - e
      if (tmp >= 0) root += Math.pow(tmp, 1 / 3)
      else root -= Math.pow(-tmp, 1 / 3)
      results.push(root - offset)
    } else if (discrim < 0) {
      const distance = Math.sqrt(-a / 3)
      const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3
      const cos = Math.cos(angle)
      const sin = Math.sin(angle)
      const sqrt3 = Math.sqrt(3)
      results.push(2 * distance * cos - offset)
      results.push(-distance * (cos + sqrt3 * sin) - offset)
      results.push(-distance * (cos - sqrt3 * sin) - offset)
    } else {
      let tmp: number
      if (halfB >= 0) tmp = -Math.pow(halfB, 1 / 3)
      else tmp = Math.pow(-halfB, 1 / 3)
      results.push(2 * tmp - offset)
      results.push(-tmp - offset)
    }
  }

  return results
}

function getQuarticPolymomialRoots(poly: number[]): number[] {
  const results: number[] = []
  if (getPolyDegree(poly) == 4) {
    const c4 = poly[4]
    const c3 = poly[3] / c4
    const c2 = poly[2] / c4
    const c1 = poly[1] / c4
    const c0 = poly[0] / c4
    const resolveRoots = getCubicPolymonialRoots([
      1,
      -c2,
      c3 * c1 - 4 * c0,
      -c3 * c3 * c0 + 4 * c2 * c0 - c1 * c1,
    ])
    const y = resolveRoots[0]
    let discrim = (c3 * c3) / 4 - c2 + y
    if (Math.abs(discrim) <= 1e-6) discrim = 0
    if (discrim > 0) {
      const e = Math.sqrt(discrim)
      const t1 = (3 * c3 * c3) / 4 - e * e - 2 * c2
      const t2 = (4 * c3 * c2 - 8 * c1 - c3 * c3 * c3) / (4 * e)
      let plus = t1 + t2
      let minus = t1 - t2
      if (Math.abs(plus) <= 1e-6) plus = 0
      if (Math.abs(minus) <= 1e-6) minus = 0
      if (plus >= 0) {
        const f = Math.sqrt(plus)
        results.push(-c3 / 4 + (e + f) / 2)
        results.push(-c3 / 4 + (e - f) / 2)
      }
      if (minus >= 0) {
        const f = Math.sqrt(minus)
        results.push(-c3 / 4 + (f - e) / 2)
        results.push(-c3 / 4 - (f + e) / 2)
      }
    } else if (discrim >= 0) {
      let t2 = y * y - 4 * c0
      if (t2 >= -1e-6) {
        if (t2 < 0) t2 = 0
        t2 = 2 * Math.sqrt(t2)
        const t1 = (3 * c3 * c3) / 4 - 2 * c2
        if (t1 + t2 >= 1e-6) {
          const d = Math.sqrt(t1 + t2)
          results.push(-c3 / 4 + d / 2)
          results.push(-c3 / 4 - d / 2)
        }
        if (t1 - t2 >= 1e-6) {
          const d = Math.sqrt(t1 - t2)
          results.push(-c3 / 4 + d / 2)
          results.push(-c3 / 4 - d / 2)
        }
      }
    }
  }
  return results
}




 class Utils {
  /**
   * Linear interpolation betwen two numbers.
   * @param y1
   * @param y2
   * @param mu
   */
  static lerp(y1: number, y2: number, mu: number): number {
    mu = Utils.clamp(mu, 0, 1)
    return y1 * (1 - mu) + y2 * mu
  }

  /**
   * Modulate a value between two ranges.
   * @param value
   * @param rangeA from [low, high]
   * @param rangeB to [low, high]
   * @param clamp
   */
  static modulate(
    value: number,
    rangeA: number[],
    rangeB: number[],
    clamp = false
  ): number {
    const [fromLow, fromHigh] = rangeA
    const [v0, v1] = rangeB
    const result = v0 + ((value - fromLow) / (fromHigh - fromLow)) * (v1 - v0)

    return clamp
      ? v0 < v1
        ? Math.max(Math.min(result, v1), v0)
        : Math.max(Math.min(result, v0), v1)
      : result
  }

  /**
   * Clamp a value into a range.
   * @param n
   * @param min
   */
  static clamp(n: number, min: number): number
  static clamp(n: number, min: number, max: number): number
  static clamp(n: number, min: number, max?: number): number {
    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)
  }

  // TODO: replace with a string compression algorithm
  static compress(s: string): string {
    return s
  }

  // TODO: replace with a string decompression algorithm
  static decompress(s: string): string {
    return s
  }

  /**
   * Recursively clone an object or array.
   * @param obj
   */
  static deepClone<T>(obj: T): T {
    if (obj === null) return null

    const clone: any = { ...obj }

    Object.keys(obj).forEach(
      (key) =>
        (clone[key] =
          typeof obj[key] === 'object' ? Utils.deepClone(obj[key]) : obj[key])
    )

    if (Array.isArray(obj)) {
      clone.length = obj.length
      return Array.from(clone) as any as T
    }

    return clone as T
  }

  /**
   * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift).
   * The result will always be betweeen -1 and 1.
   *
   * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).
   */
  static rng(seed = ''): () => number {
    let x = 0
    let y = 0
    let z = 0
    let w = 0

    function next() {
      const t = x ^ (x << 11)
      ;(x = y), (y = z), (z = w)
      w ^= ((w >>> 19) ^ t ^ (t >>> 8)) >>> 0
      return w / 0x100000000
    }

    for (let k = 0; k < seed.length + 64; k++) {
      ;(x ^= seed.charCodeAt(k) | 0), next()
    }

    return next
  }

  /**
   * Shuffle the contents of an array.
   * @param arr
   * @param offset
   */
  static shuffleArr<T>(arr: T[], offset: number): T[] {
    return arr.map((_, i) => arr[(i + offset) % arr.length])
  }

  /**
   * Deep compare two arrays.
   * @param a
   * @param b
   */
  static deepCompareArrays<T>(a: T[], b: T[]): boolean {
    if (a?.length !== b?.length) return false
    return Utils.deepCompare(a, b)
  }

  /**
   * Deep compare any values.
   * @param a
   * @param b
   */
  static deepCompare<T>(a: T, b: T): boolean {
    return a === b || JSON.stringify(a) === JSON.stringify(b)
  }

  /**
   * Find whether two arrays intersect.
   * @param a
   * @param b
   * @param fn An optional function to apply to the items of a; will check if b includes the result.
   */
  static arrsIntersect<T, K>(a: T[], b: K[], fn?: (item: K) => T): boolean
  static arrsIntersect<T>(a: T[], b: T[]): boolean
  static arrsIntersect<T>(
    a: T[],
    b: unknown[],
    fn?: (item: unknown) => T
  ): boolean {
    return a.some((item) => b.includes(fn ? fn(item) : item))
  }

  /**
   * Get the unique values from an array of strings or numbers.
   * @param items
   */
  static uniqueArray<T extends string | number>(...items: T[]): T[] {
    return Array.from(new Set(items).values())
  }

  /**
   * Convert a set to an array.
   * @param set
   */
  static setToArray<T>(set: Set<T>): T[] {
    return Array.from(set.values())
  }

  /**
   * Get the outer of between a circle and a point.
   * @param C The circle's center.
   * @param r The circle's radius.
   * @param P The point.
   * @param side
   */
  static getCircleTangentToPoint(
    C: number[],
    r: number,
    P: number[],
    side: number
  ): number[] {
    const B = Vec.lrp(C, P, 0.5),
      r1 = Vec.dist(C, B),
      delta = Vec.sub(B, C),
      d = Vec.len(delta)

    if (!(d <= r + r1 && d >= Math.abs(r - r1))) {
      return
    }

    const a = (r * r - r1 * r1 + d * d) / (2.0 * d),
      n = 1 / d,
      p = Vec.add(C, Vec.mul(delta, a * n)),
      h = Math.sqrt(r * r - a * a),
      k = Vec.mul(Vec.per(delta), h * n)

    return side === 0 ? Vec.add(p, k) : Vec.sub(p, k)
  }

  /**
   * Get outer tangents of two circles.
   * @param x0
   * @param y0
   * @param r0
   * @param x1
   * @param y1
   * @param r1
   * @returns [lx0, ly0, lx1, ly1, rx0, ry0, rx1, ry1]
   */
  static getOuterTangentsOfCircles(
    C0: number[],
    r0: number,
    C1: number[],
    r1: number
  ): number[][] {
    const a0 = Vec.angle(C0, C1)
    const d = Vec.dist(C0, C1)

    // Circles are overlapping, no tangents
    if (d < Math.abs(r1 - r0)) return

    const a1 = Math.acos((r0 - r1) / d),
      t0 = a0 + a1,
      t1 = a0 - a1

    return [
      [C0[0] + r0 * Math.cos(t1), C0[1] + r0 * Math.sin(t1)],
      [C1[0] + r1 * Math.cos(t1), C1[1] + r1 * Math.sin(t1)],
      [C0[0] + r0 * Math.cos(t0), C0[1] + r0 * Math.sin(t0)],
      [C1[0] + r1 * Math.cos(t0), C1[1] + r1 * Math.sin(t0)],
    ]
  }

  /**
   * Get the closest point on the perimeter of a circle to a given point.
   * @param C The circle's center.
   * @param r The circle's radius.
   * @param P The point.
   */
  static getClosestPointOnCircle(
    C: number[],
    r: number,
    P: number[]
  ): number[] {
    const v = Vec.sub(C, P)
    return Vec.sub(C, Vec.mul(Vec.div(v, Vec.len(v)), r))
  }

  static det(
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number
  ): number {
    return a * e * i + b * f * g + c * d * h - a * f * h - b * d * i - c * e * g
  }

  /**
   * Get a circle from three points.
   * @param A
   * @param B
   * @param C
   * @returns [x, y, r]
   */
  static circleFromThreePoints(
    A: number[],
    B: number[],
    C: number[]
  ): number[] {
    const a = Utils.det(A[0], A[1], 1, B[0], B[1], 1, C[0], C[1], 1)

    const bx = -Utils.det(
      A[0] * A[0] + A[1] * A[1],
      A[1],
      1,
      B[0] * B[0] + B[1] * B[1],
      B[1],
      1,
      C[0] * C[0] + C[1] * C[1],
      C[1],
      1
    )
    const by = Utils.det(
      A[0] * A[0] + A[1] * A[1],
      A[0],
      1,
      B[0] * B[0] + B[1] * B[1],
      B[0],
      1,
      C[0] * C[0] + C[1] * C[1],
      C[0],
      1
    )
    const c = -Utils.det(
      A[0] * A[0] + A[1] * A[1],
      A[0],
      A[1],
      B[0] * B[0] + B[1] * B[1],
      B[0],
      B[1],
      C[0] * C[0] + C[1] * C[1],
      C[0],
      C[1]
    )

    const x = -bx / (2 * a)
    const y = -by / (2 * a)
    const r = Math.sqrt(bx * bx + by * by - 4 * a * c) / (2 * Math.abs(a))

    return [x, y, r]
  }

  /**
   * Find the approximate perimeter of an ellipse.
   * @param rx
   * @param ry
   */
  static perimeterOfEllipse(rx: number, ry: number): number {
    const h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2)
    const p = Math.PI * (rx + ry) * (1 + (3 * h) / (10 + Math.sqrt(4 - 3 * h)))
    return p
  }

  /**
   * Get the short angle distance between two angles.
   * @param a0
   * @param a1
   */
  static shortAngleDist(a0: number, a1: number): number {
    const max = Math.PI * 2
    const da = (a1 - a0) % max
    return ((2 * da) % max) - da
  }

  /**
   * Get the long angle distance between two angles.
   * @param a0
   * @param a1
   */
  static longAngleDist(a0: number, a1: number): number {
    return Math.PI * 2 - Utils.shortAngleDist(a0, a1)
  }

  /**
   * Interpolate an angle between two angles.
   * @param a0
   * @param a1
   * @param t
   */
  static lerpAngles(a0: number, a1: number, t: number): number {
    return a0 + Utils.shortAngleDist(a0, a1) * t
  }

  /**
   * Get the short distance between two angles.
   * @param a0
   * @param a1
   */
  static angleDelta(a0: number, a1: number): number {
    return Utils.shortAngleDist(a0, a1)
  }

  /**
   * Get the "sweep" or short distance between two points on a circle's perimeter.
   * @param C
   * @param A
   * @param B
   */
  static getSweep(C: number[], A: number[], B: number[]): number {
    return Utils.angleDelta(Vec.angle(C, A), Vec.angle(C, B))
  }

  /**
   * Rotate a point around a center.
   * @param x The x-axis coordinate of the point.
   * @param y The y-axis coordinate of the point.
   * @param cx The x-axis coordinate of the point to rotate round.
   * @param cy The y-axis coordinate of the point to rotate round.
   * @param angle The distance (in radians) to rotate.
   */
  static rotatePoint(A: number[], B: number[], angle: number): number[] {
    const s = Math.sin(angle)
    const c = Math.cos(angle)

    const px = A[0] - B[0]
    const py = A[1] - B[1]

    const nx = px * c - py * s
    const ny = px * s + py * c

    return [nx + B[0], ny + B[1]]
  }

  /**
   * Clamp radians within 0 and 2PI
   * @param r
   */
  static clampRadians(r: number): number {
    return (Math.PI * 2 + r) % (Math.PI * 2)
  }

  /**
   * Clamp rotation to even segments.
   * @param r
   * @param segments
   */
  static clampToRotationToSegments(r: number, segments: number): number {
    const seg = (Math.PI * 2) / segments
    return Math.floor((Utils.clampRadians(r) + seg / 2) / seg) * seg
  }

  /**
   * Is angle c between angles a and b?
   * @param a
   * @param b
   * @param c
   */
  static isAngleBetween(a: number, b: number, c: number): boolean {
    if (c === a || c === b) return true
    const PI2 = Math.PI * 2
    const AB = (b - a + PI2) % PI2
    const AC = (c - a + PI2) % PI2
    return AB <= Math.PI !== AC > AB
  }

  /**
   * Convert degrees to radians.
   * @param d
   */
  static degreesToRadians(d: number): number {
    return (d * Math.PI) / 180
  }

  /**
   * Convert radians to degrees.
   * @param r
   */
  static radiansToDegrees(r: number): number {
    return (r * 180) / Math.PI
  }

  /**
   * Get the length of an arc between two points on a circle's perimeter.
   * @param C
   * @param r
   * @param A
   * @param B
   */
  static getArcLength(
    C: number[],
    r: number,
    A: number[],
    B: number[]
  ): number {
    const sweep = Utils.getSweep(C, A, B)
    return r * (2 * Math.PI) * (sweep / (2 * Math.PI))
  }

  /**
   * Get a dash offset for an arc, based on its length.
   * @param C
   * @param r
   * @param A
   * @param B
   * @param step
   */
  static getArcDashOffset(
    C: number[],
    r: number,
    A: number[],
    B: number[],
    step: number
  ): number {
    const del0 = Utils.getSweep(C, A, B)
    const len0 = Utils.getArcLength(C, r, A, B)
    const off0 = del0 < 0 ? len0 : 2 * Math.PI * C[2] - len0
    return -off0 / 2 + step
  }

  /**
   * Get a dash offset for an ellipse, based on its length.
   * @param A
   * @param step
   */
  static getEllipseDashOffset(A: number[], step: number): number {
    const c = 2 * Math.PI * A[2]
    return -c / 2 + -step
  }

  /**
   * Get an array of points between two points.
   * @param a
   * @param b
   * @param options
   */
  static getPointsBetween(
    a: number[],
    b: number[],
    options = {} as {
      steps?: number
      ease?: (t: number) => number
    }
  ): number[][] {
    const { steps = 6, ease = (t) => t * t * t } = options

    return Array.from(Array(steps))
      .map((_, i) => ease(i / steps))
      .map((t) => [...Vec.lrp(a, b, t), (1 - t) / 2])
  }

  static getRayRayIntersection(
    p0: number[],
    n0: number[],
    p1: number[],
    n1: number[]
  ): number[] {
    const p0e = Vec.add(p0, n0),
      p1e = Vec.add(p1, n1),
      m0 = (p0e[1] - p0[1]) / (p0e[0] - p0[0]),
      m1 = (p1e[1] - p1[1]) / (p1e[0] - p1[0]),
      b0 = p0[1] - m0 * p0[0],
      b1 = p1[1] - m1 * p1[0],
      x = (b1 - b0) / (m0 - m1),
      y = m0 * x + b0

    return [x, y]
  }

  static bez1d(a: number, b: number, c: number, d: number, t: number): number {
    return (
      a * (1 - t) * (1 - t) * (1 - t) +
      3 * b * t * (1 - t) * (1 - t) +
      3 * c * t * t * (1 - t) +
      d * t * t * t
    )
  }

  static getCubicBezierBounds(
    p0: number[],
    c0: number[],
    c1: number[],
    p1: number[]
  ): Bounds {
    // solve for x
    let a = 3 * p1[0] - 9 * c1[0] + 9 * c0[0] - 3 * p0[0]
    let b = 6 * p0[0] - 12 * c0[0] + 6 * c1[0]
    let c = 3 * c0[0] - 3 * p0[0]
    let disc = b * b - 4 * a * c
    let xl = p0[0]
    let xh = p0[0]

    if (p1[0] < xl) xl = p1[0]
    if (p1[0] > xh) xh = p1[0]

    if (disc >= 0) {
      const t1 = (-b + Math.sqrt(disc)) / (2 * a)
      if (t1 > 0 && t1 < 1) {
        const x1 = Utils.bez1d(p0[0], c0[0], c1[0], p1[0], t1)
        if (x1 < xl) xl = x1
        if (x1 > xh) xh = x1
      }
      const t2 = (-b - Math.sqrt(disc)) / (2 * a)
      if (t2 > 0 && t2 < 1) {
        const x2 = Utils.bez1d(p0[0], c0[0], c1[0], p1[0], t2)
        if (x2 < xl) xl = x2
        if (x2 > xh) xh = x2
      }
    }

    // Solve for y
    a = 3 * p1[1] - 9 * c1[1] + 9 * c0[1] - 3 * p0[1]
    b = 6 * p0[1] - 12 * c0[1] + 6 * c1[1]
    c = 3 * c0[1] - 3 * p0[1]
    disc = b * b - 4 * a * c
    let yl = p0[1]
    let yh = p0[1]
    if (p1[1] < yl) yl = p1[1]
    if (p1[1] > yh) yh = p1[1]
    if (disc >= 0) {
      const t1 = (-b + Math.sqrt(disc)) / (2 * a)
      if (t1 > 0 && t1 < 1) {
        const y1 = Utils.bez1d(p0[1], c0[1], c1[1], p1[1], t1)
        if (y1 < yl) yl = y1
        if (y1 > yh) yh = y1
      }
      const t2 = (-b - Math.sqrt(disc)) / (2 * a)
      if (t2 > 0 && t2 < 1) {
        const y2 = Utils.bez1d(p0[1], c0[1], c1[1], p1[1], t2)
        if (y2 < yl) yl = y2
        if (y2 > yh) yh = y2
      }
    }

    return {
      minX: xl,
      minY: yl,
      maxX: xh,
      maxY: yh,
      width: Math.abs(xl - xh),
      height: Math.abs(yl - yh),
    }
  }

  static getExpandedBounds(a: Bounds, b: Bounds): Bounds {
    const minX = Math.min(a.minX, b.minX),
      minY = Math.min(a.minY, b.minY),
      maxX = Math.max(a.maxX, b.maxX),
      maxY = Math.max(a.maxY, b.maxY),
      width = Math.abs(maxX - minX),
      height = Math.abs(maxY - minY)

    return { minX, minY, maxX, maxY, width, height }
  }

  static getCommonBounds(...b: Bounds[]): Bounds {
    if (b.length < 2) return b[0]

    let bounds = b[0]

    for (let i = 1; i < b.length; i++) {
      bounds = Utils.getExpandedBounds(bounds, b[i])
    }

    return bounds
  }

  /**
   * Get a bezier curve data for a spline that fits an array of points.
   * @param pts
   * @param tension
   * @param isClosed
   * @param numOfSegments
   */
  static getCurvePoints(
    pts: number[][],
    tension = 0.5,
    isClosed = false,
    numOfSegments = 3
  ): number[][] {
    const _pts = [...pts],
      len = pts.length,
      res: number[][] = [] // results

    let t1x: number, // tension vectors
      t2x: number,
      t1y: number,
      t2y: number,
      c1: number, // cardinal points
      c2: number,
      c3: number,
      c4: number,
      st: number,
      st2: number,
      st3: number

    // The algorithm require a previous and next point to the actual point array.
    // Check if we will draw closed or open curve.
    // If closed, copy end points to beginning and first points to end
    // If open, duplicate first points to befinning, end points to end
    if (isClosed) {
      _pts.unshift(_pts[len - 1])
      _pts.push(_pts[0])
    } else {
      //copy 1. point and insert at beginning
      _pts.unshift(_pts[0])
      _pts.push(_pts[len - 1])
      // _pts.push(_pts[len - 1])
    }

    // For each point, calculate a segment
    for (let i = 1; i < _pts.length - 2; i++) {
      // Calculate points along segment and add to results
      for (let t = 0; t <= numOfSegments; t++) {
        // Step
        st = t / numOfSegments
        st2 = Math.pow(st, 2)
        st3 = Math.pow(st, 3)

        // Cardinals
        c1 = 2 * st3 - 3 * st2 + 1
        c2 = -(2 * st3) + 3 * st2
        c3 = st3 - 2 * st2 + st
        c4 = st3 - st2

        // Tension
        t1x = (_pts[i + 1][0] - _pts[i - 1][0]) * tension
        t2x = (_pts[i + 2][0] - _pts[i][0]) * tension
        t1y = (_pts[i + 1][1] - _pts[i - 1][1]) * tension
        t2y = (_pts[i + 2][1] - _pts[i][1]) * tension

        // Control points
        res.push([
          c1 * _pts[i][0] + c2 * _pts[i + 1][0] + c3 * t1x + c4 * t2x,
          c1 * _pts[i][1] + c2 * _pts[i + 1][1] + c3 * t1y + c4 * t2y,
        ])
      }
    }

    res.push(pts[pts.length - 1])

    return res
  }

  /**
   * Simplify a line (using Ramer-Douglas-Peucker algorithm).
   * @param points An array of points as [x, y, ...][]
   * @param tolerance The minimum line distance (also called epsilon).
   * @returns Simplified array as [x, y, ...][]
   */
  static simplify(points: number[][], tolerance = 1): number[][] {
    const len = points.length,
      a = points[0],
      b = points[len - 1],
      [x1, y1] = a,
      [x2, y2] = b

    if (len > 2) {
      let distance = 0
      let index = 0
      const max = Math.hypot(y2 - y1, x2 - x1)

      for (let i = 1; i < len - 1; i++) {
        const [x0, y0] = points[i],
          d =
            Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / max

        if (distance > d) continue

        distance = d
        index = i
      }

      if (distance > tolerance) {
        const l0 = Utils.simplify(points.slice(0, index + 1), tolerance)
        const l1 = Utils.simplify(points.slice(index + 1), tolerance)
        return l0.concat(l1.slice(1))
      }
    }

    return [a, b]
  }
}




 class CodeShape<T extends Shape> {
  private _shape: Mutable<T>
  protected utils: ShapeUtility<T>

  constructor(props: T) {
    this._shape = createShape(props.type, props) as Mutable<T>
    this.utils = getShapeUtils<T>(this._shape)
    codeShapes.add(this)
  }

  /**
   * Destroy the shape.
   *
   * \`\`\`ts
   * shape.destroy()
   * \`\`\`
   */
  destroy = (): void => {
    codeShapes.delete(this)
  }

  /**
   * Move the shape to a point.
   *
   * \`\`\`ts
   * shape.moveTo(100,100)
   * \`\`\`
   */
  moveTo = (point: number[]): CodeShape<T> => {
    return this.translateTo(point)
  }

  /**
   * Move the shape to a point.
   *
   * \`\`\`ts
   * shape.translateTo([100,100])
   * \`\`\`
   */
  translateTo = (point: number[]): CodeShape<T> => {
    this.utils.translateTo(this._shape, point)
    return this
  }

  /**
   * Move the shape by a delta.
   *
   * \`\`\`ts
   * shape.translateBy([100,100])
   * \`\`\`
   */
  translateBy = (delta: number[]): CodeShape<T> => {
    this.utils.translateTo(this._shape, delta)
    return this
  }

  /**
   * Rotate the shape.
   *
   * \`\`\`ts
   * shape.rotateTo(Math.PI / 2)
   * \`\`\`
   */
  rotateTo = (rotation: number): CodeShape<T> => {
    this.utils.rotateTo(this._shape, rotation, this.shape.rotation - rotation)
    return this
  }

  /**
   * Rotate the shape by a delta.
   *
   * \`\`\`ts
   * shape.rotateBy(Math.PI / 2)
   * \`\`\`
   */
  rotateBy = (rotation: number): CodeShape<T> => {
    this.utils.rotateBy(this._shape, rotation)
    return this
  }

  /**
   * Get the shape's bounding box.
   *
   * \`\`\`ts
   * const bounds = shape.getBounds()
   * \`\`\`
   */
  getBounds = (): CodeShape<T> => {
    this.utils.getBounds(this.shape)
    return this
  }

  /**
   * Test whether a point is inside of the shape.
   *
   * \`\`\`ts
   * const isHit = shape.hitTest()
   * \`\`\`
   */
  hitTest = (point: number[]): CodeShape<T> => {
    this.utils.hitTest(this.shape, point)
    return this
  }

  /**
   * Duplicate this shape.
   *
   * \`\`\`ts
   * const shapeB = shape.duplicate()
   * \`\`\`
   */
  duplicate = (): CodeShape<T> => {
    const duplicate = Object.assign(
      Object.create(Object.getPrototypeOf(this)),
      this
    )

    duplicate._shape = createShape(this._shape.type, {
      ...this._shape,
      id: uniqueId(),
    } as any)

    codeShapes.add(duplicate)
    return duplicate
  }

  /**
   * Move the shape to the back of the painting order.
   *
   * \`\`\`ts
   * shape.moveToBack()
   * \`\`\`
   */
  moveToBack = (): CodeShape<T> => {
    const sorted = getOrderedShapes()

    if (sorted.length <= 1) return

    const first = sorted[0].childIndex
    sorted.forEach((shape) => shape.childIndex++)
    this.childIndex = first

    codeShapes.clear()
    sorted.forEach((shape) => codeShapes.add(shape))

    return this
  }

  /**
   * Move the shape to the top of the painting order.
   *
   * \`\`\`ts
   * shape.moveToFront()
   * \`\`\`
   */
  moveToFront = (): CodeShape<T> => {
    const sorted = getOrderedShapes()

    if (sorted.length <= 1) return

    const ahead = sorted.slice(sorted.indexOf(this))
    const last = ahead[ahead.length - 1].childIndex
    ahead.forEach((shape) => shape.childIndex--)
    this.childIndex = last

    codeShapes.clear()
    sorted.forEach((shape) => codeShapes.add(shape))

    return this
  }

  /**
   * Move the shape backward in the painting order.
   *
   * \`\`\`ts
   * shape.moveBackward()
   * \`\`\`
   */
  moveBackward = (): CodeShape<T> => {
    const sorted = getOrderedShapes()

    if (sorted.length <= 1) return

    const next = sorted[sorted.indexOf(this) - 1]

    if (!next) return

    const index = next.childIndex
    next.childIndex = this.childIndex
    this.childIndex = index

    codeShapes.clear()
    sorted.forEach((shape) => codeShapes.add(shape))

    return this
  }

  /**
   * Move the shape forward in the painting order.
   *
   * \`\`\`ts
   * shape.moveForward()
   * \`\`\`
   */
  moveForward = (): CodeShape<T> => {
    const sorted = getOrderedShapes()

    if (sorted.length <= 1) return

    const next = sorted[sorted.indexOf(this) + 1]

    if (!next) return

    const index = next.childIndex
    next.childIndex = this.childIndex
    this.childIndex = index

    codeShapes.clear()
    sorted.forEach((shape) => codeShapes.add(shape))

    return this
  }

  get id(): string {
    return this._shape.id
  }

  /**
   * The shape's underlying shape (readonly).
   *
   * \`\`\`ts
   * const underlyingShape = shape.shape
   * \`\`\`
   */
  get shape(): Readonly<T> {
    return this._shape
  }

  /**
   * The shape's current point.
   *
   * \`\`\`ts
   * const shapePoint = shape.point()
   * \`\`\`
   */
  get point(): number[] {
    return [...this.shape.point]
  }

  set point(point: number[]) {
    this.utils.translateTo(this._shape, point)
  }

  /**
   * The shape's current x position.
   *
   * \`\`\`ts
   * const shapeX = shape.x
   *
   * shape.x = 100
   * \`\`\`
   */
  get x(): number {
    return this.point[0]
  }

  set x(x: number) {
    this.utils.translateTo(this._shape, [x, this.y])
  }

  /**
   * The shape's current y position.
   *
   * \`\`\`ts
   * const shapeY = shape.y
   *
   * shape.y = 100
   * \`\`\`
   */
  get y(): number {
    return this.point[1]
  }

  set y(y: number) {
    this.utils.translateTo(this._shape, [this.x, y])
  }

  /**
   * The shape's rotation.
   *
   * \`\`\`ts
   * const shapeRotation = shape.rotation
   *
   * shape.rotation = Math.PI / 2
   * \`\`\`
   */
  get rotation(): number {
    return this.shape.rotation
  }

  set rotation(rotation: number) {
    this.utils.rotateTo(this._shape, rotation, rotation - this.shape.rotation)
  }

  /**
   * The shape's color style (ColorStyle).
   *
   * \`\`\`ts
   * const shapeColor = shape.color
   *
   * shape.color = ColorStyle.Red
   * \`\`\`
   */
  get color(): ColorStyle {
    return this.shape.style.color
  }

  set color(color: ColorStyle) {
    this.utils.applyStyles(this._shape, { color })
  }

  /**
   * The shape's dash style (DashStyle).
   *
   * \`\`\`ts
   * const shapeDash = shape.dash
   *
   * shape.dash = DashStyle.Dotted
   * \`\`\`
   */
  get dash(): DashStyle {
    return this.shape.style.dash
  }

  set dash(dash: DashStyle) {
    this.utils.applyStyles(this._shape, { dash })
  }

  /**
   * The shape's size (SizeStyle).
   *
   * \`\`\`ts
   * const shapeSize = shape.size
   *
   * shape.size = SizeStyle.Large
   * \`\`\`
   */
  get size(): SizeStyle {
    return this.shape.style.size
  }

  set size(size: SizeStyle) {
    this.utils.applyStyles(this._shape, { size })
  }

  /**
   * The shape's index in the painting order.
   *
   * \`\`\`ts
   * const shapeChildIndex = shape.childIndex
   *
   * shape.childIndex = 10
   * \`\`\`
   */
  get childIndex(): number {
    return this.shape.childIndex
  }

  set childIndex(childIndex: number) {
    this.utils.setProperty(this._shape, 'childIndex', childIndex)
  }

  /**
   * The shape's center.
   *
   * \`\`\`ts
   * const shapeCenter = shape.center
   *
   * shape.center = [100, 100]
   * \`\`\`
   */
  get center(): number[] {
    return this.utils.getCenter(this.shape)
  }

  set center(center: number[]) {
    const oldCenter = this.utils.getCenter(this.shape)
    const delta = Vec.sub(center, oldCenter)
    this.translateBy(delta)
  }
}




 class Dot extends CodeShape<DotShape> {
  constructor(props = {} as ShapeProps<DotShape>) {
    super({
      id: uniqueId(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Dot,
      isGenerated: true,
      name: 'Dot',
      childIndex: 0,
      point: [0, 0],
      rotation: 0,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: true,
      },
    })
  }
}




 class Ellipse extends CodeShape<EllipseShape> {
  constructor(props = {} as ShapeProps<EllipseShape>) {
    super({
      id: uniqueId(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Ellipse,
      isGenerated: true,
      name: 'Ellipse',
      childIndex: 0,
      point: [0, 0],
      radiusX: 50,
      radiusY: 50,
      rotation: 0,
      ...props,
      style: { ...defaultStyle, ...props.style },
    })
  }

  /**
   * The ellipse's x radius.
   *
   * \`\`\`ts
   * const shapeRadiusX = shape.radiusX
   *
   * shape.radiusX = 100
   * \`\`\`
   */
  get radiusX(): number {
    return this.shape.radiusX
  }

  set radiusX(radiusX: number) {
    this.utils.setProperty(this.shape, 'radiusX', radiusX)
  }

  /**
   * The ellipse's y radius.
   *
   * \`\`\`ts
   * const shapeRadiusY = shape.radiusY
   *
   * shape.radiusY = 100
   * \`\`\`
   */
  get radiusY(): number {
    return this.shape.radiusY
  }

  set radiusY(radiusY: number) {
    this.utils.setProperty(this.shape, 'radiusY', radiusY)
  }
}




 class Line extends CodeShape<LineShape> {
  constructor(props = {} as ShapeProps<LineShape>) {
    super({
      id: uniqueId(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Line,
      isGenerated: true,
      name: 'Line',
      childIndex: 0,
      point: [0, 0],
      direction: [-0.5, 0.5],
      rotation: 0,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  /**
   * The line's direction.
   *
   * \`\`\`ts
   * const shapeDirection = shape.direction
   *
   * shape.direction = [0,0]
   * \`\`\`
   */
  get direction(): number[] {
    return this.shape.direction
  }
  set direction(direction: number[]) {
    this.utils.setProperty(this.shape, 'direction', direction)
  }
}




 class Polyline extends CodeShape<PolylineShape> {
  constructor(props = {} as ShapeProps<PolylineShape>) {
    super({
      id: uniqueId(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Polyline,
      isGenerated: true,
      name: 'Polyline',
      childIndex: 0,
      point: [0, 0],
      points: [[0, 0]],
      rotation: 0,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }

  /**
   * Add a point to the polyline's points.
   *
   * \`\`\`ts
   * shape.addPoint([100,100])
   * \`\`\`
   */
  addPoint(point: number[]): CodeShape<PolylineShape> {
    this.utils.setProperty(this.shape, 'points', [...this.points, point])
    return this
  }

  /**
   * The polyline's points.
   *
   * \`\`\`ts
   * const shapePoints = shape.points
   *
   * shape.points = [[0,0], [100,100], [100,200]]
   * \`\`\`
   */
  get points(): number[][] {
    return this.shape.points
  }

  set points(points: number[][]) {
    this.utils.setProperty(this.shape, 'points', points)
  }
}




 class Ray extends CodeShape<RayShape> {
  constructor(props = {} as ShapeProps<RayShape>) {
    super({
      id: uniqueId(),
      type: ShapeType.Ray,
      isGenerated: true,
      name: 'Ray',
      parentId: 'page1',
      childIndex: 0,
      point: [0, 0],
      direction: [0, 1],
      rotation: 0,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  /**
   * The ray's direction.
   *
   * \`\`\`ts
   * const shapeDirection = shape.direction
   *
   * shape.direction = [0,0]
   * \`\`\`
   */
  get direction(): number[] {
    return this.shape.direction
  }
  set direction(direction: number[]) {
    this.utils.setProperty(this.shape, 'direction', direction)
  }
}




 class Arrow extends CodeShape<ArrowShape> {
  constructor(
    props = {} as ShapeProps<ArrowShape> & { start: number[]; end: number[] }
  ) {
    const { start = [0, 0], end = [100, 100] } = props

    const {
      point = [0, 0],
      handles = {
        start: {
          id: 'start',
          index: 0,
          point: start,
        },
        end: {
          id: 'end',
          index: 1,
          point: end,
        },
        bend: {
          id: 'bend',
          index: 2,
          point: Vec.med(start, end),
        },
      },
    } = props

    super({
      id: uniqueId(),
      type: ShapeType.Arrow,
      name: 'Arrow',
      parentId: 'page1',
      childIndex: 0,
      point,
      rotation: 0,
      bend: 0,
      handles,
      decorations: {
        start: null,
        middle: null,
        end: Decoration.Arrow,
      },
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  /**
   * The arrow's start point.
   *
   * \`\`\`ts
   * const startPoint = shape.start
   *
   * shape.start = [100, 100]
   * \`\`\`
   */
  get start(): number[] {
    return this.shape.handles.start.point
  }

  set start(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      start: { ...this.shape.handles.start, point },
    })
  }

  /**
   * The arrow's middle point.
   *
   * \`\`\`ts
   * const middlePoint = shape.middle
   *
   * shape.middle = [100, 100]
   * \`\`\`
   */
  get middle(): number[] {
    return this.shape.handles.bend.point
  }

  set middle(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      bend: { ...this.shape.handles.bend, point },
    })
  }

  /**
   * The arrow's end point.
   *
   * \`\`\`ts
   * const endPoint = shape.end
   *
   * shape.end = [100, 100]
   * \`\`\`
   */
  get end(): number[] {
    return this.shape.handles.end.point
  }

  set end(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      end: { ...this.shape.handles.end, point },
    })
  }

  get bend(): number {
    return this.shape.bend
  }
}




 class Draw extends CodeShape<DrawShape> {
  constructor(props = {} as ShapeProps<DrawShape>) {
    super({
      id: uniqueId(),
      type: ShapeType.Draw,
      parentId: (window as any).currentPageId,
      name: 'Draw',
      childIndex: 0,
      point: [0, 0],
      points: [],
      rotation: 0,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }

  /**
   * Add a point to the draw shape's points.
   *
   * \`\`\`ts
   * shape.addPoint([100,100])
   * \`\`\`
   */
  addPoint(point: number[]): CodeShape<DrawShape> {
    this.utils.setProperty(this.shape, 'points', [...this.points, point])
    return this
  }

  /**
   * The draw shape's points.
   *
   * \`\`\`ts
   * const shapePoints = shape.points
   *
   * shape.points = [[0,0], [100,100], [100,200]]
   * \`\`\`
   */
  get points(): number[][] {
    return this.shape.points
  }

  set points(points: number[][]) {
    this.utils.setProperty(this.shape, 'points', points)
  }
}




 class Text extends CodeShape<TextShape> {
  constructor(props = {} as ShapeProps<TextShape>) {
    super({
      id: uniqueId(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Text,
      isGenerated: true,
      name: 'Text',
      childIndex: 0,
      point: [0, 0],
      rotation: 0,
      text: 'Text',
      scale: 1,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }

  /**
   * The text shape's text content.
   *
   * \`\`\`ts
   * const shapeText = shape.text
   *
   * shape.text = "Hello world!"
   * \`\`\`
   */
  get text(): string {
    return this.shape.text
  }

  set text(text: string) {
    getShapeUtils(this.shape).setProperty(this.shape, 'text', text)
  }

  /**
   * The text's scale.
   *
   * \`\`\`ts
   * const shapeScale = shape.scale
   *
   * shape.scale = 2
   * \`\`\`
   */
  get scale(): number {
    return this.shape.scale
  }

  set scale(scale: number) {
    getShapeUtils(this.shape).setProperty(this.shape, 'scale', scale)
  }
}




 class Rectangle extends CodeShape<RectangleShape> {
  constructor(props = {} as ShapeProps<RectangleShape>) {
    super({
      id: uniqueId(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Rectangle,
      isGenerated: true,
      name: 'Rectangle',
      childIndex: 0,
      point: [0, 0],
      size: [100, 100],
      rotation: 0,
      radius: 2,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }

  /**
   * The rectangle's width.
   *
   * \`\`\`ts
   * const shapeWidth = shape.width
   *
   * shape.width = 100
   * \`\`\`
   */
  get width(): number {
    return this.shape.size[0]
  }

  set width(width: number) {
    getShapeUtils(this.shape).setProperty(this.shape, 'size', [
      width,
      this.height,
    ])
  }

  /**
   * The rectangle's height.
   *
   * \`\`\`ts
   * const shapeHeight = shape.height
   *
   * shape.height = 100
   * \`\`\`
   */
  get height(): number {
    return this.shape.size[1]
  }

  set height(height: number) {
    getShapeUtils(this.shape).setProperty(this.shape, 'size', [
      this.width,
      height,
    ])
  }
}




class Control<T extends CodeControl> {
  _control: T

  constructor(control: T) {
    this._control = { ...control }
    codeControls.add(this._control)

    // Could there be a better way to prevent this?
    // When updating, constructor should just bind to
    // the existing control rather than creating a new one?
    if (!(window as any).isUpdatingCode) {
      controls[this._control.label] = this._control.value
    }
  }

  destroy(): void {
    codeControls.delete(this.control)
    delete controls[this.control.label]
  }

  get control(): T {
    return this._control
  }

  get id(): string {
    return this.control.id
  }

  get value(): T['value'] {
    return this.control.value
  }
}

type ControlProps<T extends CodeControl> = Omit<Partial<T>, 'type'>

class NumberControl extends Control<NumberCodeControl> {
  constructor(options: ControlProps<NumberCodeControl>) {
    const { id = uniqueId(), label = 'Number', value = 0, step = 1 } = options

    super({
      type: ControlType.Number,
      ...options,
      label,
      value,
      step,
      id,
    })
  }
}

class VectorControl extends Control<VectorCodeControl> {
  constructor(options: ControlProps<VectorCodeControl>) {
    const {
      id = uniqueId(),
      label = 'Vector',
      value = [0, 0],
      isNormalized = false,
    } = options

    super({
      type: ControlType.Vector,
      ...options,
      label,
      value,
      isNormalized,
      id,
    })
  }
}

class TextControl extends Control<TextCodeControl> {
  constructor(options: ControlProps<TextCodeControl>) {
    const { id = uniqueId(), label = 'Text', value = 'text' } = options

    super({
      type: ControlType.Text,
      ...options,
      label,
      value,
      id,
    })
  }
}


const codeShapes = new Set<CodeShape<any>>()
const controls: Record<string, any> = {}
const defaultStyle: ShapeStyles = {
  color: ColorStyle.Black,
  size: SizeStyle.Medium,
  isFilled: false,
  dash: DashStyle.Solid,
}
const uniqueId = () => ''
const codeControls = new Set([])

declare function createShape(type: ShapeType, shape: Shape): any
declare function getShapeUtils<T>(shape: T): any
declare function getOrderedShapes(): CodeShape<any>[]

`,
}
