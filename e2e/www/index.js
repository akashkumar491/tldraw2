'use strict'
var __create = Object.create
var __defProp = Object.defineProperty
var __getOwnPropDesc = Object.getOwnPropertyDescriptor
var __getOwnPropNames = Object.getOwnPropertyNames
var __getProtoOf = Object.getPrototypeOf
var __hasOwnProp = Object.prototype.hasOwnProperty
var __defNormalProp = (obj, key, value) =>
	key in obj
		? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
		: (obj[key] = value)
var __esm = (fn, res) =>
	function __init() {
		return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res
	}
var __commonJS = (cb, mod) =>
	function __require() {
		return (
			mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports
		)
	}
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, { get: all[name], enumerable: true })
}
var __copyProps = (to, from, except, desc) => {
	if ((from && typeof from === 'object') || typeof from === 'function') {
		for (let key of __getOwnPropNames(from))
			if (!__hasOwnProp.call(to, key) && key !== except)
				__defProp(to, key, {
					get: () => from[key],
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
				})
	}
	return to
}
var __toESM = (mod, isNodeMode, target) => (
	(target = mod != null ? __create(__getProtoOf(mod)) : {}),
	__copyProps(
		// If the importer is in node compatibility mode or this is not an ESM
		// file that has been converted to a CommonJS file using a Babel-
		// compatible transform (i.e. "__esModule" has not been set), then set
		// "default" to the CommonJS "module.exports" for node compatibility.
		isNodeMode || !mod || !mod.__esModule
			? __defProp(target, 'default', { value: mod, enumerable: true })
			: target,
		mod
	)
)
var __decorateClass = (decorators, target, key, kind) => {
	var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target
	for (var i3 = decorators.length - 1, decorator; i3 >= 0; i3--)
		if ((decorator = decorators[i3]))
			result = (kind ? decorator(target, key, result) : decorator(result)) || result
	if (kind && result) __defProp(target, key, result)
	return result
}
var __publicField = (obj, key, value) => {
	__defNormalProp(obj, typeof key !== 'symbol' ? key + '' : key, value)
	return value
}

// <define:process>
var define_process_default
var init_define_process = __esm({
	'<define:process>'() {
		define_process_default = { env: { NODE_ENV: 'development' } }
	},
})

// ../node_modules/core-js/internals/global.js
var require_global = __commonJS({
	'../node_modules/core-js/internals/global.js'(exports, module2) {
		init_define_process()
		var check = function (it) {
			return it && it.Math == Math && it
		}
		module2.exports = // eslint-disable-next-line es/no-global-this -- safe
			check(typeof globalThis == 'object' && globalThis) ||
			check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
			check(typeof self == 'object' && self) ||
			check(typeof global == 'object' && global) || // eslint-disable-next-line no-new-func -- fallback
			(function () {
				return this
			})() ||
			Function('return this')()
	},
})

// ../node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
	'../node_modules/core-js/internals/fails.js'(exports, module2) {
		init_define_process()
		module2.exports = function (exec) {
			try {
				return !!exec()
			} catch (error) {
				return true
			}
		}
	},
})

// ../node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
	'../node_modules/core-js/internals/descriptors.js'(exports, module2) {
		init_define_process()
		var fails = require_fails()
		module2.exports = !fails(function () {
			return (
				Object.defineProperty({}, 1, {
					get: function () {
						return 7
					},
				})[1] != 7
			)
		})
	},
})

// ../node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
	'../node_modules/core-js/internals/function-bind-native.js'(exports, module2) {
		init_define_process()
		var fails = require_fails()
		module2.exports = !fails(function () {
			var test = function () {}.bind()
			return typeof test != 'function' || test.hasOwnProperty('prototype')
		})
	},
})

// ../node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
	'../node_modules/core-js/internals/function-call.js'(exports, module2) {
		init_define_process()
		var NATIVE_BIND = require_function_bind_native()
		var call2 = Function.prototype.call
		module2.exports = NATIVE_BIND
			? call2.bind(call2)
			: function () {
					return call2.apply(call2, arguments)
			  }
	},
})

// ../node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
	'../node_modules/core-js/internals/object-property-is-enumerable.js'(exports) {
		'use strict'
		init_define_process()
		var $propertyIsEnumerable = {}.propertyIsEnumerable
		var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
		var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1)
		exports.f = NASHORN_BUG
			? function propertyIsEnumerable(V2) {
					var descriptor = getOwnPropertyDescriptor(this, V2)
					return !!descriptor && descriptor.enumerable
			  }
			: $propertyIsEnumerable
	},
})

// ../node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
	'../node_modules/core-js/internals/create-property-descriptor.js'(exports, module2) {
		init_define_process()
		module2.exports = function (bitmap, value) {
			return {
				enumerable: !(bitmap & 1),
				configurable: !(bitmap & 2),
				writable: !(bitmap & 4),
				value,
			}
		}
	},
})

// ../node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
	'../node_modules/core-js/internals/function-uncurry-this.js'(exports, module2) {
		init_define_process()
		var NATIVE_BIND = require_function_bind_native()
		var FunctionPrototype = Function.prototype
		var call2 = FunctionPrototype.call
		var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call2, call2)
		module2.exports = NATIVE_BIND
			? uncurryThisWithBind
			: function (fn) {
					return function () {
						return call2.apply(fn, arguments)
					}
			  }
	},
})

// ../node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
	'../node_modules/core-js/internals/classof-raw.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var toString = uncurryThis({}.toString)
		var stringSlice = uncurryThis(''.slice)
		module2.exports = function (it) {
			return stringSlice(toString(it), 8, -1)
		}
	},
})

// ../node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
	'../node_modules/core-js/internals/indexed-object.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var fails = require_fails()
		var classof = require_classof_raw()
		var $Object = Object
		var split = uncurryThis(''.split)
		module2.exports = fails(function () {
			return !$Object('z').propertyIsEnumerable(0)
		})
			? function (it) {
					return classof(it) == 'String' ? split(it, '') : $Object(it)
			  }
			: $Object
	},
})

// ../node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
	'../node_modules/core-js/internals/is-null-or-undefined.js'(exports, module2) {
		init_define_process()
		module2.exports = function (it) {
			return it === null || it === void 0
		}
	},
})

// ../node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
	'../node_modules/core-js/internals/require-object-coercible.js'(exports, module2) {
		init_define_process()
		var isNullOrUndefined = require_is_null_or_undefined()
		var $TypeError = TypeError
		module2.exports = function (it) {
			if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it)
			return it
		}
	},
})

// ../node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
	'../node_modules/core-js/internals/to-indexed-object.js'(exports, module2) {
		init_define_process()
		var IndexedObject = require_indexed_object()
		var requireObjectCoercible = require_require_object_coercible()
		module2.exports = function (it) {
			return IndexedObject(requireObjectCoercible(it))
		}
	},
})

// ../node_modules/core-js/internals/document-all.js
var require_document_all = __commonJS({
	'../node_modules/core-js/internals/document-all.js'(exports, module2) {
		init_define_process()
		var documentAll = typeof document == 'object' && document.all
		var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== void 0
		module2.exports = {
			all: documentAll,
			IS_HTMLDDA,
		}
	},
})

// ../node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
	'../node_modules/core-js/internals/is-callable.js'(exports, module2) {
		init_define_process()
		var $documentAll = require_document_all()
		var documentAll = $documentAll.all
		module2.exports = $documentAll.IS_HTMLDDA
			? function (argument) {
					return typeof argument == 'function' || argument === documentAll
			  }
			: function (argument) {
					return typeof argument == 'function'
			  }
	},
})

// ../node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
	'../node_modules/core-js/internals/is-object.js'(exports, module2) {
		init_define_process()
		var isCallable = require_is_callable()
		var $documentAll = require_document_all()
		var documentAll = $documentAll.all
		module2.exports = $documentAll.IS_HTMLDDA
			? function (it) {
					return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll
			  }
			: function (it) {
					return typeof it == 'object' ? it !== null : isCallable(it)
			  }
	},
})

// ../node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
	'../node_modules/core-js/internals/get-built-in.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var isCallable = require_is_callable()
		var aFunction = function (argument) {
			return isCallable(argument) ? argument : void 0
		}
		module2.exports = function (namespace, method) {
			return arguments.length < 2
				? aFunction(global3[namespace])
				: global3[namespace] && global3[namespace][method]
		}
	},
})

// ../node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
	'../node_modules/core-js/internals/object-is-prototype-of.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		module2.exports = uncurryThis({}.isPrototypeOf)
	},
})

// ../node_modules/core-js/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
	'../node_modules/core-js/internals/engine-user-agent.js'(exports, module2) {
		init_define_process()
		module2.exports = (typeof navigator != 'undefined' && String(navigator.userAgent)) || ''
	},
})

// ../node_modules/core-js/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
	'../node_modules/core-js/internals/engine-v8-version.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var userAgent = require_engine_user_agent()
		var process2 = global3.process
		var Deno = global3.Deno
		var versions = (process2 && process2.versions) || (Deno && Deno.version)
		var v8 = versions && versions.v8
		var match
		var version
		if (v8) {
			match = v8.split('.')
			version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1])
		}
		if (!version && userAgent) {
			match = userAgent.match(/Edge\/(\d+)/)
			if (!match || match[1] >= 74) {
				match = userAgent.match(/Chrome\/(\d+)/)
				if (match) version = +match[1]
			}
		}
		module2.exports = version
	},
})

// ../node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
	'../node_modules/core-js/internals/symbol-constructor-detection.js'(exports, module2) {
		init_define_process()
		var V8_VERSION = require_engine_v8_version()
		var fails = require_fails()
		module2.exports =
			!!Object.getOwnPropertySymbols &&
			!fails(function () {
				var symbol = Symbol()
				return (
					!String(symbol) ||
					!(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
					(!Symbol.sham && V8_VERSION && V8_VERSION < 41)
				)
			})
	},
})

// ../node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
	'../node_modules/core-js/internals/use-symbol-as-uid.js'(exports, module2) {
		init_define_process()
		var NATIVE_SYMBOL = require_symbol_constructor_detection()
		module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol'
	},
})

// ../node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
	'../node_modules/core-js/internals/is-symbol.js'(exports, module2) {
		init_define_process()
		var getBuiltIn = require_get_built_in()
		var isCallable = require_is_callable()
		var isPrototypeOf = require_object_is_prototype_of()
		var USE_SYMBOL_AS_UID = require_use_symbol_as_uid()
		var $Object = Object
		module2.exports = USE_SYMBOL_AS_UID
			? function (it) {
					return typeof it == 'symbol'
			  }
			: function (it) {
					var $Symbol = getBuiltIn('Symbol')
					return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it))
			  }
	},
})

// ../node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
	'../node_modules/core-js/internals/try-to-string.js'(exports, module2) {
		init_define_process()
		var $String = String
		module2.exports = function (argument) {
			try {
				return $String(argument)
			} catch (error) {
				return 'Object'
			}
		}
	},
})

// ../node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
	'../node_modules/core-js/internals/a-callable.js'(exports, module2) {
		init_define_process()
		var isCallable = require_is_callable()
		var tryToString = require_try_to_string()
		var $TypeError = TypeError
		module2.exports = function (argument) {
			if (isCallable(argument)) return argument
			throw $TypeError(tryToString(argument) + ' is not a function')
		}
	},
})

// ../node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
	'../node_modules/core-js/internals/get-method.js'(exports, module2) {
		init_define_process()
		var aCallable = require_a_callable()
		var isNullOrUndefined = require_is_null_or_undefined()
		module2.exports = function (V2, P2) {
			var func = V2[P2]
			return isNullOrUndefined(func) ? void 0 : aCallable(func)
		}
	},
})

// ../node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
	'../node_modules/core-js/internals/ordinary-to-primitive.js'(exports, module2) {
		init_define_process()
		var call2 = require_function_call()
		var isCallable = require_is_callable()
		var isObject = require_is_object()
		var $TypeError = TypeError
		module2.exports = function (input, pref) {
			var fn, val
			if (
				pref === 'string' &&
				isCallable((fn = input.toString)) &&
				!isObject((val = call2(fn, input)))
			)
				return val
			if (isCallable((fn = input.valueOf)) && !isObject((val = call2(fn, input)))) return val
			if (
				pref !== 'string' &&
				isCallable((fn = input.toString)) &&
				!isObject((val = call2(fn, input)))
			)
				return val
			throw $TypeError("Can't convert object to primitive value")
		}
	},
})

// ../node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
	'../node_modules/core-js/internals/is-pure.js'(exports, module2) {
		init_define_process()
		module2.exports = false
	},
})

// ../node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
	'../node_modules/core-js/internals/define-global-property.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var defineProperty = Object.defineProperty
		module2.exports = function (key, value) {
			try {
				defineProperty(global3, key, { value, configurable: true, writable: true })
			} catch (error) {
				global3[key] = value
			}
			return value
		}
	},
})

// ../node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
	'../node_modules/core-js/internals/shared-store.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var defineGlobalProperty = require_define_global_property()
		var SHARED = '__core-js_shared__'
		var store = global3[SHARED] || defineGlobalProperty(SHARED, {})
		module2.exports = store
	},
})

// ../node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
	'../node_modules/core-js/internals/shared.js'(exports, module2) {
		init_define_process()
		var IS_PURE = require_is_pure()
		var store = require_shared_store()
		;(module2.exports = function (key, value) {
			return store[key] || (store[key] = value !== void 0 ? value : {})
		})('versions', []).push({
			version: '3.30.1',
			mode: IS_PURE ? 'pure' : 'global',
			copyright: '\xA9 2014-2023 Denis Pushkarev (zloirock.ru)',
			license: 'https://github.com/zloirock/core-js/blob/v3.30.1/LICENSE',
			source: 'https://github.com/zloirock/core-js',
		})
	},
})

// ../node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
	'../node_modules/core-js/internals/to-object.js'(exports, module2) {
		init_define_process()
		var requireObjectCoercible = require_require_object_coercible()
		var $Object = Object
		module2.exports = function (argument) {
			return $Object(requireObjectCoercible(argument))
		}
	},
})

// ../node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
	'../node_modules/core-js/internals/has-own-property.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var toObject = require_to_object()
		var hasOwnProperty2 = uncurryThis({}.hasOwnProperty)
		module2.exports =
			Object.hasOwn ||
			function hasOwn(it, key) {
				return hasOwnProperty2(toObject(it), key)
			}
	},
})

// ../node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
	'../node_modules/core-js/internals/uid.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var id = 0
		var postfix = Math.random()
		var toString = uncurryThis((1).toString)
		module2.exports = function (key) {
			return 'Symbol(' + (key === void 0 ? '' : key) + ')_' + toString(++id + postfix, 36)
		}
	},
})

// ../node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
	'../node_modules/core-js/internals/well-known-symbol.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var shared = require_shared()
		var hasOwn = require_has_own_property()
		var uid = require_uid()
		var NATIVE_SYMBOL = require_symbol_constructor_detection()
		var USE_SYMBOL_AS_UID = require_use_symbol_as_uid()
		var Symbol2 = global3.Symbol
		var WellKnownSymbolsStore = shared('wks')
		var createWellKnownSymbol = USE_SYMBOL_AS_UID
			? Symbol2['for'] || Symbol2
			: (Symbol2 && Symbol2.withoutSetter) || uid
		module2.exports = function (name) {
			if (!hasOwn(WellKnownSymbolsStore, name)) {
				WellKnownSymbolsStore[name] =
					NATIVE_SYMBOL && hasOwn(Symbol2, name)
						? Symbol2[name]
						: createWellKnownSymbol('Symbol.' + name)
			}
			return WellKnownSymbolsStore[name]
		}
	},
})

// ../node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
	'../node_modules/core-js/internals/to-primitive.js'(exports, module2) {
		init_define_process()
		var call2 = require_function_call()
		var isObject = require_is_object()
		var isSymbol = require_is_symbol()
		var getMethod2 = require_get_method()
		var ordinaryToPrimitive = require_ordinary_to_primitive()
		var wellKnownSymbol = require_well_known_symbol()
		var $TypeError = TypeError
		var TO_PRIMITIVE = wellKnownSymbol('toPrimitive')
		module2.exports = function (input, pref) {
			if (!isObject(input) || isSymbol(input)) return input
			var exoticToPrim = getMethod2(input, TO_PRIMITIVE)
			var result
			if (exoticToPrim) {
				if (pref === void 0) pref = 'default'
				result = call2(exoticToPrim, input, pref)
				if (!isObject(result) || isSymbol(result)) return result
				throw $TypeError("Can't convert object to primitive value")
			}
			if (pref === void 0) pref = 'number'
			return ordinaryToPrimitive(input, pref)
		}
	},
})

// ../node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
	'../node_modules/core-js/internals/to-property-key.js'(exports, module2) {
		init_define_process()
		var toPrimitive = require_to_primitive()
		var isSymbol = require_is_symbol()
		module2.exports = function (argument) {
			var key = toPrimitive(argument, 'string')
			return isSymbol(key) ? key : key + ''
		}
	},
})

// ../node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
	'../node_modules/core-js/internals/document-create-element.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var isObject = require_is_object()
		var document2 = global3.document
		var EXISTS = isObject(document2) && isObject(document2.createElement)
		module2.exports = function (it) {
			return EXISTS ? document2.createElement(it) : {}
		}
	},
})

// ../node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
	'../node_modules/core-js/internals/ie8-dom-define.js'(exports, module2) {
		init_define_process()
		var DESCRIPTORS = require_descriptors()
		var fails = require_fails()
		var createElement6 = require_document_create_element()
		module2.exports =
			!DESCRIPTORS &&
			!fails(function () {
				return (
					Object.defineProperty(createElement6('div'), 'a', {
						get: function () {
							return 7
						},
					}).a != 7
				)
			})
	},
})

// ../node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
	'../node_modules/core-js/internals/object-get-own-property-descriptor.js'(exports) {
		init_define_process()
		var DESCRIPTORS = require_descriptors()
		var call2 = require_function_call()
		var propertyIsEnumerableModule = require_object_property_is_enumerable()
		var createPropertyDescriptor = require_create_property_descriptor()
		var toIndexedObject = require_to_indexed_object()
		var toPropertyKey = require_to_property_key()
		var hasOwn = require_has_own_property()
		var IE8_DOM_DEFINE = require_ie8_dom_define()
		var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
		exports.f = DESCRIPTORS
			? $getOwnPropertyDescriptor
			: function getOwnPropertyDescriptor(O2, P2) {
					O2 = toIndexedObject(O2)
					P2 = toPropertyKey(P2)
					if (IE8_DOM_DEFINE)
						try {
							return $getOwnPropertyDescriptor(O2, P2)
						} catch (error) {}
					if (hasOwn(O2, P2))
						return createPropertyDescriptor(!call2(propertyIsEnumerableModule.f, O2, P2), O2[P2])
			  }
	},
})

// ../node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
	'../node_modules/core-js/internals/v8-prototype-define-bug.js'(exports, module2) {
		init_define_process()
		var DESCRIPTORS = require_descriptors()
		var fails = require_fails()
		module2.exports =
			DESCRIPTORS &&
			fails(function () {
				return (
					Object.defineProperty(function () {}, 'prototype', {
						value: 42,
						writable: false,
					}).prototype != 42
				)
			})
	},
})

// ../node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
	'../node_modules/core-js/internals/an-object.js'(exports, module2) {
		init_define_process()
		var isObject = require_is_object()
		var $String = String
		var $TypeError = TypeError
		module2.exports = function (argument) {
			if (isObject(argument)) return argument
			throw $TypeError($String(argument) + ' is not an object')
		}
	},
})

// ../node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
	'../node_modules/core-js/internals/object-define-property.js'(exports) {
		init_define_process()
		var DESCRIPTORS = require_descriptors()
		var IE8_DOM_DEFINE = require_ie8_dom_define()
		var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug()
		var anObject = require_an_object()
		var toPropertyKey = require_to_property_key()
		var $TypeError = TypeError
		var $defineProperty = Object.defineProperty
		var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
		var ENUMERABLE = 'enumerable'
		var CONFIGURABLE = 'configurable'
		var WRITABLE = 'writable'
		exports.f = DESCRIPTORS
			? V8_PROTOTYPE_DEFINE_BUG
				? function defineProperty(O2, P2, Attributes) {
						anObject(O2)
						P2 = toPropertyKey(P2)
						anObject(Attributes)
						if (
							typeof O2 === 'function' &&
							P2 === 'prototype' &&
							'value' in Attributes &&
							WRITABLE in Attributes &&
							!Attributes[WRITABLE]
						) {
							var current = $getOwnPropertyDescriptor(O2, P2)
							if (current && current[WRITABLE]) {
								O2[P2] = Attributes.value
								Attributes = {
									configurable:
										CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
									enumerable:
										ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
									writable: false,
								}
							}
						}
						return $defineProperty(O2, P2, Attributes)
				  }
				: $defineProperty
			: function defineProperty(O2, P2, Attributes) {
					anObject(O2)
					P2 = toPropertyKey(P2)
					anObject(Attributes)
					if (IE8_DOM_DEFINE)
						try {
							return $defineProperty(O2, P2, Attributes)
						} catch (error) {}
					if ('get' in Attributes || 'set' in Attributes)
						throw $TypeError('Accessors not supported')
					if ('value' in Attributes) O2[P2] = Attributes.value
					return O2
			  }
	},
})

// ../node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
	'../node_modules/core-js/internals/create-non-enumerable-property.js'(exports, module2) {
		init_define_process()
		var DESCRIPTORS = require_descriptors()
		var definePropertyModule = require_object_define_property()
		var createPropertyDescriptor = require_create_property_descriptor()
		module2.exports = DESCRIPTORS
			? function (object2, key, value) {
					return definePropertyModule.f(object2, key, createPropertyDescriptor(1, value))
			  }
			: function (object2, key, value) {
					object2[key] = value
					return object2
			  }
	},
})

// ../node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
	'../node_modules/core-js/internals/function-name.js'(exports, module2) {
		init_define_process()
		var DESCRIPTORS = require_descriptors()
		var hasOwn = require_has_own_property()
		var FunctionPrototype = Function.prototype
		var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor
		var EXISTS = hasOwn(FunctionPrototype, 'name')
		var PROPER = EXISTS && function something() {}.name === 'something'
		var CONFIGURABLE =
			EXISTS &&
			(!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable))
		module2.exports = {
			EXISTS,
			PROPER,
			CONFIGURABLE,
		}
	},
})

// ../node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
	'../node_modules/core-js/internals/inspect-source.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var isCallable = require_is_callable()
		var store = require_shared_store()
		var functionToString = uncurryThis(Function.toString)
		if (!isCallable(store.inspectSource)) {
			store.inspectSource = function (it) {
				return functionToString(it)
			}
		}
		module2.exports = store.inspectSource
	},
})

// ../node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
	'../node_modules/core-js/internals/weak-map-basic-detection.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var isCallable = require_is_callable()
		var WeakMap2 = global3.WeakMap
		module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2))
	},
})

// ../node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
	'../node_modules/core-js/internals/shared-key.js'(exports, module2) {
		init_define_process()
		var shared = require_shared()
		var uid = require_uid()
		var keys = shared('keys')
		module2.exports = function (key) {
			return keys[key] || (keys[key] = uid(key))
		}
	},
})

// ../node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
	'../node_modules/core-js/internals/hidden-keys.js'(exports, module2) {
		init_define_process()
		module2.exports = {}
	},
})

// ../node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
	'../node_modules/core-js/internals/internal-state.js'(exports, module2) {
		init_define_process()
		var NATIVE_WEAK_MAP = require_weak_map_basic_detection()
		var global3 = require_global()
		var isObject = require_is_object()
		var createNonEnumerableProperty = require_create_non_enumerable_property()
		var hasOwn = require_has_own_property()
		var shared = require_shared_store()
		var sharedKey = require_shared_key()
		var hiddenKeys = require_hidden_keys()
		var OBJECT_ALREADY_INITIALIZED = 'Object already initialized'
		var TypeError2 = global3.TypeError
		var WeakMap2 = global3.WeakMap
		var set
		var get
		var has
		var enforce = function (it) {
			return has(it) ? get(it) : set(it, {})
		}
		var getterFor = function (TYPE) {
			return function (it) {
				var state
				if (!isObject(it) || (state = get(it)).type !== TYPE) {
					throw TypeError2('Incompatible receiver, ' + TYPE + ' required')
				}
				return state
			}
		}
		if (NATIVE_WEAK_MAP || shared.state) {
			store = shared.state || (shared.state = new WeakMap2())
			store.get = store.get
			store.has = store.has
			store.set = store.set
			set = function (it, metadata) {
				if (store.has(it)) throw TypeError2(OBJECT_ALREADY_INITIALIZED)
				metadata.facade = it
				store.set(it, metadata)
				return metadata
			}
			get = function (it) {
				return store.get(it) || {}
			}
			has = function (it) {
				return store.has(it)
			}
		} else {
			STATE = sharedKey('state')
			hiddenKeys[STATE] = true
			set = function (it, metadata) {
				if (hasOwn(it, STATE)) throw TypeError2(OBJECT_ALREADY_INITIALIZED)
				metadata.facade = it
				createNonEnumerableProperty(it, STATE, metadata)
				return metadata
			}
			get = function (it) {
				return hasOwn(it, STATE) ? it[STATE] : {}
			}
			has = function (it) {
				return hasOwn(it, STATE)
			}
		}
		var store
		var STATE
		module2.exports = {
			set,
			get,
			has,
			enforce,
			getterFor,
		}
	},
})

// ../node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
	'../node_modules/core-js/internals/make-built-in.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var fails = require_fails()
		var isCallable = require_is_callable()
		var hasOwn = require_has_own_property()
		var DESCRIPTORS = require_descriptors()
		var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE
		var inspectSource = require_inspect_source()
		var InternalStateModule = require_internal_state()
		var enforceInternalState = InternalStateModule.enforce
		var getInternalState = InternalStateModule.get
		var $String = String
		var defineProperty = Object.defineProperty
		var stringSlice = uncurryThis(''.slice)
		var replace = uncurryThis(''.replace)
		var join = uncurryThis([].join)
		var CONFIGURABLE_LENGTH =
			DESCRIPTORS &&
			!fails(function () {
				return defineProperty(function () {}, 'length', { value: 8 }).length !== 8
			})
		var TEMPLATE = String(String).split('String')
		var makeBuiltIn = (module2.exports = function (value, name, options) {
			if (stringSlice($String(name), 0, 7) === 'Symbol(') {
				name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']'
			}
			if (options && options.getter) name = 'get ' + name
			if (options && options.setter) name = 'set ' + name
			if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
				if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true })
				else value.name = name
			}
			if (
				CONFIGURABLE_LENGTH &&
				options &&
				hasOwn(options, 'arity') &&
				value.length !== options.arity
			) {
				defineProperty(value, 'length', { value: options.arity })
			}
			try {
				if (options && hasOwn(options, 'constructor') && options.constructor) {
					if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false })
				} else if (value.prototype) value.prototype = void 0
			} catch (error) {}
			var state = enforceInternalState(value)
			if (!hasOwn(state, 'source')) {
				state.source = join(TEMPLATE, typeof name == 'string' ? name : '')
			}
			return value
		})
		Function.prototype.toString = makeBuiltIn(function toString() {
			return (isCallable(this) && getInternalState(this).source) || inspectSource(this)
		}, 'toString')
	},
})

// ../node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
	'../node_modules/core-js/internals/define-built-in.js'(exports, module2) {
		init_define_process()
		var isCallable = require_is_callable()
		var definePropertyModule = require_object_define_property()
		var makeBuiltIn = require_make_built_in()
		var defineGlobalProperty = require_define_global_property()
		module2.exports = function (O2, key, value, options) {
			if (!options) options = {}
			var simple = options.enumerable
			var name = options.name !== void 0 ? options.name : key
			if (isCallable(value)) makeBuiltIn(value, name, options)
			if (options.global) {
				if (simple) O2[key] = value
				else defineGlobalProperty(key, value)
			} else {
				try {
					if (!options.unsafe) delete O2[key]
					else if (O2[key]) simple = true
				} catch (error) {}
				if (simple) O2[key] = value
				else
					definePropertyModule.f(O2, key, {
						value,
						enumerable: false,
						configurable: !options.nonConfigurable,
						writable: !options.nonWritable,
					})
			}
			return O2
		}
	},
})

// ../node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
	'../node_modules/core-js/internals/math-trunc.js'(exports, module2) {
		init_define_process()
		var ceil = Math.ceil
		var floor = Math.floor
		module2.exports =
			Math.trunc ||
			function trunc(x3) {
				var n3 = +x3
				return (n3 > 0 ? floor : ceil)(n3)
			}
	},
})

// ../node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
	'../node_modules/core-js/internals/to-integer-or-infinity.js'(exports, module2) {
		init_define_process()
		var trunc = require_math_trunc()
		module2.exports = function (argument) {
			var number2 = +argument
			return number2 !== number2 || number2 === 0 ? 0 : trunc(number2)
		}
	},
})

// ../node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
	'../node_modules/core-js/internals/to-absolute-index.js'(exports, module2) {
		init_define_process()
		var toIntegerOrInfinity = require_to_integer_or_infinity()
		var max = Math.max
		var min2 = Math.min
		module2.exports = function (index2, length) {
			var integer2 = toIntegerOrInfinity(index2)
			return integer2 < 0 ? max(integer2 + length, 0) : min2(integer2, length)
		}
	},
})

// ../node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
	'../node_modules/core-js/internals/to-length.js'(exports, module2) {
		init_define_process()
		var toIntegerOrInfinity = require_to_integer_or_infinity()
		var min2 = Math.min
		module2.exports = function (argument) {
			return argument > 0 ? min2(toIntegerOrInfinity(argument), 9007199254740991) : 0
		}
	},
})

// ../node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
	'../node_modules/core-js/internals/length-of-array-like.js'(exports, module2) {
		init_define_process()
		var toLength = require_to_length()
		module2.exports = function (obj) {
			return toLength(obj.length)
		}
	},
})

// ../node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
	'../node_modules/core-js/internals/array-includes.js'(exports, module2) {
		init_define_process()
		var toIndexedObject = require_to_indexed_object()
		var toAbsoluteIndex = require_to_absolute_index()
		var lengthOfArrayLike = require_length_of_array_like()
		var createMethod = function (IS_INCLUDES) {
			return function ($this, el, fromIndex) {
				var O2 = toIndexedObject($this)
				var length = lengthOfArrayLike(O2)
				var index2 = toAbsoluteIndex(fromIndex, length)
				var value
				if (IS_INCLUDES && el != el)
					while (length > index2) {
						value = O2[index2++]
						if (value != value) return true
					}
				else
					for (; length > index2; index2++) {
						if ((IS_INCLUDES || index2 in O2) && O2[index2] === el)
							return IS_INCLUDES || index2 || 0
					}
				return !IS_INCLUDES && -1
			}
		}
		module2.exports = {
			// `Array.prototype.includes` method
			// https://tc39.es/ecma262/#sec-array.prototype.includes
			includes: createMethod(true),
			// `Array.prototype.indexOf` method
			// https://tc39.es/ecma262/#sec-array.prototype.indexof
			indexOf: createMethod(false),
		}
	},
})

// ../node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
	'../node_modules/core-js/internals/object-keys-internal.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var hasOwn = require_has_own_property()
		var toIndexedObject = require_to_indexed_object()
		var indexOf = require_array_includes().indexOf
		var hiddenKeys = require_hidden_keys()
		var push = uncurryThis([].push)
		module2.exports = function (object2, names) {
			var O2 = toIndexedObject(object2)
			var i3 = 0
			var result = []
			var key
			for (key in O2) !hasOwn(hiddenKeys, key) && hasOwn(O2, key) && push(result, key)
			while (names.length > i3)
				if (hasOwn(O2, (key = names[i3++]))) {
					~indexOf(result, key) || push(result, key)
				}
			return result
		}
	},
})

// ../node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
	'../node_modules/core-js/internals/enum-bug-keys.js'(exports, module2) {
		init_define_process()
		module2.exports = [
			'constructor',
			'hasOwnProperty',
			'isPrototypeOf',
			'propertyIsEnumerable',
			'toLocaleString',
			'toString',
			'valueOf',
		]
	},
})

// ../node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
	'../node_modules/core-js/internals/object-get-own-property-names.js'(exports) {
		init_define_process()
		var internalObjectKeys = require_object_keys_internal()
		var enumBugKeys = require_enum_bug_keys()
		var hiddenKeys = enumBugKeys.concat('length', 'prototype')
		exports.f =
			Object.getOwnPropertyNames ||
			function getOwnPropertyNames(O2) {
				return internalObjectKeys(O2, hiddenKeys)
			}
	},
})

// ../node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
	'../node_modules/core-js/internals/object-get-own-property-symbols.js'(exports) {
		init_define_process()
		exports.f = Object.getOwnPropertySymbols
	},
})

// ../node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
	'../node_modules/core-js/internals/own-keys.js'(exports, module2) {
		init_define_process()
		var getBuiltIn = require_get_built_in()
		var uncurryThis = require_function_uncurry_this()
		var getOwnPropertyNamesModule = require_object_get_own_property_names()
		var getOwnPropertySymbolsModule = require_object_get_own_property_symbols()
		var anObject = require_an_object()
		var concat = uncurryThis([].concat)
		module2.exports =
			getBuiltIn('Reflect', 'ownKeys') ||
			function ownKeys2(it) {
				var keys = getOwnPropertyNamesModule.f(anObject(it))
				var getOwnPropertySymbols = getOwnPropertySymbolsModule.f
				return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys
			}
	},
})

// ../node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
	'../node_modules/core-js/internals/copy-constructor-properties.js'(exports, module2) {
		init_define_process()
		var hasOwn = require_has_own_property()
		var ownKeys2 = require_own_keys()
		var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor()
		var definePropertyModule = require_object_define_property()
		module2.exports = function (target, source, exceptions) {
			var keys = ownKeys2(source)
			var defineProperty = definePropertyModule.f
			var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f
			for (var i3 = 0; i3 < keys.length; i3++) {
				var key = keys[i3]
				if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
					defineProperty(target, key, getOwnPropertyDescriptor(source, key))
				}
			}
		}
	},
})

// ../node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
	'../node_modules/core-js/internals/is-forced.js'(exports, module2) {
		init_define_process()
		var fails = require_fails()
		var isCallable = require_is_callable()
		var replacement = /#|\.prototype\./
		var isForced = function (feature, detection) {
			var value = data[normalize(feature)]
			return value == POLYFILL
				? true
				: value == NATIVE
				? false
				: isCallable(detection)
				? fails(detection)
				: !!detection
		}
		var normalize = (isForced.normalize = function (string2) {
			return String(string2).replace(replacement, '.').toLowerCase()
		})
		var data = (isForced.data = {})
		var NATIVE = (isForced.NATIVE = 'N')
		var POLYFILL = (isForced.POLYFILL = 'P')
		module2.exports = isForced
	},
})

// ../node_modules/core-js/internals/export.js
var require_export = __commonJS({
	'../node_modules/core-js/internals/export.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f
		var createNonEnumerableProperty = require_create_non_enumerable_property()
		var defineBuiltIn = require_define_built_in()
		var defineGlobalProperty = require_define_global_property()
		var copyConstructorProperties = require_copy_constructor_properties()
		var isForced = require_is_forced()
		module2.exports = function (options, source) {
			var TARGET = options.target
			var GLOBAL = options.global
			var STATIC = options.stat
			var FORCED, target, key, targetProperty, sourceProperty, descriptor
			if (GLOBAL) {
				target = global3
			} else if (STATIC) {
				target = global3[TARGET] || defineGlobalProperty(TARGET, {})
			} else {
				target = (global3[TARGET] || {}).prototype
			}
			if (target)
				for (key in source) {
					sourceProperty = source[key]
					if (options.dontCallGetSet) {
						descriptor = getOwnPropertyDescriptor(target, key)
						targetProperty = descriptor && descriptor.value
					} else targetProperty = target[key]
					FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced)
					if (!FORCED && targetProperty !== void 0) {
						if (typeof sourceProperty == typeof targetProperty) continue
						copyConstructorProperties(sourceProperty, targetProperty)
					}
					if (options.sham || (targetProperty && targetProperty.sham)) {
						createNonEnumerableProperty(sourceProperty, 'sham', true)
					}
					defineBuiltIn(target, key, sourceProperty, options)
				}
		}
	},
})

// ../node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
	'../node_modules/core-js/internals/object-keys.js'(exports, module2) {
		init_define_process()
		var internalObjectKeys = require_object_keys_internal()
		var enumBugKeys = require_enum_bug_keys()
		module2.exports =
			Object.keys ||
			function keys(O2) {
				return internalObjectKeys(O2, enumBugKeys)
			}
	},
})

// ../node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
	'../node_modules/core-js/internals/object-define-properties.js'(exports) {
		init_define_process()
		var DESCRIPTORS = require_descriptors()
		var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug()
		var definePropertyModule = require_object_define_property()
		var anObject = require_an_object()
		var toIndexedObject = require_to_indexed_object()
		var objectKeys = require_object_keys()
		exports.f =
			DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG
				? Object.defineProperties
				: function defineProperties(O2, Properties) {
						anObject(O2)
						var props = toIndexedObject(Properties)
						var keys = objectKeys(Properties)
						var length = keys.length
						var index2 = 0
						var key
						while (length > index2) definePropertyModule.f(O2, (key = keys[index2++]), props[key])
						return O2
				  }
	},
})

// ../node_modules/core-js/internals/html.js
var require_html = __commonJS({
	'../node_modules/core-js/internals/html.js'(exports, module2) {
		init_define_process()
		var getBuiltIn = require_get_built_in()
		module2.exports = getBuiltIn('document', 'documentElement')
	},
})

// ../node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
	'../node_modules/core-js/internals/object-create.js'(exports, module2) {
		init_define_process()
		var anObject = require_an_object()
		var definePropertiesModule = require_object_define_properties()
		var enumBugKeys = require_enum_bug_keys()
		var hiddenKeys = require_hidden_keys()
		var html = require_html()
		var documentCreateElement = require_document_create_element()
		var sharedKey = require_shared_key()
		var GT = '>'
		var LT = '<'
		var PROTOTYPE = 'prototype'
		var SCRIPT = 'script'
		var IE_PROTO = sharedKey('IE_PROTO')
		var EmptyConstructor = function () {}
		var scriptTag = function (content) {
			return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT
		}
		var NullProtoObjectViaActiveX = function (activeXDocument2) {
			activeXDocument2.write(scriptTag(''))
			activeXDocument2.close()
			var temp = activeXDocument2.parentWindow.Object
			activeXDocument2 = null
			return temp
		}
		var NullProtoObjectViaIFrame = function () {
			var iframe = documentCreateElement('iframe')
			var JS = 'java' + SCRIPT + ':'
			var iframeDocument
			iframe.style.display = 'none'
			html.appendChild(iframe)
			iframe.src = String(JS)
			iframeDocument = iframe.contentWindow.document
			iframeDocument.open()
			iframeDocument.write(scriptTag('document.F=Object'))
			iframeDocument.close()
			return iframeDocument.F
		}
		var activeXDocument
		var NullProtoObject = function () {
			try {
				activeXDocument = new ActiveXObject('htmlfile')
			} catch (error) {}
			NullProtoObject =
				typeof document != 'undefined'
					? document.domain && activeXDocument
						? NullProtoObjectViaActiveX(activeXDocument)
						: NullProtoObjectViaIFrame()
					: NullProtoObjectViaActiveX(activeXDocument)
			var length = enumBugKeys.length
			while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]]
			return NullProtoObject()
		}
		hiddenKeys[IE_PROTO] = true
		module2.exports =
			Object.create ||
			function create(O2, Properties) {
				var result
				if (O2 !== null) {
					EmptyConstructor[PROTOTYPE] = anObject(O2)
					result = new EmptyConstructor()
					EmptyConstructor[PROTOTYPE] = null
					result[IE_PROTO] = O2
				} else result = NullProtoObject()
				return Properties === void 0 ? result : definePropertiesModule.f(result, Properties)
			}
	},
})

// ../node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
	'../node_modules/core-js/internals/add-to-unscopables.js'(exports, module2) {
		init_define_process()
		var wellKnownSymbol = require_well_known_symbol()
		var create = require_object_create()
		var defineProperty = require_object_define_property().f
		var UNSCOPABLES = wellKnownSymbol('unscopables')
		var ArrayPrototype = Array.prototype
		if (ArrayPrototype[UNSCOPABLES] == void 0) {
			defineProperty(ArrayPrototype, UNSCOPABLES, {
				configurable: true,
				value: create(null),
			})
		}
		module2.exports = function (key) {
			ArrayPrototype[UNSCOPABLES][key] = true
		}
	},
})

// ../node_modules/core-js/modules/es.array.at.js
var require_es_array_at = __commonJS({
	'../node_modules/core-js/modules/es.array.at.js'() {
		'use strict'
		init_define_process()
		var $ = require_export()
		var toObject = require_to_object()
		var lengthOfArrayLike = require_length_of_array_like()
		var toIntegerOrInfinity = require_to_integer_or_infinity()
		var addToUnscopables = require_add_to_unscopables()
		$(
			{ target: 'Array', proto: true },
			{
				at: function at(index2) {
					var O2 = toObject(this)
					var len = lengthOfArrayLike(O2)
					var relativeIndex = toIntegerOrInfinity(index2)
					var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex
					return k2 < 0 || k2 >= len ? void 0 : O2[k2]
				},
			}
		)
		addToUnscopables('at')
	},
})

// ../node_modules/core-js/internals/entry-unbind.js
var require_entry_unbind = __commonJS({
	'../node_modules/core-js/internals/entry-unbind.js'(exports, module2) {
		init_define_process()
		var global3 = require_global()
		var uncurryThis = require_function_uncurry_this()
		module2.exports = function (CONSTRUCTOR, METHOD) {
			return uncurryThis(global3[CONSTRUCTOR].prototype[METHOD])
		}
	},
})

// ../node_modules/core-js/es/array/at.js
var require_at = __commonJS({
	'../node_modules/core-js/es/array/at.js'(exports, module2) {
		init_define_process()
		require_es_array_at()
		var entryUnbind = require_entry_unbind()
		module2.exports = entryUnbind('Array', 'at')
	},
})

// ../node_modules/core-js/stable/array/at.js
var require_at2 = __commonJS({
	'../node_modules/core-js/stable/array/at.js'(exports, module2) {
		init_define_process()
		var parent = require_at()
		module2.exports = parent
	},
})

// ../node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
	'../node_modules/core-js/internals/is-array.js'(exports, module2) {
		init_define_process()
		var classof = require_classof_raw()
		module2.exports =
			Array.isArray ||
			function isArray(argument) {
				return classof(argument) == 'Array'
			}
	},
})

// ../node_modules/core-js/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
	'../node_modules/core-js/internals/does-not-exceed-safe-integer.js'(exports, module2) {
		init_define_process()
		var $TypeError = TypeError
		var MAX_SAFE_INTEGER = 9007199254740991
		module2.exports = function (it) {
			if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded')
			return it
		}
	},
})

// ../node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
	'../node_modules/core-js/internals/function-uncurry-this-clause.js'(exports, module2) {
		init_define_process()
		var classofRaw = require_classof_raw()
		var uncurryThis = require_function_uncurry_this()
		module2.exports = function (fn) {
			if (classofRaw(fn) === 'Function') return uncurryThis(fn)
		}
	},
})

// ../node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
	'../node_modules/core-js/internals/function-bind-context.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this_clause()
		var aCallable = require_a_callable()
		var NATIVE_BIND = require_function_bind_native()
		var bind = uncurryThis(uncurryThis.bind)
		module2.exports = function (fn, that) {
			aCallable(fn)
			return that === void 0
				? fn
				: NATIVE_BIND
				? bind(fn, that)
				: function () {
						return fn.apply(that, arguments)
				  }
		}
	},
})

// ../node_modules/core-js/internals/flatten-into-array.js
var require_flatten_into_array = __commonJS({
	'../node_modules/core-js/internals/flatten-into-array.js'(exports, module2) {
		'use strict'
		init_define_process()
		var isArray = require_is_array()
		var lengthOfArrayLike = require_length_of_array_like()
		var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer()
		var bind = require_function_bind_context()
		var flattenIntoArray = function (
			target,
			original,
			source,
			sourceLen,
			start,
			depth,
			mapper,
			thisArg
		) {
			var targetIndex = start
			var sourceIndex = 0
			var mapFn = mapper ? bind(mapper, thisArg) : false
			var element, elementLen
			while (sourceIndex < sourceLen) {
				if (sourceIndex in source) {
					element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex]
					if (depth > 0 && isArray(element)) {
						elementLen = lengthOfArrayLike(element)
						targetIndex =
							flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1
					} else {
						doesNotExceedSafeInteger(targetIndex + 1)
						target[targetIndex] = element
					}
					targetIndex++
				}
				sourceIndex++
			}
			return targetIndex
		}
		module2.exports = flattenIntoArray
	},
})

// ../node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
	'../node_modules/core-js/internals/to-string-tag-support.js'(exports, module2) {
		init_define_process()
		var wellKnownSymbol = require_well_known_symbol()
		var TO_STRING_TAG = wellKnownSymbol('toStringTag')
		var test = {}
		test[TO_STRING_TAG] = 'z'
		module2.exports = String(test) === '[object z]'
	},
})

// ../node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
	'../node_modules/core-js/internals/classof.js'(exports, module2) {
		init_define_process()
		var TO_STRING_TAG_SUPPORT = require_to_string_tag_support()
		var isCallable = require_is_callable()
		var classofRaw = require_classof_raw()
		var wellKnownSymbol = require_well_known_symbol()
		var TO_STRING_TAG = wellKnownSymbol('toStringTag')
		var $Object = Object
		var CORRECT_ARGUMENTS =
			classofRaw(
				(function () {
					return arguments
				})()
			) == 'Arguments'
		var tryGet = function (it, key) {
			try {
				return it[key]
			} catch (error) {}
		}
		module2.exports = TO_STRING_TAG_SUPPORT
			? classofRaw
			: function (it) {
					var O2, tag, result
					return it === void 0
						? 'Undefined'
						: it === null
						? 'Null'
						: typeof (tag = tryGet((O2 = $Object(it)), TO_STRING_TAG)) == 'string'
						? tag
						: CORRECT_ARGUMENTS
						? classofRaw(O2)
						: (result = classofRaw(O2)) == 'Object' && isCallable(O2.callee)
						? 'Arguments'
						: result
			  }
	},
})

// ../node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
	'../node_modules/core-js/internals/is-constructor.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var fails = require_fails()
		var isCallable = require_is_callable()
		var classof = require_classof()
		var getBuiltIn = require_get_built_in()
		var inspectSource = require_inspect_source()
		var noop3 = function () {}
		var empty = []
		var construct = getBuiltIn('Reflect', 'construct')
		var constructorRegExp = /^\s*(?:class|function)\b/
		var exec = uncurryThis(constructorRegExp.exec)
		var INCORRECT_TO_STRING = !constructorRegExp.exec(noop3)
		var isConstructorModern = function isConstructor(argument) {
			if (!isCallable(argument)) return false
			try {
				construct(noop3, empty, argument)
				return true
			} catch (error) {
				return false
			}
		}
		var isConstructorLegacy = function isConstructor(argument) {
			if (!isCallable(argument)) return false
			switch (classof(argument)) {
				case 'AsyncFunction':
				case 'GeneratorFunction':
				case 'AsyncGeneratorFunction':
					return false
			}
			try {
				return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument))
			} catch (error) {
				return true
			}
		}
		isConstructorLegacy.sham = true
		module2.exports =
			!construct ||
			fails(function () {
				var called
				return (
					isConstructorModern(isConstructorModern.call) ||
					!isConstructorModern(Object) ||
					!isConstructorModern(function () {
						called = true
					}) ||
					called
				)
			})
				? isConstructorLegacy
				: isConstructorModern
	},
})

// ../node_modules/core-js/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
	'../node_modules/core-js/internals/array-species-constructor.js'(exports, module2) {
		init_define_process()
		var isArray = require_is_array()
		var isConstructor = require_is_constructor()
		var isObject = require_is_object()
		var wellKnownSymbol = require_well_known_symbol()
		var SPECIES = wellKnownSymbol('species')
		var $Array = Array
		module2.exports = function (originalArray) {
			var C2
			if (isArray(originalArray)) {
				C2 = originalArray.constructor
				if (isConstructor(C2) && (C2 === $Array || isArray(C2.prototype))) C2 = void 0
				else if (isObject(C2)) {
					C2 = C2[SPECIES]
					if (C2 === null) C2 = void 0
				}
			}
			return C2 === void 0 ? $Array : C2
		}
	},
})

// ../node_modules/core-js/internals/array-species-create.js
var require_array_species_create = __commonJS({
	'../node_modules/core-js/internals/array-species-create.js'(exports, module2) {
		init_define_process()
		var arraySpeciesConstructor = require_array_species_constructor()
		module2.exports = function (originalArray, length) {
			return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length)
		}
	},
})

// ../node_modules/core-js/modules/es.array.flat.js
var require_es_array_flat = __commonJS({
	'../node_modules/core-js/modules/es.array.flat.js'() {
		'use strict'
		init_define_process()
		var $ = require_export()
		var flattenIntoArray = require_flatten_into_array()
		var toObject = require_to_object()
		var lengthOfArrayLike = require_length_of_array_like()
		var toIntegerOrInfinity = require_to_integer_or_infinity()
		var arraySpeciesCreate = require_array_species_create()
		$(
			{ target: 'Array', proto: true },
			{
				flat: function flat() {
					var depthArg = arguments.length ? arguments[0] : void 0
					var O2 = toObject(this)
					var sourceLen = lengthOfArrayLike(O2)
					var A2 = arraySpeciesCreate(O2, 0)
					A2.length = flattenIntoArray(
						A2,
						O2,
						O2,
						sourceLen,
						0,
						depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg)
					)
					return A2
				},
			}
		)
	},
})

// ../node_modules/core-js/modules/es.array.unscopables.flat.js
var require_es_array_unscopables_flat = __commonJS({
	'../node_modules/core-js/modules/es.array.unscopables.flat.js'() {
		init_define_process()
		var addToUnscopables = require_add_to_unscopables()
		addToUnscopables('flat')
	},
})

// ../node_modules/core-js/es/array/flat.js
var require_flat = __commonJS({
	'../node_modules/core-js/es/array/flat.js'(exports, module2) {
		init_define_process()
		require_es_array_flat()
		require_es_array_unscopables_flat()
		var entryUnbind = require_entry_unbind()
		module2.exports = entryUnbind('Array', 'flat')
	},
})

// ../node_modules/core-js/stable/array/flat.js
var require_flat2 = __commonJS({
	'../node_modules/core-js/stable/array/flat.js'(exports, module2) {
		init_define_process()
		var parent = require_flat()
		module2.exports = parent
	},
})

// ../node_modules/core-js/modules/es.array.flat-map.js
var require_es_array_flat_map = __commonJS({
	'../node_modules/core-js/modules/es.array.flat-map.js'() {
		'use strict'
		init_define_process()
		var $ = require_export()
		var flattenIntoArray = require_flatten_into_array()
		var aCallable = require_a_callable()
		var toObject = require_to_object()
		var lengthOfArrayLike = require_length_of_array_like()
		var arraySpeciesCreate = require_array_species_create()
		$(
			{ target: 'Array', proto: true },
			{
				flatMap: function flatMap(callbackfn) {
					var O2 = toObject(this)
					var sourceLen = lengthOfArrayLike(O2)
					var A2
					aCallable(callbackfn)
					A2 = arraySpeciesCreate(O2, 0)
					A2.length = flattenIntoArray(
						A2,
						O2,
						O2,
						sourceLen,
						0,
						1,
						callbackfn,
						arguments.length > 1 ? arguments[1] : void 0
					)
					return A2
				},
			}
		)
	},
})

// ../node_modules/core-js/modules/es.array.unscopables.flat-map.js
var require_es_array_unscopables_flat_map = __commonJS({
	'../node_modules/core-js/modules/es.array.unscopables.flat-map.js'() {
		init_define_process()
		var addToUnscopables = require_add_to_unscopables()
		addToUnscopables('flatMap')
	},
})

// ../node_modules/core-js/es/array/flat-map.js
var require_flat_map = __commonJS({
	'../node_modules/core-js/es/array/flat-map.js'(exports, module2) {
		init_define_process()
		require_es_array_flat_map()
		require_es_array_unscopables_flat_map()
		var entryUnbind = require_entry_unbind()
		module2.exports = entryUnbind('Array', 'flatMap')
	},
})

// ../node_modules/core-js/stable/array/flat-map.js
var require_flat_map2 = __commonJS({
	'../node_modules/core-js/stable/array/flat-map.js'(exports, module2) {
		init_define_process()
		var parent = require_flat_map()
		module2.exports = parent
	},
})

// ../node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
	'../node_modules/core-js/internals/to-string.js'(exports, module2) {
		init_define_process()
		var classof = require_classof()
		var $String = String
		module2.exports = function (argument) {
			if (classof(argument) === 'Symbol')
				throw TypeError('Cannot convert a Symbol value to a string')
			return $String(argument)
		}
	},
})

// ../node_modules/core-js/modules/es.string.at-alternative.js
var require_es_string_at_alternative = __commonJS({
	'../node_modules/core-js/modules/es.string.at-alternative.js'() {
		'use strict'
		init_define_process()
		var $ = require_export()
		var uncurryThis = require_function_uncurry_this()
		var requireObjectCoercible = require_require_object_coercible()
		var toIntegerOrInfinity = require_to_integer_or_infinity()
		var toString = require_to_string()
		var fails = require_fails()
		var charAt = uncurryThis(''.charAt)
		var FORCED = fails(function () {
			return '\u{20BB7}'.at(-2) !== '\uD842'
		})
		$(
			{ target: 'String', proto: true, forced: FORCED },
			{
				at: function at(index2) {
					var S2 = toString(requireObjectCoercible(this))
					var len = S2.length
					var relativeIndex = toIntegerOrInfinity(index2)
					var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex
					return k2 < 0 || k2 >= len ? void 0 : charAt(S2, k2)
				},
			}
		)
	},
})

// ../node_modules/core-js/es/string/at.js
var require_at3 = __commonJS({
	'../node_modules/core-js/es/string/at.js'(exports, module2) {
		init_define_process()
		require_es_string_at_alternative()
		var entryUnbind = require_entry_unbind()
		module2.exports = entryUnbind('String', 'at')
	},
})

// ../node_modules/core-js/stable/string/at.js
var require_at4 = __commonJS({
	'../node_modules/core-js/stable/string/at.js'(exports, module2) {
		init_define_process()
		var parent = require_at3()
		module2.exports = parent
	},
})

// ../node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
	'../node_modules/core-js/internals/regexp-flags.js'(exports, module2) {
		'use strict'
		init_define_process()
		var anObject = require_an_object()
		module2.exports = function () {
			var that = anObject(this)
			var result = ''
			if (that.hasIndices) result += 'd'
			if (that.global) result += 'g'
			if (that.ignoreCase) result += 'i'
			if (that.multiline) result += 'm'
			if (that.dotAll) result += 's'
			if (that.unicode) result += 'u'
			if (that.unicodeSets) result += 'v'
			if (that.sticky) result += 'y'
			return result
		}
	},
})

// ../node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
	'../node_modules/core-js/internals/regexp-sticky-helpers.js'(exports, module2) {
		init_define_process()
		var fails = require_fails()
		var global3 = require_global()
		var $RegExp = global3.RegExp
		var UNSUPPORTED_Y = fails(function () {
			var re = $RegExp('a', 'y')
			re.lastIndex = 2
			return re.exec('abcd') != null
		})
		var MISSED_STICKY =
			UNSUPPORTED_Y ||
			fails(function () {
				return !$RegExp('a', 'y').sticky
			})
		var BROKEN_CARET =
			UNSUPPORTED_Y ||
			fails(function () {
				var re = $RegExp('^r', 'gy')
				re.lastIndex = 2
				return re.exec('str') != null
			})
		module2.exports = {
			BROKEN_CARET,
			MISSED_STICKY,
			UNSUPPORTED_Y,
		}
	},
})

// ../node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
	'../node_modules/core-js/internals/regexp-unsupported-dot-all.js'(exports, module2) {
		init_define_process()
		var fails = require_fails()
		var global3 = require_global()
		var $RegExp = global3.RegExp
		module2.exports = fails(function () {
			var re = $RegExp('.', 's')
			return !(re.dotAll && re.exec('\n') && re.flags === 's')
		})
	},
})

// ../node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
	'../node_modules/core-js/internals/regexp-unsupported-ncg.js'(exports, module2) {
		init_define_process()
		var fails = require_fails()
		var global3 = require_global()
		var $RegExp = global3.RegExp
		module2.exports = fails(function () {
			var re = $RegExp('(?<a>b)', 'g')
			return re.exec('b').groups.a !== 'b' || 'b'.replace(re, '$<a>c') !== 'bc'
		})
	},
})

// ../node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
	'../node_modules/core-js/internals/regexp-exec.js'(exports, module2) {
		'use strict'
		init_define_process()
		var call2 = require_function_call()
		var uncurryThis = require_function_uncurry_this()
		var toString = require_to_string()
		var regexpFlags = require_regexp_flags()
		var stickyHelpers = require_regexp_sticky_helpers()
		var shared = require_shared()
		var create = require_object_create()
		var getInternalState = require_internal_state().get
		var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all()
		var UNSUPPORTED_NCG = require_regexp_unsupported_ncg()
		var nativeReplace = shared('native-string-replace', String.prototype.replace)
		var nativeExec = RegExp.prototype.exec
		var patchedExec = nativeExec
		var charAt = uncurryThis(''.charAt)
		var indexOf = uncurryThis(''.indexOf)
		var replace = uncurryThis(''.replace)
		var stringSlice = uncurryThis(''.slice)
		var UPDATES_LAST_INDEX_WRONG = (function () {
			var re1 = /a/
			var re2 = /b*/g
			call2(nativeExec, re1, 'a')
			call2(nativeExec, re2, 'a')
			return re1.lastIndex !== 0 || re2.lastIndex !== 0
		})()
		var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET
		var NPCG_INCLUDED = /()??/.exec('')[1] !== void 0
		var PATCH =
			UPDATES_LAST_INDEX_WRONG ||
			NPCG_INCLUDED ||
			UNSUPPORTED_Y ||
			UNSUPPORTED_DOT_ALL ||
			UNSUPPORTED_NCG
		if (PATCH) {
			patchedExec = function exec(string2) {
				var re = this
				var state = getInternalState(re)
				var str = toString(string2)
				var raw = state.raw
				var result, reCopy, lastIndex, match, i3, object2, group
				if (raw) {
					raw.lastIndex = re.lastIndex
					result = call2(patchedExec, raw, str)
					re.lastIndex = raw.lastIndex
					return result
				}
				var groups = state.groups
				var sticky = UNSUPPORTED_Y && re.sticky
				var flags = call2(regexpFlags, re)
				var source = re.source
				var charsAdded = 0
				var strCopy = str
				if (sticky) {
					flags = replace(flags, 'y', '')
					if (indexOf(flags, 'g') === -1) {
						flags += 'g'
					}
					strCopy = stringSlice(str, re.lastIndex)
					if (
						re.lastIndex > 0 &&
						(!re.multiline || (re.multiline && charAt(str, re.lastIndex - 1) !== '\n'))
					) {
						source = '(?: ' + source + ')'
						strCopy = ' ' + strCopy
						charsAdded++
					}
					reCopy = new RegExp('^(?:' + source + ')', flags)
				}
				if (NPCG_INCLUDED) {
					reCopy = new RegExp('^' + source + '$(?!\\s)', flags)
				}
				if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex
				match = call2(nativeExec, sticky ? reCopy : re, strCopy)
				if (sticky) {
					if (match) {
						match.input = stringSlice(match.input, charsAdded)
						match[0] = stringSlice(match[0], charsAdded)
						match.index = re.lastIndex
						re.lastIndex += match[0].length
					} else re.lastIndex = 0
				} else if (UPDATES_LAST_INDEX_WRONG && match) {
					re.lastIndex = re.global ? match.index + match[0].length : lastIndex
				}
				if (NPCG_INCLUDED && match && match.length > 1) {
					call2(nativeReplace, match[0], reCopy, function () {
						for (i3 = 1; i3 < arguments.length - 2; i3++) {
							if (arguments[i3] === void 0) match[i3] = void 0
						}
					})
				}
				if (match && groups) {
					match.groups = object2 = create(null)
					for (i3 = 0; i3 < groups.length; i3++) {
						group = groups[i3]
						object2[group[0]] = match[group[1]]
					}
				}
				return match
			}
		}
		module2.exports = patchedExec
	},
})

// ../node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
	'../node_modules/core-js/modules/es.regexp.exec.js'() {
		'use strict'
		init_define_process()
		var $ = require_export()
		var exec = require_regexp_exec()
		$(
			{ target: 'RegExp', proto: true, forced: /./.exec !== exec },
			{
				exec,
			}
		)
	},
})

// ../node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
	'../node_modules/core-js/internals/function-apply.js'(exports, module2) {
		init_define_process()
		var NATIVE_BIND = require_function_bind_native()
		var FunctionPrototype = Function.prototype
		var apply = FunctionPrototype.apply
		var call2 = FunctionPrototype.call
		module2.exports =
			(typeof Reflect == 'object' && Reflect.apply) ||
			(NATIVE_BIND
				? call2.bind(apply)
				: function () {
						return call2.apply(apply, arguments)
				  })
	},
})

// ../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
	'../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js'(exports, module2) {
		'use strict'
		init_define_process()
		require_es_regexp_exec()
		var uncurryThis = require_function_uncurry_this_clause()
		var defineBuiltIn = require_define_built_in()
		var regexpExec = require_regexp_exec()
		var fails = require_fails()
		var wellKnownSymbol = require_well_known_symbol()
		var createNonEnumerableProperty = require_create_non_enumerable_property()
		var SPECIES = wellKnownSymbol('species')
		var RegExpPrototype = RegExp.prototype
		module2.exports = function (KEY, exec, FORCED, SHAM) {
			var SYMBOL = wellKnownSymbol(KEY)
			var DELEGATES_TO_SYMBOL = !fails(function () {
				var O2 = {}
				O2[SYMBOL] = function () {
					return 7
				}
				return ''[KEY](O2) != 7
			})
			var DELEGATES_TO_EXEC =
				DELEGATES_TO_SYMBOL &&
				!fails(function () {
					var execCalled = false
					var re = /a/
					if (KEY === 'split') {
						re = {}
						re.constructor = {}
						re.constructor[SPECIES] = function () {
							return re
						}
						re.flags = ''
						re[SYMBOL] = /./[SYMBOL]
					}
					re.exec = function () {
						execCalled = true
						return null
					}
					re[SYMBOL]('')
					return !execCalled
				})
			if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
				var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL])
				var methods = exec(
					SYMBOL,
					''[KEY],
					function (nativeMethod, regexp, str, arg2, forceStringMethod) {
						var uncurriedNativeMethod = uncurryThis(nativeMethod)
						var $exec = regexp.exec
						if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
							if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
								return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) }
							}
							return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) }
						}
						return { done: false }
					}
				)
				defineBuiltIn(String.prototype, KEY, methods[0])
				defineBuiltIn(RegExpPrototype, SYMBOL, methods[1])
			}
			if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true)
		}
	},
})

// ../node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
	'../node_modules/core-js/internals/string-multibyte.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var toIntegerOrInfinity = require_to_integer_or_infinity()
		var toString = require_to_string()
		var requireObjectCoercible = require_require_object_coercible()
		var charAt = uncurryThis(''.charAt)
		var charCodeAt = uncurryThis(''.charCodeAt)
		var stringSlice = uncurryThis(''.slice)
		var createMethod = function (CONVERT_TO_STRING) {
			return function ($this, pos) {
				var S2 = toString(requireObjectCoercible($this))
				var position = toIntegerOrInfinity(pos)
				var size = S2.length
				var first, second
				if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : void 0
				first = charCodeAt(S2, position)
				return first < 55296 ||
					first > 56319 ||
					position + 1 === size ||
					(second = charCodeAt(S2, position + 1)) < 56320 ||
					second > 57343
					? CONVERT_TO_STRING
						? charAt(S2, position)
						: first
					: CONVERT_TO_STRING
					? stringSlice(S2, position, position + 2)
					: ((first - 55296) << 10) + (second - 56320) + 65536
			}
		}
		module2.exports = {
			// `String.prototype.codePointAt` method
			// https://tc39.es/ecma262/#sec-string.prototype.codepointat
			codeAt: createMethod(false),
			// `String.prototype.at` method
			// https://github.com/mathiasbynens/String.prototype.at
			charAt: createMethod(true),
		}
	},
})

// ../node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
	'../node_modules/core-js/internals/advance-string-index.js'(exports, module2) {
		'use strict'
		init_define_process()
		var charAt = require_string_multibyte().charAt
		module2.exports = function (S2, index2, unicode) {
			return index2 + (unicode ? charAt(S2, index2).length : 1)
		}
	},
})

// ../node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
	'../node_modules/core-js/internals/get-substitution.js'(exports, module2) {
		init_define_process()
		var uncurryThis = require_function_uncurry_this()
		var toObject = require_to_object()
		var floor = Math.floor
		var charAt = uncurryThis(''.charAt)
		var replace = uncurryThis(''.replace)
		var stringSlice = uncurryThis(''.slice)
		var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g
		var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g
		module2.exports = function (matched, str, position, captures, namedCaptures, replacement) {
			var tailPos = position + matched.length
			var m3 = captures.length
			var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED
			if (namedCaptures !== void 0) {
				namedCaptures = toObject(namedCaptures)
				symbols = SUBSTITUTION_SYMBOLS
			}
			return replace(replacement, symbols, function (match, ch) {
				var capture
				switch (charAt(ch, 0)) {
					case '$':
						return '$'
					case '&':
						return matched
					case '`':
						return stringSlice(str, 0, position)
					case "'":
						return stringSlice(str, tailPos)
					case '<':
						capture = namedCaptures[stringSlice(ch, 1, -1)]
						break
					default:
						var n3 = +ch
						if (n3 === 0) return match
						if (n3 > m3) {
							var f3 = floor(n3 / 10)
							if (f3 === 0) return match
							if (f3 <= m3)
								return captures[f3 - 1] === void 0
									? charAt(ch, 1)
									: captures[f3 - 1] + charAt(ch, 1)
							return match
						}
						capture = captures[n3 - 1]
				}
				return capture === void 0 ? '' : capture
			})
		}
	},
})

// ../node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
	'../node_modules/core-js/internals/regexp-exec-abstract.js'(exports, module2) {
		init_define_process()
		var call2 = require_function_call()
		var anObject = require_an_object()
		var isCallable = require_is_callable()
		var classof = require_classof_raw()
		var regexpExec = require_regexp_exec()
		var $TypeError = TypeError
		module2.exports = function (R3, S2) {
			var exec = R3.exec
			if (isCallable(exec)) {
				var result = call2(exec, R3, S2)
				if (result !== null) anObject(result)
				return result
			}
			if (classof(R3) === 'RegExp') return call2(regexpExec, R3, S2)
			throw $TypeError('RegExp#exec called on incompatible receiver')
		}
	},
})

// ../node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
	'../node_modules/core-js/modules/es.string.replace.js'() {
		'use strict'
		init_define_process()
		var apply = require_function_apply()
		var call2 = require_function_call()
		var uncurryThis = require_function_uncurry_this()
		var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic()
		var fails = require_fails()
		var anObject = require_an_object()
		var isCallable = require_is_callable()
		var isNullOrUndefined = require_is_null_or_undefined()
		var toIntegerOrInfinity = require_to_integer_or_infinity()
		var toLength = require_to_length()
		var toString = require_to_string()
		var requireObjectCoercible = require_require_object_coercible()
		var advanceStringIndex = require_advance_string_index()
		var getMethod2 = require_get_method()
		var getSubstitution = require_get_substitution()
		var regExpExec = require_regexp_exec_abstract()
		var wellKnownSymbol = require_well_known_symbol()
		var REPLACE = wellKnownSymbol('replace')
		var max = Math.max
		var min2 = Math.min
		var concat = uncurryThis([].concat)
		var push = uncurryThis([].push)
		var stringIndexOf = uncurryThis(''.indexOf)
		var stringSlice = uncurryThis(''.slice)
		var maybeToString = function (it) {
			return it === void 0 ? it : String(it)
		}
		var REPLACE_KEEPS_$0 = (function () {
			return 'a'.replace(/./, '$0') === '$0'
		})()
		var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
			if (/./[REPLACE]) {
				return /./[REPLACE]('a', '$0') === ''
			}
			return false
		})()
		var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
			var re = /./
			re.exec = function () {
				var result = []
				result.groups = { a: '7' }
				return result
			}
			return ''.replace(re, '$<a>') !== '7'
		})
		fixRegExpWellKnownSymbolLogic(
			'replace',
			function (_, nativeReplace, maybeCallNative) {
				var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0'
				return [
					// `String.prototype.replace` method
					// https://tc39.es/ecma262/#sec-string.prototype.replace
					function replace(searchValue, replaceValue) {
						var O2 = requireObjectCoercible(this)
						var replacer = isNullOrUndefined(searchValue)
							? void 0
							: getMethod2(searchValue, REPLACE)
						return replacer
							? call2(replacer, searchValue, O2, replaceValue)
							: call2(nativeReplace, toString(O2), searchValue, replaceValue)
					},
					// `RegExp.prototype[@@replace]` method
					// https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
					function (string2, replaceValue) {
						var rx = anObject(this)
						var S2 = toString(string2)
						if (
							typeof replaceValue == 'string' &&
							stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
							stringIndexOf(replaceValue, '$<') === -1
						) {
							var res = maybeCallNative(nativeReplace, rx, S2, replaceValue)
							if (res.done) return res.value
						}
						var functionalReplace = isCallable(replaceValue)
						if (!functionalReplace) replaceValue = toString(replaceValue)
						var global3 = rx.global
						if (global3) {
							var fullUnicode = rx.unicode
							rx.lastIndex = 0
						}
						var results = []
						while (true) {
							var result = regExpExec(rx, S2)
							if (result === null) break
							push(results, result)
							if (!global3) break
							var matchStr = toString(result[0])
							if (matchStr === '')
								rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode)
						}
						var accumulatedResult = ''
						var nextSourcePosition = 0
						for (var i3 = 0; i3 < results.length; i3++) {
							result = results[i3]
							var matched = toString(result[0])
							var position = max(min2(toIntegerOrInfinity(result.index), S2.length), 0)
							var captures = []
							for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]))
							var namedCaptures = result.groups
							if (functionalReplace) {
								var replacerArgs = concat([matched], captures, position, S2)
								if (namedCaptures !== void 0) push(replacerArgs, namedCaptures)
								var replacement = toString(apply(replaceValue, void 0, replacerArgs))
							} else {
								replacement = getSubstitution(
									matched,
									S2,
									position,
									captures,
									namedCaptures,
									replaceValue
								)
							}
							if (position >= nextSourcePosition) {
								accumulatedResult += stringSlice(S2, nextSourcePosition, position) + replacement
								nextSourcePosition = position + matched.length
							}
						}
						return accumulatedResult + stringSlice(S2, nextSourcePosition)
					},
				]
			},
			!REPLACE_SUPPORTS_NAMED_GROUPS ||
				!REPLACE_KEEPS_$0 ||
				REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
		)
	},
})

// ../node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
	'../node_modules/core-js/internals/is-regexp.js'(exports, module2) {
		init_define_process()
		var isObject = require_is_object()
		var classof = require_classof_raw()
		var wellKnownSymbol = require_well_known_symbol()
		var MATCH = wellKnownSymbol('match')
		module2.exports = function (it) {
			var isRegExp
			return (
				isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == 'RegExp')
			)
		}
	},
})

// ../node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
	'../node_modules/core-js/internals/regexp-get-flags.js'(exports, module2) {
		init_define_process()
		var call2 = require_function_call()
		var hasOwn = require_has_own_property()
		var isPrototypeOf = require_object_is_prototype_of()
		var regExpFlags = require_regexp_flags()
		var RegExpPrototype = RegExp.prototype
		module2.exports = function (R3) {
			var flags = R3.flags
			return flags === void 0 &&
				!('flags' in RegExpPrototype) &&
				!hasOwn(R3, 'flags') &&
				isPrototypeOf(RegExpPrototype, R3)
				? call2(regExpFlags, R3)
				: flags
		}
	},
})

// ../node_modules/core-js/modules/es.string.replace-all.js
var require_es_string_replace_all = __commonJS({
	'../node_modules/core-js/modules/es.string.replace-all.js'() {
		'use strict'
		init_define_process()
		var $ = require_export()
		var call2 = require_function_call()
		var uncurryThis = require_function_uncurry_this()
		var requireObjectCoercible = require_require_object_coercible()
		var isCallable = require_is_callable()
		var isNullOrUndefined = require_is_null_or_undefined()
		var isRegExp = require_is_regexp()
		var toString = require_to_string()
		var getMethod2 = require_get_method()
		var getRegExpFlags = require_regexp_get_flags()
		var getSubstitution = require_get_substitution()
		var wellKnownSymbol = require_well_known_symbol()
		var IS_PURE = require_is_pure()
		var REPLACE = wellKnownSymbol('replace')
		var $TypeError = TypeError
		var indexOf = uncurryThis(''.indexOf)
		var replace = uncurryThis(''.replace)
		var stringSlice = uncurryThis(''.slice)
		var max = Math.max
		var stringIndexOf = function (string2, searchValue, fromIndex) {
			if (fromIndex > string2.length) return -1
			if (searchValue === '') return fromIndex
			return indexOf(string2, searchValue, fromIndex)
		}
		$(
			{ target: 'String', proto: true },
			{
				replaceAll: function replaceAll(searchValue, replaceValue) {
					var O2 = requireObjectCoercible(this)
					var IS_REG_EXP,
						flags,
						replacer,
						string2,
						searchString,
						functionalReplace,
						searchLength,
						advanceBy,
						replacement
					var position = 0
					var endOfLastMatch = 0
					var result = ''
					if (!isNullOrUndefined(searchValue)) {
						IS_REG_EXP = isRegExp(searchValue)
						if (IS_REG_EXP) {
							flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)))
							if (!~indexOf(flags, 'g'))
								throw $TypeError('`.replaceAll` does not allow non-global regexes')
						}
						replacer = getMethod2(searchValue, REPLACE)
						if (replacer) {
							return call2(replacer, searchValue, O2, replaceValue)
						} else if (IS_PURE && IS_REG_EXP) {
							return replace(toString(O2), searchValue, replaceValue)
						}
					}
					string2 = toString(O2)
					searchString = toString(searchValue)
					functionalReplace = isCallable(replaceValue)
					if (!functionalReplace) replaceValue = toString(replaceValue)
					searchLength = searchString.length
					advanceBy = max(1, searchLength)
					position = stringIndexOf(string2, searchString, 0)
					while (position !== -1) {
						replacement = functionalReplace
							? toString(replaceValue(searchString, position, string2))
							: getSubstitution(searchString, string2, position, [], void 0, replaceValue)
						result += stringSlice(string2, endOfLastMatch, position) + replacement
						endOfLastMatch = position + searchLength
						position = stringIndexOf(string2, searchString, position + advanceBy)
					}
					if (endOfLastMatch < string2.length) {
						result += stringSlice(string2, endOfLastMatch)
					}
					return result
				},
			}
		)
	},
})

// ../node_modules/core-js/es/string/replace-all.js
var require_replace_all = __commonJS({
	'../node_modules/core-js/es/string/replace-all.js'(exports, module2) {
		init_define_process()
		require_es_regexp_exec()
		require_es_string_replace()
		require_es_string_replace_all()
		var entryUnbind = require_entry_unbind()
		module2.exports = entryUnbind('String', 'replaceAll')
	},
})

// ../node_modules/core-js/stable/string/replace-all.js
var require_replace_all2 = __commonJS({
	'../node_modules/core-js/stable/string/replace-all.js'(exports, module2) {
		init_define_process()
		var parent = require_replace_all()
		module2.exports = parent
	},
})

// ../node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
	'../node_modules/lodash.isequal/index.js'(exports, module2) {
		init_define_process()
		var LARGE_ARRAY_SIZE = 200
		var HASH_UNDEFINED = '__lodash_hash_undefined__'
		var COMPARE_PARTIAL_FLAG = 1
		var COMPARE_UNORDERED_FLAG = 2
		var MAX_SAFE_INTEGER = 9007199254740991
		var argsTag = '[object Arguments]'
		var arrayTag = '[object Array]'
		var asyncTag = '[object AsyncFunction]'
		var boolTag = '[object Boolean]'
		var dateTag = '[object Date]'
		var errorTag = '[object Error]'
		var funcTag = '[object Function]'
		var genTag = '[object GeneratorFunction]'
		var mapTag = '[object Map]'
		var numberTag = '[object Number]'
		var nullTag = '[object Null]'
		var objectTag = '[object Object]'
		var promiseTag = '[object Promise]'
		var proxyTag = '[object Proxy]'
		var regexpTag = '[object RegExp]'
		var setTag = '[object Set]'
		var stringTag = '[object String]'
		var symbolTag = '[object Symbol]'
		var undefinedTag = '[object Undefined]'
		var weakMapTag = '[object WeakMap]'
		var arrayBufferTag = '[object ArrayBuffer]'
		var dataViewTag = '[object DataView]'
		var float32Tag = '[object Float32Array]'
		var float64Tag = '[object Float64Array]'
		var int8Tag = '[object Int8Array]'
		var int16Tag = '[object Int16Array]'
		var int32Tag = '[object Int32Array]'
		var uint8Tag = '[object Uint8Array]'
		var uint8ClampedTag = '[object Uint8ClampedArray]'
		var uint16Tag = '[object Uint16Array]'
		var uint32Tag = '[object Uint32Array]'
		var reRegExpChar = /[\\^$.*+?()[\]{}|]/g
		var reIsHostCtor = /^\[object .+?Constructor\]$/
		var reIsUint = /^(?:0|[1-9]\d*)$/
		var typedArrayTags = {}
		typedArrayTags[float32Tag] =
			typedArrayTags[float64Tag] =
			typedArrayTags[int8Tag] =
			typedArrayTags[int16Tag] =
			typedArrayTags[int32Tag] =
			typedArrayTags[uint8Tag] =
			typedArrayTags[uint8ClampedTag] =
			typedArrayTags[uint16Tag] =
			typedArrayTags[uint32Tag] =
				true
		typedArrayTags[argsTag] =
			typedArrayTags[arrayTag] =
			typedArrayTags[arrayBufferTag] =
			typedArrayTags[boolTag] =
			typedArrayTags[dataViewTag] =
			typedArrayTags[dateTag] =
			typedArrayTags[errorTag] =
			typedArrayTags[funcTag] =
			typedArrayTags[mapTag] =
			typedArrayTags[numberTag] =
			typedArrayTags[objectTag] =
			typedArrayTags[regexpTag] =
			typedArrayTags[setTag] =
			typedArrayTags[stringTag] =
			typedArrayTags[weakMapTag] =
				false
		var freeGlobal = typeof global == 'object' && global && global.Object === Object && global
		var freeSelf = typeof self == 'object' && self && self.Object === Object && self
		var root2 = freeGlobal || freeSelf || Function('return this')()
		var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports
		var freeModule =
			freeExports && typeof module2 == 'object' && module2 && !module2.nodeType && module2
		var moduleExports = freeModule && freeModule.exports === freeExports
		var freeProcess = moduleExports && freeGlobal.process
		var nodeUtil = (function () {
			try {
				return freeProcess && freeProcess.binding && freeProcess.binding('util')
			} catch (e2) {}
		})()
		var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray
		function arrayFilter(array2, predicate) {
			var index2 = -1,
				length = array2 == null ? 0 : array2.length,
				resIndex = 0,
				result = []
			while (++index2 < length) {
				var value = array2[index2]
				if (predicate(value, index2, array2)) {
					result[resIndex++] = value
				}
			}
			return result
		}
		function arrayPush(array2, values) {
			var index2 = -1,
				length = values.length,
				offset = array2.length
			while (++index2 < length) {
				array2[offset + index2] = values[index2]
			}
			return array2
		}
		function arraySome(array2, predicate) {
			var index2 = -1,
				length = array2 == null ? 0 : array2.length
			while (++index2 < length) {
				if (predicate(array2[index2], index2, array2)) {
					return true
				}
			}
			return false
		}
		function baseTimes(n3, iteratee) {
			var index2 = -1,
				result = Array(n3)
			while (++index2 < n3) {
				result[index2] = iteratee(index2)
			}
			return result
		}
		function baseUnary(func) {
			return function (value) {
				return func(value)
			}
		}
		function cacheHas(cache, key) {
			return cache.has(key)
		}
		function getValue(object2, key) {
			return object2 == null ? void 0 : object2[key]
		}
		function mapToArray(map) {
			var index2 = -1,
				result = Array(map.size)
			map.forEach(function (value, key) {
				result[++index2] = [key, value]
			})
			return result
		}
		function overArg(func, transform) {
			return function (arg) {
				return func(transform(arg))
			}
		}
		function setToArray(set) {
			var index2 = -1,
				result = Array(set.size)
			set.forEach(function (value) {
				result[++index2] = value
			})
			return result
		}
		var arrayProto = Array.prototype
		var funcProto = Function.prototype
		var objectProto = Object.prototype
		var coreJsData = root2['__core-js_shared__']
		var funcToString = funcProto.toString
		var hasOwnProperty2 = objectProto.hasOwnProperty
		var maskSrcKey = (function () {
			var uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '')
			return uid ? 'Symbol(src)_1.' + uid : ''
		})()
		var nativeObjectToString = objectProto.toString
		var reIsNative = RegExp(
			'^' +
				funcToString
					.call(hasOwnProperty2)
					.replace(reRegExpChar, '\\$&')
					.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
				'$'
		)
		var Buffer3 = moduleExports ? root2.Buffer : void 0
		var Symbol2 = root2.Symbol
		var Uint8Array2 = root2.Uint8Array
		var propertyIsEnumerable = objectProto.propertyIsEnumerable
		var splice = arrayProto.splice
		var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0
		var nativeGetSymbols = Object.getOwnPropertySymbols
		var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0
		var nativeKeys = overArg(Object.keys, Object)
		var DataView2 = getNative(root2, 'DataView')
		var Map2 = getNative(root2, 'Map')
		var Promise2 = getNative(root2, 'Promise')
		var Set2 = getNative(root2, 'Set')
		var WeakMap2 = getNative(root2, 'WeakMap')
		var nativeCreate = getNative(Object, 'create')
		var dataViewCtorString = toSource(DataView2)
		var mapCtorString = toSource(Map2)
		var promiseCtorString = toSource(Promise2)
		var setCtorString = toSource(Set2)
		var weakMapCtorString = toSource(WeakMap2)
		var symbolProto = Symbol2 ? Symbol2.prototype : void 0
		var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0
		function Hash(entries) {
			var index2 = -1,
				length = entries == null ? 0 : entries.length
			this.clear()
			while (++index2 < length) {
				var entry = entries[index2]
				this.set(entry[0], entry[1])
			}
		}
		function hashClear() {
			this.__data__ = nativeCreate ? nativeCreate(null) : {}
			this.size = 0
		}
		function hashDelete(key) {
			var result = this.has(key) && delete this.__data__[key]
			this.size -= result ? 1 : 0
			return result
		}
		function hashGet(key) {
			var data = this.__data__
			if (nativeCreate) {
				var result = data[key]
				return result === HASH_UNDEFINED ? void 0 : result
			}
			return hasOwnProperty2.call(data, key) ? data[key] : void 0
		}
		function hashHas(key) {
			var data = this.__data__
			return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key)
		}
		function hashSet(key, value) {
			var data = this.__data__
			this.size += this.has(key) ? 0 : 1
			data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value
			return this
		}
		Hash.prototype.clear = hashClear
		Hash.prototype['delete'] = hashDelete
		Hash.prototype.get = hashGet
		Hash.prototype.has = hashHas
		Hash.prototype.set = hashSet
		function ListCache(entries) {
			var index2 = -1,
				length = entries == null ? 0 : entries.length
			this.clear()
			while (++index2 < length) {
				var entry = entries[index2]
				this.set(entry[0], entry[1])
			}
		}
		function listCacheClear() {
			this.__data__ = []
			this.size = 0
		}
		function listCacheDelete(key) {
			var data = this.__data__,
				index2 = assocIndexOf(data, key)
			if (index2 < 0) {
				return false
			}
			var lastIndex = data.length - 1
			if (index2 == lastIndex) {
				data.pop()
			} else {
				splice.call(data, index2, 1)
			}
			--this.size
			return true
		}
		function listCacheGet(key) {
			var data = this.__data__,
				index2 = assocIndexOf(data, key)
			return index2 < 0 ? void 0 : data[index2][1]
		}
		function listCacheHas(key) {
			return assocIndexOf(this.__data__, key) > -1
		}
		function listCacheSet(key, value) {
			var data = this.__data__,
				index2 = assocIndexOf(data, key)
			if (index2 < 0) {
				++this.size
				data.push([key, value])
			} else {
				data[index2][1] = value
			}
			return this
		}
		ListCache.prototype.clear = listCacheClear
		ListCache.prototype['delete'] = listCacheDelete
		ListCache.prototype.get = listCacheGet
		ListCache.prototype.has = listCacheHas
		ListCache.prototype.set = listCacheSet
		function MapCache(entries) {
			var index2 = -1,
				length = entries == null ? 0 : entries.length
			this.clear()
			while (++index2 < length) {
				var entry = entries[index2]
				this.set(entry[0], entry[1])
			}
		}
		function mapCacheClear() {
			this.size = 0
			this.__data__ = {
				hash: new Hash(),
				map: new (Map2 || ListCache)(),
				string: new Hash(),
			}
		}
		function mapCacheDelete(key) {
			var result = getMapData(this, key)['delete'](key)
			this.size -= result ? 1 : 0
			return result
		}
		function mapCacheGet(key) {
			return getMapData(this, key).get(key)
		}
		function mapCacheHas(key) {
			return getMapData(this, key).has(key)
		}
		function mapCacheSet(key, value) {
			var data = getMapData(this, key),
				size = data.size
			data.set(key, value)
			this.size += data.size == size ? 0 : 1
			return this
		}
		MapCache.prototype.clear = mapCacheClear
		MapCache.prototype['delete'] = mapCacheDelete
		MapCache.prototype.get = mapCacheGet
		MapCache.prototype.has = mapCacheHas
		MapCache.prototype.set = mapCacheSet
		function SetCache(values) {
			var index2 = -1,
				length = values == null ? 0 : values.length
			this.__data__ = new MapCache()
			while (++index2 < length) {
				this.add(values[index2])
			}
		}
		function setCacheAdd(value) {
			this.__data__.set(value, HASH_UNDEFINED)
			return this
		}
		function setCacheHas(value) {
			return this.__data__.has(value)
		}
		SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
		SetCache.prototype.has = setCacheHas
		function Stack2(entries) {
			var data = (this.__data__ = new ListCache(entries))
			this.size = data.size
		}
		function stackClear() {
			this.__data__ = new ListCache()
			this.size = 0
		}
		function stackDelete(key) {
			var data = this.__data__,
				result = data['delete'](key)
			this.size = data.size
			return result
		}
		function stackGet(key) {
			return this.__data__.get(key)
		}
		function stackHas(key) {
			return this.__data__.has(key)
		}
		function stackSet(key, value) {
			var data = this.__data__
			if (data instanceof ListCache) {
				var pairs = data.__data__
				if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
					pairs.push([key, value])
					this.size = ++data.size
					return this
				}
				data = this.__data__ = new MapCache(pairs)
			}
			data.set(key, value)
			this.size = data.size
			return this
		}
		Stack2.prototype.clear = stackClear
		Stack2.prototype['delete'] = stackDelete
		Stack2.prototype.get = stackGet
		Stack2.prototype.has = stackHas
		Stack2.prototype.set = stackSet
		function arrayLikeKeys(value, inherited) {
			var isArr = isArray(value),
				isArg = !isArr && isArguments(value),
				isBuff = !isArr && !isArg && isBuffer(value),
				isType = !isArr && !isArg && !isBuff && isTypedArray(value),
				skipIndexes = isArr || isArg || isBuff || isType,
				result = skipIndexes ? baseTimes(value.length, String) : [],
				length = result.length
			for (var key in value) {
				if (
					(inherited || hasOwnProperty2.call(value, key)) &&
					!(
						skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
						(key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
							(isBuff && (key == 'offset' || key == 'parent')) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
							(isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) || // Skip index properties.
							isIndex(key, length))
					)
				) {
					result.push(key)
				}
			}
			return result
		}
		function assocIndexOf(array2, key) {
			var length = array2.length
			while (length--) {
				if (eq(array2[length][0], key)) {
					return length
				}
			}
			return -1
		}
		function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
			var result = keysFunc(object2)
			return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2))
		}
		function baseGetTag(value) {
			if (value == null) {
				return value === void 0 ? undefinedTag : nullTag
			}
			return symToStringTag && symToStringTag in Object(value)
				? getRawTag(value)
				: objectToString(value)
		}
		function baseIsArguments(value) {
			return isObjectLike(value) && baseGetTag(value) == argsTag
		}
		function baseIsEqual(value, other, bitmask, customizer, stack3) {
			if (value === other) {
				return true
			}
			if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
				return value !== value && other !== other
			}
			return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack3)
		}
		function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack3) {
			var objIsArr = isArray(object2),
				othIsArr = isArray(other),
				objTag = objIsArr ? arrayTag : getTag(object2),
				othTag = othIsArr ? arrayTag : getTag(other)
			objTag = objTag == argsTag ? objectTag : objTag
			othTag = othTag == argsTag ? objectTag : othTag
			var objIsObj = objTag == objectTag,
				othIsObj = othTag == objectTag,
				isSameTag = objTag == othTag
			if (isSameTag && isBuffer(object2)) {
				if (!isBuffer(other)) {
					return false
				}
				objIsArr = true
				objIsObj = false
			}
			if (isSameTag && !objIsObj) {
				stack3 || (stack3 = new Stack2())
				return objIsArr || isTypedArray(object2)
					? equalArrays(object2, other, bitmask, customizer, equalFunc, stack3)
					: equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack3)
			}
			if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
				var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, '__wrapped__'),
					othIsWrapped = othIsObj && hasOwnProperty2.call(other, '__wrapped__')
				if (objIsWrapped || othIsWrapped) {
					var objUnwrapped = objIsWrapped ? object2.value() : object2,
						othUnwrapped = othIsWrapped ? other.value() : other
					stack3 || (stack3 = new Stack2())
					return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack3)
				}
			}
			if (!isSameTag) {
				return false
			}
			stack3 || (stack3 = new Stack2())
			return equalObjects(object2, other, bitmask, customizer, equalFunc, stack3)
		}
		function baseIsNative(value) {
			if (!isObject(value) || isMasked(value)) {
				return false
			}
			var pattern = isFunction(value) ? reIsNative : reIsHostCtor
			return pattern.test(toSource(value))
		}
		function baseIsTypedArray(value) {
			return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]
		}
		function baseKeys(object2) {
			if (!isPrototype(object2)) {
				return nativeKeys(object2)
			}
			var result = []
			for (var key in Object(object2)) {
				if (hasOwnProperty2.call(object2, key) && key != 'constructor') {
					result.push(key)
				}
			}
			return result
		}
		function equalArrays(array2, other, bitmask, customizer, equalFunc, stack3) {
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
				arrLength = array2.length,
				othLength = other.length
			if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
				return false
			}
			var stacked = stack3.get(array2)
			if (stacked && stack3.get(other)) {
				return stacked == other
			}
			var index2 = -1,
				result = true,
				seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0
			stack3.set(array2, other)
			stack3.set(other, array2)
			while (++index2 < arrLength) {
				var arrValue = array2[index2],
					othValue = other[index2]
				if (customizer) {
					var compared = isPartial
						? customizer(othValue, arrValue, index2, other, array2, stack3)
						: customizer(arrValue, othValue, index2, array2, other, stack3)
				}
				if (compared !== void 0) {
					if (compared) {
						continue
					}
					result = false
					break
				}
				if (seen) {
					if (
						!arraySome(other, function (othValue2, othIndex) {
							if (
								!cacheHas(seen, othIndex) &&
								(arrValue === othValue2 ||
									equalFunc(arrValue, othValue2, bitmask, customizer, stack3))
							) {
								return seen.push(othIndex)
							}
						})
					) {
						result = false
						break
					}
				} else if (
					!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack3))
				) {
					result = false
					break
				}
			}
			stack3['delete'](array2)
			stack3['delete'](other)
			return result
		}
		function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack3) {
			switch (tag) {
				case dataViewTag:
					if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
						return false
					}
					object2 = object2.buffer
					other = other.buffer
				case arrayBufferTag:
					if (
						object2.byteLength != other.byteLength ||
						!equalFunc(new Uint8Array2(object2), new Uint8Array2(other))
					) {
						return false
					}
					return true
				case boolTag:
				case dateTag:
				case numberTag:
					return eq(+object2, +other)
				case errorTag:
					return object2.name == other.name && object2.message == other.message
				case regexpTag:
				case stringTag:
					return object2 == other + ''
				case mapTag:
					var convert = mapToArray
				case setTag:
					var isPartial = bitmask & COMPARE_PARTIAL_FLAG
					convert || (convert = setToArray)
					if (object2.size != other.size && !isPartial) {
						return false
					}
					var stacked = stack3.get(object2)
					if (stacked) {
						return stacked == other
					}
					bitmask |= COMPARE_UNORDERED_FLAG
					stack3.set(object2, other)
					var result = equalArrays(
						convert(object2),
						convert(other),
						bitmask,
						customizer,
						equalFunc,
						stack3
					)
					stack3['delete'](object2)
					return result
				case symbolTag:
					if (symbolValueOf) {
						return symbolValueOf.call(object2) == symbolValueOf.call(other)
					}
			}
			return false
		}
		function equalObjects(object2, other, bitmask, customizer, equalFunc, stack3) {
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
				objProps = getAllKeys(object2),
				objLength = objProps.length,
				othProps = getAllKeys(other),
				othLength = othProps.length
			if (objLength != othLength && !isPartial) {
				return false
			}
			var index2 = objLength
			while (index2--) {
				var key = objProps[index2]
				if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
					return false
				}
			}
			var stacked = stack3.get(object2)
			if (stacked && stack3.get(other)) {
				return stacked == other
			}
			var result = true
			stack3.set(object2, other)
			stack3.set(other, object2)
			var skipCtor = isPartial
			while (++index2 < objLength) {
				key = objProps[index2]
				var objValue = object2[key],
					othValue = other[key]
				if (customizer) {
					var compared = isPartial
						? customizer(othValue, objValue, key, other, object2, stack3)
						: customizer(objValue, othValue, key, object2, other, stack3)
				}
				if (
					!(compared === void 0
						? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack3)
						: compared)
				) {
					result = false
					break
				}
				skipCtor || (skipCtor = key == 'constructor')
			}
			if (result && !skipCtor) {
				var objCtor = object2.constructor,
					othCtor = other.constructor
				if (
					objCtor != othCtor &&
					'constructor' in object2 &&
					'constructor' in other &&
					!(
						typeof objCtor == 'function' &&
						objCtor instanceof objCtor &&
						typeof othCtor == 'function' &&
						othCtor instanceof othCtor
					)
				) {
					result = false
				}
			}
			stack3['delete'](object2)
			stack3['delete'](other)
			return result
		}
		function getAllKeys(object2) {
			return baseGetAllKeys(object2, keys, getSymbols)
		}
		function getMapData(map, key) {
			var data = map.__data__
			return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map
		}
		function getNative(object2, key) {
			var value = getValue(object2, key)
			return baseIsNative(value) ? value : void 0
		}
		function getRawTag(value) {
			var isOwn = hasOwnProperty2.call(value, symToStringTag),
				tag = value[symToStringTag]
			try {
				value[symToStringTag] = void 0
				var unmasked = true
			} catch (e2) {}
			var result = nativeObjectToString.call(value)
			if (unmasked) {
				if (isOwn) {
					value[symToStringTag] = tag
				} else {
					delete value[symToStringTag]
				}
			}
			return result
		}
		var getSymbols = !nativeGetSymbols
			? stubArray
			: function (object2) {
					if (object2 == null) {
						return []
					}
					object2 = Object(object2)
					return arrayFilter(nativeGetSymbols(object2), function (symbol) {
						return propertyIsEnumerable.call(object2, symbol)
					})
			  }
		var getTag = baseGetTag
		if (
			(DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag) ||
			(Map2 && getTag(new Map2()) != mapTag) ||
			(Promise2 && getTag(Promise2.resolve()) != promiseTag) ||
			(Set2 && getTag(new Set2()) != setTag) ||
			(WeakMap2 && getTag(new WeakMap2()) != weakMapTag)
		) {
			getTag = function (value) {
				var result = baseGetTag(value),
					Ctor = result == objectTag ? value.constructor : void 0,
					ctorString = Ctor ? toSource(Ctor) : ''
				if (ctorString) {
					switch (ctorString) {
						case dataViewCtorString:
							return dataViewTag
						case mapCtorString:
							return mapTag
						case promiseCtorString:
							return promiseTag
						case setCtorString:
							return setTag
						case weakMapCtorString:
							return weakMapTag
					}
				}
				return result
			}
		}
		function isIndex(value, length) {
			length = length == null ? MAX_SAFE_INTEGER : length
			return (
				!!length &&
				(typeof value == 'number' || reIsUint.test(value)) &&
				value > -1 &&
				value % 1 == 0 &&
				value < length
			)
		}
		function isKeyable(value) {
			var type = typeof value
			return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'
				? value !== '__proto__'
				: value === null
		}
		function isMasked(func) {
			return !!maskSrcKey && maskSrcKey in func
		}
		function isPrototype(value) {
			var Ctor = value && value.constructor,
				proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto
			return value === proto
		}
		function objectToString(value) {
			return nativeObjectToString.call(value)
		}
		function toSource(func) {
			if (func != null) {
				try {
					return funcToString.call(func)
				} catch (e2) {}
				try {
					return func + ''
				} catch (e2) {}
			}
			return ''
		}
		function eq(value, other) {
			return value === other || (value !== value && other !== other)
		}
		var isArguments = baseIsArguments(
			(function () {
				return arguments
			})()
		)
			? baseIsArguments
			: function (value) {
					return (
						isObjectLike(value) &&
						hasOwnProperty2.call(value, 'callee') &&
						!propertyIsEnumerable.call(value, 'callee')
					)
			  }
		var isArray = Array.isArray
		function isArrayLike(value) {
			return value != null && isLength(value.length) && !isFunction(value)
		}
		var isBuffer = nativeIsBuffer || stubFalse
		function isEqual2(value, other) {
			return baseIsEqual(value, other)
		}
		function isFunction(value) {
			if (!isObject(value)) {
				return false
			}
			var tag = baseGetTag(value)
			return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
		}
		function isLength(value) {
			return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
		}
		function isObject(value) {
			var type = typeof value
			return value != null && (type == 'object' || type == 'function')
		}
		function isObjectLike(value) {
			return value != null && typeof value == 'object'
		}
		var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray
		function keys(object2) {
			return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2)
		}
		function stubArray() {
			return []
		}
		function stubFalse() {
			return false
		}
		module2.exports = isEqual2
	},
})

// ../node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
	'../node_modules/react/cjs/react.production.min.js'(exports) {
		'use strict'
		init_define_process()
		var l3 = Symbol.for('react.element')
		var n3 = Symbol.for('react.portal')
		var p3 = Symbol.for('react.fragment')
		var q = Symbol.for('react.strict_mode')
		var r3 = Symbol.for('react.profiler')
		var t4 = Symbol.for('react.provider')
		var u3 = Symbol.for('react.context')
		var v3 = Symbol.for('react.forward_ref')
		var w3 = Symbol.for('react.suspense')
		var x3 = Symbol.for('react.memo')
		var y3 = Symbol.for('react.lazy')
		var z2 = Symbol.iterator
		function A2(a3) {
			if (null === a3 || 'object' !== typeof a3) return null
			a3 = (z2 && a3[z2]) || a3['@@iterator']
			return 'function' === typeof a3 ? a3 : null
		}
		var B = {
			isMounted: function () {
				return false
			},
			enqueueForceUpdate: function () {},
			enqueueReplaceState: function () {},
			enqueueSetState: function () {},
		}
		var C2 = Object.assign
		var D3 = {}
		function E3(a3, b3, e2) {
			this.props = a3
			this.context = b3
			this.refs = D3
			this.updater = e2 || B
		}
		E3.prototype.isReactComponent = {}
		E3.prototype.setState = function (a3, b3) {
			if ('object' !== typeof a3 && 'function' !== typeof a3 && null != a3)
				throw Error(
					'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
				)
			this.updater.enqueueSetState(this, a3, b3, 'setState')
		}
		E3.prototype.forceUpdate = function (a3) {
			this.updater.enqueueForceUpdate(this, a3, 'forceUpdate')
		}
		function F() {}
		F.prototype = E3.prototype
		function G(a3, b3, e2) {
			this.props = a3
			this.context = b3
			this.refs = D3
			this.updater = e2 || B
		}
		var H2 = (G.prototype = new F())
		H2.constructor = G
		C2(H2, E3.prototype)
		H2.isPureReactComponent = true
		var I = Array.isArray
		var J = Object.prototype.hasOwnProperty
		var K = { current: null }
		var L3 = { key: true, ref: true, __self: true, __source: true }
		function M(a3, b3, e2) {
			var d3,
				c3 = {},
				k2 = null,
				h3 = null
			if (null != b3)
				for (d3 in (void 0 !== b3.ref && (h3 = b3.ref),
				void 0 !== b3.key && (k2 = '' + b3.key),
				b3))
					J.call(b3, d3) && !L3.hasOwnProperty(d3) && (c3[d3] = b3[d3])
			var g3 = arguments.length - 2
			if (1 === g3) c3.children = e2
			else if (1 < g3) {
				for (var f3 = Array(g3), m3 = 0; m3 < g3; m3++) f3[m3] = arguments[m3 + 2]
				c3.children = f3
			}
			if (a3 && a3.defaultProps)
				for (d3 in ((g3 = a3.defaultProps), g3)) void 0 === c3[d3] && (c3[d3] = g3[d3])
			return { $$typeof: l3, type: a3, key: k2, ref: h3, props: c3, _owner: K.current }
		}
		function N2(a3, b3) {
			return {
				$$typeof: l3,
				type: a3.type,
				key: b3,
				ref: a3.ref,
				props: a3.props,
				_owner: a3._owner,
			}
		}
		function O2(a3) {
			return 'object' === typeof a3 && null !== a3 && a3.$$typeof === l3
		}
		function escape(a3) {
			var b3 = { '=': '=0', ':': '=2' }
			return (
				'$' +
				a3.replace(/[=:]/g, function (a4) {
					return b3[a4]
				})
			)
		}
		var P2 = /\/+/g
		function Q(a3, b3) {
			return 'object' === typeof a3 && null !== a3 && null != a3.key
				? escape('' + a3.key)
				: b3.toString(36)
		}
		function R3(a3, b3, e2, d3, c3) {
			var k2 = typeof a3
			if ('undefined' === k2 || 'boolean' === k2) a3 = null
			var h3 = false
			if (null === a3) h3 = true
			else
				switch (k2) {
					case 'string':
					case 'number':
						h3 = true
						break
					case 'object':
						switch (a3.$$typeof) {
							case l3:
							case n3:
								h3 = true
						}
				}
			if (h3)
				return (
					(h3 = a3),
					(c3 = c3(h3)),
					(a3 = '' === d3 ? '.' + Q(h3, 0) : d3),
					I(c3)
						? ((e2 = ''),
						  null != a3 && (e2 = a3.replace(P2, '$&/') + '/'),
						  R3(c3, b3, e2, '', function (a4) {
								return a4
						  }))
						: null != c3 &&
						  (O2(c3) &&
								(c3 = N2(
									c3,
									e2 +
										(!c3.key || (h3 && h3.key === c3.key)
											? ''
											: ('' + c3.key).replace(P2, '$&/') + '/') +
										a3
								)),
						  b3.push(c3)),
					1
				)
			h3 = 0
			d3 = '' === d3 ? '.' : d3 + ':'
			if (I(a3))
				for (var g3 = 0; g3 < a3.length; g3++) {
					k2 = a3[g3]
					var f3 = d3 + Q(k2, g3)
					h3 += R3(k2, b3, e2, f3, c3)
				}
			else if (((f3 = A2(a3)), 'function' === typeof f3))
				for (a3 = f3.call(a3), g3 = 0; !(k2 = a3.next()).done; )
					(k2 = k2.value), (f3 = d3 + Q(k2, g3++)), (h3 += R3(k2, b3, e2, f3, c3))
			else if ('object' === k2)
				throw (
					((b3 = String(a3)),
					Error(
						'Objects are not valid as a React child (found: ' +
							('[object Object]' === b3
								? 'object with keys {' + Object.keys(a3).join(', ') + '}'
								: b3) +
							'). If you meant to render a collection of children, use an array instead.'
					))
				)
			return h3
		}
		function S2(a3, b3, e2) {
			if (null == a3) return a3
			var d3 = [],
				c3 = 0
			R3(a3, d3, '', '', function (a4) {
				return b3.call(e2, a4, c3++)
			})
			return d3
		}
		function T3(a3) {
			if (-1 === a3._status) {
				var b3 = a3._result
				b3 = b3()
				b3.then(
					function (b4) {
						if (0 === a3._status || -1 === a3._status) (a3._status = 1), (a3._result = b4)
					},
					function (b4) {
						if (0 === a3._status || -1 === a3._status) (a3._status = 2), (a3._result = b4)
					}
				)
				;-1 === a3._status && ((a3._status = 0), (a3._result = b3))
			}
			if (1 === a3._status) return a3._result.default
			throw a3._result
		}
		var U = { current: null }
		var V2 = { transition: null }
		var W2 = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K }
		exports.Children = {
			map: S2,
			forEach: function (a3, b3, e2) {
				S2(
					a3,
					function () {
						b3.apply(this, arguments)
					},
					e2
				)
			},
			count: function (a3) {
				var b3 = 0
				S2(a3, function () {
					b3++
				})
				return b3
			},
			toArray: function (a3) {
				return (
					S2(a3, function (a4) {
						return a4
					}) || []
				)
			},
			only: function (a3) {
				if (!O2(a3))
					throw Error('React.Children.only expected to receive a single React element child.')
				return a3
			},
		}
		exports.Component = E3
		exports.Fragment = p3
		exports.Profiler = r3
		exports.PureComponent = G
		exports.StrictMode = q
		exports.Suspense = w3
		exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W2
		exports.cloneElement = function (a3, b3, e2) {
			if (null === a3 || void 0 === a3)
				throw Error(
					'React.cloneElement(...): The argument must be a React element, but you passed ' +
						a3 +
						'.'
				)
			var d3 = C2({}, a3.props),
				c3 = a3.key,
				k2 = a3.ref,
				h3 = a3._owner
			if (null != b3) {
				void 0 !== b3.ref && ((k2 = b3.ref), (h3 = K.current))
				void 0 !== b3.key && (c3 = '' + b3.key)
				if (a3.type && a3.type.defaultProps) var g3 = a3.type.defaultProps
				for (f3 in b3)
					J.call(b3, f3) &&
						!L3.hasOwnProperty(f3) &&
						(d3[f3] = void 0 === b3[f3] && void 0 !== g3 ? g3[f3] : b3[f3])
			}
			var f3 = arguments.length - 2
			if (1 === f3) d3.children = e2
			else if (1 < f3) {
				g3 = Array(f3)
				for (var m3 = 0; m3 < f3; m3++) g3[m3] = arguments[m3 + 2]
				d3.children = g3
			}
			return { $$typeof: l3, type: a3.type, key: c3, ref: k2, props: d3, _owner: h3 }
		}
		exports.createContext = function (a3) {
			a3 = {
				$$typeof: u3,
				_currentValue: a3,
				_currentValue2: a3,
				_threadCount: 0,
				Provider: null,
				Consumer: null,
				_defaultValue: null,
				_globalName: null,
			}
			a3.Provider = { $$typeof: t4, _context: a3 }
			return (a3.Consumer = a3)
		}
		exports.createElement = M
		exports.createFactory = function (a3) {
			var b3 = M.bind(null, a3)
			b3.type = a3
			return b3
		}
		exports.createRef = function () {
			return { current: null }
		}
		exports.forwardRef = function (a3) {
			return { $$typeof: v3, render: a3 }
		}
		exports.isValidElement = O2
		exports.lazy = function (a3) {
			return { $$typeof: y3, _payload: { _status: -1, _result: a3 }, _init: T3 }
		}
		exports.memo = function (a3, b3) {
			return { $$typeof: x3, type: a3, compare: void 0 === b3 ? null : b3 }
		}
		exports.startTransition = function (a3) {
			var b3 = V2.transition
			V2.transition = {}
			try {
				a3()
			} finally {
				V2.transition = b3
			}
		}
		exports.unstable_act = function () {
			throw Error('act(...) is not supported in production builds of React.')
		}
		exports.useCallback = function (a3, b3) {
			return U.current.useCallback(a3, b3)
		}
		exports.useContext = function (a3) {
			return U.current.useContext(a3)
		}
		exports.useDebugValue = function () {}
		exports.useDeferredValue = function (a3) {
			return U.current.useDeferredValue(a3)
		}
		exports.useEffect = function (a3, b3) {
			return U.current.useEffect(a3, b3)
		}
		exports.useId = function () {
			return U.current.useId()
		}
		exports.useImperativeHandle = function (a3, b3, e2) {
			return U.current.useImperativeHandle(a3, b3, e2)
		}
		exports.useInsertionEffect = function (a3, b3) {
			return U.current.useInsertionEffect(a3, b3)
		}
		exports.useLayoutEffect = function (a3, b3) {
			return U.current.useLayoutEffect(a3, b3)
		}
		exports.useMemo = function (a3, b3) {
			return U.current.useMemo(a3, b3)
		}
		exports.useReducer = function (a3, b3, e2) {
			return U.current.useReducer(a3, b3, e2)
		}
		exports.useRef = function (a3) {
			return U.current.useRef(a3)
		}
		exports.useState = function (a3) {
			return U.current.useState(a3)
		}
		exports.useSyncExternalStore = function (a3, b3, e2) {
			return U.current.useSyncExternalStore(a3, b3, e2)
		}
		exports.useTransition = function () {
			return U.current.useTransition()
		}
		exports.version = '18.2.0'
	},
})

// ../node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
	'../node_modules/react/cjs/react.development.js'(exports, module2) {
		'use strict'
		init_define_process()
		if (define_process_default.env.NODE_ENV !== 'production') {
			;(function () {
				'use strict'
				if (
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function'
				) {
					__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
				}
				var ReactVersion = '18.2.0'
				var REACT_ELEMENT_TYPE = Symbol.for('react.element')
				var REACT_PORTAL_TYPE = Symbol.for('react.portal')
				var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')
				var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')
				var REACT_PROFILER_TYPE = Symbol.for('react.profiler')
				var REACT_PROVIDER_TYPE = Symbol.for('react.provider')
				var REACT_CONTEXT_TYPE = Symbol.for('react.context')
				var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')
				var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')
				var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')
				var REACT_MEMO_TYPE = Symbol.for('react.memo')
				var REACT_LAZY_TYPE = Symbol.for('react.lazy')
				var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen')
				var MAYBE_ITERATOR_SYMBOL = Symbol.iterator
				var FAUX_ITERATOR_SYMBOL = '@@iterator'
				function getIteratorFn(maybeIterable) {
					if (maybeIterable === null || typeof maybeIterable !== 'object') {
						return null
					}
					var maybeIterator =
						(MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
						maybeIterable[FAUX_ITERATOR_SYMBOL]
					if (typeof maybeIterator === 'function') {
						return maybeIterator
					}
					return null
				}
				var ReactCurrentDispatcher = {
					/**
					 * @internal
					 * @type {ReactComponent}
					 */
					current: null,
				}
				var ReactCurrentBatchConfig = {
					transition: null,
				}
				var ReactCurrentActQueue = {
					current: null,
					// Used to reproduce behavior of `batchedUpdates` in legacy mode.
					isBatchingLegacy: false,
					didScheduleLegacyUpdate: false,
				}
				var ReactCurrentOwner = {
					/**
					 * @internal
					 * @type {ReactComponent}
					 */
					current: null,
				}
				var ReactDebugCurrentFrame = {}
				var currentExtraStackFrame = null
				function setExtraStackFrame(stack3) {
					{
						currentExtraStackFrame = stack3
					}
				}
				{
					ReactDebugCurrentFrame.setExtraStackFrame = function (stack3) {
						{
							currentExtraStackFrame = stack3
						}
					}
					ReactDebugCurrentFrame.getCurrentStack = null
					ReactDebugCurrentFrame.getStackAddendum = function () {
						var stack3 = ''
						if (currentExtraStackFrame) {
							stack3 += currentExtraStackFrame
						}
						var impl = ReactDebugCurrentFrame.getCurrentStack
						if (impl) {
							stack3 += impl() || ''
						}
						return stack3
					}
				}
				var enableScopeAPI = false
				var enableCacheElement = false
				var enableTransitionTracing = false
				var enableLegacyHidden = false
				var enableDebugTracing = false
				var ReactSharedInternals = {
					ReactCurrentDispatcher,
					ReactCurrentBatchConfig,
					ReactCurrentOwner,
				}
				{
					ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame
					ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue
				}
				function warn(format) {
					{
						{
							for (
								var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
								_key < _len;
								_key++
							) {
								args[_key - 1] = arguments[_key]
							}
							printWarning('warn', format, args)
						}
					}
				}
				function error(format) {
					{
						{
							for (
								var _len2 = arguments.length,
									args = new Array(_len2 > 1 ? _len2 - 1 : 0),
									_key2 = 1;
								_key2 < _len2;
								_key2++
							) {
								args[_key2 - 1] = arguments[_key2]
							}
							printWarning('error', format, args)
						}
					}
				}
				function printWarning(level, format, args) {
					{
						var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame
						var stack3 = ReactDebugCurrentFrame2.getStackAddendum()
						if (stack3 !== '') {
							format += '%s'
							args = args.concat([stack3])
						}
						var argsWithFormat = args.map(function (item) {
							return String(item)
						})
						argsWithFormat.unshift('Warning: ' + format)
						Function.prototype.apply.call(console[level], console, argsWithFormat)
					}
				}
				var didWarnStateUpdateForUnmountedComponent = {}
				function warnNoop(publicInstance, callerName) {
					{
						var _constructor = publicInstance.constructor
						var componentName =
							(_constructor && (_constructor.displayName || _constructor.name)) || 'ReactClass'
						var warningKey = componentName + '.' + callerName
						if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
							return
						}
						error(
							"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
							callerName,
							componentName
						)
						didWarnStateUpdateForUnmountedComponent[warningKey] = true
					}
				}
				var ReactNoopUpdateQueue = {
					/**
					 * Checks whether or not this composite component is mounted.
					 * @param {ReactClass} publicInstance The instance we want to test.
					 * @return {boolean} True if mounted, false otherwise.
					 * @protected
					 * @final
					 */
					isMounted: function (publicInstance) {
						return false
					},
					/**
					 * Forces an update. This should only be invoked when it is known with
					 * certainty that we are **not** in a DOM transaction.
					 *
					 * You may want to call this when you know that some deeper aspect of the
					 * component's state has changed but `setState` was not called.
					 *
					 * This will not invoke `shouldComponentUpdate`, but it will invoke
					 * `componentWillUpdate` and `componentDidUpdate`.
					 *
					 * @param {ReactClass} publicInstance The instance that should rerender.
					 * @param {?function} callback Called after component is updated.
					 * @param {?string} callerName name of the calling function in the public API.
					 * @internal
					 */
					enqueueForceUpdate: function (publicInstance, callback, callerName) {
						warnNoop(publicInstance, 'forceUpdate')
					},
					/**
					 * Replaces all of the state. Always use this or `setState` to mutate state.
					 * You should treat `this.state` as immutable.
					 *
					 * There is no guarantee that `this.state` will be immediately updated, so
					 * accessing `this.state` after calling this method may return the old value.
					 *
					 * @param {ReactClass} publicInstance The instance that should rerender.
					 * @param {object} completeState Next state.
					 * @param {?function} callback Called after component is updated.
					 * @param {?string} callerName name of the calling function in the public API.
					 * @internal
					 */
					enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
						warnNoop(publicInstance, 'replaceState')
					},
					/**
					 * Sets a subset of the state. This only exists because _pendingState is
					 * internal. This provides a merging strategy that is not available to deep
					 * properties which is confusing. TODO: Expose pendingState or don't use it
					 * during the merge.
					 *
					 * @param {ReactClass} publicInstance The instance that should rerender.
					 * @param {object} partialState Next partial state to be merged with state.
					 * @param {?function} callback Called after component is updated.
					 * @param {?string} Name of the calling function in the public API.
					 * @internal
					 */
					enqueueSetState: function (publicInstance, partialState, callback, callerName) {
						warnNoop(publicInstance, 'setState')
					},
				}
				var assign = Object.assign
				var emptyObject = {}
				{
					Object.freeze(emptyObject)
				}
				function Component3(props, context, updater) {
					this.props = props
					this.context = context
					this.refs = emptyObject
					this.updater = updater || ReactNoopUpdateQueue
				}
				Component3.prototype.isReactComponent = {}
				Component3.prototype.setState = function (partialState, callback) {
					if (
						typeof partialState !== 'object' &&
						typeof partialState !== 'function' &&
						partialState != null
					) {
						throw new Error(
							'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
						)
					}
					this.updater.enqueueSetState(this, partialState, callback, 'setState')
				}
				Component3.prototype.forceUpdate = function (callback) {
					this.updater.enqueueForceUpdate(this, callback, 'forceUpdate')
				}
				{
					var deprecatedAPIs = {
						isMounted: [
							'isMounted',
							'Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.',
						],
						replaceState: [
							'replaceState',
							'Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).',
						],
					}
					var defineDeprecationWarning = function (methodName, info) {
						Object.defineProperty(Component3.prototype, methodName, {
							get: function () {
								warn(
									'%s(...) is deprecated in plain JavaScript React classes. %s',
									info[0],
									info[1]
								)
								return void 0
							},
						})
					}
					for (var fnName in deprecatedAPIs) {
						if (deprecatedAPIs.hasOwnProperty(fnName)) {
							defineDeprecationWarning(fnName, deprecatedAPIs[fnName])
						}
					}
				}
				function ComponentDummy() {}
				ComponentDummy.prototype = Component3.prototype
				function PureComponent(props, context, updater) {
					this.props = props
					this.context = context
					this.refs = emptyObject
					this.updater = updater || ReactNoopUpdateQueue
				}
				var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy())
				pureComponentPrototype.constructor = PureComponent
				assign(pureComponentPrototype, Component3.prototype)
				pureComponentPrototype.isPureReactComponent = true
				function createRef() {
					var refObject = {
						current: null,
					}
					{
						Object.seal(refObject)
					}
					return refObject
				}
				var isArrayImpl = Array.isArray
				function isArray(a3) {
					return isArrayImpl(a3)
				}
				function typeName(value) {
					{
						var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag
						var type =
							(hasToStringTag && value[Symbol.toStringTag]) || value.constructor.name || 'Object'
						return type
					}
				}
				function willCoercionThrow(value) {
					{
						try {
							testStringCoercion(value)
							return false
						} catch (e2) {
							return true
						}
					}
				}
				function testStringCoercion(value) {
					return '' + value
				}
				function checkKeyStringCoercion(value) {
					{
						if (willCoercionThrow(value)) {
							error(
								'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
								typeName(value)
							)
							return testStringCoercion(value)
						}
					}
				}
				function getWrappedName(outerType, innerType, wrapperName) {
					var displayName = outerType.displayName
					if (displayName) {
						return displayName
					}
					var functionName = innerType.displayName || innerType.name || ''
					return functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName
				}
				function getContextName(type) {
					return type.displayName || 'Context'
				}
				function getComponentNameFromType(type) {
					if (type == null) {
						return null
					}
					{
						if (typeof type.tag === 'number') {
							error(
								'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
							)
						}
					}
					if (typeof type === 'function') {
						return type.displayName || type.name || null
					}
					if (typeof type === 'string') {
						return type
					}
					switch (type) {
						case REACT_FRAGMENT_TYPE:
							return 'Fragment'
						case REACT_PORTAL_TYPE:
							return 'Portal'
						case REACT_PROFILER_TYPE:
							return 'Profiler'
						case REACT_STRICT_MODE_TYPE:
							return 'StrictMode'
						case REACT_SUSPENSE_TYPE:
							return 'Suspense'
						case REACT_SUSPENSE_LIST_TYPE:
							return 'SuspenseList'
					}
					if (typeof type === 'object') {
						switch (type.$$typeof) {
							case REACT_CONTEXT_TYPE:
								var context = type
								return getContextName(context) + '.Consumer'
							case REACT_PROVIDER_TYPE:
								var provider = type
								return getContextName(provider._context) + '.Provider'
							case REACT_FORWARD_REF_TYPE:
								return getWrappedName(type, type.render, 'ForwardRef')
							case REACT_MEMO_TYPE:
								var outerName = type.displayName || null
								if (outerName !== null) {
									return outerName
								}
								return getComponentNameFromType(type.type) || 'Memo'
							case REACT_LAZY_TYPE: {
								var lazyComponent = type
								var payload = lazyComponent._payload
								var init = lazyComponent._init
								try {
									return getComponentNameFromType(init(payload))
								} catch (x3) {
									return null
								}
							}
						}
					}
					return null
				}
				var hasOwnProperty2 = Object.prototype.hasOwnProperty
				var RESERVED_PROPS = {
					key: true,
					ref: true,
					__self: true,
					__source: true,
				}
				var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs
				{
					didWarnAboutStringRefs = {}
				}
				function hasValidRef(config) {
					{
						if (hasOwnProperty2.call(config, 'ref')) {
							var getter = Object.getOwnPropertyDescriptor(config, 'ref').get
							if (getter && getter.isReactWarning) {
								return false
							}
						}
					}
					return config.ref !== void 0
				}
				function hasValidKey(config) {
					{
						if (hasOwnProperty2.call(config, 'key')) {
							var getter = Object.getOwnPropertyDescriptor(config, 'key').get
							if (getter && getter.isReactWarning) {
								return false
							}
						}
					}
					return config.key !== void 0
				}
				function defineKeyPropWarningGetter(props, displayName) {
					var warnAboutAccessingKey = function () {
						{
							if (!specialPropKeyWarningShown) {
								specialPropKeyWarningShown = true
								error(
									'%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
									displayName
								)
							}
						}
					}
					warnAboutAccessingKey.isReactWarning = true
					Object.defineProperty(props, 'key', {
						get: warnAboutAccessingKey,
						configurable: true,
					})
				}
				function defineRefPropWarningGetter(props, displayName) {
					var warnAboutAccessingRef = function () {
						{
							if (!specialPropRefWarningShown) {
								specialPropRefWarningShown = true
								error(
									'%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
									displayName
								)
							}
						}
					}
					warnAboutAccessingRef.isReactWarning = true
					Object.defineProperty(props, 'ref', {
						get: warnAboutAccessingRef,
						configurable: true,
					})
				}
				function warnIfStringRefCannotBeAutoConverted(config) {
					{
						if (
							typeof config.ref === 'string' &&
							ReactCurrentOwner.current &&
							config.__self &&
							ReactCurrentOwner.current.stateNode !== config.__self
						) {
							var componentName = getComponentNameFromType(ReactCurrentOwner.current.type)
							if (!didWarnAboutStringRefs[componentName]) {
								error(
									'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
									componentName,
									config.ref
								)
								didWarnAboutStringRefs[componentName] = true
							}
						}
					}
				}
				var ReactElement = function (type, key, ref, self2, source, owner, props) {
					var element = {
						// This tag allows us to uniquely identify this as a React Element
						$$typeof: REACT_ELEMENT_TYPE,
						// Built-in properties that belong on the element
						type,
						key,
						ref,
						props,
						// Record the component responsible for creating this element.
						_owner: owner,
					}
					{
						element._store = {}
						Object.defineProperty(element._store, 'validated', {
							configurable: false,
							enumerable: false,
							writable: true,
							value: false,
						})
						Object.defineProperty(element, '_self', {
							configurable: false,
							enumerable: false,
							writable: false,
							value: self2,
						})
						Object.defineProperty(element, '_source', {
							configurable: false,
							enumerable: false,
							writable: false,
							value: source,
						})
						if (Object.freeze) {
							Object.freeze(element.props)
							Object.freeze(element)
						}
					}
					return element
				}
				function createElement6(type, config, children) {
					var propName
					var props = {}
					var key = null
					var ref = null
					var self2 = null
					var source = null
					if (config != null) {
						if (hasValidRef(config)) {
							ref = config.ref
							{
								warnIfStringRefCannotBeAutoConverted(config)
							}
						}
						if (hasValidKey(config)) {
							{
								checkKeyStringCoercion(config.key)
							}
							key = '' + config.key
						}
						self2 = config.__self === void 0 ? null : config.__self
						source = config.__source === void 0 ? null : config.__source
						for (propName in config) {
							if (
								hasOwnProperty2.call(config, propName) &&
								!RESERVED_PROPS.hasOwnProperty(propName)
							) {
								props[propName] = config[propName]
							}
						}
					}
					var childrenLength = arguments.length - 2
					if (childrenLength === 1) {
						props.children = children
					} else if (childrenLength > 1) {
						var childArray = Array(childrenLength)
						for (var i3 = 0; i3 < childrenLength; i3++) {
							childArray[i3] = arguments[i3 + 2]
						}
						{
							if (Object.freeze) {
								Object.freeze(childArray)
							}
						}
						props.children = childArray
					}
					if (type && type.defaultProps) {
						var defaultProps = type.defaultProps
						for (propName in defaultProps) {
							if (props[propName] === void 0) {
								props[propName] = defaultProps[propName]
							}
						}
					}
					{
						if (key || ref) {
							var displayName =
								typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type
							if (key) {
								defineKeyPropWarningGetter(props, displayName)
							}
							if (ref) {
								defineRefPropWarningGetter(props, displayName)
							}
						}
					}
					return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props)
				}
				function cloneAndReplaceKey(oldElement, newKey) {
					var newElement = ReactElement(
						oldElement.type,
						newKey,
						oldElement.ref,
						oldElement._self,
						oldElement._source,
						oldElement._owner,
						oldElement.props
					)
					return newElement
				}
				function cloneElement2(element, config, children) {
					if (element === null || element === void 0) {
						throw new Error(
							'React.cloneElement(...): The argument must be a React element, but you passed ' +
								element +
								'.'
						)
					}
					var propName
					var props = assign({}, element.props)
					var key = element.key
					var ref = element.ref
					var self2 = element._self
					var source = element._source
					var owner = element._owner
					if (config != null) {
						if (hasValidRef(config)) {
							ref = config.ref
							owner = ReactCurrentOwner.current
						}
						if (hasValidKey(config)) {
							{
								checkKeyStringCoercion(config.key)
							}
							key = '' + config.key
						}
						var defaultProps
						if (element.type && element.type.defaultProps) {
							defaultProps = element.type.defaultProps
						}
						for (propName in config) {
							if (
								hasOwnProperty2.call(config, propName) &&
								!RESERVED_PROPS.hasOwnProperty(propName)
							) {
								if (config[propName] === void 0 && defaultProps !== void 0) {
									props[propName] = defaultProps[propName]
								} else {
									props[propName] = config[propName]
								}
							}
						}
					}
					var childrenLength = arguments.length - 2
					if (childrenLength === 1) {
						props.children = children
					} else if (childrenLength > 1) {
						var childArray = Array(childrenLength)
						for (var i3 = 0; i3 < childrenLength; i3++) {
							childArray[i3] = arguments[i3 + 2]
						}
						props.children = childArray
					}
					return ReactElement(element.type, key, ref, self2, source, owner, props)
				}
				function isValidElement(object2) {
					return (
						typeof object2 === 'object' &&
						object2 !== null &&
						object2.$$typeof === REACT_ELEMENT_TYPE
					)
				}
				var SEPARATOR = '.'
				var SUBSEPARATOR = ':'
				function escape(key) {
					var escapeRegex = /[=:]/g
					var escaperLookup = {
						'=': '=0',
						':': '=2',
					}
					var escapedString = key.replace(escapeRegex, function (match) {
						return escaperLookup[match]
					})
					return '$' + escapedString
				}
				var didWarnAboutMaps = false
				var userProvidedKeyEscapeRegex = /\/+/g
				function escapeUserProvidedKey(text) {
					return text.replace(userProvidedKeyEscapeRegex, '$&/')
				}
				function getElementKey(element, index2) {
					if (typeof element === 'object' && element !== null && element.key != null) {
						{
							checkKeyStringCoercion(element.key)
						}
						return escape('' + element.key)
					}
					return index2.toString(36)
				}
				function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
					var type = typeof children
					if (type === 'undefined' || type === 'boolean') {
						children = null
					}
					var invokeCallback = false
					if (children === null) {
						invokeCallback = true
					} else {
						switch (type) {
							case 'string':
							case 'number':
								invokeCallback = true
								break
							case 'object':
								switch (children.$$typeof) {
									case REACT_ELEMENT_TYPE:
									case REACT_PORTAL_TYPE:
										invokeCallback = true
								}
						}
					}
					if (invokeCallback) {
						var _child = children
						var mappedChild = callback(_child)
						var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar
						if (isArray(mappedChild)) {
							var escapedChildKey = ''
							if (childKey != null) {
								escapedChildKey = escapeUserProvidedKey(childKey) + '/'
							}
							mapIntoArray(mappedChild, array2, escapedChildKey, '', function (c3) {
								return c3
							})
						} else if (mappedChild != null) {
							if (isValidElement(mappedChild)) {
								{
									if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
										checkKeyStringCoercion(mappedChild.key)
									}
								}
								mappedChild = cloneAndReplaceKey(
									mappedChild,
									// Keep both the (mapped) and old keys if they differ, just as
									// traverseAllChildren used to do for objects as children
									escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
										(mappedChild.key && (!_child || _child.key !== mappedChild.key)
											? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
											  // eslint-disable-next-line react-internal/safe-string-coercion
											  escapeUserProvidedKey('' + mappedChild.key) + '/'
											: '') +
										childKey
								)
							}
							array2.push(mappedChild)
						}
						return 1
					}
					var child
					var nextName
					var subtreeCount = 0
					var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR
					if (isArray(children)) {
						for (var i3 = 0; i3 < children.length; i3++) {
							child = children[i3]
							nextName = nextNamePrefix + getElementKey(child, i3)
							subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback)
						}
					} else {
						var iteratorFn = getIteratorFn(children)
						if (typeof iteratorFn === 'function') {
							var iterableChildren = children
							{
								if (iteratorFn === iterableChildren.entries) {
									if (!didWarnAboutMaps) {
										warn(
											'Using Maps as children is not supported. Use an array of keyed ReactElements instead.'
										)
									}
									didWarnAboutMaps = true
								}
							}
							var iterator = iteratorFn.call(iterableChildren)
							var step
							var ii = 0
							while (!(step = iterator.next()).done) {
								child = step.value
								nextName = nextNamePrefix + getElementKey(child, ii++)
								subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback)
							}
						} else if (type === 'object') {
							var childrenString = String(children)
							throw new Error(
								'Objects are not valid as a React child (found: ' +
									(childrenString === '[object Object]'
										? 'object with keys {' + Object.keys(children).join(', ') + '}'
										: childrenString) +
									'). If you meant to render a collection of children, use an array instead.'
							)
						}
					}
					return subtreeCount
				}
				function mapChildren(children, func, context) {
					if (children == null) {
						return children
					}
					var result = []
					var count = 0
					mapIntoArray(children, result, '', '', function (child) {
						return func.call(context, child, count++)
					})
					return result
				}
				function countChildren(children) {
					var n3 = 0
					mapChildren(children, function () {
						n3++
					})
					return n3
				}
				function forEachChildren(children, forEachFunc, forEachContext) {
					mapChildren(
						children,
						function () {
							forEachFunc.apply(this, arguments)
						},
						forEachContext
					)
				}
				function toArray(children) {
					return (
						mapChildren(children, function (child) {
							return child
						}) || []
					)
				}
				function onlyChild(children) {
					if (!isValidElement(children)) {
						throw new Error('React.Children.only expected to receive a single React element child.')
					}
					return children
				}
				function createContext10(defaultValue) {
					var context = {
						$$typeof: REACT_CONTEXT_TYPE,
						// As a workaround to support multiple concurrent renderers, we categorize
						// some renderers as primary and others as secondary. We only expect
						// there to be two concurrent renderers at most: React Native (primary) and
						// Fabric (secondary); React DOM (primary) and React ART (secondary).
						// Secondary renderers store their context values on separate fields.
						_currentValue: defaultValue,
						_currentValue2: defaultValue,
						// Used to track how many concurrent renderers this context currently
						// supports within in a single renderer. Such as parallel server rendering.
						_threadCount: 0,
						// These are circular
						Provider: null,
						Consumer: null,
						// Add these to use same hidden class in VM as ServerContext
						_defaultValue: null,
						_globalName: null,
					}
					context.Provider = {
						$$typeof: REACT_PROVIDER_TYPE,
						_context: context,
					}
					var hasWarnedAboutUsingNestedContextConsumers = false
					var hasWarnedAboutUsingConsumerProvider = false
					var hasWarnedAboutDisplayNameOnConsumer = false
					{
						var Consumer = {
							$$typeof: REACT_CONTEXT_TYPE,
							_context: context,
						}
						Object.defineProperties(Consumer, {
							Provider: {
								get: function () {
									if (!hasWarnedAboutUsingConsumerProvider) {
										hasWarnedAboutUsingConsumerProvider = true
										error(
											'Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?'
										)
									}
									return context.Provider
								},
								set: function (_Provider) {
									context.Provider = _Provider
								},
							},
							_currentValue: {
								get: function () {
									return context._currentValue
								},
								set: function (_currentValue) {
									context._currentValue = _currentValue
								},
							},
							_currentValue2: {
								get: function () {
									return context._currentValue2
								},
								set: function (_currentValue2) {
									context._currentValue2 = _currentValue2
								},
							},
							_threadCount: {
								get: function () {
									return context._threadCount
								},
								set: function (_threadCount) {
									context._threadCount = _threadCount
								},
							},
							Consumer: {
								get: function () {
									if (!hasWarnedAboutUsingNestedContextConsumers) {
										hasWarnedAboutUsingNestedContextConsumers = true
										error(
											'Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?'
										)
									}
									return context.Consumer
								},
							},
							displayName: {
								get: function () {
									return context.displayName
								},
								set: function (displayName) {
									if (!hasWarnedAboutDisplayNameOnConsumer) {
										warn(
											"Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.",
											displayName
										)
										hasWarnedAboutDisplayNameOnConsumer = true
									}
								},
							},
						})
						context.Consumer = Consumer
					}
					{
						context._currentRenderer = null
						context._currentRenderer2 = null
					}
					return context
				}
				var Uninitialized = -1
				var Pending = 0
				var Resolved = 1
				var Rejected = 2
				function lazyInitializer(payload) {
					if (payload._status === Uninitialized) {
						var ctor = payload._result
						var thenable = ctor()
						thenable.then(
							function (moduleObject2) {
								if (payload._status === Pending || payload._status === Uninitialized) {
									var resolved = payload
									resolved._status = Resolved
									resolved._result = moduleObject2
								}
							},
							function (error2) {
								if (payload._status === Pending || payload._status === Uninitialized) {
									var rejected = payload
									rejected._status = Rejected
									rejected._result = error2
								}
							}
						)
						if (payload._status === Uninitialized) {
							var pending = payload
							pending._status = Pending
							pending._result = thenable
						}
					}
					if (payload._status === Resolved) {
						var moduleObject = payload._result
						{
							if (moduleObject === void 0) {
								error(
									"lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
									moduleObject
								)
							}
						}
						{
							if (!('default' in moduleObject)) {
								error(
									"lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
									moduleObject
								)
							}
						}
						return moduleObject.default
					} else {
						throw payload._result
					}
				}
				function lazy(ctor) {
					var payload = {
						// We use these fields to store the result.
						_status: Uninitialized,
						_result: ctor,
					}
					var lazyType = {
						$$typeof: REACT_LAZY_TYPE,
						_payload: payload,
						_init: lazyInitializer,
					}
					{
						var defaultProps
						var propTypes
						Object.defineProperties(lazyType, {
							defaultProps: {
								configurable: true,
								get: function () {
									return defaultProps
								},
								set: function (newDefaultProps) {
									error(
										'React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.'
									)
									defaultProps = newDefaultProps
									Object.defineProperty(lazyType, 'defaultProps', {
										enumerable: true,
									})
								},
							},
							propTypes: {
								configurable: true,
								get: function () {
									return propTypes
								},
								set: function (newPropTypes) {
									error(
										'React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.'
									)
									propTypes = newPropTypes
									Object.defineProperty(lazyType, 'propTypes', {
										enumerable: true,
									})
								},
							},
						})
					}
					return lazyType
				}
				function forwardRef7(render) {
					{
						if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
							error(
								'forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).'
							)
						} else if (typeof render !== 'function') {
							error(
								'forwardRef requires a render function but was given %s.',
								render === null ? 'null' : typeof render
							)
						} else {
							if (render.length !== 0 && render.length !== 2) {
								error(
									'forwardRef render functions accept exactly two parameters: props and ref. %s',
									render.length === 1
										? 'Did you forget to use the ref parameter?'
										: 'Any additional parameter will be undefined.'
								)
							}
						}
						if (render != null) {
							if (render.defaultProps != null || render.propTypes != null) {
								error(
									'forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?'
								)
							}
						}
					}
					var elementType = {
						$$typeof: REACT_FORWARD_REF_TYPE,
						render,
					}
					{
						var ownName
						Object.defineProperty(elementType, 'displayName', {
							enumerable: false,
							configurable: true,
							get: function () {
								return ownName
							},
							set: function (name) {
								ownName = name
								if (!render.name && !render.displayName) {
									render.displayName = name
								}
							},
						})
					}
					return elementType
				}
				var REACT_MODULE_REFERENCE
				{
					REACT_MODULE_REFERENCE = Symbol.for('react.module.reference')
				}
				function isValidElementType(type) {
					if (typeof type === 'string' || typeof type === 'function') {
						return true
					}
					if (
						type === REACT_FRAGMENT_TYPE ||
						type === REACT_PROFILER_TYPE ||
						enableDebugTracing ||
						type === REACT_STRICT_MODE_TYPE ||
						type === REACT_SUSPENSE_TYPE ||
						type === REACT_SUSPENSE_LIST_TYPE ||
						enableLegacyHidden ||
						type === REACT_OFFSCREEN_TYPE ||
						enableScopeAPI ||
						enableCacheElement ||
						enableTransitionTracing
					) {
						return true
					}
					if (typeof type === 'object' && type !== null) {
						if (
							type.$$typeof === REACT_LAZY_TYPE ||
							type.$$typeof === REACT_MEMO_TYPE ||
							type.$$typeof === REACT_PROVIDER_TYPE ||
							type.$$typeof === REACT_CONTEXT_TYPE ||
							type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
							// types supported by any Flight configuration anywhere since
							// we don't know which Flight build this will end up being used
							// with.
							type.$$typeof === REACT_MODULE_REFERENCE ||
							type.getModuleId !== void 0
						) {
							return true
						}
					}
					return false
				}
				function memo27(type, compare) {
					{
						if (!isValidElementType(type)) {
							error(
								'memo: The first argument must be a component. Instead received: %s',
								type === null ? 'null' : typeof type
							)
						}
					}
					var elementType = {
						$$typeof: REACT_MEMO_TYPE,
						type,
						compare: compare === void 0 ? null : compare,
					}
					{
						var ownName
						Object.defineProperty(elementType, 'displayName', {
							enumerable: false,
							configurable: true,
							get: function () {
								return ownName
							},
							set: function (name) {
								ownName = name
								if (!type.name && !type.displayName) {
									type.displayName = name
								}
							},
						})
					}
					return elementType
				}
				function resolveDispatcher() {
					var dispatcher = ReactCurrentDispatcher.current
					{
						if (dispatcher === null) {
							error(
								'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.'
							)
						}
					}
					return dispatcher
				}
				function useContext11(Context) {
					var dispatcher = resolveDispatcher()
					{
						if (Context._context !== void 0) {
							var realContext = Context._context
							if (realContext.Consumer === Context) {
								error(
									'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?'
								)
							} else if (realContext.Provider === Context) {
								error(
									'Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?'
								)
							}
						}
					}
					return dispatcher.useContext(Context)
				}
				function useState27(initialState2) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useState(initialState2)
				}
				function useReducer(reducer, initialArg, init) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useReducer(reducer, initialArg, init)
				}
				function useRef29(initialValue) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useRef(initialValue)
				}
				function useEffect34(create, deps) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useEffect(create, deps)
				}
				function useInsertionEffect(create, deps) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useInsertionEffect(create, deps)
				}
				function useLayoutEffect10(create, deps) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useLayoutEffect(create, deps)
				}
				function useCallback30(callback, deps) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useCallback(callback, deps)
				}
				function useMemo32(create, deps) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useMemo(create, deps)
				}
				function useImperativeHandle2(ref, create, deps) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useImperativeHandle(ref, create, deps)
				}
				function useDebugValue2(value, formatterFn) {
					{
						var dispatcher = resolveDispatcher()
						return dispatcher.useDebugValue(value, formatterFn)
					}
				}
				function useTransition() {
					var dispatcher = resolveDispatcher()
					return dispatcher.useTransition()
				}
				function useDeferredValue(value) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useDeferredValue(value)
				}
				function useId() {
					var dispatcher = resolveDispatcher()
					return dispatcher.useId()
				}
				function useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot) {
					var dispatcher = resolveDispatcher()
					return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)
				}
				var disabledDepth = 0
				var prevLog
				var prevInfo
				var prevWarn
				var prevError
				var prevGroup
				var prevGroupCollapsed
				var prevGroupEnd
				function disabledLog() {}
				disabledLog.__reactDisabledLog = true
				function disableLogs() {
					{
						if (disabledDepth === 0) {
							prevLog = console.log
							prevInfo = console.info
							prevWarn = console.warn
							prevError = console.error
							prevGroup = console.group
							prevGroupCollapsed = console.groupCollapsed
							prevGroupEnd = console.groupEnd
							var props = {
								configurable: true,
								enumerable: true,
								value: disabledLog,
								writable: true,
							}
							Object.defineProperties(console, {
								info: props,
								log: props,
								warn: props,
								error: props,
								group: props,
								groupCollapsed: props,
								groupEnd: props,
							})
						}
						disabledDepth++
					}
				}
				function reenableLogs() {
					{
						disabledDepth--
						if (disabledDepth === 0) {
							var props = {
								configurable: true,
								enumerable: true,
								writable: true,
							}
							Object.defineProperties(console, {
								log: assign({}, props, {
									value: prevLog,
								}),
								info: assign({}, props, {
									value: prevInfo,
								}),
								warn: assign({}, props, {
									value: prevWarn,
								}),
								error: assign({}, props, {
									value: prevError,
								}),
								group: assign({}, props, {
									value: prevGroup,
								}),
								groupCollapsed: assign({}, props, {
									value: prevGroupCollapsed,
								}),
								groupEnd: assign({}, props, {
									value: prevGroupEnd,
								}),
							})
						}
						if (disabledDepth < 0) {
							error('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
						}
					}
				}
				var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher
				var prefix
				function describeBuiltInComponentFrame(name, source, ownerFn) {
					{
						if (prefix === void 0) {
							try {
								throw Error()
							} catch (x3) {
								var match = x3.stack.trim().match(/\n( *(at )?)/)
								prefix = (match && match[1]) || ''
							}
						}
						return '\n' + prefix + name
					}
				}
				var reentry = false
				var componentFrameCache
				{
					var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map
					componentFrameCache = new PossiblyWeakMap()
				}
				function describeNativeComponentFrame(fn, construct) {
					if (!fn || reentry) {
						return ''
					}
					{
						var frame2 = componentFrameCache.get(fn)
						if (frame2 !== void 0) {
							return frame2
						}
					}
					var control
					reentry = true
					var previousPrepareStackTrace = Error.prepareStackTrace
					Error.prepareStackTrace = void 0
					var previousDispatcher
					{
						previousDispatcher = ReactCurrentDispatcher$1.current
						ReactCurrentDispatcher$1.current = null
						disableLogs()
					}
					try {
						if (construct) {
							var Fake = function () {
								throw Error()
							}
							Object.defineProperty(Fake.prototype, 'props', {
								set: function () {
									throw Error()
								},
							})
							if (typeof Reflect === 'object' && Reflect.construct) {
								try {
									Reflect.construct(Fake, [])
								} catch (x3) {
									control = x3
								}
								Reflect.construct(fn, [], Fake)
							} else {
								try {
									Fake.call()
								} catch (x3) {
									control = x3
								}
								fn.call(Fake.prototype)
							}
						} else {
							try {
								throw Error()
							} catch (x3) {
								control = x3
							}
							fn()
						}
					} catch (sample) {
						if (sample && control && typeof sample.stack === 'string') {
							var sampleLines = sample.stack.split('\n')
							var controlLines = control.stack.split('\n')
							var s3 = sampleLines.length - 1
							var c3 = controlLines.length - 1
							while (s3 >= 1 && c3 >= 0 && sampleLines[s3] !== controlLines[c3]) {
								c3--
							}
							for (; s3 >= 1 && c3 >= 0; s3--, c3--) {
								if (sampleLines[s3] !== controlLines[c3]) {
									if (s3 !== 1 || c3 !== 1) {
										do {
											s3--
											c3--
											if (c3 < 0 || sampleLines[s3] !== controlLines[c3]) {
												var _frame = '\n' + sampleLines[s3].replace(' at new ', ' at ')
												if (fn.displayName && _frame.includes('<anonymous>')) {
													_frame = _frame.replace('<anonymous>', fn.displayName)
												}
												{
													if (typeof fn === 'function') {
														componentFrameCache.set(fn, _frame)
													}
												}
												return _frame
											}
										} while (s3 >= 1 && c3 >= 0)
									}
									break
								}
							}
						}
					} finally {
						reentry = false
						{
							ReactCurrentDispatcher$1.current = previousDispatcher
							reenableLogs()
						}
						Error.prepareStackTrace = previousPrepareStackTrace
					}
					var name = fn ? fn.displayName || fn.name : ''
					var syntheticFrame = name ? describeBuiltInComponentFrame(name) : ''
					{
						if (typeof fn === 'function') {
							componentFrameCache.set(fn, syntheticFrame)
						}
					}
					return syntheticFrame
				}
				function describeFunctionComponentFrame(fn, source, ownerFn) {
					{
						return describeNativeComponentFrame(fn, false)
					}
				}
				function shouldConstruct(Component4) {
					var prototype = Component4.prototype
					return !!(prototype && prototype.isReactComponent)
				}
				function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
					if (type == null) {
						return ''
					}
					if (typeof type === 'function') {
						{
							return describeNativeComponentFrame(type, shouldConstruct(type))
						}
					}
					if (typeof type === 'string') {
						return describeBuiltInComponentFrame(type)
					}
					switch (type) {
						case REACT_SUSPENSE_TYPE:
							return describeBuiltInComponentFrame('Suspense')
						case REACT_SUSPENSE_LIST_TYPE:
							return describeBuiltInComponentFrame('SuspenseList')
					}
					if (typeof type === 'object') {
						switch (type.$$typeof) {
							case REACT_FORWARD_REF_TYPE:
								return describeFunctionComponentFrame(type.render)
							case REACT_MEMO_TYPE:
								return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn)
							case REACT_LAZY_TYPE: {
								var lazyComponent = type
								var payload = lazyComponent._payload
								var init = lazyComponent._init
								try {
									return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn)
								} catch (x3) {}
							}
						}
					}
					return ''
				}
				var loggedTypeFailures = {}
				var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame
				function setCurrentlyValidatingElement(element) {
					{
						if (element) {
							var owner = element._owner
							var stack3 = describeUnknownElementTypeFrameInDEV(
								element.type,
								element._source,
								owner ? owner.type : null
							)
							ReactDebugCurrentFrame$1.setExtraStackFrame(stack3)
						} else {
							ReactDebugCurrentFrame$1.setExtraStackFrame(null)
						}
					}
				}
				function checkPropTypes(typeSpecs, values, location, componentName, element) {
					{
						var has = Function.call.bind(hasOwnProperty2)
						for (var typeSpecName in typeSpecs) {
							if (has(typeSpecs, typeSpecName)) {
								var error$1 = void 0
								try {
									if (typeof typeSpecs[typeSpecName] !== 'function') {
										var err = Error(
											(componentName || 'React class') +
												': ' +
												location +
												' type `' +
												typeSpecName +
												'` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
												typeof typeSpecs[typeSpecName] +
												'`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
										)
										err.name = 'Invariant Violation'
										throw err
									}
									error$1 = typeSpecs[typeSpecName](
										values,
										typeSpecName,
										componentName,
										location,
										null,
										'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'
									)
								} catch (ex) {
									error$1 = ex
								}
								if (error$1 && !(error$1 instanceof Error)) {
									setCurrentlyValidatingElement(element)
									error(
										'%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
										componentName || 'React class',
										location,
										typeSpecName,
										typeof error$1
									)
									setCurrentlyValidatingElement(null)
								}
								if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
									loggedTypeFailures[error$1.message] = true
									setCurrentlyValidatingElement(element)
									error('Failed %s type: %s', location, error$1.message)
									setCurrentlyValidatingElement(null)
								}
							}
						}
					}
				}
				function setCurrentlyValidatingElement$1(element) {
					{
						if (element) {
							var owner = element._owner
							var stack3 = describeUnknownElementTypeFrameInDEV(
								element.type,
								element._source,
								owner ? owner.type : null
							)
							setExtraStackFrame(stack3)
						} else {
							setExtraStackFrame(null)
						}
					}
				}
				var propTypesMisspellWarningShown
				{
					propTypesMisspellWarningShown = false
				}
				function getDeclarationErrorAddendum() {
					if (ReactCurrentOwner.current) {
						var name = getComponentNameFromType(ReactCurrentOwner.current.type)
						if (name) {
							return '\n\nCheck the render method of `' + name + '`.'
						}
					}
					return ''
				}
				function getSourceInfoErrorAddendum(source) {
					if (source !== void 0) {
						var fileName = source.fileName.replace(/^.*[\\\/]/, '')
						var lineNumber = source.lineNumber
						return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.'
					}
					return ''
				}
				function getSourceInfoErrorAddendumForProps(elementProps) {
					if (elementProps !== null && elementProps !== void 0) {
						return getSourceInfoErrorAddendum(elementProps.__source)
					}
					return ''
				}
				var ownerHasKeyUseWarning = {}
				function getCurrentComponentErrorInfo(parentType) {
					var info = getDeclarationErrorAddendum()
					if (!info) {
						var parentName =
							typeof parentType === 'string'
								? parentType
								: parentType.displayName || parentType.name
						if (parentName) {
							info = '\n\nCheck the top-level render call using <' + parentName + '>.'
						}
					}
					return info
				}
				function validateExplicitKey(element, parentType) {
					if (!element._store || element._store.validated || element.key != null) {
						return
					}
					element._store.validated = true
					var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType)
					if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
						return
					}
					ownerHasKeyUseWarning[currentComponentErrorInfo] = true
					var childOwner = ''
					if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
						childOwner =
							' It was passed a child from ' + getComponentNameFromType(element._owner.type) + '.'
					}
					{
						setCurrentlyValidatingElement$1(element)
						error(
							'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
							currentComponentErrorInfo,
							childOwner
						)
						setCurrentlyValidatingElement$1(null)
					}
				}
				function validateChildKeys(node, parentType) {
					if (typeof node !== 'object') {
						return
					}
					if (isArray(node)) {
						for (var i3 = 0; i3 < node.length; i3++) {
							var child = node[i3]
							if (isValidElement(child)) {
								validateExplicitKey(child, parentType)
							}
						}
					} else if (isValidElement(node)) {
						if (node._store) {
							node._store.validated = true
						}
					} else if (node) {
						var iteratorFn = getIteratorFn(node)
						if (typeof iteratorFn === 'function') {
							if (iteratorFn !== node.entries) {
								var iterator = iteratorFn.call(node)
								var step
								while (!(step = iterator.next()).done) {
									if (isValidElement(step.value)) {
										validateExplicitKey(step.value, parentType)
									}
								}
							}
						}
					}
				}
				function validatePropTypes(element) {
					{
						var type = element.type
						if (type === null || type === void 0 || typeof type === 'string') {
							return
						}
						var propTypes
						if (typeof type === 'function') {
							propTypes = type.propTypes
						} else if (
							typeof type === 'object' &&
							(type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
								// Inner props are checked in the reconciler.
								type.$$typeof === REACT_MEMO_TYPE)
						) {
							propTypes = type.propTypes
						} else {
							return
						}
						if (propTypes) {
							var name = getComponentNameFromType(type)
							checkPropTypes(propTypes, element.props, 'prop', name, element)
						} else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
							propTypesMisspellWarningShown = true
							var _name = getComponentNameFromType(type)
							error(
								'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
								_name || 'Unknown'
							)
						}
						if (
							typeof type.getDefaultProps === 'function' &&
							!type.getDefaultProps.isReactClassApproved
						) {
							error(
								'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.'
							)
						}
					}
				}
				function validateFragmentProps(fragment) {
					{
						var keys = Object.keys(fragment.props)
						for (var i3 = 0; i3 < keys.length; i3++) {
							var key = keys[i3]
							if (key !== 'children' && key !== 'key') {
								setCurrentlyValidatingElement$1(fragment)
								error(
									'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
									key
								)
								setCurrentlyValidatingElement$1(null)
								break
							}
						}
						if (fragment.ref !== null) {
							setCurrentlyValidatingElement$1(fragment)
							error('Invalid attribute `ref` supplied to `React.Fragment`.')
							setCurrentlyValidatingElement$1(null)
						}
					}
				}
				function createElementWithValidation(type, props, children) {
					var validType = isValidElementType(type)
					if (!validType) {
						var info = ''
						if (
							type === void 0 ||
							(typeof type === 'object' && type !== null && Object.keys(type).length === 0)
						) {
							info +=
								" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."
						}
						var sourceInfo = getSourceInfoErrorAddendumForProps(props)
						if (sourceInfo) {
							info += sourceInfo
						} else {
							info += getDeclarationErrorAddendum()
						}
						var typeString
						if (type === null) {
							typeString = 'null'
						} else if (isArray(type)) {
							typeString = 'array'
						} else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
							typeString = '<' + (getComponentNameFromType(type.type) || 'Unknown') + ' />'
							info = ' Did you accidentally export a JSX literal instead of a component?'
						} else {
							typeString = typeof type
						}
						{
							error(
								'React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
								typeString,
								info
							)
						}
					}
					var element = createElement6.apply(this, arguments)
					if (element == null) {
						return element
					}
					if (validType) {
						for (var i3 = 2; i3 < arguments.length; i3++) {
							validateChildKeys(arguments[i3], type)
						}
					}
					if (type === REACT_FRAGMENT_TYPE) {
						validateFragmentProps(element)
					} else {
						validatePropTypes(element)
					}
					return element
				}
				var didWarnAboutDeprecatedCreateFactory = false
				function createFactoryWithValidation(type) {
					var validatedFactory = createElementWithValidation.bind(null, type)
					validatedFactory.type = type
					{
						if (!didWarnAboutDeprecatedCreateFactory) {
							didWarnAboutDeprecatedCreateFactory = true
							warn(
								'React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.'
							)
						}
						Object.defineProperty(validatedFactory, 'type', {
							enumerable: false,
							get: function () {
								warn(
									'Factory.type is deprecated. Access the class directly before passing it to createFactory.'
								)
								Object.defineProperty(this, 'type', {
									value: type,
								})
								return type
							},
						})
					}
					return validatedFactory
				}
				function cloneElementWithValidation(element, props, children) {
					var newElement = cloneElement2.apply(this, arguments)
					for (var i3 = 2; i3 < arguments.length; i3++) {
						validateChildKeys(arguments[i3], newElement.type)
					}
					validatePropTypes(newElement)
					return newElement
				}
				function startTransition(scope, options) {
					var prevTransition = ReactCurrentBatchConfig.transition
					ReactCurrentBatchConfig.transition = {}
					var currentTransition = ReactCurrentBatchConfig.transition
					{
						ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set()
					}
					try {
						scope()
					} finally {
						ReactCurrentBatchConfig.transition = prevTransition
						{
							if (prevTransition === null && currentTransition._updatedFibers) {
								var updatedFibersCount = currentTransition._updatedFibers.size
								if (updatedFibersCount > 10) {
									warn(
										'Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.'
									)
								}
								currentTransition._updatedFibers.clear()
							}
						}
					}
				}
				var didWarnAboutMessageChannel = false
				var enqueueTaskImpl = null
				function enqueueTask(task) {
					if (enqueueTaskImpl === null) {
						try {
							var requireString = ('require' + Math.random()).slice(0, 7)
							var nodeRequire = module2 && module2[requireString]
							enqueueTaskImpl = nodeRequire.call(module2, 'timers').setImmediate
						} catch (_err) {
							enqueueTaskImpl = function (callback) {
								{
									if (didWarnAboutMessageChannel === false) {
										didWarnAboutMessageChannel = true
										if (typeof MessageChannel === 'undefined') {
											error(
												'This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.'
											)
										}
									}
								}
								var channel2 = new MessageChannel()
								channel2.port1.onmessage = callback
								channel2.port2.postMessage(void 0)
							}
						}
					}
					return enqueueTaskImpl(task)
				}
				var actScopeDepth = 0
				var didWarnNoAwaitAct = false
				function act(callback) {
					{
						var prevActScopeDepth = actScopeDepth
						actScopeDepth++
						if (ReactCurrentActQueue.current === null) {
							ReactCurrentActQueue.current = []
						}
						var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy
						var result
						try {
							ReactCurrentActQueue.isBatchingLegacy = true
							result = callback()
							if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
								var queue = ReactCurrentActQueue.current
								if (queue !== null) {
									ReactCurrentActQueue.didScheduleLegacyUpdate = false
									flushActQueue(queue)
								}
							}
						} catch (error2) {
							popActScope(prevActScopeDepth)
							throw error2
						} finally {
							ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy
						}
						if (
							result !== null &&
							typeof result === 'object' &&
							typeof result.then === 'function'
						) {
							var thenableResult = result
							var wasAwaited = false
							var thenable = {
								then: function (resolve, reject) {
									wasAwaited = true
									thenableResult.then(
										function (returnValue2) {
											popActScope(prevActScopeDepth)
											if (actScopeDepth === 0) {
												recursivelyFlushAsyncActWork(returnValue2, resolve, reject)
											} else {
												resolve(returnValue2)
											}
										},
										function (error2) {
											popActScope(prevActScopeDepth)
											reject(error2)
										}
									)
								},
							}
							{
								if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {
									Promise.resolve()
										.then(function () {})
										.then(function () {
											if (!wasAwaited) {
												didWarnNoAwaitAct = true
												error(
													'You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);'
												)
											}
										})
								}
							}
							return thenable
						} else {
							var returnValue = result
							popActScope(prevActScopeDepth)
							if (actScopeDepth === 0) {
								var _queue = ReactCurrentActQueue.current
								if (_queue !== null) {
									flushActQueue(_queue)
									ReactCurrentActQueue.current = null
								}
								var _thenable = {
									then: function (resolve, reject) {
										if (ReactCurrentActQueue.current === null) {
											ReactCurrentActQueue.current = []
											recursivelyFlushAsyncActWork(returnValue, resolve, reject)
										} else {
											resolve(returnValue)
										}
									},
								}
								return _thenable
							} else {
								var _thenable2 = {
									then: function (resolve, reject) {
										resolve(returnValue)
									},
								}
								return _thenable2
							}
						}
					}
				}
				function popActScope(prevActScopeDepth) {
					{
						if (prevActScopeDepth !== actScopeDepth - 1) {
							error(
								'You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. '
							)
						}
						actScopeDepth = prevActScopeDepth
					}
				}
				function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
					{
						var queue = ReactCurrentActQueue.current
						if (queue !== null) {
							try {
								flushActQueue(queue)
								enqueueTask(function () {
									if (queue.length === 0) {
										ReactCurrentActQueue.current = null
										resolve(returnValue)
									} else {
										recursivelyFlushAsyncActWork(returnValue, resolve, reject)
									}
								})
							} catch (error2) {
								reject(error2)
							}
						} else {
							resolve(returnValue)
						}
					}
				}
				var isFlushing = false
				function flushActQueue(queue) {
					{
						if (!isFlushing) {
							isFlushing = true
							var i3 = 0
							try {
								for (; i3 < queue.length; i3++) {
									var callback = queue[i3]
									do {
										callback = callback(true)
									} while (callback !== null)
								}
								queue.length = 0
							} catch (error2) {
								queue = queue.slice(i3 + 1)
								throw error2
							} finally {
								isFlushing = false
							}
						}
					}
				}
				var createElement$1 = createElementWithValidation
				var cloneElement$1 = cloneElementWithValidation
				var createFactory = createFactoryWithValidation
				var Children2 = {
					map: mapChildren,
					forEach: forEachChildren,
					count: countChildren,
					toArray,
					only: onlyChild,
				}
				exports.Children = Children2
				exports.Component = Component3
				exports.Fragment = REACT_FRAGMENT_TYPE
				exports.Profiler = REACT_PROFILER_TYPE
				exports.PureComponent = PureComponent
				exports.StrictMode = REACT_STRICT_MODE_TYPE
				exports.Suspense = REACT_SUSPENSE_TYPE
				exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals
				exports.cloneElement = cloneElement$1
				exports.createContext = createContext10
				exports.createElement = createElement$1
				exports.createFactory = createFactory
				exports.createRef = createRef
				exports.forwardRef = forwardRef7
				exports.isValidElement = isValidElement
				exports.lazy = lazy
				exports.memo = memo27
				exports.startTransition = startTransition
				exports.unstable_act = act
				exports.useCallback = useCallback30
				exports.useContext = useContext11
				exports.useDebugValue = useDebugValue2
				exports.useDeferredValue = useDeferredValue
				exports.useEffect = useEffect34
				exports.useId = useId
				exports.useImperativeHandle = useImperativeHandle2
				exports.useInsertionEffect = useInsertionEffect
				exports.useLayoutEffect = useLayoutEffect10
				exports.useMemo = useMemo32
				exports.useReducer = useReducer
				exports.useRef = useRef29
				exports.useState = useState27
				exports.useSyncExternalStore = useSyncExternalStore3
				exports.useTransition = useTransition
				exports.version = ReactVersion
				if (
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function'
				) {
					__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
				}
			})()
		}
	},
})

// ../node_modules/react/index.js
var require_react = __commonJS({
	'../node_modules/react/index.js'(exports, module2) {
		'use strict'
		init_define_process()
		if (define_process_default.env.NODE_ENV === 'production') {
			module2.exports = require_react_production_min()
		} else {
			module2.exports = require_react_development()
		}
	},
})

// ../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
	'../node_modules/eventemitter3/index.js'(exports, module2) {
		'use strict'
		init_define_process()
		var has = Object.prototype.hasOwnProperty
		var prefix = '~'
		function Events() {}
		if (Object.create) {
			Events.prototype = /* @__PURE__ */ Object.create(null)
			if (!new Events().__proto__) prefix = false
		}
		function EE(fn, context, once) {
			this.fn = fn
			this.context = context
			this.once = once || false
		}
		function addListener(emitter, event, fn, context, once) {
			if (typeof fn !== 'function') {
				throw new TypeError('The listener must be a function')
			}
			var listener = new EE(fn, context || emitter, once),
				evt = prefix ? prefix + event : event
			if (!emitter._events[evt]) (emitter._events[evt] = listener), emitter._eventsCount++
			else if (!emitter._events[evt].fn) emitter._events[evt].push(listener)
			else emitter._events[evt] = [emitter._events[evt], listener]
			return emitter
		}
		function clearEvent(emitter, evt) {
			if (--emitter._eventsCount === 0) emitter._events = new Events()
			else delete emitter._events[evt]
		}
		function EventEmitter2() {
			this._events = new Events()
			this._eventsCount = 0
		}
		EventEmitter2.prototype.eventNames = function eventNames() {
			var names = [],
				events,
				name
			if (this._eventsCount === 0) return names
			for (name in (events = this._events)) {
				if (has.call(events, name)) names.push(prefix ? name.slice(1) : name)
			}
			if (Object.getOwnPropertySymbols) {
				return names.concat(Object.getOwnPropertySymbols(events))
			}
			return names
		}
		EventEmitter2.prototype.listeners = function listeners(event) {
			var evt = prefix ? prefix + event : event,
				handlers = this._events[evt]
			if (!handlers) return []
			if (handlers.fn) return [handlers.fn]
			for (var i3 = 0, l3 = handlers.length, ee = new Array(l3); i3 < l3; i3++) {
				ee[i3] = handlers[i3].fn
			}
			return ee
		}
		EventEmitter2.prototype.listenerCount = function listenerCount(event) {
			var evt = prefix ? prefix + event : event,
				listeners = this._events[evt]
			if (!listeners) return 0
			if (listeners.fn) return 1
			return listeners.length
		}
		EventEmitter2.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
			var evt = prefix ? prefix + event : event
			if (!this._events[evt]) return false
			var listeners = this._events[evt],
				len = arguments.length,
				args,
				i3
			if (listeners.fn) {
				if (listeners.once) this.removeListener(event, listeners.fn, void 0, true)
				switch (len) {
					case 1:
						return listeners.fn.call(listeners.context), true
					case 2:
						return listeners.fn.call(listeners.context, a1), true
					case 3:
						return listeners.fn.call(listeners.context, a1, a22), true
					case 4:
						return listeners.fn.call(listeners.context, a1, a22, a3), true
					case 5:
						return listeners.fn.call(listeners.context, a1, a22, a3, a4), true
					case 6:
						return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true
				}
				for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
					args[i3 - 1] = arguments[i3]
				}
				listeners.fn.apply(listeners.context, args)
			} else {
				var length = listeners.length,
					j
				for (i3 = 0; i3 < length; i3++) {
					if (listeners[i3].once) this.removeListener(event, listeners[i3].fn, void 0, true)
					switch (len) {
						case 1:
							listeners[i3].fn.call(listeners[i3].context)
							break
						case 2:
							listeners[i3].fn.call(listeners[i3].context, a1)
							break
						case 3:
							listeners[i3].fn.call(listeners[i3].context, a1, a22)
							break
						case 4:
							listeners[i3].fn.call(listeners[i3].context, a1, a22, a3)
							break
						default:
							if (!args)
								for (j = 1, args = new Array(len - 1); j < len; j++) {
									args[j - 1] = arguments[j]
								}
							listeners[i3].fn.apply(listeners[i3].context, args)
					}
				}
			}
			return true
		}
		EventEmitter2.prototype.on = function on(event, fn, context) {
			return addListener(this, event, fn, context, false)
		}
		EventEmitter2.prototype.once = function once(event, fn, context) {
			return addListener(this, event, fn, context, true)
		}
		EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
			var evt = prefix ? prefix + event : event
			if (!this._events[evt]) return this
			if (!fn) {
				clearEvent(this, evt)
				return this
			}
			var listeners = this._events[evt]
			if (listeners.fn) {
				if (
					listeners.fn === fn &&
					(!once || listeners.once) &&
					(!context || listeners.context === context)
				) {
					clearEvent(this, evt)
				}
			} else {
				for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
					if (
						listeners[i3].fn !== fn ||
						(once && !listeners[i3].once) ||
						(context && listeners[i3].context !== context)
					) {
						events.push(listeners[i3])
					}
				}
				if (events.length) this._events[evt] = events.length === 1 ? events[0] : events
				else clearEvent(this, evt)
			}
			return this
		}
		EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
			var evt
			if (event) {
				evt = prefix ? prefix + event : event
				if (this._events[evt]) clearEvent(this, evt)
			} else {
				this._events = new Events()
				this._eventsCount = 0
			}
			return this
		}
		EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener
		EventEmitter2.prototype.addListener = EventEmitter2.prototype.on
		EventEmitter2.prefixed = prefix
		EventEmitter2.EventEmitter = EventEmitter2
		if ('undefined' !== typeof module2) {
			module2.exports = EventEmitter2
		}
	},
})

// ../node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
	'../node_modules/react/cjs/react-jsx-runtime.production.min.js'(exports) {
		'use strict'
		init_define_process()
		var f3 = require_react()
		var k2 = Symbol.for('react.element')
		var l3 = Symbol.for('react.fragment')
		var m3 = Object.prototype.hasOwnProperty
		var n3 = f3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
		var p3 = { key: true, ref: true, __self: true, __source: true }
		function q(c3, a3, g3) {
			var b3,
				d3 = {},
				e2 = null,
				h3 = null
			void 0 !== g3 && (e2 = '' + g3)
			void 0 !== a3.key && (e2 = '' + a3.key)
			void 0 !== a3.ref && (h3 = a3.ref)
			for (b3 in a3) m3.call(a3, b3) && !p3.hasOwnProperty(b3) && (d3[b3] = a3[b3])
			if (c3 && c3.defaultProps)
				for (b3 in ((a3 = c3.defaultProps), a3)) void 0 === d3[b3] && (d3[b3] = a3[b3])
			return { $$typeof: k2, type: c3, key: e2, ref: h3, props: d3, _owner: n3.current }
		}
		exports.Fragment = l3
		exports.jsx = q
		exports.jsxs = q
	},
})

// ../node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
	'../node_modules/react/cjs/react-jsx-runtime.development.js'(exports) {
		'use strict'
		init_define_process()
		if (define_process_default.env.NODE_ENV !== 'production') {
			;(function () {
				'use strict'
				var React70 = require_react()
				var REACT_ELEMENT_TYPE = Symbol.for('react.element')
				var REACT_PORTAL_TYPE = Symbol.for('react.portal')
				var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')
				var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')
				var REACT_PROFILER_TYPE = Symbol.for('react.profiler')
				var REACT_PROVIDER_TYPE = Symbol.for('react.provider')
				var REACT_CONTEXT_TYPE = Symbol.for('react.context')
				var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')
				var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')
				var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')
				var REACT_MEMO_TYPE = Symbol.for('react.memo')
				var REACT_LAZY_TYPE = Symbol.for('react.lazy')
				var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen')
				var MAYBE_ITERATOR_SYMBOL = Symbol.iterator
				var FAUX_ITERATOR_SYMBOL = '@@iterator'
				function getIteratorFn(maybeIterable) {
					if (maybeIterable === null || typeof maybeIterable !== 'object') {
						return null
					}
					var maybeIterator =
						(MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
						maybeIterable[FAUX_ITERATOR_SYMBOL]
					if (typeof maybeIterator === 'function') {
						return maybeIterator
					}
					return null
				}
				var ReactSharedInternals = React70.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
				function error(format) {
					{
						{
							for (
								var _len2 = arguments.length,
									args = new Array(_len2 > 1 ? _len2 - 1 : 0),
									_key2 = 1;
								_key2 < _len2;
								_key2++
							) {
								args[_key2 - 1] = arguments[_key2]
							}
							printWarning('error', format, args)
						}
					}
				}
				function printWarning(level, format, args) {
					{
						var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame
						var stack3 = ReactDebugCurrentFrame2.getStackAddendum()
						if (stack3 !== '') {
							format += '%s'
							args = args.concat([stack3])
						}
						var argsWithFormat = args.map(function (item) {
							return String(item)
						})
						argsWithFormat.unshift('Warning: ' + format)
						Function.prototype.apply.call(console[level], console, argsWithFormat)
					}
				}
				var enableScopeAPI = false
				var enableCacheElement = false
				var enableTransitionTracing = false
				var enableLegacyHidden = false
				var enableDebugTracing = false
				var REACT_MODULE_REFERENCE
				{
					REACT_MODULE_REFERENCE = Symbol.for('react.module.reference')
				}
				function isValidElementType(type) {
					if (typeof type === 'string' || typeof type === 'function') {
						return true
					}
					if (
						type === REACT_FRAGMENT_TYPE ||
						type === REACT_PROFILER_TYPE ||
						enableDebugTracing ||
						type === REACT_STRICT_MODE_TYPE ||
						type === REACT_SUSPENSE_TYPE ||
						type === REACT_SUSPENSE_LIST_TYPE ||
						enableLegacyHidden ||
						type === REACT_OFFSCREEN_TYPE ||
						enableScopeAPI ||
						enableCacheElement ||
						enableTransitionTracing
					) {
						return true
					}
					if (typeof type === 'object' && type !== null) {
						if (
							type.$$typeof === REACT_LAZY_TYPE ||
							type.$$typeof === REACT_MEMO_TYPE ||
							type.$$typeof === REACT_PROVIDER_TYPE ||
							type.$$typeof === REACT_CONTEXT_TYPE ||
							type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
							// types supported by any Flight configuration anywhere since
							// we don't know which Flight build this will end up being used
							// with.
							type.$$typeof === REACT_MODULE_REFERENCE ||
							type.getModuleId !== void 0
						) {
							return true
						}
					}
					return false
				}
				function getWrappedName(outerType, innerType, wrapperName) {
					var displayName = outerType.displayName
					if (displayName) {
						return displayName
					}
					var functionName = innerType.displayName || innerType.name || ''
					return functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName
				}
				function getContextName(type) {
					return type.displayName || 'Context'
				}
				function getComponentNameFromType(type) {
					if (type == null) {
						return null
					}
					{
						if (typeof type.tag === 'number') {
							error(
								'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
							)
						}
					}
					if (typeof type === 'function') {
						return type.displayName || type.name || null
					}
					if (typeof type === 'string') {
						return type
					}
					switch (type) {
						case REACT_FRAGMENT_TYPE:
							return 'Fragment'
						case REACT_PORTAL_TYPE:
							return 'Portal'
						case REACT_PROFILER_TYPE:
							return 'Profiler'
						case REACT_STRICT_MODE_TYPE:
							return 'StrictMode'
						case REACT_SUSPENSE_TYPE:
							return 'Suspense'
						case REACT_SUSPENSE_LIST_TYPE:
							return 'SuspenseList'
					}
					if (typeof type === 'object') {
						switch (type.$$typeof) {
							case REACT_CONTEXT_TYPE:
								var context = type
								return getContextName(context) + '.Consumer'
							case REACT_PROVIDER_TYPE:
								var provider = type
								return getContextName(provider._context) + '.Provider'
							case REACT_FORWARD_REF_TYPE:
								return getWrappedName(type, type.render, 'ForwardRef')
							case REACT_MEMO_TYPE:
								var outerName = type.displayName || null
								if (outerName !== null) {
									return outerName
								}
								return getComponentNameFromType(type.type) || 'Memo'
							case REACT_LAZY_TYPE: {
								var lazyComponent = type
								var payload = lazyComponent._payload
								var init = lazyComponent._init
								try {
									return getComponentNameFromType(init(payload))
								} catch (x3) {
									return null
								}
							}
						}
					}
					return null
				}
				var assign = Object.assign
				var disabledDepth = 0
				var prevLog
				var prevInfo
				var prevWarn
				var prevError
				var prevGroup
				var prevGroupCollapsed
				var prevGroupEnd
				function disabledLog() {}
				disabledLog.__reactDisabledLog = true
				function disableLogs() {
					{
						if (disabledDepth === 0) {
							prevLog = console.log
							prevInfo = console.info
							prevWarn = console.warn
							prevError = console.error
							prevGroup = console.group
							prevGroupCollapsed = console.groupCollapsed
							prevGroupEnd = console.groupEnd
							var props = {
								configurable: true,
								enumerable: true,
								value: disabledLog,
								writable: true,
							}
							Object.defineProperties(console, {
								info: props,
								log: props,
								warn: props,
								error: props,
								group: props,
								groupCollapsed: props,
								groupEnd: props,
							})
						}
						disabledDepth++
					}
				}
				function reenableLogs() {
					{
						disabledDepth--
						if (disabledDepth === 0) {
							var props = {
								configurable: true,
								enumerable: true,
								writable: true,
							}
							Object.defineProperties(console, {
								log: assign({}, props, {
									value: prevLog,
								}),
								info: assign({}, props, {
									value: prevInfo,
								}),
								warn: assign({}, props, {
									value: prevWarn,
								}),
								error: assign({}, props, {
									value: prevError,
								}),
								group: assign({}, props, {
									value: prevGroup,
								}),
								groupCollapsed: assign({}, props, {
									value: prevGroupCollapsed,
								}),
								groupEnd: assign({}, props, {
									value: prevGroupEnd,
								}),
							})
						}
						if (disabledDepth < 0) {
							error('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
						}
					}
				}
				var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
				var prefix
				function describeBuiltInComponentFrame(name, source, ownerFn) {
					{
						if (prefix === void 0) {
							try {
								throw Error()
							} catch (x3) {
								var match = x3.stack.trim().match(/\n( *(at )?)/)
								prefix = (match && match[1]) || ''
							}
						}
						return '\n' + prefix + name
					}
				}
				var reentry = false
				var componentFrameCache
				{
					var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map
					componentFrameCache = new PossiblyWeakMap()
				}
				function describeNativeComponentFrame(fn, construct) {
					if (!fn || reentry) {
						return ''
					}
					{
						var frame2 = componentFrameCache.get(fn)
						if (frame2 !== void 0) {
							return frame2
						}
					}
					var control
					reentry = true
					var previousPrepareStackTrace = Error.prepareStackTrace
					Error.prepareStackTrace = void 0
					var previousDispatcher
					{
						previousDispatcher = ReactCurrentDispatcher.current
						ReactCurrentDispatcher.current = null
						disableLogs()
					}
					try {
						if (construct) {
							var Fake = function () {
								throw Error()
							}
							Object.defineProperty(Fake.prototype, 'props', {
								set: function () {
									throw Error()
								},
							})
							if (typeof Reflect === 'object' && Reflect.construct) {
								try {
									Reflect.construct(Fake, [])
								} catch (x3) {
									control = x3
								}
								Reflect.construct(fn, [], Fake)
							} else {
								try {
									Fake.call()
								} catch (x3) {
									control = x3
								}
								fn.call(Fake.prototype)
							}
						} else {
							try {
								throw Error()
							} catch (x3) {
								control = x3
							}
							fn()
						}
					} catch (sample) {
						if (sample && control && typeof sample.stack === 'string') {
							var sampleLines = sample.stack.split('\n')
							var controlLines = control.stack.split('\n')
							var s3 = sampleLines.length - 1
							var c3 = controlLines.length - 1
							while (s3 >= 1 && c3 >= 0 && sampleLines[s3] !== controlLines[c3]) {
								c3--
							}
							for (; s3 >= 1 && c3 >= 0; s3--, c3--) {
								if (sampleLines[s3] !== controlLines[c3]) {
									if (s3 !== 1 || c3 !== 1) {
										do {
											s3--
											c3--
											if (c3 < 0 || sampleLines[s3] !== controlLines[c3]) {
												var _frame = '\n' + sampleLines[s3].replace(' at new ', ' at ')
												if (fn.displayName && _frame.includes('<anonymous>')) {
													_frame = _frame.replace('<anonymous>', fn.displayName)
												}
												{
													if (typeof fn === 'function') {
														componentFrameCache.set(fn, _frame)
													}
												}
												return _frame
											}
										} while (s3 >= 1 && c3 >= 0)
									}
									break
								}
							}
						}
					} finally {
						reentry = false
						{
							ReactCurrentDispatcher.current = previousDispatcher
							reenableLogs()
						}
						Error.prepareStackTrace = previousPrepareStackTrace
					}
					var name = fn ? fn.displayName || fn.name : ''
					var syntheticFrame = name ? describeBuiltInComponentFrame(name) : ''
					{
						if (typeof fn === 'function') {
							componentFrameCache.set(fn, syntheticFrame)
						}
					}
					return syntheticFrame
				}
				function describeFunctionComponentFrame(fn, source, ownerFn) {
					{
						return describeNativeComponentFrame(fn, false)
					}
				}
				function shouldConstruct(Component3) {
					var prototype = Component3.prototype
					return !!(prototype && prototype.isReactComponent)
				}
				function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
					if (type == null) {
						return ''
					}
					if (typeof type === 'function') {
						{
							return describeNativeComponentFrame(type, shouldConstruct(type))
						}
					}
					if (typeof type === 'string') {
						return describeBuiltInComponentFrame(type)
					}
					switch (type) {
						case REACT_SUSPENSE_TYPE:
							return describeBuiltInComponentFrame('Suspense')
						case REACT_SUSPENSE_LIST_TYPE:
							return describeBuiltInComponentFrame('SuspenseList')
					}
					if (typeof type === 'object') {
						switch (type.$$typeof) {
							case REACT_FORWARD_REF_TYPE:
								return describeFunctionComponentFrame(type.render)
							case REACT_MEMO_TYPE:
								return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn)
							case REACT_LAZY_TYPE: {
								var lazyComponent = type
								var payload = lazyComponent._payload
								var init = lazyComponent._init
								try {
									return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn)
								} catch (x3) {}
							}
						}
					}
					return ''
				}
				var hasOwnProperty2 = Object.prototype.hasOwnProperty
				var loggedTypeFailures = {}
				var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame
				function setCurrentlyValidatingElement(element) {
					{
						if (element) {
							var owner = element._owner
							var stack3 = describeUnknownElementTypeFrameInDEV(
								element.type,
								element._source,
								owner ? owner.type : null
							)
							ReactDebugCurrentFrame.setExtraStackFrame(stack3)
						} else {
							ReactDebugCurrentFrame.setExtraStackFrame(null)
						}
					}
				}
				function checkPropTypes(typeSpecs, values, location, componentName, element) {
					{
						var has = Function.call.bind(hasOwnProperty2)
						for (var typeSpecName in typeSpecs) {
							if (has(typeSpecs, typeSpecName)) {
								var error$1 = void 0
								try {
									if (typeof typeSpecs[typeSpecName] !== 'function') {
										var err = Error(
											(componentName || 'React class') +
												': ' +
												location +
												' type `' +
												typeSpecName +
												'` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
												typeof typeSpecs[typeSpecName] +
												'`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
										)
										err.name = 'Invariant Violation'
										throw err
									}
									error$1 = typeSpecs[typeSpecName](
										values,
										typeSpecName,
										componentName,
										location,
										null,
										'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'
									)
								} catch (ex) {
									error$1 = ex
								}
								if (error$1 && !(error$1 instanceof Error)) {
									setCurrentlyValidatingElement(element)
									error(
										'%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
										componentName || 'React class',
										location,
										typeSpecName,
										typeof error$1
									)
									setCurrentlyValidatingElement(null)
								}
								if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
									loggedTypeFailures[error$1.message] = true
									setCurrentlyValidatingElement(element)
									error('Failed %s type: %s', location, error$1.message)
									setCurrentlyValidatingElement(null)
								}
							}
						}
					}
				}
				var isArrayImpl = Array.isArray
				function isArray(a3) {
					return isArrayImpl(a3)
				}
				function typeName(value) {
					{
						var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag
						var type =
							(hasToStringTag && value[Symbol.toStringTag]) || value.constructor.name || 'Object'
						return type
					}
				}
				function willCoercionThrow(value) {
					{
						try {
							testStringCoercion(value)
							return false
						} catch (e2) {
							return true
						}
					}
				}
				function testStringCoercion(value) {
					return '' + value
				}
				function checkKeyStringCoercion(value) {
					{
						if (willCoercionThrow(value)) {
							error(
								'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
								typeName(value)
							)
							return testStringCoercion(value)
						}
					}
				}
				var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner
				var RESERVED_PROPS = {
					key: true,
					ref: true,
					__self: true,
					__source: true,
				}
				var specialPropKeyWarningShown
				var specialPropRefWarningShown
				var didWarnAboutStringRefs
				{
					didWarnAboutStringRefs = {}
				}
				function hasValidRef(config) {
					{
						if (hasOwnProperty2.call(config, 'ref')) {
							var getter = Object.getOwnPropertyDescriptor(config, 'ref').get
							if (getter && getter.isReactWarning) {
								return false
							}
						}
					}
					return config.ref !== void 0
				}
				function hasValidKey(config) {
					{
						if (hasOwnProperty2.call(config, 'key')) {
							var getter = Object.getOwnPropertyDescriptor(config, 'key').get
							if (getter && getter.isReactWarning) {
								return false
							}
						}
					}
					return config.key !== void 0
				}
				function warnIfStringRefCannotBeAutoConverted(config, self2) {
					{
						if (
							typeof config.ref === 'string' &&
							ReactCurrentOwner.current &&
							self2 &&
							ReactCurrentOwner.current.stateNode !== self2
						) {
							var componentName = getComponentNameFromType(ReactCurrentOwner.current.type)
							if (!didWarnAboutStringRefs[componentName]) {
								error(
									'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
									getComponentNameFromType(ReactCurrentOwner.current.type),
									config.ref
								)
								didWarnAboutStringRefs[componentName] = true
							}
						}
					}
				}
				function defineKeyPropWarningGetter(props, displayName) {
					{
						var warnAboutAccessingKey = function () {
							if (!specialPropKeyWarningShown) {
								specialPropKeyWarningShown = true
								error(
									'%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
									displayName
								)
							}
						}
						warnAboutAccessingKey.isReactWarning = true
						Object.defineProperty(props, 'key', {
							get: warnAboutAccessingKey,
							configurable: true,
						})
					}
				}
				function defineRefPropWarningGetter(props, displayName) {
					{
						var warnAboutAccessingRef = function () {
							if (!specialPropRefWarningShown) {
								specialPropRefWarningShown = true
								error(
									'%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
									displayName
								)
							}
						}
						warnAboutAccessingRef.isReactWarning = true
						Object.defineProperty(props, 'ref', {
							get: warnAboutAccessingRef,
							configurable: true,
						})
					}
				}
				var ReactElement = function (type, key, ref, self2, source, owner, props) {
					var element = {
						// This tag allows us to uniquely identify this as a React Element
						$$typeof: REACT_ELEMENT_TYPE,
						// Built-in properties that belong on the element
						type,
						key,
						ref,
						props,
						// Record the component responsible for creating this element.
						_owner: owner,
					}
					{
						element._store = {}
						Object.defineProperty(element._store, 'validated', {
							configurable: false,
							enumerable: false,
							writable: true,
							value: false,
						})
						Object.defineProperty(element, '_self', {
							configurable: false,
							enumerable: false,
							writable: false,
							value: self2,
						})
						Object.defineProperty(element, '_source', {
							configurable: false,
							enumerable: false,
							writable: false,
							value: source,
						})
						if (Object.freeze) {
							Object.freeze(element.props)
							Object.freeze(element)
						}
					}
					return element
				}
				function jsxDEV(type, config, maybeKey, source, self2) {
					{
						var propName
						var props = {}
						var key = null
						var ref = null
						if (maybeKey !== void 0) {
							{
								checkKeyStringCoercion(maybeKey)
							}
							key = '' + maybeKey
						}
						if (hasValidKey(config)) {
							{
								checkKeyStringCoercion(config.key)
							}
							key = '' + config.key
						}
						if (hasValidRef(config)) {
							ref = config.ref
							warnIfStringRefCannotBeAutoConverted(config, self2)
						}
						for (propName in config) {
							if (
								hasOwnProperty2.call(config, propName) &&
								!RESERVED_PROPS.hasOwnProperty(propName)
							) {
								props[propName] = config[propName]
							}
						}
						if (type && type.defaultProps) {
							var defaultProps = type.defaultProps
							for (propName in defaultProps) {
								if (props[propName] === void 0) {
									props[propName] = defaultProps[propName]
								}
							}
						}
						if (key || ref) {
							var displayName =
								typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type
							if (key) {
								defineKeyPropWarningGetter(props, displayName)
							}
							if (ref) {
								defineRefPropWarningGetter(props, displayName)
							}
						}
						return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props)
					}
				}
				var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner
				var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame
				function setCurrentlyValidatingElement$1(element) {
					{
						if (element) {
							var owner = element._owner
							var stack3 = describeUnknownElementTypeFrameInDEV(
								element.type,
								element._source,
								owner ? owner.type : null
							)
							ReactDebugCurrentFrame$1.setExtraStackFrame(stack3)
						} else {
							ReactDebugCurrentFrame$1.setExtraStackFrame(null)
						}
					}
				}
				var propTypesMisspellWarningShown
				{
					propTypesMisspellWarningShown = false
				}
				function isValidElement(object2) {
					{
						return (
							typeof object2 === 'object' &&
							object2 !== null &&
							object2.$$typeof === REACT_ELEMENT_TYPE
						)
					}
				}
				function getDeclarationErrorAddendum() {
					{
						if (ReactCurrentOwner$1.current) {
							var name = getComponentNameFromType(ReactCurrentOwner$1.current.type)
							if (name) {
								return '\n\nCheck the render method of `' + name + '`.'
							}
						}
						return ''
					}
				}
				function getSourceInfoErrorAddendum(source) {
					{
						if (source !== void 0) {
							var fileName = source.fileName.replace(/^.*[\\\/]/, '')
							var lineNumber = source.lineNumber
							return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.'
						}
						return ''
					}
				}
				var ownerHasKeyUseWarning = {}
				function getCurrentComponentErrorInfo(parentType) {
					{
						var info = getDeclarationErrorAddendum()
						if (!info) {
							var parentName =
								typeof parentType === 'string'
									? parentType
									: parentType.displayName || parentType.name
							if (parentName) {
								info = '\n\nCheck the top-level render call using <' + parentName + '>.'
							}
						}
						return info
					}
				}
				function validateExplicitKey(element, parentType) {
					{
						if (!element._store || element._store.validated || element.key != null) {
							return
						}
						element._store.validated = true
						var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType)
						if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
							return
						}
						ownerHasKeyUseWarning[currentComponentErrorInfo] = true
						var childOwner = ''
						if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
							childOwner =
								' It was passed a child from ' + getComponentNameFromType(element._owner.type) + '.'
						}
						setCurrentlyValidatingElement$1(element)
						error(
							'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
							currentComponentErrorInfo,
							childOwner
						)
						setCurrentlyValidatingElement$1(null)
					}
				}
				function validateChildKeys(node, parentType) {
					{
						if (typeof node !== 'object') {
							return
						}
						if (isArray(node)) {
							for (var i3 = 0; i3 < node.length; i3++) {
								var child = node[i3]
								if (isValidElement(child)) {
									validateExplicitKey(child, parentType)
								}
							}
						} else if (isValidElement(node)) {
							if (node._store) {
								node._store.validated = true
							}
						} else if (node) {
							var iteratorFn = getIteratorFn(node)
							if (typeof iteratorFn === 'function') {
								if (iteratorFn !== node.entries) {
									var iterator = iteratorFn.call(node)
									var step
									while (!(step = iterator.next()).done) {
										if (isValidElement(step.value)) {
											validateExplicitKey(step.value, parentType)
										}
									}
								}
							}
						}
					}
				}
				function validatePropTypes(element) {
					{
						var type = element.type
						if (type === null || type === void 0 || typeof type === 'string') {
							return
						}
						var propTypes
						if (typeof type === 'function') {
							propTypes = type.propTypes
						} else if (
							typeof type === 'object' &&
							(type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
								// Inner props are checked in the reconciler.
								type.$$typeof === REACT_MEMO_TYPE)
						) {
							propTypes = type.propTypes
						} else {
							return
						}
						if (propTypes) {
							var name = getComponentNameFromType(type)
							checkPropTypes(propTypes, element.props, 'prop', name, element)
						} else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
							propTypesMisspellWarningShown = true
							var _name = getComponentNameFromType(type)
							error(
								'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
								_name || 'Unknown'
							)
						}
						if (
							typeof type.getDefaultProps === 'function' &&
							!type.getDefaultProps.isReactClassApproved
						) {
							error(
								'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.'
							)
						}
					}
				}
				function validateFragmentProps(fragment) {
					{
						var keys = Object.keys(fragment.props)
						for (var i3 = 0; i3 < keys.length; i3++) {
							var key = keys[i3]
							if (key !== 'children' && key !== 'key') {
								setCurrentlyValidatingElement$1(fragment)
								error(
									'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
									key
								)
								setCurrentlyValidatingElement$1(null)
								break
							}
						}
						if (fragment.ref !== null) {
							setCurrentlyValidatingElement$1(fragment)
							error('Invalid attribute `ref` supplied to `React.Fragment`.')
							setCurrentlyValidatingElement$1(null)
						}
					}
				}
				function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
					{
						var validType = isValidElementType(type)
						if (!validType) {
							var info = ''
							if (
								type === void 0 ||
								(typeof type === 'object' && type !== null && Object.keys(type).length === 0)
							) {
								info +=
									" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."
							}
							var sourceInfo = getSourceInfoErrorAddendum(source)
							if (sourceInfo) {
								info += sourceInfo
							} else {
								info += getDeclarationErrorAddendum()
							}
							var typeString
							if (type === null) {
								typeString = 'null'
							} else if (isArray(type)) {
								typeString = 'array'
							} else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
								typeString = '<' + (getComponentNameFromType(type.type) || 'Unknown') + ' />'
								info = ' Did you accidentally export a JSX literal instead of a component?'
							} else {
								typeString = typeof type
							}
							error(
								'React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
								typeString,
								info
							)
						}
						var element = jsxDEV(type, props, key, source, self2)
						if (element == null) {
							return element
						}
						if (validType) {
							var children = props.children
							if (children !== void 0) {
								if (isStaticChildren) {
									if (isArray(children)) {
										for (var i3 = 0; i3 < children.length; i3++) {
											validateChildKeys(children[i3], type)
										}
										if (Object.freeze) {
											Object.freeze(children)
										}
									} else {
										error(
											'React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.'
										)
									}
								} else {
									validateChildKeys(children, type)
								}
							}
						}
						if (type === REACT_FRAGMENT_TYPE) {
							validateFragmentProps(element)
						} else {
							validatePropTypes(element)
						}
						return element
					}
				}
				function jsxWithValidationStatic(type, props, key) {
					{
						return jsxWithValidation(type, props, key, true)
					}
				}
				function jsxWithValidationDynamic(type, props, key) {
					{
						return jsxWithValidation(type, props, key, false)
					}
				}
				var jsx116 = jsxWithValidationDynamic
				var jsxs64 = jsxWithValidationStatic
				exports.Fragment = REACT_FRAGMENT_TYPE
				exports.jsx = jsx116
				exports.jsxs = jsxs64
			})()
		}
	},
})

// ../node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
	'../node_modules/react/jsx-runtime.js'(exports, module2) {
		'use strict'
		init_define_process()
		if (define_process_default.env.NODE_ENV === 'production') {
			module2.exports = require_react_jsx_runtime_production_min()
		} else {
			module2.exports = require_react_jsx_runtime_development()
		}
	},
})

// ../node_modules/lodash.uniq/index.js
var require_lodash2 = __commonJS({
	'../node_modules/lodash.uniq/index.js'(exports, module2) {
		init_define_process()
		var LARGE_ARRAY_SIZE = 200
		var HASH_UNDEFINED = '__lodash_hash_undefined__'
		var INFINITY = 1 / 0
		var funcTag = '[object Function]'
		var genTag = '[object GeneratorFunction]'
		var reRegExpChar = /[\\^$.*+?()[\]{}|]/g
		var reIsHostCtor = /^\[object .+?Constructor\]$/
		var freeGlobal = typeof global == 'object' && global && global.Object === Object && global
		var freeSelf = typeof self == 'object' && self && self.Object === Object && self
		var root2 = freeGlobal || freeSelf || Function('return this')()
		function arrayIncludes(array2, value) {
			var length = array2 ? array2.length : 0
			return !!length && baseIndexOf(array2, value, 0) > -1
		}
		function arrayIncludesWith(array2, value, comparator) {
			var index2 = -1,
				length = array2 ? array2.length : 0
			while (++index2 < length) {
				if (comparator(value, array2[index2])) {
					return true
				}
			}
			return false
		}
		function baseFindIndex(array2, predicate, fromIndex, fromRight) {
			var length = array2.length,
				index2 = fromIndex + (fromRight ? 1 : -1)
			while (fromRight ? index2-- : ++index2 < length) {
				if (predicate(array2[index2], index2, array2)) {
					return index2
				}
			}
			return -1
		}
		function baseIndexOf(array2, value, fromIndex) {
			if (value !== value) {
				return baseFindIndex(array2, baseIsNaN, fromIndex)
			}
			var index2 = fromIndex - 1,
				length = array2.length
			while (++index2 < length) {
				if (array2[index2] === value) {
					return index2
				}
			}
			return -1
		}
		function baseIsNaN(value) {
			return value !== value
		}
		function cacheHas(cache, key) {
			return cache.has(key)
		}
		function getValue(object2, key) {
			return object2 == null ? void 0 : object2[key]
		}
		function isHostObject(value) {
			var result = false
			if (value != null && typeof value.toString != 'function') {
				try {
					result = !!(value + '')
				} catch (e2) {}
			}
			return result
		}
		function setToArray(set) {
			var index2 = -1,
				result = Array(set.size)
			set.forEach(function (value) {
				result[++index2] = value
			})
			return result
		}
		var arrayProto = Array.prototype
		var funcProto = Function.prototype
		var objectProto = Object.prototype
		var coreJsData = root2['__core-js_shared__']
		var maskSrcKey = (function () {
			var uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '')
			return uid ? 'Symbol(src)_1.' + uid : ''
		})()
		var funcToString = funcProto.toString
		var hasOwnProperty2 = objectProto.hasOwnProperty
		var objectToString = objectProto.toString
		var reIsNative = RegExp(
			'^' +
				funcToString
					.call(hasOwnProperty2)
					.replace(reRegExpChar, '\\$&')
					.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
				'$'
		)
		var splice = arrayProto.splice
		var Map2 = getNative(root2, 'Map')
		var Set2 = getNative(root2, 'Set')
		var nativeCreate = getNative(Object, 'create')
		function Hash(entries) {
			var index2 = -1,
				length = entries ? entries.length : 0
			this.clear()
			while (++index2 < length) {
				var entry = entries[index2]
				this.set(entry[0], entry[1])
			}
		}
		function hashClear() {
			this.__data__ = nativeCreate ? nativeCreate(null) : {}
		}
		function hashDelete(key) {
			return this.has(key) && delete this.__data__[key]
		}
		function hashGet(key) {
			var data = this.__data__
			if (nativeCreate) {
				var result = data[key]
				return result === HASH_UNDEFINED ? void 0 : result
			}
			return hasOwnProperty2.call(data, key) ? data[key] : void 0
		}
		function hashHas(key) {
			var data = this.__data__
			return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key)
		}
		function hashSet(key, value) {
			var data = this.__data__
			data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value
			return this
		}
		Hash.prototype.clear = hashClear
		Hash.prototype['delete'] = hashDelete
		Hash.prototype.get = hashGet
		Hash.prototype.has = hashHas
		Hash.prototype.set = hashSet
		function ListCache(entries) {
			var index2 = -1,
				length = entries ? entries.length : 0
			this.clear()
			while (++index2 < length) {
				var entry = entries[index2]
				this.set(entry[0], entry[1])
			}
		}
		function listCacheClear() {
			this.__data__ = []
		}
		function listCacheDelete(key) {
			var data = this.__data__,
				index2 = assocIndexOf(data, key)
			if (index2 < 0) {
				return false
			}
			var lastIndex = data.length - 1
			if (index2 == lastIndex) {
				data.pop()
			} else {
				splice.call(data, index2, 1)
			}
			return true
		}
		function listCacheGet(key) {
			var data = this.__data__,
				index2 = assocIndexOf(data, key)
			return index2 < 0 ? void 0 : data[index2][1]
		}
		function listCacheHas(key) {
			return assocIndexOf(this.__data__, key) > -1
		}
		function listCacheSet(key, value) {
			var data = this.__data__,
				index2 = assocIndexOf(data, key)
			if (index2 < 0) {
				data.push([key, value])
			} else {
				data[index2][1] = value
			}
			return this
		}
		ListCache.prototype.clear = listCacheClear
		ListCache.prototype['delete'] = listCacheDelete
		ListCache.prototype.get = listCacheGet
		ListCache.prototype.has = listCacheHas
		ListCache.prototype.set = listCacheSet
		function MapCache(entries) {
			var index2 = -1,
				length = entries ? entries.length : 0
			this.clear()
			while (++index2 < length) {
				var entry = entries[index2]
				this.set(entry[0], entry[1])
			}
		}
		function mapCacheClear() {
			this.__data__ = {
				hash: new Hash(),
				map: new (Map2 || ListCache)(),
				string: new Hash(),
			}
		}
		function mapCacheDelete(key) {
			return getMapData(this, key)['delete'](key)
		}
		function mapCacheGet(key) {
			return getMapData(this, key).get(key)
		}
		function mapCacheHas(key) {
			return getMapData(this, key).has(key)
		}
		function mapCacheSet(key, value) {
			getMapData(this, key).set(key, value)
			return this
		}
		MapCache.prototype.clear = mapCacheClear
		MapCache.prototype['delete'] = mapCacheDelete
		MapCache.prototype.get = mapCacheGet
		MapCache.prototype.has = mapCacheHas
		MapCache.prototype.set = mapCacheSet
		function SetCache(values) {
			var index2 = -1,
				length = values ? values.length : 0
			this.__data__ = new MapCache()
			while (++index2 < length) {
				this.add(values[index2])
			}
		}
		function setCacheAdd(value) {
			this.__data__.set(value, HASH_UNDEFINED)
			return this
		}
		function setCacheHas(value) {
			return this.__data__.has(value)
		}
		SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
		SetCache.prototype.has = setCacheHas
		function assocIndexOf(array2, key) {
			var length = array2.length
			while (length--) {
				if (eq(array2[length][0], key)) {
					return length
				}
			}
			return -1
		}
		function baseIsNative(value) {
			if (!isObject(value) || isMasked(value)) {
				return false
			}
			var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor
			return pattern.test(toSource(value))
		}
		function baseUniq(array2, iteratee, comparator) {
			var index2 = -1,
				includes = arrayIncludes,
				length = array2.length,
				isCommon = true,
				result = [],
				seen = result
			if (comparator) {
				isCommon = false
				includes = arrayIncludesWith
			} else if (length >= LARGE_ARRAY_SIZE) {
				var set = iteratee ? null : createSet(array2)
				if (set) {
					return setToArray(set)
				}
				isCommon = false
				includes = cacheHas
				seen = new SetCache()
			} else {
				seen = iteratee ? [] : result
			}
			outer: while (++index2 < length) {
				var value = array2[index2],
					computed2 = iteratee ? iteratee(value) : value
				value = comparator || value !== 0 ? value : 0
				if (isCommon && computed2 === computed2) {
					var seenIndex = seen.length
					while (seenIndex--) {
						if (seen[seenIndex] === computed2) {
							continue outer
						}
					}
					if (iteratee) {
						seen.push(computed2)
					}
					result.push(value)
				} else if (!includes(seen, computed2, comparator)) {
					if (seen !== result) {
						seen.push(computed2)
					}
					result.push(value)
				}
			}
			return result
		}
		var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY)
			? noop3
			: function (values) {
					return new Set2(values)
			  }
		function getMapData(map, key) {
			var data = map.__data__
			return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map
		}
		function getNative(object2, key) {
			var value = getValue(object2, key)
			return baseIsNative(value) ? value : void 0
		}
		function isKeyable(value) {
			var type = typeof value
			return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'
				? value !== '__proto__'
				: value === null
		}
		function isMasked(func) {
			return !!maskSrcKey && maskSrcKey in func
		}
		function toSource(func) {
			if (func != null) {
				try {
					return funcToString.call(func)
				} catch (e2) {}
				try {
					return func + ''
				} catch (e2) {}
			}
			return ''
		}
		function uniq3(array2) {
			return array2 && array2.length ? baseUniq(array2) : []
		}
		function eq(value, other) {
			return value === other || (value !== value && other !== other)
		}
		function isFunction(value) {
			var tag = isObject(value) ? objectToString.call(value) : ''
			return tag == funcTag || tag == genTag
		}
		function isObject(value) {
			var type = typeof value
			return !!value && (type == 'object' || type == 'function')
		}
		function noop3() {}
		module2.exports = uniq3
	},
})

// ../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
	'../node_modules/base64-js/index.js'(exports) {
		'use strict'
		init_define_process()
		exports.byteLength = byteLength
		exports.toByteArray = toByteArray
		exports.fromByteArray = fromByteArray
		var lookup = []
		var revLookup = []
		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
		var code3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
		for (i3 = 0, len = code3.length; i3 < len; ++i3) {
			lookup[i3] = code3[i3]
			revLookup[code3.charCodeAt(i3)] = i3
		}
		var i3
		var len
		revLookup['-'.charCodeAt(0)] = 62
		revLookup['_'.charCodeAt(0)] = 63
		function getLens(b64) {
			var len2 = b64.length
			if (len2 % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
			var validLen = b64.indexOf('=')
			if (validLen === -1) validLen = len2
			var placeHoldersLen = validLen === len2 ? 0 : 4 - (validLen % 4)
			return [validLen, placeHoldersLen]
		}
		function byteLength(b64) {
			var lens = getLens(b64)
			var validLen = lens[0]
			var placeHoldersLen = lens[1]
			return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
		}
		function _byteLength(b64, validLen, placeHoldersLen) {
			return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
		}
		function toByteArray(b64) {
			var tmp
			var lens = getLens(b64)
			var validLen = lens[0]
			var placeHoldersLen = lens[1]
			var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
			var curByte = 0
			var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen
			var i4
			for (i4 = 0; i4 < len2; i4 += 4) {
				tmp =
					(revLookup[b64.charCodeAt(i4)] << 18) |
					(revLookup[b64.charCodeAt(i4 + 1)] << 12) |
					(revLookup[b64.charCodeAt(i4 + 2)] << 6) |
					revLookup[b64.charCodeAt(i4 + 3)]
				arr[curByte++] = (tmp >> 16) & 255
				arr[curByte++] = (tmp >> 8) & 255
				arr[curByte++] = tmp & 255
			}
			if (placeHoldersLen === 2) {
				tmp = (revLookup[b64.charCodeAt(i4)] << 2) | (revLookup[b64.charCodeAt(i4 + 1)] >> 4)
				arr[curByte++] = tmp & 255
			}
			if (placeHoldersLen === 1) {
				tmp =
					(revLookup[b64.charCodeAt(i4)] << 10) |
					(revLookup[b64.charCodeAt(i4 + 1)] << 4) |
					(revLookup[b64.charCodeAt(i4 + 2)] >> 2)
				arr[curByte++] = (tmp >> 8) & 255
				arr[curByte++] = tmp & 255
			}
			return arr
		}
		function tripletToBase64(num) {
			return (
				lookup[(num >> 18) & 63] +
				lookup[(num >> 12) & 63] +
				lookup[(num >> 6) & 63] +
				lookup[num & 63]
			)
		}
		function encodeChunk(uint8, start, end) {
			var tmp
			var output = []
			for (var i4 = start; i4 < end; i4 += 3) {
				tmp =
					((uint8[i4] << 16) & 16711680) + ((uint8[i4 + 1] << 8) & 65280) + (uint8[i4 + 2] & 255)
				output.push(tripletToBase64(tmp))
			}
			return output.join('')
		}
		function fromByteArray(uint8) {
			var tmp
			var len2 = uint8.length
			var extraBytes = len2 % 3
			var parts = []
			var maxChunkLength = 16383
			for (var i4 = 0, len22 = len2 - extraBytes; i4 < len22; i4 += maxChunkLength) {
				parts.push(
					encodeChunk(uint8, i4, i4 + maxChunkLength > len22 ? len22 : i4 + maxChunkLength)
				)
			}
			if (extraBytes === 1) {
				tmp = uint8[len2 - 1]
				parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 63] + '==')
			} else if (extraBytes === 2) {
				tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1]
				parts.push(lookup[tmp >> 10] + lookup[(tmp >> 4) & 63] + lookup[(tmp << 2) & 63] + '=')
			}
			return parts.join('')
		}
	},
})

// ../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
	'../node_modules/ieee754/index.js'(exports) {
		init_define_process()
		exports.read = function (buffer, offset, isLE, mLen, nBytes) {
			var e2, m3
			var eLen = nBytes * 8 - mLen - 1
			var eMax = (1 << eLen) - 1
			var eBias = eMax >> 1
			var nBits = -7
			var i3 = isLE ? nBytes - 1 : 0
			var d3 = isLE ? -1 : 1
			var s3 = buffer[offset + i3]
			i3 += d3
			e2 = s3 & ((1 << -nBits) - 1)
			s3 >>= -nBits
			nBits += eLen
			for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i3], i3 += d3, nBits -= 8) {}
			m3 = e2 & ((1 << -nBits) - 1)
			e2 >>= -nBits
			nBits += mLen
			for (; nBits > 0; m3 = m3 * 256 + buffer[offset + i3], i3 += d3, nBits -= 8) {}
			if (e2 === 0) {
				e2 = 1 - eBias
			} else if (e2 === eMax) {
				return m3 ? NaN : (s3 ? -1 : 1) * Infinity
			} else {
				m3 = m3 + Math.pow(2, mLen)
				e2 = e2 - eBias
			}
			return (s3 ? -1 : 1) * m3 * Math.pow(2, e2 - mLen)
		}
		exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
			var e2, m3, c3
			var eLen = nBytes * 8 - mLen - 1
			var eMax = (1 << eLen) - 1
			var eBias = eMax >> 1
			var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
			var i3 = isLE ? 0 : nBytes - 1
			var d3 = isLE ? 1 : -1
			var s3 = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
			value = Math.abs(value)
			if (isNaN(value) || value === Infinity) {
				m3 = isNaN(value) ? 1 : 0
				e2 = eMax
			} else {
				e2 = Math.floor(Math.log(value) / Math.LN2)
				if (value * (c3 = Math.pow(2, -e2)) < 1) {
					e2--
					c3 *= 2
				}
				if (e2 + eBias >= 1) {
					value += rt / c3
				} else {
					value += rt * Math.pow(2, 1 - eBias)
				}
				if (value * c3 >= 2) {
					e2++
					c3 /= 2
				}
				if (e2 + eBias >= eMax) {
					m3 = 0
					e2 = eMax
				} else if (e2 + eBias >= 1) {
					m3 = (value * c3 - 1) * Math.pow(2, mLen)
					e2 = e2 + eBias
				} else {
					m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
					e2 = 0
				}
			}
			for (; mLen >= 8; buffer[offset + i3] = m3 & 255, i3 += d3, m3 /= 256, mLen -= 8) {}
			e2 = (e2 << mLen) | m3
			eLen += mLen
			for (; eLen > 0; buffer[offset + i3] = e2 & 255, i3 += d3, e2 /= 256, eLen -= 8) {}
			buffer[offset + i3 - d3] |= s3 * 128
		}
	},
})

// ../node_modules/buffer/index.js
var require_buffer = __commonJS({
	'../node_modules/buffer/index.js'(exports) {
		'use strict'
		init_define_process()
		var base64 = require_base64_js()
		var ieee754 = require_ieee754()
		var customInspectSymbol =
			typeof Symbol === 'function' && typeof Symbol['for'] === 'function'
				? Symbol['for']('nodejs.util.inspect.custom')
				: null
		exports.Buffer = Buffer3
		exports.SlowBuffer = SlowBuffer
		exports.INSPECT_MAX_BYTES = 50
		var K_MAX_LENGTH = 2147483647
		exports.kMaxLength = K_MAX_LENGTH
		Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport()
		if (
			!Buffer3.TYPED_ARRAY_SUPPORT &&
			typeof console !== 'undefined' &&
			typeof console.error === 'function'
		) {
			console.error(
				'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
			)
		}
		function typedArraySupport() {
			try {
				const arr = new Uint8Array(1)
				const proto = {
					foo: function () {
						return 42
					},
				}
				Object.setPrototypeOf(proto, Uint8Array.prototype)
				Object.setPrototypeOf(arr, proto)
				return arr.foo() === 42
			} catch (e2) {
				return false
			}
		}
		Object.defineProperty(Buffer3.prototype, 'parent', {
			enumerable: true,
			get: function () {
				if (!Buffer3.isBuffer(this)) return void 0
				return this.buffer
			},
		})
		Object.defineProperty(Buffer3.prototype, 'offset', {
			enumerable: true,
			get: function () {
				if (!Buffer3.isBuffer(this)) return void 0
				return this.byteOffset
			},
		})
		function createBuffer2(length) {
			if (length > K_MAX_LENGTH) {
				throw new RangeError('The value "' + length + '" is invalid for option "size"')
			}
			const buf = new Uint8Array(length)
			Object.setPrototypeOf(buf, Buffer3.prototype)
			return buf
		}
		function Buffer3(arg, encodingOrOffset, length) {
			if (typeof arg === 'number') {
				if (typeof encodingOrOffset === 'string') {
					throw new TypeError('The "string" argument must be of type string. Received type number')
				}
				return allocUnsafe(arg)
			}
			return from(arg, encodingOrOffset, length)
		}
		Buffer3.poolSize = 8192
		function from(value, encodingOrOffset, length) {
			if (typeof value === 'string') {
				return fromString(value, encodingOrOffset)
			}
			if (ArrayBuffer.isView(value)) {
				return fromArrayView(value)
			}
			if (value == null) {
				throw new TypeError(
					'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
						typeof value
				)
			}
			if (isInstance(value, ArrayBuffer) || (value && isInstance(value.buffer, ArrayBuffer))) {
				return fromArrayBuffer(value, encodingOrOffset, length)
			}
			if (
				typeof SharedArrayBuffer !== 'undefined' &&
				(isInstance(value, SharedArrayBuffer) ||
					(value && isInstance(value.buffer, SharedArrayBuffer)))
			) {
				return fromArrayBuffer(value, encodingOrOffset, length)
			}
			if (typeof value === 'number') {
				throw new TypeError('The "value" argument must not be of type number. Received type number')
			}
			const valueOf = value.valueOf && value.valueOf()
			if (valueOf != null && valueOf !== value) {
				return Buffer3.from(valueOf, encodingOrOffset, length)
			}
			const b3 = fromObject(value)
			if (b3) return b3
			if (
				typeof Symbol !== 'undefined' &&
				Symbol.toPrimitive != null &&
				typeof value[Symbol.toPrimitive] === 'function'
			) {
				return Buffer3.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
			}
			throw new TypeError(
				'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
					typeof value
			)
		}
		Buffer3.from = function (value, encodingOrOffset, length) {
			return from(value, encodingOrOffset, length)
		}
		Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype)
		Object.setPrototypeOf(Buffer3, Uint8Array)
		function assertSize(size) {
			if (typeof size !== 'number') {
				throw new TypeError('"size" argument must be of type number')
			} else if (size < 0) {
				throw new RangeError('The value "' + size + '" is invalid for option "size"')
			}
		}
		function alloc(size, fill, encoding) {
			assertSize(size)
			if (size <= 0) {
				return createBuffer2(size)
			}
			if (fill !== void 0) {
				return typeof encoding === 'string'
					? createBuffer2(size).fill(fill, encoding)
					: createBuffer2(size).fill(fill)
			}
			return createBuffer2(size)
		}
		Buffer3.alloc = function (size, fill, encoding) {
			return alloc(size, fill, encoding)
		}
		function allocUnsafe(size) {
			assertSize(size)
			return createBuffer2(size < 0 ? 0 : checked(size) | 0)
		}
		Buffer3.allocUnsafe = function (size) {
			return allocUnsafe(size)
		}
		Buffer3.allocUnsafeSlow = function (size) {
			return allocUnsafe(size)
		}
		function fromString(string2, encoding) {
			if (typeof encoding !== 'string' || encoding === '') {
				encoding = 'utf8'
			}
			if (!Buffer3.isEncoding(encoding)) {
				throw new TypeError('Unknown encoding: ' + encoding)
			}
			const length = byteLength(string2, encoding) | 0
			let buf = createBuffer2(length)
			const actual = buf.write(string2, encoding)
			if (actual !== length) {
				buf = buf.slice(0, actual)
			}
			return buf
		}
		function fromArrayLike(array2) {
			const length = array2.length < 0 ? 0 : checked(array2.length) | 0
			const buf = createBuffer2(length)
			for (let i3 = 0; i3 < length; i3 += 1) {
				buf[i3] = array2[i3] & 255
			}
			return buf
		}
		function fromArrayView(arrayView) {
			if (isInstance(arrayView, Uint8Array)) {
				const copy = new Uint8Array(arrayView)
				return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
			}
			return fromArrayLike(arrayView)
		}
		function fromArrayBuffer(array2, byteOffset, length) {
			if (byteOffset < 0 || array2.byteLength < byteOffset) {
				throw new RangeError('"offset" is outside of buffer bounds')
			}
			if (array2.byteLength < byteOffset + (length || 0)) {
				throw new RangeError('"length" is outside of buffer bounds')
			}
			let buf
			if (byteOffset === void 0 && length === void 0) {
				buf = new Uint8Array(array2)
			} else if (length === void 0) {
				buf = new Uint8Array(array2, byteOffset)
			} else {
				buf = new Uint8Array(array2, byteOffset, length)
			}
			Object.setPrototypeOf(buf, Buffer3.prototype)
			return buf
		}
		function fromObject(obj) {
			if (Buffer3.isBuffer(obj)) {
				const len = checked(obj.length) | 0
				const buf = createBuffer2(len)
				if (buf.length === 0) {
					return buf
				}
				obj.copy(buf, 0, 0, len)
				return buf
			}
			if (obj.length !== void 0) {
				if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
					return createBuffer2(0)
				}
				return fromArrayLike(obj)
			}
			if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
				return fromArrayLike(obj.data)
			}
		}
		function checked(length) {
			if (length >= K_MAX_LENGTH) {
				throw new RangeError(
					'Attempt to allocate Buffer larger than maximum size: 0x' +
						K_MAX_LENGTH.toString(16) +
						' bytes'
				)
			}
			return length | 0
		}
		function SlowBuffer(length) {
			if (+length != length) {
				length = 0
			}
			return Buffer3.alloc(+length)
		}
		Buffer3.isBuffer = function isBuffer(b3) {
			return b3 != null && b3._isBuffer === true && b3 !== Buffer3.prototype
		}
		Buffer3.compare = function compare(a3, b3) {
			if (isInstance(a3, Uint8Array)) a3 = Buffer3.from(a3, a3.offset, a3.byteLength)
			if (isInstance(b3, Uint8Array)) b3 = Buffer3.from(b3, b3.offset, b3.byteLength)
			if (!Buffer3.isBuffer(a3) || !Buffer3.isBuffer(b3)) {
				throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array')
			}
			if (a3 === b3) return 0
			let x3 = a3.length
			let y3 = b3.length
			for (let i3 = 0, len = Math.min(x3, y3); i3 < len; ++i3) {
				if (a3[i3] !== b3[i3]) {
					x3 = a3[i3]
					y3 = b3[i3]
					break
				}
			}
			if (x3 < y3) return -1
			if (y3 < x3) return 1
			return 0
		}
		Buffer3.isEncoding = function isEncoding(encoding) {
			switch (String(encoding).toLowerCase()) {
				case 'hex':
				case 'utf8':
				case 'utf-8':
				case 'ascii':
				case 'latin1':
				case 'binary':
				case 'base64':
				case 'ucs2':
				case 'ucs-2':
				case 'utf16le':
				case 'utf-16le':
					return true
				default:
					return false
			}
		}
		Buffer3.concat = function concat(list, length) {
			if (!Array.isArray(list)) {
				throw new TypeError('"list" argument must be an Array of Buffers')
			}
			if (list.length === 0) {
				return Buffer3.alloc(0)
			}
			let i3
			if (length === void 0) {
				length = 0
				for (i3 = 0; i3 < list.length; ++i3) {
					length += list[i3].length
				}
			}
			const buffer = Buffer3.allocUnsafe(length)
			let pos = 0
			for (i3 = 0; i3 < list.length; ++i3) {
				let buf = list[i3]
				if (isInstance(buf, Uint8Array)) {
					if (pos + buf.length > buffer.length) {
						if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf)
						buf.copy(buffer, pos)
					} else {
						Uint8Array.prototype.set.call(buffer, buf, pos)
					}
				} else if (!Buffer3.isBuffer(buf)) {
					throw new TypeError('"list" argument must be an Array of Buffers')
				} else {
					buf.copy(buffer, pos)
				}
				pos += buf.length
			}
			return buffer
		}
		function byteLength(string2, encoding) {
			if (Buffer3.isBuffer(string2)) {
				return string2.length
			}
			if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
				return string2.byteLength
			}
			if (typeof string2 !== 'string') {
				throw new TypeError(
					'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
						typeof string2
				)
			}
			const len = string2.length
			const mustMatch = arguments.length > 2 && arguments[2] === true
			if (!mustMatch && len === 0) return 0
			let loweredCase = false
			for (;;) {
				switch (encoding) {
					case 'ascii':
					case 'latin1':
					case 'binary':
						return len
					case 'utf8':
					case 'utf-8':
						return utf8ToBytes(string2).length
					case 'ucs2':
					case 'ucs-2':
					case 'utf16le':
					case 'utf-16le':
						return len * 2
					case 'hex':
						return len >>> 1
					case 'base64':
						return base64ToBytes(string2).length
					default:
						if (loweredCase) {
							return mustMatch ? -1 : utf8ToBytes(string2).length
						}
						encoding = ('' + encoding).toLowerCase()
						loweredCase = true
				}
			}
		}
		Buffer3.byteLength = byteLength
		function slowToString(encoding, start, end) {
			let loweredCase = false
			if (start === void 0 || start < 0) {
				start = 0
			}
			if (start > this.length) {
				return ''
			}
			if (end === void 0 || end > this.length) {
				end = this.length
			}
			if (end <= 0) {
				return ''
			}
			end >>>= 0
			start >>>= 0
			if (end <= start) {
				return ''
			}
			if (!encoding) encoding = 'utf8'
			while (true) {
				switch (encoding) {
					case 'hex':
						return hexSlice(this, start, end)
					case 'utf8':
					case 'utf-8':
						return utf8Slice(this, start, end)
					case 'ascii':
						return asciiSlice(this, start, end)
					case 'latin1':
					case 'binary':
						return latin1Slice(this, start, end)
					case 'base64':
						return base64Slice(this, start, end)
					case 'ucs2':
					case 'ucs-2':
					case 'utf16le':
					case 'utf-16le':
						return utf16leSlice(this, start, end)
					default:
						if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
						encoding = (encoding + '').toLowerCase()
						loweredCase = true
				}
			}
		}
		Buffer3.prototype._isBuffer = true
		function swap(b3, n3, m3) {
			const i3 = b3[n3]
			b3[n3] = b3[m3]
			b3[m3] = i3
		}
		Buffer3.prototype.swap16 = function swap16() {
			const len = this.length
			if (len % 2 !== 0) {
				throw new RangeError('Buffer size must be a multiple of 16-bits')
			}
			for (let i3 = 0; i3 < len; i3 += 2) {
				swap(this, i3, i3 + 1)
			}
			return this
		}
		Buffer3.prototype.swap32 = function swap32() {
			const len = this.length
			if (len % 4 !== 0) {
				throw new RangeError('Buffer size must be a multiple of 32-bits')
			}
			for (let i3 = 0; i3 < len; i3 += 4) {
				swap(this, i3, i3 + 3)
				swap(this, i3 + 1, i3 + 2)
			}
			return this
		}
		Buffer3.prototype.swap64 = function swap64() {
			const len = this.length
			if (len % 8 !== 0) {
				throw new RangeError('Buffer size must be a multiple of 64-bits')
			}
			for (let i3 = 0; i3 < len; i3 += 8) {
				swap(this, i3, i3 + 7)
				swap(this, i3 + 1, i3 + 6)
				swap(this, i3 + 2, i3 + 5)
				swap(this, i3 + 3, i3 + 4)
			}
			return this
		}
		Buffer3.prototype.toString = function toString() {
			const length = this.length
			if (length === 0) return ''
			if (arguments.length === 0) return utf8Slice(this, 0, length)
			return slowToString.apply(this, arguments)
		}
		Buffer3.prototype.toLocaleString = Buffer3.prototype.toString
		Buffer3.prototype.equals = function equals2(b3) {
			if (!Buffer3.isBuffer(b3)) throw new TypeError('Argument must be a Buffer')
			if (this === b3) return true
			return Buffer3.compare(this, b3) === 0
		}
		Buffer3.prototype.inspect = function inspect() {
			let str = ''
			const max = exports.INSPECT_MAX_BYTES
			str = this.toString('hex', 0, max)
				.replace(/(.{2})/g, '$1 ')
				.trim()
			if (this.length > max) str += ' ... '
			return '<Buffer ' + str + '>'
		}
		if (customInspectSymbol) {
			Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect
		}
		Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
			if (isInstance(target, Uint8Array)) {
				target = Buffer3.from(target, target.offset, target.byteLength)
			}
			if (!Buffer3.isBuffer(target)) {
				throw new TypeError(
					'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
						typeof target
				)
			}
			if (start === void 0) {
				start = 0
			}
			if (end === void 0) {
				end = target ? target.length : 0
			}
			if (thisStart === void 0) {
				thisStart = 0
			}
			if (thisEnd === void 0) {
				thisEnd = this.length
			}
			if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
				throw new RangeError('out of range index')
			}
			if (thisStart >= thisEnd && start >= end) {
				return 0
			}
			if (thisStart >= thisEnd) {
				return -1
			}
			if (start >= end) {
				return 1
			}
			start >>>= 0
			end >>>= 0
			thisStart >>>= 0
			thisEnd >>>= 0
			if (this === target) return 0
			let x3 = thisEnd - thisStart
			let y3 = end - start
			const len = Math.min(x3, y3)
			const thisCopy = this.slice(thisStart, thisEnd)
			const targetCopy = target.slice(start, end)
			for (let i3 = 0; i3 < len; ++i3) {
				if (thisCopy[i3] !== targetCopy[i3]) {
					x3 = thisCopy[i3]
					y3 = targetCopy[i3]
					break
				}
			}
			if (x3 < y3) return -1
			if (y3 < x3) return 1
			return 0
		}
		function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
			if (buffer.length === 0) return -1
			if (typeof byteOffset === 'string') {
				encoding = byteOffset
				byteOffset = 0
			} else if (byteOffset > 2147483647) {
				byteOffset = 2147483647
			} else if (byteOffset < -2147483648) {
				byteOffset = -2147483648
			}
			byteOffset = +byteOffset
			if (numberIsNaN(byteOffset)) {
				byteOffset = dir ? 0 : buffer.length - 1
			}
			if (byteOffset < 0) byteOffset = buffer.length + byteOffset
			if (byteOffset >= buffer.length) {
				if (dir) return -1
				else byteOffset = buffer.length - 1
			} else if (byteOffset < 0) {
				if (dir) byteOffset = 0
				else return -1
			}
			if (typeof val === 'string') {
				val = Buffer3.from(val, encoding)
			}
			if (Buffer3.isBuffer(val)) {
				if (val.length === 0) {
					return -1
				}
				return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
			} else if (typeof val === 'number') {
				val = val & 255
				if (typeof Uint8Array.prototype.indexOf === 'function') {
					if (dir) {
						return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
					} else {
						return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
					}
				}
				return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
			}
			throw new TypeError('val must be string, number or Buffer')
		}
		function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
			let indexSize = 1
			let arrLength = arr.length
			let valLength = val.length
			if (encoding !== void 0) {
				encoding = String(encoding).toLowerCase()
				if (
					encoding === 'ucs2' ||
					encoding === 'ucs-2' ||
					encoding === 'utf16le' ||
					encoding === 'utf-16le'
				) {
					if (arr.length < 2 || val.length < 2) {
						return -1
					}
					indexSize = 2
					arrLength /= 2
					valLength /= 2
					byteOffset /= 2
				}
			}
			function read(buf, i4) {
				if (indexSize === 1) {
					return buf[i4]
				} else {
					return buf.readUInt16BE(i4 * indexSize)
				}
			}
			let i3
			if (dir) {
				let foundIndex = -1
				for (i3 = byteOffset; i3 < arrLength; i3++) {
					if (read(arr, i3) === read(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
						if (foundIndex === -1) foundIndex = i3
						if (i3 - foundIndex + 1 === valLength) return foundIndex * indexSize
					} else {
						if (foundIndex !== -1) i3 -= i3 - foundIndex
						foundIndex = -1
					}
				}
			} else {
				if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
				for (i3 = byteOffset; i3 >= 0; i3--) {
					let found = true
					for (let j = 0; j < valLength; j++) {
						if (read(arr, i3 + j) !== read(val, j)) {
							found = false
							break
						}
					}
					if (found) return i3
				}
			}
			return -1
		}
		Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
			return this.indexOf(val, byteOffset, encoding) !== -1
		}
		Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
			return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		}
		Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
			return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		}
		function hexWrite(buf, string2, offset, length) {
			offset = Number(offset) || 0
			const remaining = buf.length - offset
			if (!length) {
				length = remaining
			} else {
				length = Number(length)
				if (length > remaining) {
					length = remaining
				}
			}
			const strLen = string2.length
			if (length > strLen / 2) {
				length = strLen / 2
			}
			let i3
			for (i3 = 0; i3 < length; ++i3) {
				const parsed = parseInt(string2.substr(i3 * 2, 2), 16)
				if (numberIsNaN(parsed)) return i3
				buf[offset + i3] = parsed
			}
			return i3
		}
		function utf8Write(buf, string2, offset, length) {
			return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length)
		}
		function asciiWrite(buf, string2, offset, length) {
			return blitBuffer(asciiToBytes(string2), buf, offset, length)
		}
		function base64Write(buf, string2, offset, length) {
			return blitBuffer(base64ToBytes(string2), buf, offset, length)
		}
		function ucs2Write(buf, string2, offset, length) {
			return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length)
		}
		Buffer3.prototype.write = function write(string2, offset, length, encoding) {
			if (offset === void 0) {
				encoding = 'utf8'
				length = this.length
				offset = 0
			} else if (length === void 0 && typeof offset === 'string') {
				encoding = offset
				length = this.length
				offset = 0
			} else if (isFinite(offset)) {
				offset = offset >>> 0
				if (isFinite(length)) {
					length = length >>> 0
					if (encoding === void 0) encoding = 'utf8'
				} else {
					encoding = length
					length = void 0
				}
			} else {
				throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported')
			}
			const remaining = this.length - offset
			if (length === void 0 || length > remaining) length = remaining
			if ((string2.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
				throw new RangeError('Attempt to write outside buffer bounds')
			}
			if (!encoding) encoding = 'utf8'
			let loweredCase = false
			for (;;) {
				switch (encoding) {
					case 'hex':
						return hexWrite(this, string2, offset, length)
					case 'utf8':
					case 'utf-8':
						return utf8Write(this, string2, offset, length)
					case 'ascii':
					case 'latin1':
					case 'binary':
						return asciiWrite(this, string2, offset, length)
					case 'base64':
						return base64Write(this, string2, offset, length)
					case 'ucs2':
					case 'ucs-2':
					case 'utf16le':
					case 'utf-16le':
						return ucs2Write(this, string2, offset, length)
					default:
						if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
						encoding = ('' + encoding).toLowerCase()
						loweredCase = true
				}
			}
		}
		Buffer3.prototype.toJSON = function toJSON() {
			return {
				type: 'Buffer',
				data: Array.prototype.slice.call(this._arr || this, 0),
			}
		}
		function base64Slice(buf, start, end) {
			if (start === 0 && end === buf.length) {
				return base64.fromByteArray(buf)
			} else {
				return base64.fromByteArray(buf.slice(start, end))
			}
		}
		function utf8Slice(buf, start, end) {
			end = Math.min(buf.length, end)
			const res = []
			let i3 = start
			while (i3 < end) {
				const firstByte = buf[i3]
				let codePoint = null
				let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1
				if (i3 + bytesPerSequence <= end) {
					let secondByte, thirdByte, fourthByte, tempCodePoint
					switch (bytesPerSequence) {
						case 1:
							if (firstByte < 128) {
								codePoint = firstByte
							}
							break
						case 2:
							secondByte = buf[i3 + 1]
							if ((secondByte & 192) === 128) {
								tempCodePoint = ((firstByte & 31) << 6) | (secondByte & 63)
								if (tempCodePoint > 127) {
									codePoint = tempCodePoint
								}
							}
							break
						case 3:
							secondByte = buf[i3 + 1]
							thirdByte = buf[i3 + 2]
							if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
								tempCodePoint =
									((firstByte & 15) << 12) | ((secondByte & 63) << 6) | (thirdByte & 63)
								if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
									codePoint = tempCodePoint
								}
							}
							break
						case 4:
							secondByte = buf[i3 + 1]
							thirdByte = buf[i3 + 2]
							fourthByte = buf[i3 + 3]
							if (
								(secondByte & 192) === 128 &&
								(thirdByte & 192) === 128 &&
								(fourthByte & 192) === 128
							) {
								tempCodePoint =
									((firstByte & 15) << 18) |
									((secondByte & 63) << 12) |
									((thirdByte & 63) << 6) |
									(fourthByte & 63)
								if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
									codePoint = tempCodePoint
								}
							}
					}
				}
				if (codePoint === null) {
					codePoint = 65533
					bytesPerSequence = 1
				} else if (codePoint > 65535) {
					codePoint -= 65536
					res.push(((codePoint >>> 10) & 1023) | 55296)
					codePoint = 56320 | (codePoint & 1023)
				}
				res.push(codePoint)
				i3 += bytesPerSequence
			}
			return decodeCodePointsArray(res)
		}
		var MAX_ARGUMENTS_LENGTH = 4096
		function decodeCodePointsArray(codePoints) {
			const len = codePoints.length
			if (len <= MAX_ARGUMENTS_LENGTH) {
				return String.fromCharCode.apply(String, codePoints)
			}
			let res = ''
			let i3 = 0
			while (i3 < len) {
				res += String.fromCharCode.apply(String, codePoints.slice(i3, (i3 += MAX_ARGUMENTS_LENGTH)))
			}
			return res
		}
		function asciiSlice(buf, start, end) {
			let ret = ''
			end = Math.min(buf.length, end)
			for (let i3 = start; i3 < end; ++i3) {
				ret += String.fromCharCode(buf[i3] & 127)
			}
			return ret
		}
		function latin1Slice(buf, start, end) {
			let ret = ''
			end = Math.min(buf.length, end)
			for (let i3 = start; i3 < end; ++i3) {
				ret += String.fromCharCode(buf[i3])
			}
			return ret
		}
		function hexSlice(buf, start, end) {
			const len = buf.length
			if (!start || start < 0) start = 0
			if (!end || end < 0 || end > len) end = len
			let out = ''
			for (let i3 = start; i3 < end; ++i3) {
				out += hexSliceLookupTable[buf[i3]]
			}
			return out
		}
		function utf16leSlice(buf, start, end) {
			const bytes = buf.slice(start, end)
			let res = ''
			for (let i3 = 0; i3 < bytes.length - 1; i3 += 2) {
				res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256)
			}
			return res
		}
		Buffer3.prototype.slice = function slice(start, end) {
			const len = this.length
			start = ~~start
			end = end === void 0 ? len : ~~end
			if (start < 0) {
				start += len
				if (start < 0) start = 0
			} else if (start > len) {
				start = len
			}
			if (end < 0) {
				end += len
				if (end < 0) end = 0
			} else if (end > len) {
				end = len
			}
			if (end < start) end = start
			const newBuf = this.subarray(start, end)
			Object.setPrototypeOf(newBuf, Buffer3.prototype)
			return newBuf
		}
		function checkOffset(offset, ext, length) {
			if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint')
			if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}
		Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(
			offset,
			byteLength2,
			noAssert
		) {
			offset = offset >>> 0
			byteLength2 = byteLength2 >>> 0
			if (!noAssert) checkOffset(offset, byteLength2, this.length)
			let val = this[offset]
			let mul = 1
			let i3 = 0
			while (++i3 < byteLength2 && (mul *= 256)) {
				val += this[offset + i3] * mul
			}
			return val
		}
		Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(
			offset,
			byteLength2,
			noAssert
		) {
			offset = offset >>> 0
			byteLength2 = byteLength2 >>> 0
			if (!noAssert) {
				checkOffset(offset, byteLength2, this.length)
			}
			let val = this[offset + --byteLength2]
			let mul = 1
			while (byteLength2 > 0 && (mul *= 256)) {
				val += this[offset + --byteLength2] * mul
			}
			return val
		}
		Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(
			offset,
			noAssert
		) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 1, this.length)
			return this[offset]
		}
		Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(
			offset,
			noAssert
		) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 2, this.length)
			return this[offset] | (this[offset + 1] << 8)
		}
		Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(
			offset,
			noAssert
		) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 2, this.length)
			return (this[offset] << 8) | this[offset + 1]
		}
		Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(
			offset,
			noAssert
		) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 4, this.length)
			return (
				(this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +
				this[offset + 3] * 16777216
			)
		}
		Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(
			offset,
			noAssert
		) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 4, this.length)
			return (
				this[offset] * 16777216 +
				((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])
			)
		}
		Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
			offset = offset >>> 0
			validateNumber(offset, 'offset')
			const first = this[offset]
			const last2 = this[offset + 7]
			if (first === void 0 || last2 === void 0) {
				boundsError(offset, this.length - 8)
			}
			const lo =
				first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24
			const hi =
				this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24
			return BigInt(lo) + (BigInt(hi) << BigInt(32))
		})
		Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
			offset = offset >>> 0
			validateNumber(offset, 'offset')
			const first = this[offset]
			const last2 = this[offset + 7]
			if (first === void 0 || last2 === void 0) {
				boundsError(offset, this.length - 8)
			}
			const hi =
				first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset]
			const lo =
				this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2
			return (BigInt(hi) << BigInt(32)) + BigInt(lo)
		})
		Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
			offset = offset >>> 0
			byteLength2 = byteLength2 >>> 0
			if (!noAssert) checkOffset(offset, byteLength2, this.length)
			let val = this[offset]
			let mul = 1
			let i3 = 0
			while (++i3 < byteLength2 && (mul *= 256)) {
				val += this[offset + i3] * mul
			}
			mul *= 128
			if (val >= mul) val -= Math.pow(2, 8 * byteLength2)
			return val
		}
		Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
			offset = offset >>> 0
			byteLength2 = byteLength2 >>> 0
			if (!noAssert) checkOffset(offset, byteLength2, this.length)
			let i3 = byteLength2
			let mul = 1
			let val = this[offset + --i3]
			while (i3 > 0 && (mul *= 256)) {
				val += this[offset + --i3] * mul
			}
			mul *= 128
			if (val >= mul) val -= Math.pow(2, 8 * byteLength2)
			return val
		}
		Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 1, this.length)
			if (!(this[offset] & 128)) return this[offset]
			return (255 - this[offset] + 1) * -1
		}
		Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 2, this.length)
			const val = this[offset] | (this[offset + 1] << 8)
			return val & 32768 ? val | 4294901760 : val
		}
		Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 2, this.length)
			const val = this[offset + 1] | (this[offset] << 8)
			return val & 32768 ? val | 4294901760 : val
		}
		Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 4, this.length)
			return (
				this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24)
			)
		}
		Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 4, this.length)
			return (
				(this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]
			)
		}
		Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
			offset = offset >>> 0
			validateNumber(offset, 'offset')
			const first = this[offset]
			const last2 = this[offset + 7]
			if (first === void 0 || last2 === void 0) {
				boundsError(offset, this.length - 8)
			}
			const val =
				this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24)
			return (
				(BigInt(val) << BigInt(32)) +
				BigInt(
					first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24
				)
			)
		})
		Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
			offset = offset >>> 0
			validateNumber(offset, 'offset')
			const first = this[offset]
			const last2 = this[offset + 7]
			if (first === void 0 || last2 === void 0) {
				boundsError(offset, this.length - 8)
			}
			const val =
				(first << 24) + // Overflow
				this[++offset] * 2 ** 16 +
				this[++offset] * 2 ** 8 +
				this[++offset]
			return (
				(BigInt(val) << BigInt(32)) +
				BigInt(
					this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2
				)
			)
		})
		Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 4, this.length)
			return ieee754.read(this, offset, true, 23, 4)
		}
		Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 4, this.length)
			return ieee754.read(this, offset, false, 23, 4)
		}
		Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 8, this.length)
			return ieee754.read(this, offset, true, 52, 8)
		}
		Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
			offset = offset >>> 0
			if (!noAssert) checkOffset(offset, 8, this.length)
			return ieee754.read(this, offset, false, 52, 8)
		}
		function checkInt(buf, value, offset, ext, max, min2) {
			if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
			if (value > max || value < min2) throw new RangeError('"value" argument is out of bounds')
			if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}
		Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(
			value,
			offset,
			byteLength2,
			noAssert
		) {
			value = +value
			offset = offset >>> 0
			byteLength2 = byteLength2 >>> 0
			if (!noAssert) {
				const maxBytes = Math.pow(2, 8 * byteLength2) - 1
				checkInt(this, value, offset, byteLength2, maxBytes, 0)
			}
			let mul = 1
			let i3 = 0
			this[offset] = value & 255
			while (++i3 < byteLength2 && (mul *= 256)) {
				this[offset + i3] = (value / mul) & 255
			}
			return offset + byteLength2
		}
		Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(
			value,
			offset,
			byteLength2,
			noAssert
		) {
			value = +value
			offset = offset >>> 0
			byteLength2 = byteLength2 >>> 0
			if (!noAssert) {
				const maxBytes = Math.pow(2, 8 * byteLength2) - 1
				checkInt(this, value, offset, byteLength2, maxBytes, 0)
			}
			let i3 = byteLength2 - 1
			let mul = 1
			this[offset + i3] = value & 255
			while (--i3 >= 0 && (mul *= 256)) {
				this[offset + i3] = (value / mul) & 255
			}
			return offset + byteLength2
		}
		Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(
			value,
			offset,
			noAssert
		) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 1, 255, 0)
			this[offset] = value & 255
			return offset + 1
		}
		Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(
			value,
			offset,
			noAssert
		) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 2, 65535, 0)
			this[offset] = value & 255
			this[offset + 1] = value >>> 8
			return offset + 2
		}
		Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(
			value,
			offset,
			noAssert
		) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 2, 65535, 0)
			this[offset] = value >>> 8
			this[offset + 1] = value & 255
			return offset + 2
		}
		Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(
			value,
			offset,
			noAssert
		) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0)
			this[offset + 3] = value >>> 24
			this[offset + 2] = value >>> 16
			this[offset + 1] = value >>> 8
			this[offset] = value & 255
			return offset + 4
		}
		Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(
			value,
			offset,
			noAssert
		) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0)
			this[offset] = value >>> 24
			this[offset + 1] = value >>> 16
			this[offset + 2] = value >>> 8
			this[offset + 3] = value & 255
			return offset + 4
		}
		function wrtBigUInt64LE(buf, value, offset, min2, max) {
			checkIntBI(value, min2, max, buf, offset, 7)
			let lo = Number(value & BigInt(4294967295))
			buf[offset++] = lo
			lo = lo >> 8
			buf[offset++] = lo
			lo = lo >> 8
			buf[offset++] = lo
			lo = lo >> 8
			buf[offset++] = lo
			let hi = Number((value >> BigInt(32)) & BigInt(4294967295))
			buf[offset++] = hi
			hi = hi >> 8
			buf[offset++] = hi
			hi = hi >> 8
			buf[offset++] = hi
			hi = hi >> 8
			buf[offset++] = hi
			return offset
		}
		function wrtBigUInt64BE(buf, value, offset, min2, max) {
			checkIntBI(value, min2, max, buf, offset, 7)
			let lo = Number(value & BigInt(4294967295))
			buf[offset + 7] = lo
			lo = lo >> 8
			buf[offset + 6] = lo
			lo = lo >> 8
			buf[offset + 5] = lo
			lo = lo >> 8
			buf[offset + 4] = lo
			let hi = Number((value >> BigInt(32)) & BigInt(4294967295))
			buf[offset + 3] = hi
			hi = hi >> 8
			buf[offset + 2] = hi
			hi = hi >> 8
			buf[offset + 1] = hi
			hi = hi >> 8
			buf[offset] = hi
			return offset + 8
		}
		Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(
			value,
			offset = 0
		) {
			return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
		})
		Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(
			value,
			offset = 0
		) {
			return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
		})
		Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) {
				const limit = Math.pow(2, 8 * byteLength2 - 1)
				checkInt(this, value, offset, byteLength2, limit - 1, -limit)
			}
			let i3 = 0
			let mul = 1
			let sub = 0
			this[offset] = value & 255
			while (++i3 < byteLength2 && (mul *= 256)) {
				if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
					sub = 1
				}
				this[offset + i3] = (((value / mul) >> 0) - sub) & 255
			}
			return offset + byteLength2
		}
		Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) {
				const limit = Math.pow(2, 8 * byteLength2 - 1)
				checkInt(this, value, offset, byteLength2, limit - 1, -limit)
			}
			let i3 = byteLength2 - 1
			let mul = 1
			let sub = 0
			this[offset + i3] = value & 255
			while (--i3 >= 0 && (mul *= 256)) {
				if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
					sub = 1
				}
				this[offset + i3] = (((value / mul) >> 0) - sub) & 255
			}
			return offset + byteLength2
		}
		Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 1, 127, -128)
			if (value < 0) value = 255 + value + 1
			this[offset] = value & 255
			return offset + 1
		}
		Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768)
			this[offset] = value & 255
			this[offset + 1] = value >>> 8
			return offset + 2
		}
		Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768)
			this[offset] = value >>> 8
			this[offset + 1] = value & 255
			return offset + 2
		}
		Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648)
			this[offset] = value & 255
			this[offset + 1] = value >>> 8
			this[offset + 2] = value >>> 16
			this[offset + 3] = value >>> 24
			return offset + 4
		}
		Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648)
			if (value < 0) value = 4294967295 + value + 1
			this[offset] = value >>> 24
			this[offset + 1] = value >>> 16
			this[offset + 2] = value >>> 8
			this[offset + 3] = value & 255
			return offset + 4
		}
		Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(
			value,
			offset = 0
		) {
			return wrtBigUInt64LE(
				this,
				value,
				offset,
				-BigInt('0x8000000000000000'),
				BigInt('0x7fffffffffffffff')
			)
		})
		Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(
			value,
			offset = 0
		) {
			return wrtBigUInt64BE(
				this,
				value,
				offset,
				-BigInt('0x8000000000000000'),
				BigInt('0x7fffffffffffffff')
			)
		})
		function checkIEEE754(buf, value, offset, ext, max, min2) {
			if (offset + ext > buf.length) throw new RangeError('Index out of range')
			if (offset < 0) throw new RangeError('Index out of range')
		}
		function writeFloat(buf, value, offset, littleEndian, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) {
				checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22)
			}
			ieee754.write(buf, value, offset, littleEndian, 23, 4)
			return offset + 4
		}
		Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
			return writeFloat(this, value, offset, true, noAssert)
		}
		Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
			return writeFloat(this, value, offset, false, noAssert)
		}
		function writeDouble(buf, value, offset, littleEndian, noAssert) {
			value = +value
			offset = offset >>> 0
			if (!noAssert) {
				checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292)
			}
			ieee754.write(buf, value, offset, littleEndian, 52, 8)
			return offset + 8
		}
		Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
			return writeDouble(this, value, offset, true, noAssert)
		}
		Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
			return writeDouble(this, value, offset, false, noAssert)
		}
		Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
			if (!Buffer3.isBuffer(target)) throw new TypeError('argument should be a Buffer')
			if (!start) start = 0
			if (!end && end !== 0) end = this.length
			if (targetStart >= target.length) targetStart = target.length
			if (!targetStart) targetStart = 0
			if (end > 0 && end < start) end = start
			if (end === start) return 0
			if (target.length === 0 || this.length === 0) return 0
			if (targetStart < 0) {
				throw new RangeError('targetStart out of bounds')
			}
			if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
			if (end < 0) throw new RangeError('sourceEnd out of bounds')
			if (end > this.length) end = this.length
			if (target.length - targetStart < end - start) {
				end = target.length - targetStart + start
			}
			const len = end - start
			if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
				this.copyWithin(targetStart, start, end)
			} else {
				Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart)
			}
			return len
		}
		Buffer3.prototype.fill = function fill(val, start, end, encoding) {
			if (typeof val === 'string') {
				if (typeof start === 'string') {
					encoding = start
					start = 0
					end = this.length
				} else if (typeof end === 'string') {
					encoding = end
					end = this.length
				}
				if (encoding !== void 0 && typeof encoding !== 'string') {
					throw new TypeError('encoding must be a string')
				}
				if (typeof encoding === 'string' && !Buffer3.isEncoding(encoding)) {
					throw new TypeError('Unknown encoding: ' + encoding)
				}
				if (val.length === 1) {
					const code3 = val.charCodeAt(0)
					if ((encoding === 'utf8' && code3 < 128) || encoding === 'latin1') {
						val = code3
					}
				}
			} else if (typeof val === 'number') {
				val = val & 255
			} else if (typeof val === 'boolean') {
				val = Number(val)
			}
			if (start < 0 || this.length < start || this.length < end) {
				throw new RangeError('Out of range index')
			}
			if (end <= start) {
				return this
			}
			start = start >>> 0
			end = end === void 0 ? this.length : end >>> 0
			if (!val) val = 0
			let i3
			if (typeof val === 'number') {
				for (i3 = start; i3 < end; ++i3) {
					this[i3] = val
				}
			} else {
				const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding)
				const len = bytes.length
				if (len === 0) {
					throw new TypeError('The value "' + val + '" is invalid for argument "value"')
				}
				for (i3 = 0; i3 < end - start; ++i3) {
					this[i3 + start] = bytes[i3 % len]
				}
			}
			return this
		}
		var errors = {}
		function E3(sym, getMessage, Base) {
			errors[sym] = class NodeError extends Base {
				constructor() {
					super()
					Object.defineProperty(this, 'message', {
						value: getMessage.apply(this, arguments),
						writable: true,
						configurable: true,
					})
					this.name = `${this.name} [${sym}]`
					this.stack
					delete this.name
				}
				get code() {
					return sym
				}
				set code(value) {
					Object.defineProperty(this, 'code', {
						configurable: true,
						enumerable: true,
						value,
						writable: true,
					})
				}
				toString() {
					return `${this.name} [${sym}]: ${this.message}`
				}
			}
		}
		E3(
			'ERR_BUFFER_OUT_OF_BOUNDS',
			function (name) {
				if (name) {
					return `${name} is outside of buffer bounds`
				}
				return 'Attempt to access memory outside buffer bounds'
			},
			RangeError
		)
		E3(
			'ERR_INVALID_ARG_TYPE',
			function (name, actual) {
				return `The "${name}" argument must be of type number. Received type ${typeof actual}`
			},
			TypeError
		)
		E3(
			'ERR_OUT_OF_RANGE',
			function (str, range, input) {
				let msg2 = `The value of "${str}" is out of range.`
				let received = input
				if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
					received = addNumericalSeparator(String(input))
				} else if (typeof input === 'bigint') {
					received = String(input)
					if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
						received = addNumericalSeparator(received)
					}
					received += 'n'
				}
				msg2 += ` It must be ${range}. Received ${received}`
				return msg2
			},
			RangeError
		)
		function addNumericalSeparator(val) {
			let res = ''
			let i3 = val.length
			const start = val[0] === '-' ? 1 : 0
			for (; i3 >= start + 4; i3 -= 3) {
				res = `_${val.slice(i3 - 3, i3)}${res}`
			}
			return `${val.slice(0, i3)}${res}`
		}
		function checkBounds(buf, offset, byteLength2) {
			validateNumber(offset, 'offset')
			if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
				boundsError(offset, buf.length - (byteLength2 + 1))
			}
		}
		function checkIntBI(value, min2, max, buf, offset, byteLength2) {
			if (value > max || value < min2) {
				const n3 = typeof min2 === 'bigint' ? 'n' : ''
				let range
				if (byteLength2 > 3) {
					if (min2 === 0 || min2 === BigInt(0)) {
						range = `>= 0${n3} and < 2${n3} ** ${(byteLength2 + 1) * 8}${n3}`
					} else {
						range = `>= -(2${n3} ** ${(byteLength2 + 1) * 8 - 1}${n3}) and < 2 ** ${
							(byteLength2 + 1) * 8 - 1
						}${n3}`
					}
				} else {
					range = `>= ${min2}${n3} and <= ${max}${n3}`
				}
				throw new errors.ERR_OUT_OF_RANGE('value', range, value)
			}
			checkBounds(buf, offset, byteLength2)
		}
		function validateNumber(value, name) {
			if (typeof value !== 'number') {
				throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
			}
		}
		function boundsError(value, length, type) {
			if (Math.floor(value) !== value) {
				validateNumber(value, type)
				throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
			}
			if (length < 0) {
				throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
			}
			throw new errors.ERR_OUT_OF_RANGE(
				type || 'offset',
				`>= ${type ? 1 : 0} and <= ${length}`,
				value
			)
		}
		var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
		function base64clean(str) {
			str = str.split('=')[0]
			str = str.trim().replace(INVALID_BASE64_RE, '')
			if (str.length < 2) return ''
			while (str.length % 4 !== 0) {
				str = str + '='
			}
			return str
		}
		function utf8ToBytes(string2, units) {
			units = units || Infinity
			let codePoint
			const length = string2.length
			let leadSurrogate = null
			const bytes = []
			for (let i3 = 0; i3 < length; ++i3) {
				codePoint = string2.charCodeAt(i3)
				if (codePoint > 55295 && codePoint < 57344) {
					if (!leadSurrogate) {
						if (codePoint > 56319) {
							if ((units -= 3) > -1) bytes.push(239, 191, 189)
							continue
						} else if (i3 + 1 === length) {
							if ((units -= 3) > -1) bytes.push(239, 191, 189)
							continue
						}
						leadSurrogate = codePoint
						continue
					}
					if (codePoint < 56320) {
						if ((units -= 3) > -1) bytes.push(239, 191, 189)
						leadSurrogate = codePoint
						continue
					}
					codePoint = (((leadSurrogate - 55296) << 10) | (codePoint - 56320)) + 65536
				} else if (leadSurrogate) {
					if ((units -= 3) > -1) bytes.push(239, 191, 189)
				}
				leadSurrogate = null
				if (codePoint < 128) {
					if ((units -= 1) < 0) break
					bytes.push(codePoint)
				} else if (codePoint < 2048) {
					if ((units -= 2) < 0) break
					bytes.push((codePoint >> 6) | 192, (codePoint & 63) | 128)
				} else if (codePoint < 65536) {
					if ((units -= 3) < 0) break
					bytes.push((codePoint >> 12) | 224, ((codePoint >> 6) & 63) | 128, (codePoint & 63) | 128)
				} else if (codePoint < 1114112) {
					if ((units -= 4) < 0) break
					bytes.push(
						(codePoint >> 18) | 240,
						((codePoint >> 12) & 63) | 128,
						((codePoint >> 6) & 63) | 128,
						(codePoint & 63) | 128
					)
				} else {
					throw new Error('Invalid code point')
				}
			}
			return bytes
		}
		function asciiToBytes(str) {
			const byteArray = []
			for (let i3 = 0; i3 < str.length; ++i3) {
				byteArray.push(str.charCodeAt(i3) & 255)
			}
			return byteArray
		}
		function utf16leToBytes(str, units) {
			let c3, hi, lo
			const byteArray = []
			for (let i3 = 0; i3 < str.length; ++i3) {
				if ((units -= 2) < 0) break
				c3 = str.charCodeAt(i3)
				hi = c3 >> 8
				lo = c3 % 256
				byteArray.push(lo)
				byteArray.push(hi)
			}
			return byteArray
		}
		function base64ToBytes(str) {
			return base64.toByteArray(base64clean(str))
		}
		function blitBuffer(src, dst, offset, length) {
			let i3
			for (i3 = 0; i3 < length; ++i3) {
				if (i3 + offset >= dst.length || i3 >= src.length) break
				dst[i3 + offset] = src[i3]
			}
			return i3
		}
		function isInstance(obj, type) {
			return (
				obj instanceof type ||
				(obj != null &&
					obj.constructor != null &&
					obj.constructor.name != null &&
					obj.constructor.name === type.name)
			)
		}
		function numberIsNaN(obj) {
			return obj !== obj
		}
		var hexSliceLookupTable = (function () {
			const alphabet = '0123456789abcdef'
			const table = new Array(256)
			for (let i3 = 0; i3 < 16; ++i3) {
				const i16 = i3 * 16
				for (let j = 0; j < 16; ++j) {
					table[i16 + j] = alphabet[i3] + alphabet[j]
				}
			}
			return table
		})()
		function defineBigIntMethod(fn) {
			return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
		}
		function BufferBigIntNotDefined() {
			throw new Error('BigInt not supported')
		}
	},
})

// ../node_modules/classnames/index.js
var require_classnames = __commonJS({
	'../node_modules/classnames/index.js'(exports, module2) {
		init_define_process()
		;(function () {
			'use strict'
			var hasOwn = {}.hasOwnProperty
			var nativeCodeString = '[native code]'
			function classNames21() {
				var classes = []
				for (var i3 = 0; i3 < arguments.length; i3++) {
					var arg = arguments[i3]
					if (!arg) continue
					var argType = typeof arg
					if (argType === 'string' || argType === 'number') {
						classes.push(arg)
					} else if (Array.isArray(arg)) {
						if (arg.length) {
							var inner = classNames21.apply(null, arg)
							if (inner) {
								classes.push(inner)
							}
						}
					} else if (argType === 'object') {
						if (
							arg.toString !== Object.prototype.toString &&
							!arg.toString.toString().includes('[native code]')
						) {
							classes.push(arg.toString())
							continue
						}
						for (var key in arg) {
							if (hasOwn.call(arg, key) && arg[key]) {
								classes.push(key)
							}
						}
					}
				}
				return classes.join(' ')
			}
			if (typeof module2 !== 'undefined' && module2.exports) {
				classNames21.default = classNames21
				module2.exports = classNames21
			} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
				define('classnames', [], function () {
					return classNames21
				})
			} else {
				window.classNames = classNames21
			}
		})()
	},
})

// ../node_modules/lodash.throttle/index.js
var require_lodash3 = __commonJS({
	'../node_modules/lodash.throttle/index.js'(exports, module2) {
		init_define_process()
		var FUNC_ERROR_TEXT = 'Expected a function'
		var NAN = 0 / 0
		var symbolTag = '[object Symbol]'
		var reTrim = /^\s+|\s+$/g
		var reIsBadHex = /^[-+]0x[0-9a-f]+$/i
		var reIsBinary = /^0b[01]+$/i
		var reIsOctal = /^0o[0-7]+$/i
		var freeParseInt = parseInt
		var freeGlobal = typeof global == 'object' && global && global.Object === Object && global
		var freeSelf = typeof self == 'object' && self && self.Object === Object && self
		var root2 = freeGlobal || freeSelf || Function('return this')()
		var objectProto = Object.prototype
		var objectToString = objectProto.toString
		var nativeMax = Math.max
		var nativeMin = Math.min
		var now = function () {
			return root2.Date.now()
		}
		function debounce2(func, wait, options) {
			var lastArgs,
				lastThis,
				maxWait,
				result,
				timerId,
				lastCallTime,
				lastInvokeTime = 0,
				leading = false,
				maxing = false,
				trailing = true
			if (typeof func != 'function') {
				throw new TypeError(FUNC_ERROR_TEXT)
			}
			wait = toNumber(wait) || 0
			if (isObject(options)) {
				leading = !!options.leading
				maxing = 'maxWait' in options
				maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait
				trailing = 'trailing' in options ? !!options.trailing : trailing
			}
			function invokeFunc(time) {
				var args = lastArgs,
					thisArg = lastThis
				lastArgs = lastThis = void 0
				lastInvokeTime = time
				result = func.apply(thisArg, args)
				return result
			}
			function leadingEdge(time) {
				lastInvokeTime = time
				timerId = setTimeout(timerExpired, wait)
				return leading ? invokeFunc(time) : result
			}
			function remainingWait(time) {
				var timeSinceLastCall = time - lastCallTime,
					timeSinceLastInvoke = time - lastInvokeTime,
					result2 = wait - timeSinceLastCall
				return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2
			}
			function shouldInvoke(time) {
				var timeSinceLastCall = time - lastCallTime,
					timeSinceLastInvoke = time - lastInvokeTime
				return (
					lastCallTime === void 0 ||
					timeSinceLastCall >= wait ||
					timeSinceLastCall < 0 ||
					(maxing && timeSinceLastInvoke >= maxWait)
				)
			}
			function timerExpired() {
				var time = now()
				if (shouldInvoke(time)) {
					return trailingEdge(time)
				}
				timerId = setTimeout(timerExpired, remainingWait(time))
			}
			function trailingEdge(time) {
				timerId = void 0
				if (trailing && lastArgs) {
					return invokeFunc(time)
				}
				lastArgs = lastThis = void 0
				return result
			}
			function cancel() {
				if (timerId !== void 0) {
					clearTimeout(timerId)
				}
				lastInvokeTime = 0
				lastArgs = lastCallTime = lastThis = timerId = void 0
			}
			function flush() {
				return timerId === void 0 ? result : trailingEdge(now())
			}
			function debounced() {
				var time = now(),
					isInvoking = shouldInvoke(time)
				lastArgs = arguments
				lastThis = this
				lastCallTime = time
				if (isInvoking) {
					if (timerId === void 0) {
						return leadingEdge(lastCallTime)
					}
					if (maxing) {
						timerId = setTimeout(timerExpired, wait)
						return invokeFunc(lastCallTime)
					}
				}
				if (timerId === void 0) {
					timerId = setTimeout(timerExpired, wait)
				}
				return result
			}
			debounced.cancel = cancel
			debounced.flush = flush
			return debounced
		}
		function throttle4(func, wait, options) {
			var leading = true,
				trailing = true
			if (typeof func != 'function') {
				throw new TypeError(FUNC_ERROR_TEXT)
			}
			if (isObject(options)) {
				leading = 'leading' in options ? !!options.leading : leading
				trailing = 'trailing' in options ? !!options.trailing : trailing
			}
			return debounce2(func, wait, {
				leading: leading,
				maxWait: wait,
				trailing: trailing,
			})
		}
		function isObject(value) {
			var type = typeof value
			return !!value && (type == 'object' || type == 'function')
		}
		function isObjectLike(value) {
			return !!value && typeof value == 'object'
		}
		function isSymbol(value) {
			return (
				typeof value == 'symbol' || (isObjectLike(value) && objectToString.call(value) == symbolTag)
			)
		}
		function toNumber(value) {
			if (typeof value == 'number') {
				return value
			}
			if (isSymbol(value)) {
				return NAN
			}
			if (isObject(value)) {
				var other = typeof value.valueOf == 'function' ? value.valueOf() : value
				value = isObject(other) ? other + '' : other
			}
			if (typeof value != 'string') {
				return value === 0 ? value : +value
			}
			value = value.replace(reTrim, '')
			var isBinary = reIsBinary.test(value)
			return isBinary || reIsOctal.test(value)
				? freeParseInt(value.slice(2), isBinary ? 2 : 8)
				: reIsBadHex.test(value)
				? NAN
				: +value
		}
		module2.exports = throttle4
	},
})

// ../node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
	'../node_modules/scheduler/cjs/scheduler.production.min.js'(exports) {
		'use strict'
		init_define_process()
		function f3(a3, b3) {
			var c3 = a3.length
			a3.push(b3)
			a: for (; 0 < c3; ) {
				var d3 = (c3 - 1) >>> 1,
					e2 = a3[d3]
				if (0 < g3(e2, b3)) (a3[d3] = b3), (a3[c3] = e2), (c3 = d3)
				else break a
			}
		}
		function h3(a3) {
			return 0 === a3.length ? null : a3[0]
		}
		function k2(a3) {
			if (0 === a3.length) return null
			var b3 = a3[0],
				c3 = a3.pop()
			if (c3 !== b3) {
				a3[0] = c3
				a: for (var d3 = 0, e2 = a3.length, w3 = e2 >>> 1; d3 < w3; ) {
					var m3 = 2 * (d3 + 1) - 1,
						C2 = a3[m3],
						n3 = m3 + 1,
						x3 = a3[n3]
					if (0 > g3(C2, c3))
						n3 < e2 && 0 > g3(x3, C2)
							? ((a3[d3] = x3), (a3[n3] = c3), (d3 = n3))
							: ((a3[d3] = C2), (a3[m3] = c3), (d3 = m3))
					else if (n3 < e2 && 0 > g3(x3, c3)) (a3[d3] = x3), (a3[n3] = c3), (d3 = n3)
					else break a
				}
			}
			return b3
		}
		function g3(a3, b3) {
			var c3 = a3.sortIndex - b3.sortIndex
			return 0 !== c3 ? c3 : a3.id - b3.id
		}
		if ('object' === typeof performance && 'function' === typeof performance.now) {
			l3 = performance
			exports.unstable_now = function () {
				return l3.now()
			}
		} else {
			;(p3 = Date), (q = p3.now())
			exports.unstable_now = function () {
				return p3.now() - q
			}
		}
		var l3
		var p3
		var q
		var r3 = []
		var t4 = []
		var u3 = 1
		var v3 = null
		var y3 = 3
		var z2 = false
		var A2 = false
		var B = false
		var D3 = 'function' === typeof setTimeout ? setTimeout : null
		var E3 = 'function' === typeof clearTimeout ? clearTimeout : null
		var F = 'undefined' !== typeof setImmediate ? setImmediate : null
		'undefined' !== typeof navigator &&
			void 0 !== navigator.scheduling &&
			void 0 !== navigator.scheduling.isInputPending &&
			navigator.scheduling.isInputPending.bind(navigator.scheduling)
		function G(a3) {
			for (var b3 = h3(t4); null !== b3; ) {
				if (null === b3.callback) k2(t4)
				else if (b3.startTime <= a3) k2(t4), (b3.sortIndex = b3.expirationTime), f3(r3, b3)
				else break
				b3 = h3(t4)
			}
		}
		function H2(a3) {
			B = false
			G(a3)
			if (!A2)
				if (null !== h3(r3)) (A2 = true), I(J)
				else {
					var b3 = h3(t4)
					null !== b3 && K(H2, b3.startTime - a3)
				}
		}
		function J(a3, b3) {
			A2 = false
			B && ((B = false), E3(L3), (L3 = -1))
			z2 = true
			var c3 = y3
			try {
				G(b3)
				for (v3 = h3(r3); null !== v3 && (!(v3.expirationTime > b3) || (a3 && !M())); ) {
					var d3 = v3.callback
					if ('function' === typeof d3) {
						v3.callback = null
						y3 = v3.priorityLevel
						var e2 = d3(v3.expirationTime <= b3)
						b3 = exports.unstable_now()
						'function' === typeof e2 ? (v3.callback = e2) : v3 === h3(r3) && k2(r3)
						G(b3)
					} else k2(r3)
					v3 = h3(r3)
				}
				if (null !== v3) var w3 = true
				else {
					var m3 = h3(t4)
					null !== m3 && K(H2, m3.startTime - b3)
					w3 = false
				}
				return w3
			} finally {
				;(v3 = null), (y3 = c3), (z2 = false)
			}
		}
		var N2 = false
		var O2 = null
		var L3 = -1
		var P2 = 5
		var Q = -1
		function M() {
			return exports.unstable_now() - Q < P2 ? false : true
		}
		function R3() {
			if (null !== O2) {
				var a3 = exports.unstable_now()
				Q = a3
				var b3 = true
				try {
					b3 = O2(true, a3)
				} finally {
					b3 ? S2() : ((N2 = false), (O2 = null))
				}
			} else N2 = false
		}
		var S2
		if ('function' === typeof F)
			S2 = function () {
				F(R3)
			}
		else if ('undefined' !== typeof MessageChannel) {
			;(T3 = new MessageChannel()), (U = T3.port2)
			T3.port1.onmessage = R3
			S2 = function () {
				U.postMessage(null)
			}
		} else
			S2 = function () {
				D3(R3, 0)
			}
		var T3
		var U
		function I(a3) {
			O2 = a3
			N2 || ((N2 = true), S2())
		}
		function K(a3, b3) {
			L3 = D3(function () {
				a3(exports.unstable_now())
			}, b3)
		}
		exports.unstable_IdlePriority = 5
		exports.unstable_ImmediatePriority = 1
		exports.unstable_LowPriority = 4
		exports.unstable_NormalPriority = 3
		exports.unstable_Profiling = null
		exports.unstable_UserBlockingPriority = 2
		exports.unstable_cancelCallback = function (a3) {
			a3.callback = null
		}
		exports.unstable_continueExecution = function () {
			A2 || z2 || ((A2 = true), I(J))
		}
		exports.unstable_forceFrameRate = function (a3) {
			0 > a3 || 125 < a3
				? console.error(
						'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
				  )
				: (P2 = 0 < a3 ? Math.floor(1e3 / a3) : 5)
		}
		exports.unstable_getCurrentPriorityLevel = function () {
			return y3
		}
		exports.unstable_getFirstCallbackNode = function () {
			return h3(r3)
		}
		exports.unstable_next = function (a3) {
			switch (y3) {
				case 1:
				case 2:
				case 3:
					var b3 = 3
					break
				default:
					b3 = y3
			}
			var c3 = y3
			y3 = b3
			try {
				return a3()
			} finally {
				y3 = c3
			}
		}
		exports.unstable_pauseExecution = function () {}
		exports.unstable_requestPaint = function () {}
		exports.unstable_runWithPriority = function (a3, b3) {
			switch (a3) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
					break
				default:
					a3 = 3
			}
			var c3 = y3
			y3 = a3
			try {
				return b3()
			} finally {
				y3 = c3
			}
		}
		exports.unstable_scheduleCallback = function (a3, b3, c3) {
			var d3 = exports.unstable_now()
			'object' === typeof c3 && null !== c3
				? ((c3 = c3.delay), (c3 = 'number' === typeof c3 && 0 < c3 ? d3 + c3 : d3))
				: (c3 = d3)
			switch (a3) {
				case 1:
					var e2 = -1
					break
				case 2:
					e2 = 250
					break
				case 5:
					e2 = 1073741823
					break
				case 4:
					e2 = 1e4
					break
				default:
					e2 = 5e3
			}
			e2 = c3 + e2
			a3 = {
				id: u3++,
				callback: b3,
				priorityLevel: a3,
				startTime: c3,
				expirationTime: e2,
				sortIndex: -1,
			}
			c3 > d3
				? ((a3.sortIndex = c3),
				  f3(t4, a3),
				  null === h3(r3) &&
						a3 === h3(t4) &&
						(B ? (E3(L3), (L3 = -1)) : (B = true), K(H2, c3 - d3)))
				: ((a3.sortIndex = e2), f3(r3, a3), A2 || z2 || ((A2 = true), I(J)))
			return a3
		}
		exports.unstable_shouldYield = M
		exports.unstable_wrapCallback = function (a3) {
			var b3 = y3
			return function () {
				var c3 = y3
				y3 = b3
				try {
					return a3.apply(this, arguments)
				} finally {
					y3 = c3
				}
			}
		}
	},
})

// ../node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
	'../node_modules/scheduler/cjs/scheduler.development.js'(exports) {
		'use strict'
		init_define_process()
		if (define_process_default.env.NODE_ENV !== 'production') {
			;(function () {
				'use strict'
				if (
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function'
				) {
					__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
				}
				var enableSchedulerDebugging = false
				var enableProfiling = false
				var frameYieldMs = 5
				function push(heap, node) {
					var index2 = heap.length
					heap.push(node)
					siftUp(heap, node, index2)
				}
				function peek(heap) {
					return heap.length === 0 ? null : heap[0]
				}
				function pop(heap) {
					if (heap.length === 0) {
						return null
					}
					var first = heap[0]
					var last2 = heap.pop()
					if (last2 !== first) {
						heap[0] = last2
						siftDown(heap, last2, 0)
					}
					return first
				}
				function siftUp(heap, node, i3) {
					var index2 = i3
					while (index2 > 0) {
						var parentIndex = (index2 - 1) >>> 1
						var parent = heap[parentIndex]
						if (compare(parent, node) > 0) {
							heap[parentIndex] = node
							heap[index2] = parent
							index2 = parentIndex
						} else {
							return
						}
					}
				}
				function siftDown(heap, node, i3) {
					var index2 = i3
					var length = heap.length
					var halfLength = length >>> 1
					while (index2 < halfLength) {
						var leftIndex = (index2 + 1) * 2 - 1
						var left = heap[leftIndex]
						var rightIndex = leftIndex + 1
						var right = heap[rightIndex]
						if (compare(left, node) < 0) {
							if (rightIndex < length && compare(right, left) < 0) {
								heap[index2] = right
								heap[rightIndex] = node
								index2 = rightIndex
							} else {
								heap[index2] = left
								heap[leftIndex] = node
								index2 = leftIndex
							}
						} else if (rightIndex < length && compare(right, node) < 0) {
							heap[index2] = right
							heap[rightIndex] = node
							index2 = rightIndex
						} else {
							return
						}
					}
				}
				function compare(a3, b3) {
					var diff = a3.sortIndex - b3.sortIndex
					return diff !== 0 ? diff : a3.id - b3.id
				}
				var ImmediatePriority = 1
				var UserBlockingPriority = 2
				var NormalPriority = 3
				var LowPriority = 4
				var IdlePriority = 5
				function markTaskErrored(task, ms) {}
				var hasPerformanceNow =
					typeof performance === 'object' && typeof performance.now === 'function'
				if (hasPerformanceNow) {
					var localPerformance = performance
					exports.unstable_now = function () {
						return localPerformance.now()
					}
				} else {
					var localDate = Date
					var initialTime = localDate.now()
					exports.unstable_now = function () {
						return localDate.now() - initialTime
					}
				}
				var maxSigned31BitInt = 1073741823
				var IMMEDIATE_PRIORITY_TIMEOUT = -1
				var USER_BLOCKING_PRIORITY_TIMEOUT = 250
				var NORMAL_PRIORITY_TIMEOUT = 5e3
				var LOW_PRIORITY_TIMEOUT = 1e4
				var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt
				var taskQueue = []
				var timerQueue = []
				var taskIdCounter = 1
				var currentTask = null
				var currentPriorityLevel = NormalPriority
				var isPerformingWork = false
				var isHostCallbackScheduled = false
				var isHostTimeoutScheduled = false
				var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null
				var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null
				var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null
				var isInputPending =
					typeof navigator !== 'undefined' &&
					navigator.scheduling !== void 0 &&
					navigator.scheduling.isInputPending !== void 0
						? navigator.scheduling.isInputPending.bind(navigator.scheduling)
						: null
				function advanceTimers(currentTime) {
					var timer = peek(timerQueue)
					while (timer !== null) {
						if (timer.callback === null) {
							pop(timerQueue)
						} else if (timer.startTime <= currentTime) {
							pop(timerQueue)
							timer.sortIndex = timer.expirationTime
							push(taskQueue, timer)
						} else {
							return
						}
						timer = peek(timerQueue)
					}
				}
				function handleTimeout(currentTime) {
					isHostTimeoutScheduled = false
					advanceTimers(currentTime)
					if (!isHostCallbackScheduled) {
						if (peek(taskQueue) !== null) {
							isHostCallbackScheduled = true
							requestHostCallback(flushWork)
						} else {
							var firstTimer = peek(timerQueue)
							if (firstTimer !== null) {
								requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime)
							}
						}
					}
				}
				function flushWork(hasTimeRemaining, initialTime2) {
					isHostCallbackScheduled = false
					if (isHostTimeoutScheduled) {
						isHostTimeoutScheduled = false
						cancelHostTimeout()
					}
					isPerformingWork = true
					var previousPriorityLevel = currentPriorityLevel
					try {
						if (enableProfiling) {
							try {
								return workLoop(hasTimeRemaining, initialTime2)
							} catch (error) {
								if (currentTask !== null) {
									var currentTime = exports.unstable_now()
									markTaskErrored(currentTask, currentTime)
									currentTask.isQueued = false
								}
								throw error
							}
						} else {
							return workLoop(hasTimeRemaining, initialTime2)
						}
					} finally {
						currentTask = null
						currentPriorityLevel = previousPriorityLevel
						isPerformingWork = false
					}
				}
				function workLoop(hasTimeRemaining, initialTime2) {
					var currentTime = initialTime2
					advanceTimers(currentTime)
					currentTask = peek(taskQueue)
					while (currentTask !== null && !enableSchedulerDebugging) {
						if (
							currentTask.expirationTime > currentTime &&
							(!hasTimeRemaining || shouldYieldToHost())
						) {
							break
						}
						var callback = currentTask.callback
						if (typeof callback === 'function') {
							currentTask.callback = null
							currentPriorityLevel = currentTask.priorityLevel
							var didUserCallbackTimeout = currentTask.expirationTime <= currentTime
							var continuationCallback = callback(didUserCallbackTimeout)
							currentTime = exports.unstable_now()
							if (typeof continuationCallback === 'function') {
								currentTask.callback = continuationCallback
							} else {
								if (currentTask === peek(taskQueue)) {
									pop(taskQueue)
								}
							}
							advanceTimers(currentTime)
						} else {
							pop(taskQueue)
						}
						currentTask = peek(taskQueue)
					}
					if (currentTask !== null) {
						return true
					} else {
						var firstTimer = peek(timerQueue)
						if (firstTimer !== null) {
							requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime)
						}
						return false
					}
				}
				function unstable_runWithPriority(priorityLevel, eventHandler2) {
					switch (priorityLevel) {
						case ImmediatePriority:
						case UserBlockingPriority:
						case NormalPriority:
						case LowPriority:
						case IdlePriority:
							break
						default:
							priorityLevel = NormalPriority
					}
					var previousPriorityLevel = currentPriorityLevel
					currentPriorityLevel = priorityLevel
					try {
						return eventHandler2()
					} finally {
						currentPriorityLevel = previousPriorityLevel
					}
				}
				function unstable_next(eventHandler2) {
					var priorityLevel
					switch (currentPriorityLevel) {
						case ImmediatePriority:
						case UserBlockingPriority:
						case NormalPriority:
							priorityLevel = NormalPriority
							break
						default:
							priorityLevel = currentPriorityLevel
							break
					}
					var previousPriorityLevel = currentPriorityLevel
					currentPriorityLevel = priorityLevel
					try {
						return eventHandler2()
					} finally {
						currentPriorityLevel = previousPriorityLevel
					}
				}
				function unstable_wrapCallback(callback) {
					var parentPriorityLevel = currentPriorityLevel
					return function () {
						var previousPriorityLevel = currentPriorityLevel
						currentPriorityLevel = parentPriorityLevel
						try {
							return callback.apply(this, arguments)
						} finally {
							currentPriorityLevel = previousPriorityLevel
						}
					}
				}
				function unstable_scheduleCallback(priorityLevel, callback, options) {
					var currentTime = exports.unstable_now()
					var startTime2
					if (typeof options === 'object' && options !== null) {
						var delay = options.delay
						if (typeof delay === 'number' && delay > 0) {
							startTime2 = currentTime + delay
						} else {
							startTime2 = currentTime
						}
					} else {
						startTime2 = currentTime
					}
					var timeout
					switch (priorityLevel) {
						case ImmediatePriority:
							timeout = IMMEDIATE_PRIORITY_TIMEOUT
							break
						case UserBlockingPriority:
							timeout = USER_BLOCKING_PRIORITY_TIMEOUT
							break
						case IdlePriority:
							timeout = IDLE_PRIORITY_TIMEOUT
							break
						case LowPriority:
							timeout = LOW_PRIORITY_TIMEOUT
							break
						case NormalPriority:
						default:
							timeout = NORMAL_PRIORITY_TIMEOUT
							break
					}
					var expirationTime = startTime2 + timeout
					var newTask = {
						id: taskIdCounter++,
						callback,
						priorityLevel,
						startTime: startTime2,
						expirationTime,
						sortIndex: -1,
					}
					if (startTime2 > currentTime) {
						newTask.sortIndex = startTime2
						push(timerQueue, newTask)
						if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
							if (isHostTimeoutScheduled) {
								cancelHostTimeout()
							} else {
								isHostTimeoutScheduled = true
							}
							requestHostTimeout(handleTimeout, startTime2 - currentTime)
						}
					} else {
						newTask.sortIndex = expirationTime
						push(taskQueue, newTask)
						if (!isHostCallbackScheduled && !isPerformingWork) {
							isHostCallbackScheduled = true
							requestHostCallback(flushWork)
						}
					}
					return newTask
				}
				function unstable_pauseExecution() {}
				function unstable_continueExecution() {
					if (!isHostCallbackScheduled && !isPerformingWork) {
						isHostCallbackScheduled = true
						requestHostCallback(flushWork)
					}
				}
				function unstable_getFirstCallbackNode() {
					return peek(taskQueue)
				}
				function unstable_cancelCallback(task) {
					task.callback = null
				}
				function unstable_getCurrentPriorityLevel() {
					return currentPriorityLevel
				}
				var isMessageLoopRunning = false
				var scheduledHostCallback = null
				var taskTimeoutID = -1
				var frameInterval = frameYieldMs
				var startTime = -1
				function shouldYieldToHost() {
					var timeElapsed = exports.unstable_now() - startTime
					if (timeElapsed < frameInterval) {
						return false
					}
					return true
				}
				function requestPaint() {}
				function forceFrameRate(fps) {
					if (fps < 0 || fps > 125) {
						console['error'](
							'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
						)
						return
					}
					if (fps > 0) {
						frameInterval = Math.floor(1e3 / fps)
					} else {
						frameInterval = frameYieldMs
					}
				}
				var performWorkUntilDeadline = function () {
					if (scheduledHostCallback !== null) {
						var currentTime = exports.unstable_now()
						startTime = currentTime
						var hasTimeRemaining = true
						var hasMoreWork = true
						try {
							hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime)
						} finally {
							if (hasMoreWork) {
								schedulePerformWorkUntilDeadline()
							} else {
								isMessageLoopRunning = false
								scheduledHostCallback = null
							}
						}
					} else {
						isMessageLoopRunning = false
					}
				}
				var schedulePerformWorkUntilDeadline
				if (typeof localSetImmediate === 'function') {
					schedulePerformWorkUntilDeadline = function () {
						localSetImmediate(performWorkUntilDeadline)
					}
				} else if (typeof MessageChannel !== 'undefined') {
					var channel2 = new MessageChannel()
					var port = channel2.port2
					channel2.port1.onmessage = performWorkUntilDeadline
					schedulePerformWorkUntilDeadline = function () {
						port.postMessage(null)
					}
				} else {
					schedulePerformWorkUntilDeadline = function () {
						localSetTimeout(performWorkUntilDeadline, 0)
					}
				}
				function requestHostCallback(callback) {
					scheduledHostCallback = callback
					if (!isMessageLoopRunning) {
						isMessageLoopRunning = true
						schedulePerformWorkUntilDeadline()
					}
				}
				function requestHostTimeout(callback, ms) {
					taskTimeoutID = localSetTimeout(function () {
						callback(exports.unstable_now())
					}, ms)
				}
				function cancelHostTimeout() {
					localClearTimeout(taskTimeoutID)
					taskTimeoutID = -1
				}
				var unstable_requestPaint = requestPaint
				var unstable_Profiling = null
				exports.unstable_IdlePriority = IdlePriority
				exports.unstable_ImmediatePriority = ImmediatePriority
				exports.unstable_LowPriority = LowPriority
				exports.unstable_NormalPriority = NormalPriority
				exports.unstable_Profiling = unstable_Profiling
				exports.unstable_UserBlockingPriority = UserBlockingPriority
				exports.unstable_cancelCallback = unstable_cancelCallback
				exports.unstable_continueExecution = unstable_continueExecution
				exports.unstable_forceFrameRate = forceFrameRate
				exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel
				exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode
				exports.unstable_next = unstable_next
				exports.unstable_pauseExecution = unstable_pauseExecution
				exports.unstable_requestPaint = unstable_requestPaint
				exports.unstable_runWithPriority = unstable_runWithPriority
				exports.unstable_scheduleCallback = unstable_scheduleCallback
				exports.unstable_shouldYield = shouldYieldToHost
				exports.unstable_wrapCallback = unstable_wrapCallback
				if (
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function'
				) {
					__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
				}
			})()
		}
	},
})

// ../node_modules/scheduler/index.js
var require_scheduler = __commonJS({
	'../node_modules/scheduler/index.js'(exports, module2) {
		'use strict'
		init_define_process()
		if (define_process_default.env.NODE_ENV === 'production') {
			module2.exports = require_scheduler_production_min()
		} else {
			module2.exports = require_scheduler_development()
		}
	},
})

// ../node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
	'../node_modules/react-dom/cjs/react-dom.production.min.js'(exports) {
		'use strict'
		init_define_process()
		var aa = require_react()
		var ca = require_scheduler()
		function p3(a3) {
			for (
				var b3 = 'https://reactjs.org/docs/error-decoder.html?invariant=' + a3, c3 = 1;
				c3 < arguments.length;
				c3++
			)
				b3 += '&args[]=' + encodeURIComponent(arguments[c3])
			return (
				'Minified React error #' +
				a3 +
				'; visit ' +
				b3 +
				' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
			)
		}
		var da = /* @__PURE__ */ new Set()
		var ea = {}
		function fa(a3, b3) {
			ha(a3, b3)
			ha(a3 + 'Capture', b3)
		}
		function ha(a3, b3) {
			ea[a3] = b3
			for (a3 = 0; a3 < b3.length; a3++) da.add(b3[a3])
		}
		var ia = !(
			'undefined' === typeof window ||
			'undefined' === typeof window.document ||
			'undefined' === typeof window.document.createElement
		)
		var ja = Object.prototype.hasOwnProperty
		var ka =
			/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
		var la = {}
		var ma = {}
		function oa(a3) {
			if (ja.call(ma, a3)) return true
			if (ja.call(la, a3)) return false
			if (ka.test(a3)) return (ma[a3] = true)
			la[a3] = true
			return false
		}
		function pa(a3, b3, c3, d3) {
			if (null !== c3 && 0 === c3.type) return false
			switch (typeof b3) {
				case 'function':
				case 'symbol':
					return true
				case 'boolean':
					if (d3) return false
					if (null !== c3) return !c3.acceptsBooleans
					a3 = a3.toLowerCase().slice(0, 5)
					return 'data-' !== a3 && 'aria-' !== a3
				default:
					return false
			}
		}
		function qa(a3, b3, c3, d3) {
			if (null === b3 || 'undefined' === typeof b3 || pa(a3, b3, c3, d3)) return true
			if (d3) return false
			if (null !== c3)
				switch (c3.type) {
					case 3:
						return !b3
					case 4:
						return false === b3
					case 5:
						return isNaN(b3)
					case 6:
						return isNaN(b3) || 1 > b3
				}
			return false
		}
		function v3(a3, b3, c3, d3, e2, f3, g3) {
			this.acceptsBooleans = 2 === b3 || 3 === b3 || 4 === b3
			this.attributeName = d3
			this.attributeNamespace = e2
			this.mustUseProperty = c3
			this.propertyName = a3
			this.type = b3
			this.sanitizeURL = f3
			this.removeEmptyString = g3
		}
		var z2 = {}
		'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
			.split(' ')
			.forEach(function (a3) {
				z2[a3] = new v3(a3, 0, false, a3, null, false, false)
			})
		;[
			['acceptCharset', 'accept-charset'],
			['className', 'class'],
			['htmlFor', 'for'],
			['httpEquiv', 'http-equiv'],
		].forEach(function (a3) {
			var b3 = a3[0]
			z2[b3] = new v3(b3, 1, false, a3[1], null, false, false)
		})
		;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (a3) {
			z2[a3] = new v3(a3, 2, false, a3.toLowerCase(), null, false, false)
		})
		;['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (
			a3
		) {
			z2[a3] = new v3(a3, 2, false, a3, null, false, false)
		})
		'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
			.split(' ')
			.forEach(function (a3) {
				z2[a3] = new v3(a3, 3, false, a3.toLowerCase(), null, false, false)
			})
		;['checked', 'multiple', 'muted', 'selected'].forEach(function (a3) {
			z2[a3] = new v3(a3, 3, true, a3, null, false, false)
		})
		;['capture', 'download'].forEach(function (a3) {
			z2[a3] = new v3(a3, 4, false, a3, null, false, false)
		})
		;['cols', 'rows', 'size', 'span'].forEach(function (a3) {
			z2[a3] = new v3(a3, 6, false, a3, null, false, false)
		})
		;['rowSpan', 'start'].forEach(function (a3) {
			z2[a3] = new v3(a3, 5, false, a3.toLowerCase(), null, false, false)
		})
		var ra = /[\-:]([a-z])/g
		function sa(a3) {
			return a3[1].toUpperCase()
		}
		'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
			.split(' ')
			.forEach(function (a3) {
				var b3 = a3.replace(ra, sa)
				z2[b3] = new v3(b3, 1, false, a3, null, false, false)
			})
		'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
			.split(' ')
			.forEach(function (a3) {
				var b3 = a3.replace(ra, sa)
				z2[b3] = new v3(b3, 1, false, a3, 'http://www.w3.org/1999/xlink', false, false)
			})
		;['xml:base', 'xml:lang', 'xml:space'].forEach(function (a3) {
			var b3 = a3.replace(ra, sa)
			z2[b3] = new v3(b3, 1, false, a3, 'http://www.w3.org/XML/1998/namespace', false, false)
		})
		;['tabIndex', 'crossOrigin'].forEach(function (a3) {
			z2[a3] = new v3(a3, 1, false, a3.toLowerCase(), null, false, false)
		})
		z2.xlinkHref = new v3(
			'xlinkHref',
			1,
			false,
			'xlink:href',
			'http://www.w3.org/1999/xlink',
			true,
			false
		)
		;['src', 'href', 'action', 'formAction'].forEach(function (a3) {
			z2[a3] = new v3(a3, 1, false, a3.toLowerCase(), null, true, true)
		})
		function ta(a3, b3, c3, d3) {
			var e2 = z2.hasOwnProperty(b3) ? z2[b3] : null
			if (
				null !== e2
					? 0 !== e2.type
					: d3 ||
					  !(2 < b3.length) ||
					  ('o' !== b3[0] && 'O' !== b3[0]) ||
					  ('n' !== b3[1] && 'N' !== b3[1])
			)
				qa(b3, c3, e2, d3) && (c3 = null),
					d3 || null === e2
						? oa(b3) && (null === c3 ? a3.removeAttribute(b3) : a3.setAttribute(b3, '' + c3))
						: e2.mustUseProperty
						? (a3[e2.propertyName] = null === c3 ? (3 === e2.type ? false : '') : c3)
						: ((b3 = e2.attributeName),
						  (d3 = e2.attributeNamespace),
						  null === c3
								? a3.removeAttribute(b3)
								: ((e2 = e2.type),
								  (c3 = 3 === e2 || (4 === e2 && true === c3) ? '' : '' + c3),
								  d3 ? a3.setAttributeNS(d3, b3, c3) : a3.setAttribute(b3, c3)))
		}
		var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
		var va = Symbol.for('react.element')
		var wa = Symbol.for('react.portal')
		var ya = Symbol.for('react.fragment')
		var za = Symbol.for('react.strict_mode')
		var Aa = Symbol.for('react.profiler')
		var Ba = Symbol.for('react.provider')
		var Ca = Symbol.for('react.context')
		var Da = Symbol.for('react.forward_ref')
		var Ea = Symbol.for('react.suspense')
		var Fa = Symbol.for('react.suspense_list')
		var Ga = Symbol.for('react.memo')
		var Ha = Symbol.for('react.lazy')
		Symbol.for('react.scope')
		Symbol.for('react.debug_trace_mode')
		var Ia = Symbol.for('react.offscreen')
		Symbol.for('react.legacy_hidden')
		Symbol.for('react.cache')
		Symbol.for('react.tracing_marker')
		var Ja = Symbol.iterator
		function Ka(a3) {
			if (null === a3 || 'object' !== typeof a3) return null
			a3 = (Ja && a3[Ja]) || a3['@@iterator']
			return 'function' === typeof a3 ? a3 : null
		}
		var A2 = Object.assign
		var La
		function Ma(a3) {
			if (void 0 === La)
				try {
					throw Error()
				} catch (c3) {
					var b3 = c3.stack.trim().match(/\n( *(at )?)/)
					La = (b3 && b3[1]) || ''
				}
			return '\n' + La + a3
		}
		var Na = false
		function Oa(a3, b3) {
			if (!a3 || Na) return ''
			Na = true
			var c3 = Error.prepareStackTrace
			Error.prepareStackTrace = void 0
			try {
				if (b3)
					if (
						((b3 = function () {
							throw Error()
						}),
						Object.defineProperty(b3.prototype, 'props', {
							set: function () {
								throw Error()
							},
						}),
						'object' === typeof Reflect && Reflect.construct)
					) {
						try {
							Reflect.construct(b3, [])
						} catch (l3) {
							var d3 = l3
						}
						Reflect.construct(a3, [], b3)
					} else {
						try {
							b3.call()
						} catch (l3) {
							d3 = l3
						}
						a3.call(b3.prototype)
					}
				else {
					try {
						throw Error()
					} catch (l3) {
						d3 = l3
					}
					a3()
				}
			} catch (l3) {
				if (l3 && d3 && 'string' === typeof l3.stack) {
					for (
						var e2 = l3.stack.split('\n'),
							f3 = d3.stack.split('\n'),
							g3 = e2.length - 1,
							h3 = f3.length - 1;
						1 <= g3 && 0 <= h3 && e2[g3] !== f3[h3];

					)
						h3--
					for (; 1 <= g3 && 0 <= h3; g3--, h3--)
						if (e2[g3] !== f3[h3]) {
							if (1 !== g3 || 1 !== h3) {
								do
									if ((g3--, h3--, 0 > h3 || e2[g3] !== f3[h3])) {
										var k2 = '\n' + e2[g3].replace(' at new ', ' at ')
										a3.displayName &&
											k2.includes('<anonymous>') &&
											(k2 = k2.replace('<anonymous>', a3.displayName))
										return k2
									}
								while (1 <= g3 && 0 <= h3)
							}
							break
						}
				}
			} finally {
				;(Na = false), (Error.prepareStackTrace = c3)
			}
			return (a3 = a3 ? a3.displayName || a3.name : '') ? Ma(a3) : ''
		}
		function Pa(a3) {
			switch (a3.tag) {
				case 5:
					return Ma(a3.type)
				case 16:
					return Ma('Lazy')
				case 13:
					return Ma('Suspense')
				case 19:
					return Ma('SuspenseList')
				case 0:
				case 2:
				case 15:
					return (a3 = Oa(a3.type, false)), a3
				case 11:
					return (a3 = Oa(a3.type.render, false)), a3
				case 1:
					return (a3 = Oa(a3.type, true)), a3
				default:
					return ''
			}
		}
		function Qa(a3) {
			if (null == a3) return null
			if ('function' === typeof a3) return a3.displayName || a3.name || null
			if ('string' === typeof a3) return a3
			switch (a3) {
				case ya:
					return 'Fragment'
				case wa:
					return 'Portal'
				case Aa:
					return 'Profiler'
				case za:
					return 'StrictMode'
				case Ea:
					return 'Suspense'
				case Fa:
					return 'SuspenseList'
			}
			if ('object' === typeof a3)
				switch (a3.$$typeof) {
					case Ca:
						return (a3.displayName || 'Context') + '.Consumer'
					case Ba:
						return (a3._context.displayName || 'Context') + '.Provider'
					case Da:
						var b3 = a3.render
						a3 = a3.displayName
						a3 ||
							((a3 = b3.displayName || b3.name || ''),
							(a3 = '' !== a3 ? 'ForwardRef(' + a3 + ')' : 'ForwardRef'))
						return a3
					case Ga:
						return (b3 = a3.displayName || null), null !== b3 ? b3 : Qa(a3.type) || 'Memo'
					case Ha:
						b3 = a3._payload
						a3 = a3._init
						try {
							return Qa(a3(b3))
						} catch (c3) {}
				}
			return null
		}
		function Ra(a3) {
			var b3 = a3.type
			switch (a3.tag) {
				case 24:
					return 'Cache'
				case 9:
					return (b3.displayName || 'Context') + '.Consumer'
				case 10:
					return (b3._context.displayName || 'Context') + '.Provider'
				case 18:
					return 'DehydratedFragment'
				case 11:
					return (
						(a3 = b3.render),
						(a3 = a3.displayName || a3.name || ''),
						b3.displayName || ('' !== a3 ? 'ForwardRef(' + a3 + ')' : 'ForwardRef')
					)
				case 7:
					return 'Fragment'
				case 5:
					return b3
				case 4:
					return 'Portal'
				case 3:
					return 'Root'
				case 6:
					return 'Text'
				case 16:
					return Qa(b3)
				case 8:
					return b3 === za ? 'StrictMode' : 'Mode'
				case 22:
					return 'Offscreen'
				case 12:
					return 'Profiler'
				case 21:
					return 'Scope'
				case 13:
					return 'Suspense'
				case 19:
					return 'SuspenseList'
				case 25:
					return 'TracingMarker'
				case 1:
				case 0:
				case 17:
				case 2:
				case 14:
				case 15:
					if ('function' === typeof b3) return b3.displayName || b3.name || null
					if ('string' === typeof b3) return b3
			}
			return null
		}
		function Sa(a3) {
			switch (typeof a3) {
				case 'boolean':
				case 'number':
				case 'string':
				case 'undefined':
					return a3
				case 'object':
					return a3
				default:
					return ''
			}
		}
		function Ta(a3) {
			var b3 = a3.type
			return (
				(a3 = a3.nodeName) && 'input' === a3.toLowerCase() && ('checkbox' === b3 || 'radio' === b3)
			)
		}
		function Ua(a3) {
			var b3 = Ta(a3) ? 'checked' : 'value',
				c3 = Object.getOwnPropertyDescriptor(a3.constructor.prototype, b3),
				d3 = '' + a3[b3]
			if (
				!a3.hasOwnProperty(b3) &&
				'undefined' !== typeof c3 &&
				'function' === typeof c3.get &&
				'function' === typeof c3.set
			) {
				var e2 = c3.get,
					f3 = c3.set
				Object.defineProperty(a3, b3, {
					configurable: true,
					get: function () {
						return e2.call(this)
					},
					set: function (a4) {
						d3 = '' + a4
						f3.call(this, a4)
					},
				})
				Object.defineProperty(a3, b3, { enumerable: c3.enumerable })
				return {
					getValue: function () {
						return d3
					},
					setValue: function (a4) {
						d3 = '' + a4
					},
					stopTracking: function () {
						a3._valueTracker = null
						delete a3[b3]
					},
				}
			}
		}
		function Va(a3) {
			a3._valueTracker || (a3._valueTracker = Ua(a3))
		}
		function Wa(a3) {
			if (!a3) return false
			var b3 = a3._valueTracker
			if (!b3) return true
			var c3 = b3.getValue()
			var d3 = ''
			a3 && (d3 = Ta(a3) ? (a3.checked ? 'true' : 'false') : a3.value)
			a3 = d3
			return a3 !== c3 ? (b3.setValue(a3), true) : false
		}
		function Xa(a3) {
			a3 = a3 || ('undefined' !== typeof document ? document : void 0)
			if ('undefined' === typeof a3) return null
			try {
				return a3.activeElement || a3.body
			} catch (b3) {
				return a3.body
			}
		}
		function Ya(a3, b3) {
			var c3 = b3.checked
			return A2({}, b3, {
				defaultChecked: void 0,
				defaultValue: void 0,
				value: void 0,
				checked: null != c3 ? c3 : a3._wrapperState.initialChecked,
			})
		}
		function Za(a3, b3) {
			var c3 = null == b3.defaultValue ? '' : b3.defaultValue,
				d3 = null != b3.checked ? b3.checked : b3.defaultChecked
			c3 = Sa(null != b3.value ? b3.value : c3)
			a3._wrapperState = {
				initialChecked: d3,
				initialValue: c3,
				controlled:
					'checkbox' === b3.type || 'radio' === b3.type ? null != b3.checked : null != b3.value,
			}
		}
		function ab(a3, b3) {
			b3 = b3.checked
			null != b3 && ta(a3, 'checked', b3, false)
		}
		function bb(a3, b3) {
			ab(a3, b3)
			var c3 = Sa(b3.value),
				d3 = b3.type
			if (null != c3)
				if ('number' === d3) {
					if ((0 === c3 && '' === a3.value) || a3.value != c3) a3.value = '' + c3
				} else a3.value !== '' + c3 && (a3.value = '' + c3)
			else if ('submit' === d3 || 'reset' === d3) {
				a3.removeAttribute('value')
				return
			}
			b3.hasOwnProperty('value')
				? cb(a3, b3.type, c3)
				: b3.hasOwnProperty('defaultValue') && cb(a3, b3.type, Sa(b3.defaultValue))
			null == b3.checked && null != b3.defaultChecked && (a3.defaultChecked = !!b3.defaultChecked)
		}
		function db(a3, b3, c3) {
			if (b3.hasOwnProperty('value') || b3.hasOwnProperty('defaultValue')) {
				var d3 = b3.type
				if (!(('submit' !== d3 && 'reset' !== d3) || (void 0 !== b3.value && null !== b3.value)))
					return
				b3 = '' + a3._wrapperState.initialValue
				c3 || b3 === a3.value || (a3.value = b3)
				a3.defaultValue = b3
			}
			c3 = a3.name
			'' !== c3 && (a3.name = '')
			a3.defaultChecked = !!a3._wrapperState.initialChecked
			'' !== c3 && (a3.name = c3)
		}
		function cb(a3, b3, c3) {
			if ('number' !== b3 || Xa(a3.ownerDocument) !== a3)
				null == c3
					? (a3.defaultValue = '' + a3._wrapperState.initialValue)
					: a3.defaultValue !== '' + c3 && (a3.defaultValue = '' + c3)
		}
		var eb = Array.isArray
		function fb(a3, b3, c3, d3) {
			a3 = a3.options
			if (b3) {
				b3 = {}
				for (var e2 = 0; e2 < c3.length; e2++) b3['$' + c3[e2]] = true
				for (c3 = 0; c3 < a3.length; c3++)
					(e2 = b3.hasOwnProperty('$' + a3[c3].value)),
						a3[c3].selected !== e2 && (a3[c3].selected = e2),
						e2 && d3 && (a3[c3].defaultSelected = true)
			} else {
				c3 = '' + Sa(c3)
				b3 = null
				for (e2 = 0; e2 < a3.length; e2++) {
					if (a3[e2].value === c3) {
						a3[e2].selected = true
						d3 && (a3[e2].defaultSelected = true)
						return
					}
					null !== b3 || a3[e2].disabled || (b3 = a3[e2])
				}
				null !== b3 && (b3.selected = true)
			}
		}
		function gb(a3, b3) {
			if (null != b3.dangerouslySetInnerHTML) throw Error(p3(91))
			return A2({}, b3, {
				value: void 0,
				defaultValue: void 0,
				children: '' + a3._wrapperState.initialValue,
			})
		}
		function hb(a3, b3) {
			var c3 = b3.value
			if (null == c3) {
				c3 = b3.children
				b3 = b3.defaultValue
				if (null != c3) {
					if (null != b3) throw Error(p3(92))
					if (eb(c3)) {
						if (1 < c3.length) throw Error(p3(93))
						c3 = c3[0]
					}
					b3 = c3
				}
				null == b3 && (b3 = '')
				c3 = b3
			}
			a3._wrapperState = { initialValue: Sa(c3) }
		}
		function ib(a3, b3) {
			var c3 = Sa(b3.value),
				d3 = Sa(b3.defaultValue)
			null != c3 &&
				((c3 = '' + c3),
				c3 !== a3.value && (a3.value = c3),
				null == b3.defaultValue && a3.defaultValue !== c3 && (a3.defaultValue = c3))
			null != d3 && (a3.defaultValue = '' + d3)
		}
		function jb(a3) {
			var b3 = a3.textContent
			b3 === a3._wrapperState.initialValue && '' !== b3 && null !== b3 && (a3.value = b3)
		}
		function kb(a3) {
			switch (a3) {
				case 'svg':
					return 'http://www.w3.org/2000/svg'
				case 'math':
					return 'http://www.w3.org/1998/Math/MathML'
				default:
					return 'http://www.w3.org/1999/xhtml'
			}
		}
		function lb(a3, b3) {
			return null == a3 || 'http://www.w3.org/1999/xhtml' === a3
				? kb(b3)
				: 'http://www.w3.org/2000/svg' === a3 && 'foreignObject' === b3
				? 'http://www.w3.org/1999/xhtml'
				: a3
		}
		var mb
		var nb = (function (a3) {
			return 'undefined' !== typeof MSApp && MSApp.execUnsafeLocalFunction
				? function (b3, c3, d3, e2) {
						MSApp.execUnsafeLocalFunction(function () {
							return a3(b3, c3, d3, e2)
						})
				  }
				: a3
		})(function (a3, b3) {
			if ('http://www.w3.org/2000/svg' !== a3.namespaceURI || 'innerHTML' in a3) a3.innerHTML = b3
			else {
				mb = mb || document.createElement('div')
				mb.innerHTML = '<svg>' + b3.valueOf().toString() + '</svg>'
				for (b3 = mb.firstChild; a3.firstChild; ) a3.removeChild(a3.firstChild)
				for (; b3.firstChild; ) a3.appendChild(b3.firstChild)
			}
		})
		function ob(a3, b3) {
			if (b3) {
				var c3 = a3.firstChild
				if (c3 && c3 === a3.lastChild && 3 === c3.nodeType) {
					c3.nodeValue = b3
					return
				}
			}
			a3.textContent = b3
		}
		var pb = {
			animationIterationCount: true,
			aspectRatio: true,
			borderImageOutset: true,
			borderImageSlice: true,
			borderImageWidth: true,
			boxFlex: true,
			boxFlexGroup: true,
			boxOrdinalGroup: true,
			columnCount: true,
			columns: true,
			flex: true,
			flexGrow: true,
			flexPositive: true,
			flexShrink: true,
			flexNegative: true,
			flexOrder: true,
			gridArea: true,
			gridRow: true,
			gridRowEnd: true,
			gridRowSpan: true,
			gridRowStart: true,
			gridColumn: true,
			gridColumnEnd: true,
			gridColumnSpan: true,
			gridColumnStart: true,
			fontWeight: true,
			lineClamp: true,
			lineHeight: true,
			opacity: true,
			order: true,
			orphans: true,
			tabSize: true,
			widows: true,
			zIndex: true,
			zoom: true,
			fillOpacity: true,
			floodOpacity: true,
			stopOpacity: true,
			strokeDasharray: true,
			strokeDashoffset: true,
			strokeMiterlimit: true,
			strokeOpacity: true,
			strokeWidth: true,
		}
		var qb = ['Webkit', 'ms', 'Moz', 'O']
		Object.keys(pb).forEach(function (a3) {
			qb.forEach(function (b3) {
				b3 = b3 + a3.charAt(0).toUpperCase() + a3.substring(1)
				pb[b3] = pb[a3]
			})
		})
		function rb(a3, b3, c3) {
			return null == b3 || 'boolean' === typeof b3 || '' === b3
				? ''
				: c3 || 'number' !== typeof b3 || 0 === b3 || (pb.hasOwnProperty(a3) && pb[a3])
				? ('' + b3).trim()
				: b3 + 'px'
		}
		function sb(a3, b3) {
			a3 = a3.style
			for (var c3 in b3)
				if (b3.hasOwnProperty(c3)) {
					var d3 = 0 === c3.indexOf('--'),
						e2 = rb(c3, b3[c3], d3)
					'float' === c3 && (c3 = 'cssFloat')
					d3 ? a3.setProperty(c3, e2) : (a3[c3] = e2)
				}
		}
		var tb = A2(
			{ menuitem: true },
			{
				area: true,
				base: true,
				br: true,
				col: true,
				embed: true,
				hr: true,
				img: true,
				input: true,
				keygen: true,
				link: true,
				meta: true,
				param: true,
				source: true,
				track: true,
				wbr: true,
			}
		)
		function ub(a3, b3) {
			if (b3) {
				if (tb[a3] && (null != b3.children || null != b3.dangerouslySetInnerHTML))
					throw Error(p3(137, a3))
				if (null != b3.dangerouslySetInnerHTML) {
					if (null != b3.children) throw Error(p3(60))
					if (
						'object' !== typeof b3.dangerouslySetInnerHTML ||
						!('__html' in b3.dangerouslySetInnerHTML)
					)
						throw Error(p3(61))
				}
				if (null != b3.style && 'object' !== typeof b3.style) throw Error(p3(62))
			}
		}
		function vb(a3, b3) {
			if (-1 === a3.indexOf('-')) return 'string' === typeof b3.is
			switch (a3) {
				case 'annotation-xml':
				case 'color-profile':
				case 'font-face':
				case 'font-face-src':
				case 'font-face-uri':
				case 'font-face-format':
				case 'font-face-name':
				case 'missing-glyph':
					return false
				default:
					return true
			}
		}
		var wb = null
		function xb(a3) {
			a3 = a3.target || a3.srcElement || window
			a3.correspondingUseElement && (a3 = a3.correspondingUseElement)
			return 3 === a3.nodeType ? a3.parentNode : a3
		}
		var yb = null
		var zb = null
		var Ab = null
		function Bb(a3) {
			if ((a3 = Cb(a3))) {
				if ('function' !== typeof yb) throw Error(p3(280))
				var b3 = a3.stateNode
				b3 && ((b3 = Db(b3)), yb(a3.stateNode, a3.type, b3))
			}
		}
		function Eb(a3) {
			zb ? (Ab ? Ab.push(a3) : (Ab = [a3])) : (zb = a3)
		}
		function Fb() {
			if (zb) {
				var a3 = zb,
					b3 = Ab
				Ab = zb = null
				Bb(a3)
				if (b3) for (a3 = 0; a3 < b3.length; a3++) Bb(b3[a3])
			}
		}
		function Gb(a3, b3) {
			return a3(b3)
		}
		function Hb() {}
		var Ib = false
		function Jb(a3, b3, c3) {
			if (Ib) return a3(b3, c3)
			Ib = true
			try {
				return Gb(a3, b3, c3)
			} finally {
				if (((Ib = false), null !== zb || null !== Ab)) Hb(), Fb()
			}
		}
		function Kb(a3, b3) {
			var c3 = a3.stateNode
			if (null === c3) return null
			var d3 = Db(c3)
			if (null === d3) return null
			c3 = d3[b3]
			a: switch (b3) {
				case 'onClick':
				case 'onClickCapture':
				case 'onDoubleClick':
				case 'onDoubleClickCapture':
				case 'onMouseDown':
				case 'onMouseDownCapture':
				case 'onMouseMove':
				case 'onMouseMoveCapture':
				case 'onMouseUp':
				case 'onMouseUpCapture':
				case 'onMouseEnter':
					;(d3 = !d3.disabled) ||
						((a3 = a3.type),
						(d3 = !('button' === a3 || 'input' === a3 || 'select' === a3 || 'textarea' === a3)))
					a3 = !d3
					break a
				default:
					a3 = false
			}
			if (a3) return null
			if (c3 && 'function' !== typeof c3) throw Error(p3(231, b3, typeof c3))
			return c3
		}
		var Lb = false
		if (ia)
			try {
				Mb = {}
				Object.defineProperty(Mb, 'passive', {
					get: function () {
						Lb = true
					},
				})
				window.addEventListener('test', Mb, Mb)
				window.removeEventListener('test', Mb, Mb)
			} catch (a3) {
				Lb = false
			}
		var Mb
		function Nb(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
			var l3 = Array.prototype.slice.call(arguments, 3)
			try {
				b3.apply(c3, l3)
			} catch (m3) {
				this.onError(m3)
			}
		}
		var Ob = false
		var Pb = null
		var Qb = false
		var Rb = null
		var Sb = {
			onError: function (a3) {
				Ob = true
				Pb = a3
			},
		}
		function Tb(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
			Ob = false
			Pb = null
			Nb.apply(Sb, arguments)
		}
		function Ub(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
			Tb.apply(this, arguments)
			if (Ob) {
				if (Ob) {
					var l3 = Pb
					Ob = false
					Pb = null
				} else throw Error(p3(198))
				Qb || ((Qb = true), (Rb = l3))
			}
		}
		function Vb(a3) {
			var b3 = a3,
				c3 = a3
			if (a3.alternate) for (; b3.return; ) b3 = b3.return
			else {
				a3 = b3
				do (b3 = a3), 0 !== (b3.flags & 4098) && (c3 = b3.return), (a3 = b3.return)
				while (a3)
			}
			return 3 === b3.tag ? c3 : null
		}
		function Wb(a3) {
			if (13 === a3.tag) {
				var b3 = a3.memoizedState
				null === b3 && ((a3 = a3.alternate), null !== a3 && (b3 = a3.memoizedState))
				if (null !== b3) return b3.dehydrated
			}
			return null
		}
		function Xb(a3) {
			if (Vb(a3) !== a3) throw Error(p3(188))
		}
		function Yb(a3) {
			var b3 = a3.alternate
			if (!b3) {
				b3 = Vb(a3)
				if (null === b3) throw Error(p3(188))
				return b3 !== a3 ? null : a3
			}
			for (var c3 = a3, d3 = b3; ; ) {
				var e2 = c3.return
				if (null === e2) break
				var f3 = e2.alternate
				if (null === f3) {
					d3 = e2.return
					if (null !== d3) {
						c3 = d3
						continue
					}
					break
				}
				if (e2.child === f3.child) {
					for (f3 = e2.child; f3; ) {
						if (f3 === c3) return Xb(e2), a3
						if (f3 === d3) return Xb(e2), b3
						f3 = f3.sibling
					}
					throw Error(p3(188))
				}
				if (c3.return !== d3.return) (c3 = e2), (d3 = f3)
				else {
					for (var g3 = false, h3 = e2.child; h3; ) {
						if (h3 === c3) {
							g3 = true
							c3 = e2
							d3 = f3
							break
						}
						if (h3 === d3) {
							g3 = true
							d3 = e2
							c3 = f3
							break
						}
						h3 = h3.sibling
					}
					if (!g3) {
						for (h3 = f3.child; h3; ) {
							if (h3 === c3) {
								g3 = true
								c3 = f3
								d3 = e2
								break
							}
							if (h3 === d3) {
								g3 = true
								d3 = f3
								c3 = e2
								break
							}
							h3 = h3.sibling
						}
						if (!g3) throw Error(p3(189))
					}
				}
				if (c3.alternate !== d3) throw Error(p3(190))
			}
			if (3 !== c3.tag) throw Error(p3(188))
			return c3.stateNode.current === c3 ? a3 : b3
		}
		function Zb(a3) {
			a3 = Yb(a3)
			return null !== a3 ? $b(a3) : null
		}
		function $b(a3) {
			if (5 === a3.tag || 6 === a3.tag) return a3
			for (a3 = a3.child; null !== a3; ) {
				var b3 = $b(a3)
				if (null !== b3) return b3
				a3 = a3.sibling
			}
			return null
		}
		var ac = ca.unstable_scheduleCallback
		var bc = ca.unstable_cancelCallback
		var cc = ca.unstable_shouldYield
		var dc = ca.unstable_requestPaint
		var B = ca.unstable_now
		var ec = ca.unstable_getCurrentPriorityLevel
		var fc = ca.unstable_ImmediatePriority
		var gc = ca.unstable_UserBlockingPriority
		var hc = ca.unstable_NormalPriority
		var ic = ca.unstable_LowPriority
		var jc = ca.unstable_IdlePriority
		var kc = null
		var lc = null
		function mc(a3) {
			if (lc && 'function' === typeof lc.onCommitFiberRoot)
				try {
					lc.onCommitFiberRoot(kc, a3, void 0, 128 === (a3.current.flags & 128))
				} catch (b3) {}
		}
		var oc = Math.clz32 ? Math.clz32 : nc
		var pc = Math.log
		var qc = Math.LN2
		function nc(a3) {
			a3 >>>= 0
			return 0 === a3 ? 32 : (31 - ((pc(a3) / qc) | 0)) | 0
		}
		var rc = 64
		var sc = 4194304
		function tc(a3) {
			switch (a3 & -a3) {
				case 1:
					return 1
				case 2:
					return 2
				case 4:
					return 4
				case 8:
					return 8
				case 16:
					return 16
				case 32:
					return 32
				case 64:
				case 128:
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152:
					return a3 & 4194240
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432:
				case 67108864:
					return a3 & 130023424
				case 134217728:
					return 134217728
				case 268435456:
					return 268435456
				case 536870912:
					return 536870912
				case 1073741824:
					return 1073741824
				default:
					return a3
			}
		}
		function uc(a3, b3) {
			var c3 = a3.pendingLanes
			if (0 === c3) return 0
			var d3 = 0,
				e2 = a3.suspendedLanes,
				f3 = a3.pingedLanes,
				g3 = c3 & 268435455
			if (0 !== g3) {
				var h3 = g3 & ~e2
				0 !== h3 ? (d3 = tc(h3)) : ((f3 &= g3), 0 !== f3 && (d3 = tc(f3)))
			} else (g3 = c3 & ~e2), 0 !== g3 ? (d3 = tc(g3)) : 0 !== f3 && (d3 = tc(f3))
			if (0 === d3) return 0
			if (
				0 !== b3 &&
				b3 !== d3 &&
				0 === (b3 & e2) &&
				((e2 = d3 & -d3), (f3 = b3 & -b3), e2 >= f3 || (16 === e2 && 0 !== (f3 & 4194240)))
			)
				return b3
			0 !== (d3 & 4) && (d3 |= c3 & 16)
			b3 = a3.entangledLanes
			if (0 !== b3)
				for (a3 = a3.entanglements, b3 &= d3; 0 < b3; )
					(c3 = 31 - oc(b3)), (e2 = 1 << c3), (d3 |= a3[c3]), (b3 &= ~e2)
			return d3
		}
		function vc(a3, b3) {
			switch (a3) {
				case 1:
				case 2:
				case 4:
					return b3 + 250
				case 8:
				case 16:
				case 32:
				case 64:
				case 128:
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152:
					return b3 + 5e3
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432:
				case 67108864:
					return -1
				case 134217728:
				case 268435456:
				case 536870912:
				case 1073741824:
					return -1
				default:
					return -1
			}
		}
		function wc(a3, b3) {
			for (
				var c3 = a3.suspendedLanes,
					d3 = a3.pingedLanes,
					e2 = a3.expirationTimes,
					f3 = a3.pendingLanes;
				0 < f3;

			) {
				var g3 = 31 - oc(f3),
					h3 = 1 << g3,
					k2 = e2[g3]
				if (-1 === k2) {
					if (0 === (h3 & c3) || 0 !== (h3 & d3)) e2[g3] = vc(h3, b3)
				} else k2 <= b3 && (a3.expiredLanes |= h3)
				f3 &= ~h3
			}
		}
		function xc(a3) {
			a3 = a3.pendingLanes & -1073741825
			return 0 !== a3 ? a3 : a3 & 1073741824 ? 1073741824 : 0
		}
		function yc() {
			var a3 = rc
			rc <<= 1
			0 === (rc & 4194240) && (rc = 64)
			return a3
		}
		function zc(a3) {
			for (var b3 = [], c3 = 0; 31 > c3; c3++) b3.push(a3)
			return b3
		}
		function Ac(a3, b3, c3) {
			a3.pendingLanes |= b3
			536870912 !== b3 && ((a3.suspendedLanes = 0), (a3.pingedLanes = 0))
			a3 = a3.eventTimes
			b3 = 31 - oc(b3)
			a3[b3] = c3
		}
		function Bc(a3, b3) {
			var c3 = a3.pendingLanes & ~b3
			a3.pendingLanes = b3
			a3.suspendedLanes = 0
			a3.pingedLanes = 0
			a3.expiredLanes &= b3
			a3.mutableReadLanes &= b3
			a3.entangledLanes &= b3
			b3 = a3.entanglements
			var d3 = a3.eventTimes
			for (a3 = a3.expirationTimes; 0 < c3; ) {
				var e2 = 31 - oc(c3),
					f3 = 1 << e2
				b3[e2] = 0
				d3[e2] = -1
				a3[e2] = -1
				c3 &= ~f3
			}
		}
		function Cc(a3, b3) {
			var c3 = (a3.entangledLanes |= b3)
			for (a3 = a3.entanglements; c3; ) {
				var d3 = 31 - oc(c3),
					e2 = 1 << d3
				;(e2 & b3) | (a3[d3] & b3) && (a3[d3] |= b3)
				c3 &= ~e2
			}
		}
		var C2 = 0
		function Dc(a3) {
			a3 &= -a3
			return 1 < a3 ? (4 < a3 ? (0 !== (a3 & 268435455) ? 16 : 536870912) : 4) : 1
		}
		var Ec
		var Fc
		var Gc
		var Hc
		var Ic
		var Jc = false
		var Kc = []
		var Lc = null
		var Mc = null
		var Nc = null
		var Oc = /* @__PURE__ */ new Map()
		var Pc = /* @__PURE__ */ new Map()
		var Qc = []
		var Rc =
			'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
				' '
			)
		function Sc(a3, b3) {
			switch (a3) {
				case 'focusin':
				case 'focusout':
					Lc = null
					break
				case 'dragenter':
				case 'dragleave':
					Mc = null
					break
				case 'mouseover':
				case 'mouseout':
					Nc = null
					break
				case 'pointerover':
				case 'pointerout':
					Oc.delete(b3.pointerId)
					break
				case 'gotpointercapture':
				case 'lostpointercapture':
					Pc.delete(b3.pointerId)
			}
		}
		function Tc(a3, b3, c3, d3, e2, f3) {
			if (null === a3 || a3.nativeEvent !== f3)
				return (
					(a3 = {
						blockedOn: b3,
						domEventName: c3,
						eventSystemFlags: d3,
						nativeEvent: f3,
						targetContainers: [e2],
					}),
					null !== b3 && ((b3 = Cb(b3)), null !== b3 && Fc(b3)),
					a3
				)
			a3.eventSystemFlags |= d3
			b3 = a3.targetContainers
			null !== e2 && -1 === b3.indexOf(e2) && b3.push(e2)
			return a3
		}
		function Uc(a3, b3, c3, d3, e2) {
			switch (b3) {
				case 'focusin':
					return (Lc = Tc(Lc, a3, b3, c3, d3, e2)), true
				case 'dragenter':
					return (Mc = Tc(Mc, a3, b3, c3, d3, e2)), true
				case 'mouseover':
					return (Nc = Tc(Nc, a3, b3, c3, d3, e2)), true
				case 'pointerover':
					var f3 = e2.pointerId
					Oc.set(f3, Tc(Oc.get(f3) || null, a3, b3, c3, d3, e2))
					return true
				case 'gotpointercapture':
					return (f3 = e2.pointerId), Pc.set(f3, Tc(Pc.get(f3) || null, a3, b3, c3, d3, e2)), true
			}
			return false
		}
		function Vc(a3) {
			var b3 = Wc(a3.target)
			if (null !== b3) {
				var c3 = Vb(b3)
				if (null !== c3) {
					if (((b3 = c3.tag), 13 === b3)) {
						if (((b3 = Wb(c3)), null !== b3)) {
							a3.blockedOn = b3
							Ic(a3.priority, function () {
								Gc(c3)
							})
							return
						}
					} else if (3 === b3 && c3.stateNode.current.memoizedState.isDehydrated) {
						a3.blockedOn = 3 === c3.tag ? c3.stateNode.containerInfo : null
						return
					}
				}
			}
			a3.blockedOn = null
		}
		function Xc(a3) {
			if (null !== a3.blockedOn) return false
			for (var b3 = a3.targetContainers; 0 < b3.length; ) {
				var c3 = Yc(a3.domEventName, a3.eventSystemFlags, b3[0], a3.nativeEvent)
				if (null === c3) {
					c3 = a3.nativeEvent
					var d3 = new c3.constructor(c3.type, c3)
					wb = d3
					c3.target.dispatchEvent(d3)
					wb = null
				} else return (b3 = Cb(c3)), null !== b3 && Fc(b3), (a3.blockedOn = c3), false
				b3.shift()
			}
			return true
		}
		function Zc(a3, b3, c3) {
			Xc(a3) && c3.delete(b3)
		}
		function $c() {
			Jc = false
			null !== Lc && Xc(Lc) && (Lc = null)
			null !== Mc && Xc(Mc) && (Mc = null)
			null !== Nc && Xc(Nc) && (Nc = null)
			Oc.forEach(Zc)
			Pc.forEach(Zc)
		}
		function ad(a3, b3) {
			a3.blockedOn === b3 &&
				((a3.blockedOn = null),
				Jc || ((Jc = true), ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
		}
		function bd(a3) {
			function b3(b4) {
				return ad(b4, a3)
			}
			if (0 < Kc.length) {
				ad(Kc[0], a3)
				for (var c3 = 1; c3 < Kc.length; c3++) {
					var d3 = Kc[c3]
					d3.blockedOn === a3 && (d3.blockedOn = null)
				}
			}
			null !== Lc && ad(Lc, a3)
			null !== Mc && ad(Mc, a3)
			null !== Nc && ad(Nc, a3)
			Oc.forEach(b3)
			Pc.forEach(b3)
			for (c3 = 0; c3 < Qc.length; c3++) (d3 = Qc[c3]), d3.blockedOn === a3 && (d3.blockedOn = null)
			for (; 0 < Qc.length && ((c3 = Qc[0]), null === c3.blockedOn); )
				Vc(c3), null === c3.blockedOn && Qc.shift()
		}
		var cd = ua.ReactCurrentBatchConfig
		var dd = true
		function ed(a3, b3, c3, d3) {
			var e2 = C2,
				f3 = cd.transition
			cd.transition = null
			try {
				;(C2 = 1), fd(a3, b3, c3, d3)
			} finally {
				;(C2 = e2), (cd.transition = f3)
			}
		}
		function gd(a3, b3, c3, d3) {
			var e2 = C2,
				f3 = cd.transition
			cd.transition = null
			try {
				;(C2 = 4), fd(a3, b3, c3, d3)
			} finally {
				;(C2 = e2), (cd.transition = f3)
			}
		}
		function fd(a3, b3, c3, d3) {
			if (dd) {
				var e2 = Yc(a3, b3, c3, d3)
				if (null === e2) hd(a3, b3, d3, id, c3), Sc(a3, d3)
				else if (Uc(e2, a3, b3, c3, d3)) d3.stopPropagation()
				else if ((Sc(a3, d3), b3 & 4 && -1 < Rc.indexOf(a3))) {
					for (; null !== e2; ) {
						var f3 = Cb(e2)
						null !== f3 && Ec(f3)
						f3 = Yc(a3, b3, c3, d3)
						null === f3 && hd(a3, b3, d3, id, c3)
						if (f3 === e2) break
						e2 = f3
					}
					null !== e2 && d3.stopPropagation()
				} else hd(a3, b3, d3, null, c3)
			}
		}
		var id = null
		function Yc(a3, b3, c3, d3) {
			id = null
			a3 = xb(d3)
			a3 = Wc(a3)
			if (null !== a3)
				if (((b3 = Vb(a3)), null === b3)) a3 = null
				else if (((c3 = b3.tag), 13 === c3)) {
					a3 = Wb(b3)
					if (null !== a3) return a3
					a3 = null
				} else if (3 === c3) {
					if (b3.stateNode.current.memoizedState.isDehydrated)
						return 3 === b3.tag ? b3.stateNode.containerInfo : null
					a3 = null
				} else b3 !== a3 && (a3 = null)
			id = a3
			return null
		}
		function jd(a3) {
			switch (a3) {
				case 'cancel':
				case 'click':
				case 'close':
				case 'contextmenu':
				case 'copy':
				case 'cut':
				case 'auxclick':
				case 'dblclick':
				case 'dragend':
				case 'dragstart':
				case 'drop':
				case 'focusin':
				case 'focusout':
				case 'input':
				case 'invalid':
				case 'keydown':
				case 'keypress':
				case 'keyup':
				case 'mousedown':
				case 'mouseup':
				case 'paste':
				case 'pause':
				case 'play':
				case 'pointercancel':
				case 'pointerdown':
				case 'pointerup':
				case 'ratechange':
				case 'reset':
				case 'resize':
				case 'seeked':
				case 'submit':
				case 'touchcancel':
				case 'touchend':
				case 'touchstart':
				case 'volumechange':
				case 'change':
				case 'selectionchange':
				case 'textInput':
				case 'compositionstart':
				case 'compositionend':
				case 'compositionupdate':
				case 'beforeblur':
				case 'afterblur':
				case 'beforeinput':
				case 'blur':
				case 'fullscreenchange':
				case 'focus':
				case 'hashchange':
				case 'popstate':
				case 'select':
				case 'selectstart':
					return 1
				case 'drag':
				case 'dragenter':
				case 'dragexit':
				case 'dragleave':
				case 'dragover':
				case 'mousemove':
				case 'mouseout':
				case 'mouseover':
				case 'pointermove':
				case 'pointerout':
				case 'pointerover':
				case 'scroll':
				case 'toggle':
				case 'touchmove':
				case 'wheel':
				case 'mouseenter':
				case 'mouseleave':
				case 'pointerenter':
				case 'pointerleave':
					return 4
				case 'message':
					switch (ec()) {
						case fc:
							return 1
						case gc:
							return 4
						case hc:
						case ic:
							return 16
						case jc:
							return 536870912
						default:
							return 16
					}
				default:
					return 16
			}
		}
		var kd = null
		var ld = null
		var md = null
		function nd() {
			if (md) return md
			var a3,
				b3 = ld,
				c3 = b3.length,
				d3,
				e2 = 'value' in kd ? kd.value : kd.textContent,
				f3 = e2.length
			for (a3 = 0; a3 < c3 && b3[a3] === e2[a3]; a3++);
			var g3 = c3 - a3
			for (d3 = 1; d3 <= g3 && b3[c3 - d3] === e2[f3 - d3]; d3++);
			return (md = e2.slice(a3, 1 < d3 ? 1 - d3 : void 0))
		}
		function od(a3) {
			var b3 = a3.keyCode
			'charCode' in a3 ? ((a3 = a3.charCode), 0 === a3 && 13 === b3 && (a3 = 13)) : (a3 = b3)
			10 === a3 && (a3 = 13)
			return 32 <= a3 || 13 === a3 ? a3 : 0
		}
		function pd() {
			return true
		}
		function qd() {
			return false
		}
		function rd(a3) {
			function b3(b4, d3, e2, f3, g3) {
				this._reactName = b4
				this._targetInst = e2
				this.type = d3
				this.nativeEvent = f3
				this.target = g3
				this.currentTarget = null
				for (var c3 in a3)
					a3.hasOwnProperty(c3) && ((b4 = a3[c3]), (this[c3] = b4 ? b4(f3) : f3[c3]))
				this.isDefaultPrevented = (
					null != f3.defaultPrevented ? f3.defaultPrevented : false === f3.returnValue
				)
					? pd
					: qd
				this.isPropagationStopped = qd
				return this
			}
			A2(b3.prototype, {
				preventDefault: function () {
					this.defaultPrevented = true
					var a4 = this.nativeEvent
					a4 &&
						(a4.preventDefault
							? a4.preventDefault()
							: 'unknown' !== typeof a4.returnValue && (a4.returnValue = false),
						(this.isDefaultPrevented = pd))
				},
				stopPropagation: function () {
					var a4 = this.nativeEvent
					a4 &&
						(a4.stopPropagation
							? a4.stopPropagation()
							: 'unknown' !== typeof a4.cancelBubble && (a4.cancelBubble = true),
						(this.isPropagationStopped = pd))
				},
				persist: function () {},
				isPersistent: pd,
			})
			return b3
		}
		var sd = {
			eventPhase: 0,
			bubbles: 0,
			cancelable: 0,
			timeStamp: function (a3) {
				return a3.timeStamp || Date.now()
			},
			defaultPrevented: 0,
			isTrusted: 0,
		}
		var td = rd(sd)
		var ud = A2({}, sd, { view: 0, detail: 0 })
		var vd = rd(ud)
		var wd
		var xd
		var yd
		var Ad = A2({}, ud, {
			screenX: 0,
			screenY: 0,
			clientX: 0,
			clientY: 0,
			pageX: 0,
			pageY: 0,
			ctrlKey: 0,
			shiftKey: 0,
			altKey: 0,
			metaKey: 0,
			getModifierState: zd,
			button: 0,
			buttons: 0,
			relatedTarget: function (a3) {
				return void 0 === a3.relatedTarget
					? a3.fromElement === a3.srcElement
						? a3.toElement
						: a3.fromElement
					: a3.relatedTarget
			},
			movementX: function (a3) {
				if ('movementX' in a3) return a3.movementX
				a3 !== yd &&
					(yd && 'mousemove' === a3.type
						? ((wd = a3.screenX - yd.screenX), (xd = a3.screenY - yd.screenY))
						: (xd = wd = 0),
					(yd = a3))
				return wd
			},
			movementY: function (a3) {
				return 'movementY' in a3 ? a3.movementY : xd
			},
		})
		var Bd = rd(Ad)
		var Cd = A2({}, Ad, { dataTransfer: 0 })
		var Dd = rd(Cd)
		var Ed = A2({}, ud, { relatedTarget: 0 })
		var Fd = rd(Ed)
		var Gd = A2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })
		var Hd = rd(Gd)
		var Id = A2({}, sd, {
			clipboardData: function (a3) {
				return 'clipboardData' in a3 ? a3.clipboardData : window.clipboardData
			},
		})
		var Jd = rd(Id)
		var Kd = A2({}, sd, { data: 0 })
		var Ld = rd(Kd)
		var Md = {
			Esc: 'Escape',
			Spacebar: ' ',
			Left: 'ArrowLeft',
			Up: 'ArrowUp',
			Right: 'ArrowRight',
			Down: 'ArrowDown',
			Del: 'Delete',
			Win: 'OS',
			Menu: 'ContextMenu',
			Apps: 'ContextMenu',
			Scroll: 'ScrollLock',
			MozPrintableKey: 'Unidentified',
		}
		var Nd = {
			8: 'Backspace',
			9: 'Tab',
			12: 'Clear',
			13: 'Enter',
			16: 'Shift',
			17: 'Control',
			18: 'Alt',
			19: 'Pause',
			20: 'CapsLock',
			27: 'Escape',
			32: ' ',
			33: 'PageUp',
			34: 'PageDown',
			35: 'End',
			36: 'Home',
			37: 'ArrowLeft',
			38: 'ArrowUp',
			39: 'ArrowRight',
			40: 'ArrowDown',
			45: 'Insert',
			46: 'Delete',
			112: 'F1',
			113: 'F2',
			114: 'F3',
			115: 'F4',
			116: 'F5',
			117: 'F6',
			118: 'F7',
			119: 'F8',
			120: 'F9',
			121: 'F10',
			122: 'F11',
			123: 'F12',
			144: 'NumLock',
			145: 'ScrollLock',
			224: 'Meta',
		}
		var Od = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
		function Pd(a3) {
			var b3 = this.nativeEvent
			return b3.getModifierState ? b3.getModifierState(a3) : (a3 = Od[a3]) ? !!b3[a3] : false
		}
		function zd() {
			return Pd
		}
		var Qd = A2({}, ud, {
			key: function (a3) {
				if (a3.key) {
					var b3 = Md[a3.key] || a3.key
					if ('Unidentified' !== b3) return b3
				}
				return 'keypress' === a3.type
					? ((a3 = od(a3)), 13 === a3 ? 'Enter' : String.fromCharCode(a3))
					: 'keydown' === a3.type || 'keyup' === a3.type
					? Nd[a3.keyCode] || 'Unidentified'
					: ''
			},
			code: 0,
			location: 0,
			ctrlKey: 0,
			shiftKey: 0,
			altKey: 0,
			metaKey: 0,
			repeat: 0,
			locale: 0,
			getModifierState: zd,
			charCode: function (a3) {
				return 'keypress' === a3.type ? od(a3) : 0
			},
			keyCode: function (a3) {
				return 'keydown' === a3.type || 'keyup' === a3.type ? a3.keyCode : 0
			},
			which: function (a3) {
				return 'keypress' === a3.type
					? od(a3)
					: 'keydown' === a3.type || 'keyup' === a3.type
					? a3.keyCode
					: 0
			},
		})
		var Rd = rd(Qd)
		var Sd = A2({}, Ad, {
			pointerId: 0,
			width: 0,
			height: 0,
			pressure: 0,
			tangentialPressure: 0,
			tiltX: 0,
			tiltY: 0,
			twist: 0,
			pointerType: 0,
			isPrimary: 0,
		})
		var Td = rd(Sd)
		var Ud = A2({}, ud, {
			touches: 0,
			targetTouches: 0,
			changedTouches: 0,
			altKey: 0,
			metaKey: 0,
			ctrlKey: 0,
			shiftKey: 0,
			getModifierState: zd,
		})
		var Vd = rd(Ud)
		var Wd = A2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })
		var Xd = rd(Wd)
		var Yd = A2({}, Ad, {
			deltaX: function (a3) {
				return 'deltaX' in a3 ? a3.deltaX : 'wheelDeltaX' in a3 ? -a3.wheelDeltaX : 0
			},
			deltaY: function (a3) {
				return 'deltaY' in a3
					? a3.deltaY
					: 'wheelDeltaY' in a3
					? -a3.wheelDeltaY
					: 'wheelDelta' in a3
					? -a3.wheelDelta
					: 0
			},
			deltaZ: 0,
			deltaMode: 0,
		})
		var Zd = rd(Yd)
		var $d = [9, 13, 27, 32]
		var ae = ia && 'CompositionEvent' in window
		var be = null
		ia && 'documentMode' in document && (be = document.documentMode)
		var ce = ia && 'TextEvent' in window && !be
		var de = ia && (!ae || (be && 8 < be && 11 >= be))
		var ee = String.fromCharCode(32)
		var fe = false
		function ge(a3, b3) {
			switch (a3) {
				case 'keyup':
					return -1 !== $d.indexOf(b3.keyCode)
				case 'keydown':
					return 229 !== b3.keyCode
				case 'keypress':
				case 'mousedown':
				case 'focusout':
					return true
				default:
					return false
			}
		}
		function he(a3) {
			a3 = a3.detail
			return 'object' === typeof a3 && 'data' in a3 ? a3.data : null
		}
		var ie = false
		function je(a3, b3) {
			switch (a3) {
				case 'compositionend':
					return he(b3)
				case 'keypress':
					if (32 !== b3.which) return null
					fe = true
					return ee
				case 'textInput':
					return (a3 = b3.data), a3 === ee && fe ? null : a3
				default:
					return null
			}
		}
		function ke(a3, b3) {
			if (ie)
				return 'compositionend' === a3 || (!ae && ge(a3, b3))
					? ((a3 = nd()), (md = ld = kd = null), (ie = false), a3)
					: null
			switch (a3) {
				case 'paste':
					return null
				case 'keypress':
					if (!(b3.ctrlKey || b3.altKey || b3.metaKey) || (b3.ctrlKey && b3.altKey)) {
						if (b3.char && 1 < b3.char.length) return b3.char
						if (b3.which) return String.fromCharCode(b3.which)
					}
					return null
				case 'compositionend':
					return de && 'ko' !== b3.locale ? null : b3.data
				default:
					return null
			}
		}
		var le = {
			color: true,
			date: true,
			datetime: true,
			'datetime-local': true,
			email: true,
			month: true,
			number: true,
			password: true,
			range: true,
			search: true,
			tel: true,
			text: true,
			time: true,
			url: true,
			week: true,
		}
		function me(a3) {
			var b3 = a3 && a3.nodeName && a3.nodeName.toLowerCase()
			return 'input' === b3 ? !!le[a3.type] : 'textarea' === b3 ? true : false
		}
		function ne(a3, b3, c3, d3) {
			Eb(d3)
			b3 = oe(b3, 'onChange')
			0 < b3.length &&
				((c3 = new td('onChange', 'change', null, c3, d3)), a3.push({ event: c3, listeners: b3 }))
		}
		var pe = null
		var qe = null
		function re(a3) {
			se(a3, 0)
		}
		function te(a3) {
			var b3 = ue(a3)
			if (Wa(b3)) return a3
		}
		function ve(a3, b3) {
			if ('change' === a3) return b3
		}
		var we = false
		if (ia) {
			if (ia) {
				ye = 'oninput' in document
				if (!ye) {
					ze = document.createElement('div')
					ze.setAttribute('oninput', 'return;')
					ye = 'function' === typeof ze.oninput
				}
				xe = ye
			} else xe = false
			we = xe && (!document.documentMode || 9 < document.documentMode)
		}
		var xe
		var ye
		var ze
		function Ae() {
			pe && (pe.detachEvent('onpropertychange', Be), (qe = pe = null))
		}
		function Be(a3) {
			if ('value' === a3.propertyName && te(qe)) {
				var b3 = []
				ne(b3, qe, a3, xb(a3))
				Jb(re, b3)
			}
		}
		function Ce(a3, b3, c3) {
			'focusin' === a3
				? (Ae(), (pe = b3), (qe = c3), pe.attachEvent('onpropertychange', Be))
				: 'focusout' === a3 && Ae()
		}
		function De(a3) {
			if ('selectionchange' === a3 || 'keyup' === a3 || 'keydown' === a3) return te(qe)
		}
		function Ee(a3, b3) {
			if ('click' === a3) return te(b3)
		}
		function Fe(a3, b3) {
			if ('input' === a3 || 'change' === a3) return te(b3)
		}
		function Ge(a3, b3) {
			return (a3 === b3 && (0 !== a3 || 1 / a3 === 1 / b3)) || (a3 !== a3 && b3 !== b3)
		}
		var He = 'function' === typeof Object.is ? Object.is : Ge
		function Ie(a3, b3) {
			if (He(a3, b3)) return true
			if ('object' !== typeof a3 || null === a3 || 'object' !== typeof b3 || null === b3)
				return false
			var c3 = Object.keys(a3),
				d3 = Object.keys(b3)
			if (c3.length !== d3.length) return false
			for (d3 = 0; d3 < c3.length; d3++) {
				var e2 = c3[d3]
				if (!ja.call(b3, e2) || !He(a3[e2], b3[e2])) return false
			}
			return true
		}
		function Je(a3) {
			for (; a3 && a3.firstChild; ) a3 = a3.firstChild
			return a3
		}
		function Ke(a3, b3) {
			var c3 = Je(a3)
			a3 = 0
			for (var d3; c3; ) {
				if (3 === c3.nodeType) {
					d3 = a3 + c3.textContent.length
					if (a3 <= b3 && d3 >= b3) return { node: c3, offset: b3 - a3 }
					a3 = d3
				}
				a: {
					for (; c3; ) {
						if (c3.nextSibling) {
							c3 = c3.nextSibling
							break a
						}
						c3 = c3.parentNode
					}
					c3 = void 0
				}
				c3 = Je(c3)
			}
		}
		function Le(a3, b3) {
			return a3 && b3
				? a3 === b3
					? true
					: a3 && 3 === a3.nodeType
					? false
					: b3 && 3 === b3.nodeType
					? Le(a3, b3.parentNode)
					: 'contains' in a3
					? a3.contains(b3)
					: a3.compareDocumentPosition
					? !!(a3.compareDocumentPosition(b3) & 16)
					: false
				: false
		}
		function Me() {
			for (var a3 = window, b3 = Xa(); b3 instanceof a3.HTMLIFrameElement; ) {
				try {
					var c3 = 'string' === typeof b3.contentWindow.location.href
				} catch (d3) {
					c3 = false
				}
				if (c3) a3 = b3.contentWindow
				else break
				b3 = Xa(a3.document)
			}
			return b3
		}
		function Ne(a3) {
			var b3 = a3 && a3.nodeName && a3.nodeName.toLowerCase()
			return (
				b3 &&
				(('input' === b3 &&
					('text' === a3.type ||
						'search' === a3.type ||
						'tel' === a3.type ||
						'url' === a3.type ||
						'password' === a3.type)) ||
					'textarea' === b3 ||
					'true' === a3.contentEditable)
			)
		}
		function Oe(a3) {
			var b3 = Me(),
				c3 = a3.focusedElem,
				d3 = a3.selectionRange
			if (b3 !== c3 && c3 && c3.ownerDocument && Le(c3.ownerDocument.documentElement, c3)) {
				if (null !== d3 && Ne(c3)) {
					if (((b3 = d3.start), (a3 = d3.end), void 0 === a3 && (a3 = b3), 'selectionStart' in c3))
						(c3.selectionStart = b3), (c3.selectionEnd = Math.min(a3, c3.value.length))
					else if (
						((a3 = ((b3 = c3.ownerDocument || document) && b3.defaultView) || window),
						a3.getSelection)
					) {
						a3 = a3.getSelection()
						var e2 = c3.textContent.length,
							f3 = Math.min(d3.start, e2)
						d3 = void 0 === d3.end ? f3 : Math.min(d3.end, e2)
						!a3.extend && f3 > d3 && ((e2 = d3), (d3 = f3), (f3 = e2))
						e2 = Ke(c3, f3)
						var g3 = Ke(c3, d3)
						e2 &&
							g3 &&
							(1 !== a3.rangeCount ||
								a3.anchorNode !== e2.node ||
								a3.anchorOffset !== e2.offset ||
								a3.focusNode !== g3.node ||
								a3.focusOffset !== g3.offset) &&
							((b3 = b3.createRange()),
							b3.setStart(e2.node, e2.offset),
							a3.removeAllRanges(),
							f3 > d3
								? (a3.addRange(b3), a3.extend(g3.node, g3.offset))
								: (b3.setEnd(g3.node, g3.offset), a3.addRange(b3)))
					}
				}
				b3 = []
				for (a3 = c3; (a3 = a3.parentNode); )
					1 === a3.nodeType && b3.push({ element: a3, left: a3.scrollLeft, top: a3.scrollTop })
				'function' === typeof c3.focus && c3.focus()
				for (c3 = 0; c3 < b3.length; c3++)
					(a3 = b3[c3]), (a3.element.scrollLeft = a3.left), (a3.element.scrollTop = a3.top)
			}
		}
		var Pe = ia && 'documentMode' in document && 11 >= document.documentMode
		var Qe = null
		var Re = null
		var Se = null
		var Te = false
		function Ue(a3, b3, c3) {
			var d3 = c3.window === c3 ? c3.document : 9 === c3.nodeType ? c3 : c3.ownerDocument
			Te ||
				null == Qe ||
				Qe !== Xa(d3) ||
				((d3 = Qe),
				'selectionStart' in d3 && Ne(d3)
					? (d3 = { start: d3.selectionStart, end: d3.selectionEnd })
					: ((d3 = ((d3.ownerDocument && d3.ownerDocument.defaultView) || window).getSelection()),
					  (d3 = {
							anchorNode: d3.anchorNode,
							anchorOffset: d3.anchorOffset,
							focusNode: d3.focusNode,
							focusOffset: d3.focusOffset,
					  })),
				(Se && Ie(Se, d3)) ||
					((Se = d3),
					(d3 = oe(Re, 'onSelect')),
					0 < d3.length &&
						((b3 = new td('onSelect', 'select', null, b3, c3)),
						a3.push({ event: b3, listeners: d3 }),
						(b3.target = Qe))))
		}
		function Ve(a3, b3) {
			var c3 = {}
			c3[a3.toLowerCase()] = b3.toLowerCase()
			c3['Webkit' + a3] = 'webkit' + b3
			c3['Moz' + a3] = 'moz' + b3
			return c3
		}
		var We = {
			animationend: Ve('Animation', 'AnimationEnd'),
			animationiteration: Ve('Animation', 'AnimationIteration'),
			animationstart: Ve('Animation', 'AnimationStart'),
			transitionend: Ve('Transition', 'TransitionEnd'),
		}
		var Xe = {}
		var Ye = {}
		ia &&
			((Ye = document.createElement('div').style),
			'AnimationEvent' in window ||
				(delete We.animationend.animation,
				delete We.animationiteration.animation,
				delete We.animationstart.animation),
			'TransitionEvent' in window || delete We.transitionend.transition)
		function Ze(a3) {
			if (Xe[a3]) return Xe[a3]
			if (!We[a3]) return a3
			var b3 = We[a3],
				c3
			for (c3 in b3) if (b3.hasOwnProperty(c3) && c3 in Ye) return (Xe[a3] = b3[c3])
			return a3
		}
		var $e = Ze('animationend')
		var af = Ze('animationiteration')
		var bf = Ze('animationstart')
		var cf = Ze('transitionend')
		var df = /* @__PURE__ */ new Map()
		var ef =
			'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
				' '
			)
		function ff(a3, b3) {
			df.set(a3, b3)
			fa(b3, [a3])
		}
		for (gf = 0; gf < ef.length; gf++) {
			;(hf = ef[gf]), (jf = hf.toLowerCase()), (kf = hf[0].toUpperCase() + hf.slice(1))
			ff(jf, 'on' + kf)
		}
		var hf
		var jf
		var kf
		var gf
		ff($e, 'onAnimationEnd')
		ff(af, 'onAnimationIteration')
		ff(bf, 'onAnimationStart')
		ff('dblclick', 'onDoubleClick')
		ff('focusin', 'onFocus')
		ff('focusout', 'onBlur')
		ff(cf, 'onTransitionEnd')
		ha('onMouseEnter', ['mouseout', 'mouseover'])
		ha('onMouseLeave', ['mouseout', 'mouseover'])
		ha('onPointerEnter', ['pointerout', 'pointerover'])
		ha('onPointerLeave', ['pointerout', 'pointerover'])
		fa('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' '))
		fa(
			'onSelect',
			'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
				' '
			)
		)
		fa('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste'])
		fa('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' '))
		fa(
			'onCompositionStart',
			'compositionstart focusout keydown keypress keyup mousedown'.split(' ')
		)
		fa(
			'onCompositionUpdate',
			'compositionupdate focusout keydown keypress keyup mousedown'.split(' ')
		)
		var lf =
			'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
				' '
			)
		var mf = new Set('cancel close invalid load scroll toggle'.split(' ').concat(lf))
		function nf(a3, b3, c3) {
			var d3 = a3.type || 'unknown-event'
			a3.currentTarget = c3
			Ub(d3, b3, void 0, a3)
			a3.currentTarget = null
		}
		function se(a3, b3) {
			b3 = 0 !== (b3 & 4)
			for (var c3 = 0; c3 < a3.length; c3++) {
				var d3 = a3[c3],
					e2 = d3.event
				d3 = d3.listeners
				a: {
					var f3 = void 0
					if (b3)
						for (var g3 = d3.length - 1; 0 <= g3; g3--) {
							var h3 = d3[g3],
								k2 = h3.instance,
								l3 = h3.currentTarget
							h3 = h3.listener
							if (k2 !== f3 && e2.isPropagationStopped()) break a
							nf(e2, h3, l3)
							f3 = k2
						}
					else
						for (g3 = 0; g3 < d3.length; g3++) {
							h3 = d3[g3]
							k2 = h3.instance
							l3 = h3.currentTarget
							h3 = h3.listener
							if (k2 !== f3 && e2.isPropagationStopped()) break a
							nf(e2, h3, l3)
							f3 = k2
						}
				}
			}
			if (Qb) throw ((a3 = Rb), (Qb = false), (Rb = null), a3)
		}
		function D3(a3, b3) {
			var c3 = b3[of]
			void 0 === c3 && (c3 = b3[of] = /* @__PURE__ */ new Set())
			var d3 = a3 + '__bubble'
			c3.has(d3) || (pf(b3, a3, 2, false), c3.add(d3))
		}
		function qf(a3, b3, c3) {
			var d3 = 0
			b3 && (d3 |= 4)
			pf(c3, a3, d3, b3)
		}
		var rf = '_reactListening' + Math.random().toString(36).slice(2)
		function sf(a3) {
			if (!a3[rf]) {
				a3[rf] = true
				da.forEach(function (b4) {
					'selectionchange' !== b4 && (mf.has(b4) || qf(b4, false, a3), qf(b4, true, a3))
				})
				var b3 = 9 === a3.nodeType ? a3 : a3.ownerDocument
				null === b3 || b3[rf] || ((b3[rf] = true), qf('selectionchange', false, b3))
			}
		}
		function pf(a3, b3, c3, d3) {
			switch (jd(b3)) {
				case 1:
					var e2 = ed
					break
				case 4:
					e2 = gd
					break
				default:
					e2 = fd
			}
			c3 = e2.bind(null, b3, c3, a3)
			e2 = void 0
			!Lb || ('touchstart' !== b3 && 'touchmove' !== b3 && 'wheel' !== b3) || (e2 = true)
			d3
				? void 0 !== e2
					? a3.addEventListener(b3, c3, { capture: true, passive: e2 })
					: a3.addEventListener(b3, c3, true)
				: void 0 !== e2
				? a3.addEventListener(b3, c3, { passive: e2 })
				: a3.addEventListener(b3, c3, false)
		}
		function hd(a3, b3, c3, d3, e2) {
			var f3 = d3
			if (0 === (b3 & 1) && 0 === (b3 & 2) && null !== d3)
				a: for (;;) {
					if (null === d3) return
					var g3 = d3.tag
					if (3 === g3 || 4 === g3) {
						var h3 = d3.stateNode.containerInfo
						if (h3 === e2 || (8 === h3.nodeType && h3.parentNode === e2)) break
						if (4 === g3)
							for (g3 = d3.return; null !== g3; ) {
								var k2 = g3.tag
								if (3 === k2 || 4 === k2) {
									if (
										((k2 = g3.stateNode.containerInfo),
										k2 === e2 || (8 === k2.nodeType && k2.parentNode === e2))
									)
										return
								}
								g3 = g3.return
							}
						for (; null !== h3; ) {
							g3 = Wc(h3)
							if (null === g3) return
							k2 = g3.tag
							if (5 === k2 || 6 === k2) {
								d3 = f3 = g3
								continue a
							}
							h3 = h3.parentNode
						}
					}
					d3 = d3.return
				}
			Jb(function () {
				var d4 = f3,
					e3 = xb(c3),
					g4 = []
				a: {
					var h4 = df.get(a3)
					if (void 0 !== h4) {
						var k3 = td,
							n3 = a3
						switch (a3) {
							case 'keypress':
								if (0 === od(c3)) break a
							case 'keydown':
							case 'keyup':
								k3 = Rd
								break
							case 'focusin':
								n3 = 'focus'
								k3 = Fd
								break
							case 'focusout':
								n3 = 'blur'
								k3 = Fd
								break
							case 'beforeblur':
							case 'afterblur':
								k3 = Fd
								break
							case 'click':
								if (2 === c3.button) break a
							case 'auxclick':
							case 'dblclick':
							case 'mousedown':
							case 'mousemove':
							case 'mouseup':
							case 'mouseout':
							case 'mouseover':
							case 'contextmenu':
								k3 = Bd
								break
							case 'drag':
							case 'dragend':
							case 'dragenter':
							case 'dragexit':
							case 'dragleave':
							case 'dragover':
							case 'dragstart':
							case 'drop':
								k3 = Dd
								break
							case 'touchcancel':
							case 'touchend':
							case 'touchmove':
							case 'touchstart':
								k3 = Vd
								break
							case $e:
							case af:
							case bf:
								k3 = Hd
								break
							case cf:
								k3 = Xd
								break
							case 'scroll':
								k3 = vd
								break
							case 'wheel':
								k3 = Zd
								break
							case 'copy':
							case 'cut':
							case 'paste':
								k3 = Jd
								break
							case 'gotpointercapture':
							case 'lostpointercapture':
							case 'pointercancel':
							case 'pointerdown':
							case 'pointermove':
							case 'pointerout':
							case 'pointerover':
							case 'pointerup':
								k3 = Td
						}
						var t4 = 0 !== (b3 & 4),
							J = !t4 && 'scroll' === a3,
							x3 = t4 ? (null !== h4 ? h4 + 'Capture' : null) : h4
						t4 = []
						for (var w3 = d4, u3; null !== w3; ) {
							u3 = w3
							var F = u3.stateNode
							5 === u3.tag &&
								null !== F &&
								((u3 = F), null !== x3 && ((F = Kb(w3, x3)), null != F && t4.push(tf(w3, F, u3))))
							if (J) break
							w3 = w3.return
						}
						0 < t4.length &&
							((h4 = new k3(h4, n3, null, c3, e3)), g4.push({ event: h4, listeners: t4 }))
					}
				}
				if (0 === (b3 & 7)) {
					a: {
						h4 = 'mouseover' === a3 || 'pointerover' === a3
						k3 = 'mouseout' === a3 || 'pointerout' === a3
						if (h4 && c3 !== wb && (n3 = c3.relatedTarget || c3.fromElement) && (Wc(n3) || n3[uf]))
							break a
						if (k3 || h4) {
							h4 =
								e3.window === e3
									? e3
									: (h4 = e3.ownerDocument)
									? h4.defaultView || h4.parentWindow
									: window
							if (k3) {
								if (
									((n3 = c3.relatedTarget || c3.toElement),
									(k3 = d4),
									(n3 = n3 ? Wc(n3) : null),
									null !== n3 && ((J = Vb(n3)), n3 !== J || (5 !== n3.tag && 6 !== n3.tag)))
								)
									n3 = null
							} else (k3 = null), (n3 = d4)
							if (k3 !== n3) {
								t4 = Bd
								F = 'onMouseLeave'
								x3 = 'onMouseEnter'
								w3 = 'mouse'
								if ('pointerout' === a3 || 'pointerover' === a3)
									(t4 = Td), (F = 'onPointerLeave'), (x3 = 'onPointerEnter'), (w3 = 'pointer')
								J = null == k3 ? h4 : ue(k3)
								u3 = null == n3 ? h4 : ue(n3)
								h4 = new t4(F, w3 + 'leave', k3, c3, e3)
								h4.target = J
								h4.relatedTarget = u3
								F = null
								Wc(e3) === d4 &&
									((t4 = new t4(x3, w3 + 'enter', n3, c3, e3)),
									(t4.target = u3),
									(t4.relatedTarget = J),
									(F = t4))
								J = F
								if (k3 && n3)
									b: {
										t4 = k3
										x3 = n3
										w3 = 0
										for (u3 = t4; u3; u3 = vf(u3)) w3++
										u3 = 0
										for (F = x3; F; F = vf(F)) u3++
										for (; 0 < w3 - u3; ) (t4 = vf(t4)), w3--
										for (; 0 < u3 - w3; ) (x3 = vf(x3)), u3--
										for (; w3--; ) {
											if (t4 === x3 || (null !== x3 && t4 === x3.alternate)) break b
											t4 = vf(t4)
											x3 = vf(x3)
										}
										t4 = null
									}
								else t4 = null
								null !== k3 && wf(g4, h4, k3, t4, false)
								null !== n3 && null !== J && wf(g4, J, n3, t4, true)
							}
						}
					}
					a: {
						h4 = d4 ? ue(d4) : window
						k3 = h4.nodeName && h4.nodeName.toLowerCase()
						if ('select' === k3 || ('input' === k3 && 'file' === h4.type)) var na = ve
						else if (me(h4))
							if (we) na = Fe
							else {
								na = De
								var xa = Ce
							}
						else
							(k3 = h4.nodeName) &&
								'input' === k3.toLowerCase() &&
								('checkbox' === h4.type || 'radio' === h4.type) &&
								(na = Ee)
						if (na && (na = na(a3, d4))) {
							ne(g4, na, c3, e3)
							break a
						}
						xa && xa(a3, h4, d4)
						'focusout' === a3 &&
							(xa = h4._wrapperState) &&
							xa.controlled &&
							'number' === h4.type &&
							cb(h4, 'number', h4.value)
					}
					xa = d4 ? ue(d4) : window
					switch (a3) {
						case 'focusin':
							if (me(xa) || 'true' === xa.contentEditable) (Qe = xa), (Re = d4), (Se = null)
							break
						case 'focusout':
							Se = Re = Qe = null
							break
						case 'mousedown':
							Te = true
							break
						case 'contextmenu':
						case 'mouseup':
						case 'dragend':
							Te = false
							Ue(g4, c3, e3)
							break
						case 'selectionchange':
							if (Pe) break
						case 'keydown':
						case 'keyup':
							Ue(g4, c3, e3)
					}
					var $a
					if (ae)
						b: {
							switch (a3) {
								case 'compositionstart':
									var ba = 'onCompositionStart'
									break b
								case 'compositionend':
									ba = 'onCompositionEnd'
									break b
								case 'compositionupdate':
									ba = 'onCompositionUpdate'
									break b
							}
							ba = void 0
						}
					else
						ie
							? ge(a3, c3) && (ba = 'onCompositionEnd')
							: 'keydown' === a3 && 229 === c3.keyCode && (ba = 'onCompositionStart')
					ba &&
						(de &&
							'ko' !== c3.locale &&
							(ie || 'onCompositionStart' !== ba
								? 'onCompositionEnd' === ba && ie && ($a = nd())
								: ((kd = e3), (ld = 'value' in kd ? kd.value : kd.textContent), (ie = true))),
						(xa = oe(d4, ba)),
						0 < xa.length &&
							((ba = new Ld(ba, a3, null, c3, e3)),
							g4.push({ event: ba, listeners: xa }),
							$a ? (ba.data = $a) : (($a = he(c3)), null !== $a && (ba.data = $a))))
					if (($a = ce ? je(a3, c3) : ke(a3, c3)))
						(d4 = oe(d4, 'onBeforeInput')),
							0 < d4.length &&
								((e3 = new Ld('onBeforeInput', 'beforeinput', null, c3, e3)),
								g4.push({ event: e3, listeners: d4 }),
								(e3.data = $a))
				}
				se(g4, b3)
			})
		}
		function tf(a3, b3, c3) {
			return { instance: a3, listener: b3, currentTarget: c3 }
		}
		function oe(a3, b3) {
			for (var c3 = b3 + 'Capture', d3 = []; null !== a3; ) {
				var e2 = a3,
					f3 = e2.stateNode
				5 === e2.tag &&
					null !== f3 &&
					((e2 = f3),
					(f3 = Kb(a3, c3)),
					null != f3 && d3.unshift(tf(a3, f3, e2)),
					(f3 = Kb(a3, b3)),
					null != f3 && d3.push(tf(a3, f3, e2)))
				a3 = a3.return
			}
			return d3
		}
		function vf(a3) {
			if (null === a3) return null
			do a3 = a3.return
			while (a3 && 5 !== a3.tag)
			return a3 ? a3 : null
		}
		function wf(a3, b3, c3, d3, e2) {
			for (var f3 = b3._reactName, g3 = []; null !== c3 && c3 !== d3; ) {
				var h3 = c3,
					k2 = h3.alternate,
					l3 = h3.stateNode
				if (null !== k2 && k2 === d3) break
				5 === h3.tag &&
					null !== l3 &&
					((h3 = l3),
					e2
						? ((k2 = Kb(c3, f3)), null != k2 && g3.unshift(tf(c3, k2, h3)))
						: e2 || ((k2 = Kb(c3, f3)), null != k2 && g3.push(tf(c3, k2, h3))))
				c3 = c3.return
			}
			0 !== g3.length && a3.push({ event: b3, listeners: g3 })
		}
		var xf = /\r\n?/g
		var yf = /\u0000|\uFFFD/g
		function zf(a3) {
			return ('string' === typeof a3 ? a3 : '' + a3).replace(xf, '\n').replace(yf, '')
		}
		function Af(a3, b3, c3) {
			b3 = zf(b3)
			if (zf(a3) !== b3 && c3) throw Error(p3(425))
		}
		function Bf() {}
		var Cf = null
		var Df = null
		function Ef(a3, b3) {
			return (
				'textarea' === a3 ||
				'noscript' === a3 ||
				'string' === typeof b3.children ||
				'number' === typeof b3.children ||
				('object' === typeof b3.dangerouslySetInnerHTML &&
					null !== b3.dangerouslySetInnerHTML &&
					null != b3.dangerouslySetInnerHTML.__html)
			)
		}
		var Ff = 'function' === typeof setTimeout ? setTimeout : void 0
		var Gf = 'function' === typeof clearTimeout ? clearTimeout : void 0
		var Hf = 'function' === typeof Promise ? Promise : void 0
		var Jf =
			'function' === typeof queueMicrotask
				? queueMicrotask
				: 'undefined' !== typeof Hf
				? function (a3) {
						return Hf.resolve(null).then(a3).catch(If)
				  }
				: Ff
		function If(a3) {
			setTimeout(function () {
				throw a3
			})
		}
		function Kf(a3, b3) {
			var c3 = b3,
				d3 = 0
			do {
				var e2 = c3.nextSibling
				a3.removeChild(c3)
				if (e2 && 8 === e2.nodeType)
					if (((c3 = e2.data), '/$' === c3)) {
						if (0 === d3) {
							a3.removeChild(e2)
							bd(b3)
							return
						}
						d3--
					} else ('$' !== c3 && '$?' !== c3 && '$!' !== c3) || d3++
				c3 = e2
			} while (c3)
			bd(b3)
		}
		function Lf(a3) {
			for (; null != a3; a3 = a3.nextSibling) {
				var b3 = a3.nodeType
				if (1 === b3 || 3 === b3) break
				if (8 === b3) {
					b3 = a3.data
					if ('$' === b3 || '$!' === b3 || '$?' === b3) break
					if ('/$' === b3) return null
				}
			}
			return a3
		}
		function Mf(a3) {
			a3 = a3.previousSibling
			for (var b3 = 0; a3; ) {
				if (8 === a3.nodeType) {
					var c3 = a3.data
					if ('$' === c3 || '$!' === c3 || '$?' === c3) {
						if (0 === b3) return a3
						b3--
					} else '/$' === c3 && b3++
				}
				a3 = a3.previousSibling
			}
			return null
		}
		var Nf = Math.random().toString(36).slice(2)
		var Of = '__reactFiber$' + Nf
		var Pf = '__reactProps$' + Nf
		var uf = '__reactContainer$' + Nf
		var of = '__reactEvents$' + Nf
		var Qf = '__reactListeners$' + Nf
		var Rf = '__reactHandles$' + Nf
		function Wc(a3) {
			var b3 = a3[Of]
			if (b3) return b3
			for (var c3 = a3.parentNode; c3; ) {
				if ((b3 = c3[uf] || c3[Of])) {
					c3 = b3.alternate
					if (null !== b3.child || (null !== c3 && null !== c3.child))
						for (a3 = Mf(a3); null !== a3; ) {
							if ((c3 = a3[Of])) return c3
							a3 = Mf(a3)
						}
					return b3
				}
				a3 = c3
				c3 = a3.parentNode
			}
			return null
		}
		function Cb(a3) {
			a3 = a3[Of] || a3[uf]
			return !a3 || (5 !== a3.tag && 6 !== a3.tag && 13 !== a3.tag && 3 !== a3.tag) ? null : a3
		}
		function ue(a3) {
			if (5 === a3.tag || 6 === a3.tag) return a3.stateNode
			throw Error(p3(33))
		}
		function Db(a3) {
			return a3[Pf] || null
		}
		var Sf = []
		var Tf = -1
		function Uf(a3) {
			return { current: a3 }
		}
		function E3(a3) {
			0 > Tf || ((a3.current = Sf[Tf]), (Sf[Tf] = null), Tf--)
		}
		function G(a3, b3) {
			Tf++
			Sf[Tf] = a3.current
			a3.current = b3
		}
		var Vf = {}
		var H2 = Uf(Vf)
		var Wf = Uf(false)
		var Xf = Vf
		function Yf(a3, b3) {
			var c3 = a3.type.contextTypes
			if (!c3) return Vf
			var d3 = a3.stateNode
			if (d3 && d3.__reactInternalMemoizedUnmaskedChildContext === b3)
				return d3.__reactInternalMemoizedMaskedChildContext
			var e2 = {},
				f3
			for (f3 in c3) e2[f3] = b3[f3]
			d3 &&
				((a3 = a3.stateNode),
				(a3.__reactInternalMemoizedUnmaskedChildContext = b3),
				(a3.__reactInternalMemoizedMaskedChildContext = e2))
			return e2
		}
		function Zf(a3) {
			a3 = a3.childContextTypes
			return null !== a3 && void 0 !== a3
		}
		function $f() {
			E3(Wf)
			E3(H2)
		}
		function ag(a3, b3, c3) {
			if (H2.current !== Vf) throw Error(p3(168))
			G(H2, b3)
			G(Wf, c3)
		}
		function bg(a3, b3, c3) {
			var d3 = a3.stateNode
			b3 = b3.childContextTypes
			if ('function' !== typeof d3.getChildContext) return c3
			d3 = d3.getChildContext()
			for (var e2 in d3) if (!(e2 in b3)) throw Error(p3(108, Ra(a3) || 'Unknown', e2))
			return A2({}, c3, d3)
		}
		function cg(a3) {
			a3 = ((a3 = a3.stateNode) && a3.__reactInternalMemoizedMergedChildContext) || Vf
			Xf = H2.current
			G(H2, a3)
			G(Wf, Wf.current)
			return true
		}
		function dg(a3, b3, c3) {
			var d3 = a3.stateNode
			if (!d3) throw Error(p3(169))
			c3
				? ((a3 = bg(a3, b3, Xf)),
				  (d3.__reactInternalMemoizedMergedChildContext = a3),
				  E3(Wf),
				  E3(H2),
				  G(H2, a3))
				: E3(Wf)
			G(Wf, c3)
		}
		var eg = null
		var fg = false
		var gg = false
		function hg(a3) {
			null === eg ? (eg = [a3]) : eg.push(a3)
		}
		function ig(a3) {
			fg = true
			hg(a3)
		}
		function jg() {
			if (!gg && null !== eg) {
				gg = true
				var a3 = 0,
					b3 = C2
				try {
					var c3 = eg
					for (C2 = 1; a3 < c3.length; a3++) {
						var d3 = c3[a3]
						do d3 = d3(true)
						while (null !== d3)
					}
					eg = null
					fg = false
				} catch (e2) {
					throw (null !== eg && (eg = eg.slice(a3 + 1)), ac(fc, jg), e2)
				} finally {
					;(C2 = b3), (gg = false)
				}
			}
			return null
		}
		var kg = []
		var lg = 0
		var mg = null
		var ng = 0
		var og = []
		var pg = 0
		var qg = null
		var rg = 1
		var sg = ''
		function tg(a3, b3) {
			kg[lg++] = ng
			kg[lg++] = mg
			mg = a3
			ng = b3
		}
		function ug(a3, b3, c3) {
			og[pg++] = rg
			og[pg++] = sg
			og[pg++] = qg
			qg = a3
			var d3 = rg
			a3 = sg
			var e2 = 32 - oc(d3) - 1
			d3 &= ~(1 << e2)
			c3 += 1
			var f3 = 32 - oc(b3) + e2
			if (30 < f3) {
				var g3 = e2 - (e2 % 5)
				f3 = (d3 & ((1 << g3) - 1)).toString(32)
				d3 >>= g3
				e2 -= g3
				rg = (1 << (32 - oc(b3) + e2)) | (c3 << e2) | d3
				sg = f3 + a3
			} else (rg = (1 << f3) | (c3 << e2) | d3), (sg = a3)
		}
		function vg(a3) {
			null !== a3.return && (tg(a3, 1), ug(a3, 1, 0))
		}
		function wg(a3) {
			for (; a3 === mg; ) (mg = kg[--lg]), (kg[lg] = null), (ng = kg[--lg]), (kg[lg] = null)
			for (; a3 === qg; )
				(qg = og[--pg]),
					(og[pg] = null),
					(sg = og[--pg]),
					(og[pg] = null),
					(rg = og[--pg]),
					(og[pg] = null)
		}
		var xg = null
		var yg = null
		var I = false
		var zg = null
		function Ag(a3, b3) {
			var c3 = Bg(5, null, null, 0)
			c3.elementType = 'DELETED'
			c3.stateNode = b3
			c3.return = a3
			b3 = a3.deletions
			null === b3 ? ((a3.deletions = [c3]), (a3.flags |= 16)) : b3.push(c3)
		}
		function Cg(a3, b3) {
			switch (a3.tag) {
				case 5:
					var c3 = a3.type
					b3 = 1 !== b3.nodeType || c3.toLowerCase() !== b3.nodeName.toLowerCase() ? null : b3
					return null !== b3
						? ((a3.stateNode = b3), (xg = a3), (yg = Lf(b3.firstChild)), true)
						: false
				case 6:
					return (
						(b3 = '' === a3.pendingProps || 3 !== b3.nodeType ? null : b3),
						null !== b3 ? ((a3.stateNode = b3), (xg = a3), (yg = null), true) : false
					)
				case 13:
					return (
						(b3 = 8 !== b3.nodeType ? null : b3),
						null !== b3
							? ((c3 = null !== qg ? { id: rg, overflow: sg } : null),
							  (a3.memoizedState = { dehydrated: b3, treeContext: c3, retryLane: 1073741824 }),
							  (c3 = Bg(18, null, null, 0)),
							  (c3.stateNode = b3),
							  (c3.return = a3),
							  (a3.child = c3),
							  (xg = a3),
							  (yg = null),
							  true)
							: false
					)
				default:
					return false
			}
		}
		function Dg(a3) {
			return 0 !== (a3.mode & 1) && 0 === (a3.flags & 128)
		}
		function Eg(a3) {
			if (I) {
				var b3 = yg
				if (b3) {
					var c3 = b3
					if (!Cg(a3, b3)) {
						if (Dg(a3)) throw Error(p3(418))
						b3 = Lf(c3.nextSibling)
						var d3 = xg
						b3 && Cg(a3, b3)
							? Ag(d3, c3)
							: ((a3.flags = (a3.flags & -4097) | 2), (I = false), (xg = a3))
					}
				} else {
					if (Dg(a3)) throw Error(p3(418))
					a3.flags = (a3.flags & -4097) | 2
					I = false
					xg = a3
				}
			}
		}
		function Fg(a3) {
			for (a3 = a3.return; null !== a3 && 5 !== a3.tag && 3 !== a3.tag && 13 !== a3.tag; )
				a3 = a3.return
			xg = a3
		}
		function Gg(a3) {
			if (a3 !== xg) return false
			if (!I) return Fg(a3), (I = true), false
			var b3
			;(b3 = 3 !== a3.tag) &&
				!(b3 = 5 !== a3.tag) &&
				((b3 = a3.type), (b3 = 'head' !== b3 && 'body' !== b3 && !Ef(a3.type, a3.memoizedProps)))
			if (b3 && (b3 = yg)) {
				if (Dg(a3)) throw (Hg(), Error(p3(418)))
				for (; b3; ) Ag(a3, b3), (b3 = Lf(b3.nextSibling))
			}
			Fg(a3)
			if (13 === a3.tag) {
				a3 = a3.memoizedState
				a3 = null !== a3 ? a3.dehydrated : null
				if (!a3) throw Error(p3(317))
				a: {
					a3 = a3.nextSibling
					for (b3 = 0; a3; ) {
						if (8 === a3.nodeType) {
							var c3 = a3.data
							if ('/$' === c3) {
								if (0 === b3) {
									yg = Lf(a3.nextSibling)
									break a
								}
								b3--
							} else ('$' !== c3 && '$!' !== c3 && '$?' !== c3) || b3++
						}
						a3 = a3.nextSibling
					}
					yg = null
				}
			} else yg = xg ? Lf(a3.stateNode.nextSibling) : null
			return true
		}
		function Hg() {
			for (var a3 = yg; a3; ) a3 = Lf(a3.nextSibling)
		}
		function Ig() {
			yg = xg = null
			I = false
		}
		function Jg(a3) {
			null === zg ? (zg = [a3]) : zg.push(a3)
		}
		var Kg = ua.ReactCurrentBatchConfig
		function Lg(a3, b3) {
			if (a3 && a3.defaultProps) {
				b3 = A2({}, b3)
				a3 = a3.defaultProps
				for (var c3 in a3) void 0 === b3[c3] && (b3[c3] = a3[c3])
				return b3
			}
			return b3
		}
		var Mg = Uf(null)
		var Ng = null
		var Og = null
		var Pg = null
		function Qg() {
			Pg = Og = Ng = null
		}
		function Rg(a3) {
			var b3 = Mg.current
			E3(Mg)
			a3._currentValue = b3
		}
		function Sg(a3, b3, c3) {
			for (; null !== a3; ) {
				var d3 = a3.alternate
				;(a3.childLanes & b3) !== b3
					? ((a3.childLanes |= b3), null !== d3 && (d3.childLanes |= b3))
					: null !== d3 && (d3.childLanes & b3) !== b3 && (d3.childLanes |= b3)
				if (a3 === c3) break
				a3 = a3.return
			}
		}
		function Tg(a3, b3) {
			Ng = a3
			Pg = Og = null
			a3 = a3.dependencies
			null !== a3 &&
				null !== a3.firstContext &&
				(0 !== (a3.lanes & b3) && (Ug = true), (a3.firstContext = null))
		}
		function Vg(a3) {
			var b3 = a3._currentValue
			if (Pg !== a3)
				if (((a3 = { context: a3, memoizedValue: b3, next: null }), null === Og)) {
					if (null === Ng) throw Error(p3(308))
					Og = a3
					Ng.dependencies = { lanes: 0, firstContext: a3 }
				} else Og = Og.next = a3
			return b3
		}
		var Wg = null
		function Xg(a3) {
			null === Wg ? (Wg = [a3]) : Wg.push(a3)
		}
		function Yg(a3, b3, c3, d3) {
			var e2 = b3.interleaved
			null === e2 ? ((c3.next = c3), Xg(b3)) : ((c3.next = e2.next), (e2.next = c3))
			b3.interleaved = c3
			return Zg(a3, d3)
		}
		function Zg(a3, b3) {
			a3.lanes |= b3
			var c3 = a3.alternate
			null !== c3 && (c3.lanes |= b3)
			c3 = a3
			for (a3 = a3.return; null !== a3; )
				(a3.childLanes |= b3),
					(c3 = a3.alternate),
					null !== c3 && (c3.childLanes |= b3),
					(c3 = a3),
					(a3 = a3.return)
			return 3 === c3.tag ? c3.stateNode : null
		}
		var $g = false
		function ah(a3) {
			a3.updateQueue = {
				baseState: a3.memoizedState,
				firstBaseUpdate: null,
				lastBaseUpdate: null,
				shared: { pending: null, interleaved: null, lanes: 0 },
				effects: null,
			}
		}
		function bh(a3, b3) {
			a3 = a3.updateQueue
			b3.updateQueue === a3 &&
				(b3.updateQueue = {
					baseState: a3.baseState,
					firstBaseUpdate: a3.firstBaseUpdate,
					lastBaseUpdate: a3.lastBaseUpdate,
					shared: a3.shared,
					effects: a3.effects,
				})
		}
		function ch(a3, b3) {
			return { eventTime: a3, lane: b3, tag: 0, payload: null, callback: null, next: null }
		}
		function dh(a3, b3, c3) {
			var d3 = a3.updateQueue
			if (null === d3) return null
			d3 = d3.shared
			if (0 !== (K & 2)) {
				var e2 = d3.pending
				null === e2 ? (b3.next = b3) : ((b3.next = e2.next), (e2.next = b3))
				d3.pending = b3
				return Zg(a3, c3)
			}
			e2 = d3.interleaved
			null === e2 ? ((b3.next = b3), Xg(d3)) : ((b3.next = e2.next), (e2.next = b3))
			d3.interleaved = b3
			return Zg(a3, c3)
		}
		function eh(a3, b3, c3) {
			b3 = b3.updateQueue
			if (null !== b3 && ((b3 = b3.shared), 0 !== (c3 & 4194240))) {
				var d3 = b3.lanes
				d3 &= a3.pendingLanes
				c3 |= d3
				b3.lanes = c3
				Cc(a3, c3)
			}
		}
		function fh(a3, b3) {
			var c3 = a3.updateQueue,
				d3 = a3.alternate
			if (null !== d3 && ((d3 = d3.updateQueue), c3 === d3)) {
				var e2 = null,
					f3 = null
				c3 = c3.firstBaseUpdate
				if (null !== c3) {
					do {
						var g3 = {
							eventTime: c3.eventTime,
							lane: c3.lane,
							tag: c3.tag,
							payload: c3.payload,
							callback: c3.callback,
							next: null,
						}
						null === f3 ? (e2 = f3 = g3) : (f3 = f3.next = g3)
						c3 = c3.next
					} while (null !== c3)
					null === f3 ? (e2 = f3 = b3) : (f3 = f3.next = b3)
				} else e2 = f3 = b3
				c3 = {
					baseState: d3.baseState,
					firstBaseUpdate: e2,
					lastBaseUpdate: f3,
					shared: d3.shared,
					effects: d3.effects,
				}
				a3.updateQueue = c3
				return
			}
			a3 = c3.lastBaseUpdate
			null === a3 ? (c3.firstBaseUpdate = b3) : (a3.next = b3)
			c3.lastBaseUpdate = b3
		}
		function gh(a3, b3, c3, d3) {
			var e2 = a3.updateQueue
			$g = false
			var f3 = e2.firstBaseUpdate,
				g3 = e2.lastBaseUpdate,
				h3 = e2.shared.pending
			if (null !== h3) {
				e2.shared.pending = null
				var k2 = h3,
					l3 = k2.next
				k2.next = null
				null === g3 ? (f3 = l3) : (g3.next = l3)
				g3 = k2
				var m3 = a3.alternate
				null !== m3 &&
					((m3 = m3.updateQueue),
					(h3 = m3.lastBaseUpdate),
					h3 !== g3 &&
						(null === h3 ? (m3.firstBaseUpdate = l3) : (h3.next = l3), (m3.lastBaseUpdate = k2)))
			}
			if (null !== f3) {
				var q = e2.baseState
				g3 = 0
				m3 = l3 = k2 = null
				h3 = f3
				do {
					var r3 = h3.lane,
						y3 = h3.eventTime
					if ((d3 & r3) === r3) {
						null !== m3 &&
							(m3 = m3.next =
								{
									eventTime: y3,
									lane: 0,
									tag: h3.tag,
									payload: h3.payload,
									callback: h3.callback,
									next: null,
								})
						a: {
							var n3 = a3,
								t4 = h3
							r3 = b3
							y3 = c3
							switch (t4.tag) {
								case 1:
									n3 = t4.payload
									if ('function' === typeof n3) {
										q = n3.call(y3, q, r3)
										break a
									}
									q = n3
									break a
								case 3:
									n3.flags = (n3.flags & -65537) | 128
								case 0:
									n3 = t4.payload
									r3 = 'function' === typeof n3 ? n3.call(y3, q, r3) : n3
									if (null === r3 || void 0 === r3) break a
									q = A2({}, q, r3)
									break a
								case 2:
									$g = true
							}
						}
						null !== h3.callback &&
							0 !== h3.lane &&
							((a3.flags |= 64), (r3 = e2.effects), null === r3 ? (e2.effects = [h3]) : r3.push(h3))
					} else
						(y3 = {
							eventTime: y3,
							lane: r3,
							tag: h3.tag,
							payload: h3.payload,
							callback: h3.callback,
							next: null,
						}),
							null === m3 ? ((l3 = m3 = y3), (k2 = q)) : (m3 = m3.next = y3),
							(g3 |= r3)
					h3 = h3.next
					if (null === h3)
						if (((h3 = e2.shared.pending), null === h3)) break
						else
							(r3 = h3),
								(h3 = r3.next),
								(r3.next = null),
								(e2.lastBaseUpdate = r3),
								(e2.shared.pending = null)
				} while (1)
				null === m3 && (k2 = q)
				e2.baseState = k2
				e2.firstBaseUpdate = l3
				e2.lastBaseUpdate = m3
				b3 = e2.shared.interleaved
				if (null !== b3) {
					e2 = b3
					do (g3 |= e2.lane), (e2 = e2.next)
					while (e2 !== b3)
				} else null === f3 && (e2.shared.lanes = 0)
				hh |= g3
				a3.lanes = g3
				a3.memoizedState = q
			}
		}
		function ih(a3, b3, c3) {
			a3 = b3.effects
			b3.effects = null
			if (null !== a3)
				for (b3 = 0; b3 < a3.length; b3++) {
					var d3 = a3[b3],
						e2 = d3.callback
					if (null !== e2) {
						d3.callback = null
						d3 = c3
						if ('function' !== typeof e2) throw Error(p3(191, e2))
						e2.call(d3)
					}
				}
		}
		var jh = new aa.Component().refs
		function kh(a3, b3, c3, d3) {
			b3 = a3.memoizedState
			c3 = c3(d3, b3)
			c3 = null === c3 || void 0 === c3 ? b3 : A2({}, b3, c3)
			a3.memoizedState = c3
			0 === a3.lanes && (a3.updateQueue.baseState = c3)
		}
		var nh = {
			isMounted: function (a3) {
				return (a3 = a3._reactInternals) ? Vb(a3) === a3 : false
			},
			enqueueSetState: function (a3, b3, c3) {
				a3 = a3._reactInternals
				var d3 = L3(),
					e2 = lh(a3),
					f3 = ch(d3, e2)
				f3.payload = b3
				void 0 !== c3 && null !== c3 && (f3.callback = c3)
				b3 = dh(a3, f3, e2)
				null !== b3 && (mh(b3, a3, e2, d3), eh(b3, a3, e2))
			},
			enqueueReplaceState: function (a3, b3, c3) {
				a3 = a3._reactInternals
				var d3 = L3(),
					e2 = lh(a3),
					f3 = ch(d3, e2)
				f3.tag = 1
				f3.payload = b3
				void 0 !== c3 && null !== c3 && (f3.callback = c3)
				b3 = dh(a3, f3, e2)
				null !== b3 && (mh(b3, a3, e2, d3), eh(b3, a3, e2))
			},
			enqueueForceUpdate: function (a3, b3) {
				a3 = a3._reactInternals
				var c3 = L3(),
					d3 = lh(a3),
					e2 = ch(c3, d3)
				e2.tag = 2
				void 0 !== b3 && null !== b3 && (e2.callback = b3)
				b3 = dh(a3, e2, d3)
				null !== b3 && (mh(b3, a3, d3, c3), eh(b3, a3, d3))
			},
		}
		function oh(a3, b3, c3, d3, e2, f3, g3) {
			a3 = a3.stateNode
			return 'function' === typeof a3.shouldComponentUpdate
				? a3.shouldComponentUpdate(d3, f3, g3)
				: b3.prototype && b3.prototype.isPureReactComponent
				? !Ie(c3, d3) || !Ie(e2, f3)
				: true
		}
		function ph(a3, b3, c3) {
			var d3 = false,
				e2 = Vf
			var f3 = b3.contextType
			'object' === typeof f3 && null !== f3
				? (f3 = Vg(f3))
				: ((e2 = Zf(b3) ? Xf : H2.current),
				  (d3 = b3.contextTypes),
				  (f3 = (d3 = null !== d3 && void 0 !== d3) ? Yf(a3, e2) : Vf))
			b3 = new b3(c3, f3)
			a3.memoizedState = null !== b3.state && void 0 !== b3.state ? b3.state : null
			b3.updater = nh
			a3.stateNode = b3
			b3._reactInternals = a3
			d3 &&
				((a3 = a3.stateNode),
				(a3.__reactInternalMemoizedUnmaskedChildContext = e2),
				(a3.__reactInternalMemoizedMaskedChildContext = f3))
			return b3
		}
		function qh(a3, b3, c3, d3) {
			a3 = b3.state
			'function' === typeof b3.componentWillReceiveProps && b3.componentWillReceiveProps(c3, d3)
			'function' === typeof b3.UNSAFE_componentWillReceiveProps &&
				b3.UNSAFE_componentWillReceiveProps(c3, d3)
			b3.state !== a3 && nh.enqueueReplaceState(b3, b3.state, null)
		}
		function rh(a3, b3, c3, d3) {
			var e2 = a3.stateNode
			e2.props = c3
			e2.state = a3.memoizedState
			e2.refs = jh
			ah(a3)
			var f3 = b3.contextType
			'object' === typeof f3 && null !== f3
				? (e2.context = Vg(f3))
				: ((f3 = Zf(b3) ? Xf : H2.current), (e2.context = Yf(a3, f3)))
			e2.state = a3.memoizedState
			f3 = b3.getDerivedStateFromProps
			'function' === typeof f3 && (kh(a3, b3, f3, c3), (e2.state = a3.memoizedState))
			'function' === typeof b3.getDerivedStateFromProps ||
				'function' === typeof e2.getSnapshotBeforeUpdate ||
				('function' !== typeof e2.UNSAFE_componentWillMount &&
					'function' !== typeof e2.componentWillMount) ||
				((b3 = e2.state),
				'function' === typeof e2.componentWillMount && e2.componentWillMount(),
				'function' === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(),
				b3 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null),
				gh(a3, c3, e2, d3),
				(e2.state = a3.memoizedState))
			'function' === typeof e2.componentDidMount && (a3.flags |= 4194308)
		}
		function sh(a3, b3, c3) {
			a3 = c3.ref
			if (null !== a3 && 'function' !== typeof a3 && 'object' !== typeof a3) {
				if (c3._owner) {
					c3 = c3._owner
					if (c3) {
						if (1 !== c3.tag) throw Error(p3(309))
						var d3 = c3.stateNode
					}
					if (!d3) throw Error(p3(147, a3))
					var e2 = d3,
						f3 = '' + a3
					if (
						null !== b3 &&
						null !== b3.ref &&
						'function' === typeof b3.ref &&
						b3.ref._stringRef === f3
					)
						return b3.ref
					b3 = function (a4) {
						var b4 = e2.refs
						b4 === jh && (b4 = e2.refs = {})
						null === a4 ? delete b4[f3] : (b4[f3] = a4)
					}
					b3._stringRef = f3
					return b3
				}
				if ('string' !== typeof a3) throw Error(p3(284))
				if (!c3._owner) throw Error(p3(290, a3))
			}
			return a3
		}
		function th(a3, b3) {
			a3 = Object.prototype.toString.call(b3)
			throw Error(
				p3(
					31,
					'[object Object]' === a3 ? 'object with keys {' + Object.keys(b3).join(', ') + '}' : a3
				)
			)
		}
		function uh(a3) {
			var b3 = a3._init
			return b3(a3._payload)
		}
		function vh(a3) {
			function b3(b4, c4) {
				if (a3) {
					var d4 = b4.deletions
					null === d4 ? ((b4.deletions = [c4]), (b4.flags |= 16)) : d4.push(c4)
				}
			}
			function c3(c4, d4) {
				if (!a3) return null
				for (; null !== d4; ) b3(c4, d4), (d4 = d4.sibling)
				return null
			}
			function d3(a4, b4) {
				for (a4 = /* @__PURE__ */ new Map(); null !== b4; )
					null !== b4.key ? a4.set(b4.key, b4) : a4.set(b4.index, b4), (b4 = b4.sibling)
				return a4
			}
			function e2(a4, b4) {
				a4 = wh(a4, b4)
				a4.index = 0
				a4.sibling = null
				return a4
			}
			function f3(b4, c4, d4) {
				b4.index = d4
				if (!a3) return (b4.flags |= 1048576), c4
				d4 = b4.alternate
				if (null !== d4) return (d4 = d4.index), d4 < c4 ? ((b4.flags |= 2), c4) : d4
				b4.flags |= 2
				return c4
			}
			function g3(b4) {
				a3 && null === b4.alternate && (b4.flags |= 2)
				return b4
			}
			function h3(a4, b4, c4, d4) {
				if (null === b4 || 6 !== b4.tag) return (b4 = xh(c4, a4.mode, d4)), (b4.return = a4), b4
				b4 = e2(b4, c4)
				b4.return = a4
				return b4
			}
			function k2(a4, b4, c4, d4) {
				var f4 = c4.type
				if (f4 === ya) return m3(a4, b4, c4.props.children, d4, c4.key)
				if (
					null !== b4 &&
					(b4.elementType === f4 ||
						('object' === typeof f4 && null !== f4 && f4.$$typeof === Ha && uh(f4) === b4.type))
				)
					return (d4 = e2(b4, c4.props)), (d4.ref = sh(a4, b4, c4)), (d4.return = a4), d4
				d4 = yh(c4.type, c4.key, c4.props, null, a4.mode, d4)
				d4.ref = sh(a4, b4, c4)
				d4.return = a4
				return d4
			}
			function l3(a4, b4, c4, d4) {
				if (
					null === b4 ||
					4 !== b4.tag ||
					b4.stateNode.containerInfo !== c4.containerInfo ||
					b4.stateNode.implementation !== c4.implementation
				)
					return (b4 = zh(c4, a4.mode, d4)), (b4.return = a4), b4
				b4 = e2(b4, c4.children || [])
				b4.return = a4
				return b4
			}
			function m3(a4, b4, c4, d4, f4) {
				if (null === b4 || 7 !== b4.tag) return (b4 = Ah(c4, a4.mode, d4, f4)), (b4.return = a4), b4
				b4 = e2(b4, c4)
				b4.return = a4
				return b4
			}
			function q(a4, b4, c4) {
				if (('string' === typeof b4 && '' !== b4) || 'number' === typeof b4)
					return (b4 = xh('' + b4, a4.mode, c4)), (b4.return = a4), b4
				if ('object' === typeof b4 && null !== b4) {
					switch (b4.$$typeof) {
						case va:
							return (
								(c4 = yh(b4.type, b4.key, b4.props, null, a4.mode, c4)),
								(c4.ref = sh(a4, null, b4)),
								(c4.return = a4),
								c4
							)
						case wa:
							return (b4 = zh(b4, a4.mode, c4)), (b4.return = a4), b4
						case Ha:
							var d4 = b4._init
							return q(a4, d4(b4._payload), c4)
					}
					if (eb(b4) || Ka(b4)) return (b4 = Ah(b4, a4.mode, c4, null)), (b4.return = a4), b4
					th(a4, b4)
				}
				return null
			}
			function r3(a4, b4, c4, d4) {
				var e3 = null !== b4 ? b4.key : null
				if (('string' === typeof c4 && '' !== c4) || 'number' === typeof c4)
					return null !== e3 ? null : h3(a4, b4, '' + c4, d4)
				if ('object' === typeof c4 && null !== c4) {
					switch (c4.$$typeof) {
						case va:
							return c4.key === e3 ? k2(a4, b4, c4, d4) : null
						case wa:
							return c4.key === e3 ? l3(a4, b4, c4, d4) : null
						case Ha:
							return (e3 = c4._init), r3(a4, b4, e3(c4._payload), d4)
					}
					if (eb(c4) || Ka(c4)) return null !== e3 ? null : m3(a4, b4, c4, d4, null)
					th(a4, c4)
				}
				return null
			}
			function y3(a4, b4, c4, d4, e3) {
				if (('string' === typeof d4 && '' !== d4) || 'number' === typeof d4)
					return (a4 = a4.get(c4) || null), h3(b4, a4, '' + d4, e3)
				if ('object' === typeof d4 && null !== d4) {
					switch (d4.$$typeof) {
						case va:
							return (a4 = a4.get(null === d4.key ? c4 : d4.key) || null), k2(b4, a4, d4, e3)
						case wa:
							return (a4 = a4.get(null === d4.key ? c4 : d4.key) || null), l3(b4, a4, d4, e3)
						case Ha:
							var f4 = d4._init
							return y3(a4, b4, c4, f4(d4._payload), e3)
					}
					if (eb(d4) || Ka(d4)) return (a4 = a4.get(c4) || null), m3(b4, a4, d4, e3, null)
					th(b4, d4)
				}
				return null
			}
			function n3(e3, g4, h4, k3) {
				for (
					var l4 = null, m4 = null, u3 = g4, w3 = (g4 = 0), x3 = null;
					null !== u3 && w3 < h4.length;
					w3++
				) {
					u3.index > w3 ? ((x3 = u3), (u3 = null)) : (x3 = u3.sibling)
					var n4 = r3(e3, u3, h4[w3], k3)
					if (null === n4) {
						null === u3 && (u3 = x3)
						break
					}
					a3 && u3 && null === n4.alternate && b3(e3, u3)
					g4 = f3(n4, g4, w3)
					null === m4 ? (l4 = n4) : (m4.sibling = n4)
					m4 = n4
					u3 = x3
				}
				if (w3 === h4.length) return c3(e3, u3), I && tg(e3, w3), l4
				if (null === u3) {
					for (; w3 < h4.length; w3++)
						(u3 = q(e3, h4[w3], k3)),
							null !== u3 &&
								((g4 = f3(u3, g4, w3)), null === m4 ? (l4 = u3) : (m4.sibling = u3), (m4 = u3))
					I && tg(e3, w3)
					return l4
				}
				for (u3 = d3(e3, u3); w3 < h4.length; w3++)
					(x3 = y3(u3, e3, w3, h4[w3], k3)),
						null !== x3 &&
							(a3 && null !== x3.alternate && u3.delete(null === x3.key ? w3 : x3.key),
							(g4 = f3(x3, g4, w3)),
							null === m4 ? (l4 = x3) : (m4.sibling = x3),
							(m4 = x3))
				a3 &&
					u3.forEach(function (a4) {
						return b3(e3, a4)
					})
				I && tg(e3, w3)
				return l4
			}
			function t4(e3, g4, h4, k3) {
				var l4 = Ka(h4)
				if ('function' !== typeof l4) throw Error(p3(150))
				h4 = l4.call(h4)
				if (null == h4) throw Error(p3(151))
				for (
					var u3 = (l4 = null), m4 = g4, w3 = (g4 = 0), x3 = null, n4 = h4.next();
					null !== m4 && !n4.done;
					w3++, n4 = h4.next()
				) {
					m4.index > w3 ? ((x3 = m4), (m4 = null)) : (x3 = m4.sibling)
					var t5 = r3(e3, m4, n4.value, k3)
					if (null === t5) {
						null === m4 && (m4 = x3)
						break
					}
					a3 && m4 && null === t5.alternate && b3(e3, m4)
					g4 = f3(t5, g4, w3)
					null === u3 ? (l4 = t5) : (u3.sibling = t5)
					u3 = t5
					m4 = x3
				}
				if (n4.done) return c3(e3, m4), I && tg(e3, w3), l4
				if (null === m4) {
					for (; !n4.done; w3++, n4 = h4.next())
						(n4 = q(e3, n4.value, k3)),
							null !== n4 &&
								((g4 = f3(n4, g4, w3)), null === u3 ? (l4 = n4) : (u3.sibling = n4), (u3 = n4))
					I && tg(e3, w3)
					return l4
				}
				for (m4 = d3(e3, m4); !n4.done; w3++, n4 = h4.next())
					(n4 = y3(m4, e3, w3, n4.value, k3)),
						null !== n4 &&
							(a3 && null !== n4.alternate && m4.delete(null === n4.key ? w3 : n4.key),
							(g4 = f3(n4, g4, w3)),
							null === u3 ? (l4 = n4) : (u3.sibling = n4),
							(u3 = n4))
				a3 &&
					m4.forEach(function (a4) {
						return b3(e3, a4)
					})
				I && tg(e3, w3)
				return l4
			}
			function J(a4, d4, f4, h4) {
				'object' === typeof f4 &&
					null !== f4 &&
					f4.type === ya &&
					null === f4.key &&
					(f4 = f4.props.children)
				if ('object' === typeof f4 && null !== f4) {
					switch (f4.$$typeof) {
						case va:
							a: {
								for (var k3 = f4.key, l4 = d4; null !== l4; ) {
									if (l4.key === k3) {
										k3 = f4.type
										if (k3 === ya) {
											if (7 === l4.tag) {
												c3(a4, l4.sibling)
												d4 = e2(l4, f4.props.children)
												d4.return = a4
												a4 = d4
												break a
											}
										} else if (
											l4.elementType === k3 ||
											('object' === typeof k3 &&
												null !== k3 &&
												k3.$$typeof === Ha &&
												uh(k3) === l4.type)
										) {
											c3(a4, l4.sibling)
											d4 = e2(l4, f4.props)
											d4.ref = sh(a4, l4, f4)
											d4.return = a4
											a4 = d4
											break a
										}
										c3(a4, l4)
										break
									} else b3(a4, l4)
									l4 = l4.sibling
								}
								f4.type === ya
									? ((d4 = Ah(f4.props.children, a4.mode, h4, f4.key)), (d4.return = a4), (a4 = d4))
									: ((h4 = yh(f4.type, f4.key, f4.props, null, a4.mode, h4)),
									  (h4.ref = sh(a4, d4, f4)),
									  (h4.return = a4),
									  (a4 = h4))
							}
							return g3(a4)
						case wa:
							a: {
								for (l4 = f4.key; null !== d4; ) {
									if (d4.key === l4)
										if (
											4 === d4.tag &&
											d4.stateNode.containerInfo === f4.containerInfo &&
											d4.stateNode.implementation === f4.implementation
										) {
											c3(a4, d4.sibling)
											d4 = e2(d4, f4.children || [])
											d4.return = a4
											a4 = d4
											break a
										} else {
											c3(a4, d4)
											break
										}
									else b3(a4, d4)
									d4 = d4.sibling
								}
								d4 = zh(f4, a4.mode, h4)
								d4.return = a4
								a4 = d4
							}
							return g3(a4)
						case Ha:
							return (l4 = f4._init), J(a4, d4, l4(f4._payload), h4)
					}
					if (eb(f4)) return n3(a4, d4, f4, h4)
					if (Ka(f4)) return t4(a4, d4, f4, h4)
					th(a4, f4)
				}
				return ('string' === typeof f4 && '' !== f4) || 'number' === typeof f4
					? ((f4 = '' + f4),
					  null !== d4 && 6 === d4.tag
							? (c3(a4, d4.sibling), (d4 = e2(d4, f4)), (d4.return = a4), (a4 = d4))
							: (c3(a4, d4), (d4 = xh(f4, a4.mode, h4)), (d4.return = a4), (a4 = d4)),
					  g3(a4))
					: c3(a4, d4)
			}
			return J
		}
		var Bh = vh(true)
		var Ch = vh(false)
		var Dh = {}
		var Eh = Uf(Dh)
		var Fh = Uf(Dh)
		var Gh = Uf(Dh)
		function Hh(a3) {
			if (a3 === Dh) throw Error(p3(174))
			return a3
		}
		function Ih(a3, b3) {
			G(Gh, b3)
			G(Fh, a3)
			G(Eh, Dh)
			a3 = b3.nodeType
			switch (a3) {
				case 9:
				case 11:
					b3 = (b3 = b3.documentElement) ? b3.namespaceURI : lb(null, '')
					break
				default:
					;(a3 = 8 === a3 ? b3.parentNode : b3),
						(b3 = a3.namespaceURI || null),
						(a3 = a3.tagName),
						(b3 = lb(b3, a3))
			}
			E3(Eh)
			G(Eh, b3)
		}
		function Jh() {
			E3(Eh)
			E3(Fh)
			E3(Gh)
		}
		function Kh(a3) {
			Hh(Gh.current)
			var b3 = Hh(Eh.current)
			var c3 = lb(b3, a3.type)
			b3 !== c3 && (G(Fh, a3), G(Eh, c3))
		}
		function Lh(a3) {
			Fh.current === a3 && (E3(Eh), E3(Fh))
		}
		var M = Uf(0)
		function Mh(a3) {
			for (var b3 = a3; null !== b3; ) {
				if (13 === b3.tag) {
					var c3 = b3.memoizedState
					if (
						null !== c3 &&
						((c3 = c3.dehydrated), null === c3 || '$?' === c3.data || '$!' === c3.data)
					)
						return b3
				} else if (19 === b3.tag && void 0 !== b3.memoizedProps.revealOrder) {
					if (0 !== (b3.flags & 128)) return b3
				} else if (null !== b3.child) {
					b3.child.return = b3
					b3 = b3.child
					continue
				}
				if (b3 === a3) break
				for (; null === b3.sibling; ) {
					if (null === b3.return || b3.return === a3) return null
					b3 = b3.return
				}
				b3.sibling.return = b3.return
				b3 = b3.sibling
			}
			return null
		}
		var Nh = []
		function Oh() {
			for (var a3 = 0; a3 < Nh.length; a3++) Nh[a3]._workInProgressVersionPrimary = null
			Nh.length = 0
		}
		var Ph = ua.ReactCurrentDispatcher
		var Qh = ua.ReactCurrentBatchConfig
		var Rh = 0
		var N2 = null
		var O2 = null
		var P2 = null
		var Sh = false
		var Th = false
		var Uh = 0
		var Vh = 0
		function Q() {
			throw Error(p3(321))
		}
		function Wh(a3, b3) {
			if (null === b3) return false
			for (var c3 = 0; c3 < b3.length && c3 < a3.length; c3++) if (!He(a3[c3], b3[c3])) return false
			return true
		}
		function Xh(a3, b3, c3, d3, e2, f3) {
			Rh = f3
			N2 = b3
			b3.memoizedState = null
			b3.updateQueue = null
			b3.lanes = 0
			Ph.current = null === a3 || null === a3.memoizedState ? Yh : Zh
			a3 = c3(d3, e2)
			if (Th) {
				f3 = 0
				do {
					Th = false
					Uh = 0
					if (25 <= f3) throw Error(p3(301))
					f3 += 1
					P2 = O2 = null
					b3.updateQueue = null
					Ph.current = $h
					a3 = c3(d3, e2)
				} while (Th)
			}
			Ph.current = ai
			b3 = null !== O2 && null !== O2.next
			Rh = 0
			P2 = O2 = N2 = null
			Sh = false
			if (b3) throw Error(p3(300))
			return a3
		}
		function bi() {
			var a3 = 0 !== Uh
			Uh = 0
			return a3
		}
		function ci() {
			var a3 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
			null === P2 ? (N2.memoizedState = P2 = a3) : (P2 = P2.next = a3)
			return P2
		}
		function di() {
			if (null === O2) {
				var a3 = N2.alternate
				a3 = null !== a3 ? a3.memoizedState : null
			} else a3 = O2.next
			var b3 = null === P2 ? N2.memoizedState : P2.next
			if (null !== b3) (P2 = b3), (O2 = a3)
			else {
				if (null === a3) throw Error(p3(310))
				O2 = a3
				a3 = {
					memoizedState: O2.memoizedState,
					baseState: O2.baseState,
					baseQueue: O2.baseQueue,
					queue: O2.queue,
					next: null,
				}
				null === P2 ? (N2.memoizedState = P2 = a3) : (P2 = P2.next = a3)
			}
			return P2
		}
		function ei(a3, b3) {
			return 'function' === typeof b3 ? b3(a3) : b3
		}
		function fi(a3) {
			var b3 = di(),
				c3 = b3.queue
			if (null === c3) throw Error(p3(311))
			c3.lastRenderedReducer = a3
			var d3 = O2,
				e2 = d3.baseQueue,
				f3 = c3.pending
			if (null !== f3) {
				if (null !== e2) {
					var g3 = e2.next
					e2.next = f3.next
					f3.next = g3
				}
				d3.baseQueue = e2 = f3
				c3.pending = null
			}
			if (null !== e2) {
				f3 = e2.next
				d3 = d3.baseState
				var h3 = (g3 = null),
					k2 = null,
					l3 = f3
				do {
					var m3 = l3.lane
					if ((Rh & m3) === m3)
						null !== k2 &&
							(k2 = k2.next =
								{
									lane: 0,
									action: l3.action,
									hasEagerState: l3.hasEagerState,
									eagerState: l3.eagerState,
									next: null,
								}),
							(d3 = l3.hasEagerState ? l3.eagerState : a3(d3, l3.action))
					else {
						var q = {
							lane: m3,
							action: l3.action,
							hasEagerState: l3.hasEagerState,
							eagerState: l3.eagerState,
							next: null,
						}
						null === k2 ? ((h3 = k2 = q), (g3 = d3)) : (k2 = k2.next = q)
						N2.lanes |= m3
						hh |= m3
					}
					l3 = l3.next
				} while (null !== l3 && l3 !== f3)
				null === k2 ? (g3 = d3) : (k2.next = h3)
				He(d3, b3.memoizedState) || (Ug = true)
				b3.memoizedState = d3
				b3.baseState = g3
				b3.baseQueue = k2
				c3.lastRenderedState = d3
			}
			a3 = c3.interleaved
			if (null !== a3) {
				e2 = a3
				do (f3 = e2.lane), (N2.lanes |= f3), (hh |= f3), (e2 = e2.next)
				while (e2 !== a3)
			} else null === e2 && (c3.lanes = 0)
			return [b3.memoizedState, c3.dispatch]
		}
		function gi(a3) {
			var b3 = di(),
				c3 = b3.queue
			if (null === c3) throw Error(p3(311))
			c3.lastRenderedReducer = a3
			var d3 = c3.dispatch,
				e2 = c3.pending,
				f3 = b3.memoizedState
			if (null !== e2) {
				c3.pending = null
				var g3 = (e2 = e2.next)
				do (f3 = a3(f3, g3.action)), (g3 = g3.next)
				while (g3 !== e2)
				He(f3, b3.memoizedState) || (Ug = true)
				b3.memoizedState = f3
				null === b3.baseQueue && (b3.baseState = f3)
				c3.lastRenderedState = f3
			}
			return [f3, d3]
		}
		function hi() {}
		function ii(a3, b3) {
			var c3 = N2,
				d3 = di(),
				e2 = b3(),
				f3 = !He(d3.memoizedState, e2)
			f3 && ((d3.memoizedState = e2), (Ug = true))
			d3 = d3.queue
			ji(ki.bind(null, c3, d3, a3), [a3])
			if (d3.getSnapshot !== b3 || f3 || (null !== P2 && P2.memoizedState.tag & 1)) {
				c3.flags |= 2048
				li(9, mi.bind(null, c3, d3, e2, b3), void 0, null)
				if (null === R3) throw Error(p3(349))
				0 !== (Rh & 30) || ni(c3, b3, e2)
			}
			return e2
		}
		function ni(a3, b3, c3) {
			a3.flags |= 16384
			a3 = { getSnapshot: b3, value: c3 }
			b3 = N2.updateQueue
			null === b3
				? ((b3 = { lastEffect: null, stores: null }), (N2.updateQueue = b3), (b3.stores = [a3]))
				: ((c3 = b3.stores), null === c3 ? (b3.stores = [a3]) : c3.push(a3))
		}
		function mi(a3, b3, c3, d3) {
			b3.value = c3
			b3.getSnapshot = d3
			oi(b3) && pi(a3)
		}
		function ki(a3, b3, c3) {
			return c3(function () {
				oi(b3) && pi(a3)
			})
		}
		function oi(a3) {
			var b3 = a3.getSnapshot
			a3 = a3.value
			try {
				var c3 = b3()
				return !He(a3, c3)
			} catch (d3) {
				return true
			}
		}
		function pi(a3) {
			var b3 = Zg(a3, 1)
			null !== b3 && mh(b3, a3, 1, -1)
		}
		function qi(a3) {
			var b3 = ci()
			'function' === typeof a3 && (a3 = a3())
			b3.memoizedState = b3.baseState = a3
			a3 = {
				pending: null,
				interleaved: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: ei,
				lastRenderedState: a3,
			}
			b3.queue = a3
			a3 = a3.dispatch = ri.bind(null, N2, a3)
			return [b3.memoizedState, a3]
		}
		function li(a3, b3, c3, d3) {
			a3 = { tag: a3, create: b3, destroy: c3, deps: d3, next: null }
			b3 = N2.updateQueue
			null === b3
				? ((b3 = { lastEffect: null, stores: null }),
				  (N2.updateQueue = b3),
				  (b3.lastEffect = a3.next = a3))
				: ((c3 = b3.lastEffect),
				  null === c3
						? (b3.lastEffect = a3.next = a3)
						: ((d3 = c3.next), (c3.next = a3), (a3.next = d3), (b3.lastEffect = a3)))
			return a3
		}
		function si() {
			return di().memoizedState
		}
		function ti(a3, b3, c3, d3) {
			var e2 = ci()
			N2.flags |= a3
			e2.memoizedState = li(1 | b3, c3, void 0, void 0 === d3 ? null : d3)
		}
		function ui(a3, b3, c3, d3) {
			var e2 = di()
			d3 = void 0 === d3 ? null : d3
			var f3 = void 0
			if (null !== O2) {
				var g3 = O2.memoizedState
				f3 = g3.destroy
				if (null !== d3 && Wh(d3, g3.deps)) {
					e2.memoizedState = li(b3, c3, f3, d3)
					return
				}
			}
			N2.flags |= a3
			e2.memoizedState = li(1 | b3, c3, f3, d3)
		}
		function vi(a3, b3) {
			return ti(8390656, 8, a3, b3)
		}
		function ji(a3, b3) {
			return ui(2048, 8, a3, b3)
		}
		function wi(a3, b3) {
			return ui(4, 2, a3, b3)
		}
		function xi(a3, b3) {
			return ui(4, 4, a3, b3)
		}
		function yi(a3, b3) {
			if ('function' === typeof b3)
				return (
					(a3 = a3()),
					b3(a3),
					function () {
						b3(null)
					}
				)
			if (null !== b3 && void 0 !== b3)
				return (
					(a3 = a3()),
					(b3.current = a3),
					function () {
						b3.current = null
					}
				)
		}
		function zi(a3, b3, c3) {
			c3 = null !== c3 && void 0 !== c3 ? c3.concat([a3]) : null
			return ui(4, 4, yi.bind(null, b3, a3), c3)
		}
		function Ai() {}
		function Bi(a3, b3) {
			var c3 = di()
			b3 = void 0 === b3 ? null : b3
			var d3 = c3.memoizedState
			if (null !== d3 && null !== b3 && Wh(b3, d3[1])) return d3[0]
			c3.memoizedState = [a3, b3]
			return a3
		}
		function Ci(a3, b3) {
			var c3 = di()
			b3 = void 0 === b3 ? null : b3
			var d3 = c3.memoizedState
			if (null !== d3 && null !== b3 && Wh(b3, d3[1])) return d3[0]
			a3 = a3()
			c3.memoizedState = [a3, b3]
			return a3
		}
		function Di(a3, b3, c3) {
			if (0 === (Rh & 21))
				return a3.baseState && ((a3.baseState = false), (Ug = true)), (a3.memoizedState = c3)
			He(c3, b3) || ((c3 = yc()), (N2.lanes |= c3), (hh |= c3), (a3.baseState = true))
			return b3
		}
		function Ei(a3, b3) {
			var c3 = C2
			C2 = 0 !== c3 && 4 > c3 ? c3 : 4
			a3(true)
			var d3 = Qh.transition
			Qh.transition = {}
			try {
				a3(false), b3()
			} finally {
				;(C2 = c3), (Qh.transition = d3)
			}
		}
		function Fi() {
			return di().memoizedState
		}
		function Gi(a3, b3, c3) {
			var d3 = lh(a3)
			c3 = { lane: d3, action: c3, hasEagerState: false, eagerState: null, next: null }
			if (Hi(a3)) Ii(b3, c3)
			else if (((c3 = Yg(a3, b3, c3, d3)), null !== c3)) {
				var e2 = L3()
				mh(c3, a3, d3, e2)
				Ji(c3, b3, d3)
			}
		}
		function ri(a3, b3, c3) {
			var d3 = lh(a3),
				e2 = { lane: d3, action: c3, hasEagerState: false, eagerState: null, next: null }
			if (Hi(a3)) Ii(b3, e2)
			else {
				var f3 = a3.alternate
				if (
					0 === a3.lanes &&
					(null === f3 || 0 === f3.lanes) &&
					((f3 = b3.lastRenderedReducer), null !== f3)
				)
					try {
						var g3 = b3.lastRenderedState,
							h3 = f3(g3, c3)
						e2.hasEagerState = true
						e2.eagerState = h3
						if (He(h3, g3)) {
							var k2 = b3.interleaved
							null === k2 ? ((e2.next = e2), Xg(b3)) : ((e2.next = k2.next), (k2.next = e2))
							b3.interleaved = e2
							return
						}
					} catch (l3) {
					} finally {
					}
				c3 = Yg(a3, b3, e2, d3)
				null !== c3 && ((e2 = L3()), mh(c3, a3, d3, e2), Ji(c3, b3, d3))
			}
		}
		function Hi(a3) {
			var b3 = a3.alternate
			return a3 === N2 || (null !== b3 && b3 === N2)
		}
		function Ii(a3, b3) {
			Th = Sh = true
			var c3 = a3.pending
			null === c3 ? (b3.next = b3) : ((b3.next = c3.next), (c3.next = b3))
			a3.pending = b3
		}
		function Ji(a3, b3, c3) {
			if (0 !== (c3 & 4194240)) {
				var d3 = b3.lanes
				d3 &= a3.pendingLanes
				c3 |= d3
				b3.lanes = c3
				Cc(a3, c3)
			}
		}
		var ai = {
			readContext: Vg,
			useCallback: Q,
			useContext: Q,
			useEffect: Q,
			useImperativeHandle: Q,
			useInsertionEffect: Q,
			useLayoutEffect: Q,
			useMemo: Q,
			useReducer: Q,
			useRef: Q,
			useState: Q,
			useDebugValue: Q,
			useDeferredValue: Q,
			useTransition: Q,
			useMutableSource: Q,
			useSyncExternalStore: Q,
			useId: Q,
			unstable_isNewReconciler: false,
		}
		var Yh = {
			readContext: Vg,
			useCallback: function (a3, b3) {
				ci().memoizedState = [a3, void 0 === b3 ? null : b3]
				return a3
			},
			useContext: Vg,
			useEffect: vi,
			useImperativeHandle: function (a3, b3, c3) {
				c3 = null !== c3 && void 0 !== c3 ? c3.concat([a3]) : null
				return ti(4194308, 4, yi.bind(null, b3, a3), c3)
			},
			useLayoutEffect: function (a3, b3) {
				return ti(4194308, 4, a3, b3)
			},
			useInsertionEffect: function (a3, b3) {
				return ti(4, 2, a3, b3)
			},
			useMemo: function (a3, b3) {
				var c3 = ci()
				b3 = void 0 === b3 ? null : b3
				a3 = a3()
				c3.memoizedState = [a3, b3]
				return a3
			},
			useReducer: function (a3, b3, c3) {
				var d3 = ci()
				b3 = void 0 !== c3 ? c3(b3) : b3
				d3.memoizedState = d3.baseState = b3
				a3 = {
					pending: null,
					interleaved: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: a3,
					lastRenderedState: b3,
				}
				d3.queue = a3
				a3 = a3.dispatch = Gi.bind(null, N2, a3)
				return [d3.memoizedState, a3]
			},
			useRef: function (a3) {
				var b3 = ci()
				a3 = { current: a3 }
				return (b3.memoizedState = a3)
			},
			useState: qi,
			useDebugValue: Ai,
			useDeferredValue: function (a3) {
				return (ci().memoizedState = a3)
			},
			useTransition: function () {
				var a3 = qi(false),
					b3 = a3[0]
				a3 = Ei.bind(null, a3[1])
				ci().memoizedState = a3
				return [b3, a3]
			},
			useMutableSource: function () {},
			useSyncExternalStore: function (a3, b3, c3) {
				var d3 = N2,
					e2 = ci()
				if (I) {
					if (void 0 === c3) throw Error(p3(407))
					c3 = c3()
				} else {
					c3 = b3()
					if (null === R3) throw Error(p3(349))
					0 !== (Rh & 30) || ni(d3, b3, c3)
				}
				e2.memoizedState = c3
				var f3 = { value: c3, getSnapshot: b3 }
				e2.queue = f3
				vi(ki.bind(null, d3, f3, a3), [a3])
				d3.flags |= 2048
				li(9, mi.bind(null, d3, f3, c3, b3), void 0, null)
				return c3
			},
			useId: function () {
				var a3 = ci(),
					b3 = R3.identifierPrefix
				if (I) {
					var c3 = sg
					var d3 = rg
					c3 = (d3 & ~(1 << (32 - oc(d3) - 1))).toString(32) + c3
					b3 = ':' + b3 + 'R' + c3
					c3 = Uh++
					0 < c3 && (b3 += 'H' + c3.toString(32))
					b3 += ':'
				} else (c3 = Vh++), (b3 = ':' + b3 + 'r' + c3.toString(32) + ':')
				return (a3.memoizedState = b3)
			},
			unstable_isNewReconciler: false,
		}
		var Zh = {
			readContext: Vg,
			useCallback: Bi,
			useContext: Vg,
			useEffect: ji,
			useImperativeHandle: zi,
			useInsertionEffect: wi,
			useLayoutEffect: xi,
			useMemo: Ci,
			useReducer: fi,
			useRef: si,
			useState: function () {
				return fi(ei)
			},
			useDebugValue: Ai,
			useDeferredValue: function (a3) {
				var b3 = di()
				return Di(b3, O2.memoizedState, a3)
			},
			useTransition: function () {
				var a3 = fi(ei)[0],
					b3 = di().memoizedState
				return [a3, b3]
			},
			useMutableSource: hi,
			useSyncExternalStore: ii,
			useId: Fi,
			unstable_isNewReconciler: false,
		}
		var $h = {
			readContext: Vg,
			useCallback: Bi,
			useContext: Vg,
			useEffect: ji,
			useImperativeHandle: zi,
			useInsertionEffect: wi,
			useLayoutEffect: xi,
			useMemo: Ci,
			useReducer: gi,
			useRef: si,
			useState: function () {
				return gi(ei)
			},
			useDebugValue: Ai,
			useDeferredValue: function (a3) {
				var b3 = di()
				return null === O2 ? (b3.memoizedState = a3) : Di(b3, O2.memoizedState, a3)
			},
			useTransition: function () {
				var a3 = gi(ei)[0],
					b3 = di().memoizedState
				return [a3, b3]
			},
			useMutableSource: hi,
			useSyncExternalStore: ii,
			useId: Fi,
			unstable_isNewReconciler: false,
		}
		function Ki(a3, b3) {
			try {
				var c3 = '',
					d3 = b3
				do (c3 += Pa(d3)), (d3 = d3.return)
				while (d3)
				var e2 = c3
			} catch (f3) {
				e2 = '\nError generating stack: ' + f3.message + '\n' + f3.stack
			}
			return { value: a3, source: b3, stack: e2, digest: null }
		}
		function Li(a3, b3, c3) {
			return {
				value: a3,
				source: null,
				stack: null != c3 ? c3 : null,
				digest: null != b3 ? b3 : null,
			}
		}
		function Mi(a3, b3) {
			try {
				console.error(b3.value)
			} catch (c3) {
				setTimeout(function () {
					throw c3
				})
			}
		}
		var Ni = 'function' === typeof WeakMap ? WeakMap : Map
		function Oi(a3, b3, c3) {
			c3 = ch(-1, c3)
			c3.tag = 3
			c3.payload = { element: null }
			var d3 = b3.value
			c3.callback = function () {
				Pi || ((Pi = true), (Qi = d3))
				Mi(a3, b3)
			}
			return c3
		}
		function Ri(a3, b3, c3) {
			c3 = ch(-1, c3)
			c3.tag = 3
			var d3 = a3.type.getDerivedStateFromError
			if ('function' === typeof d3) {
				var e2 = b3.value
				c3.payload = function () {
					return d3(e2)
				}
				c3.callback = function () {
					Mi(a3, b3)
				}
			}
			var f3 = a3.stateNode
			null !== f3 &&
				'function' === typeof f3.componentDidCatch &&
				(c3.callback = function () {
					Mi(a3, b3)
					'function' !== typeof d3 &&
						(null === Si ? (Si = /* @__PURE__ */ new Set([this])) : Si.add(this))
					var c4 = b3.stack
					this.componentDidCatch(b3.value, { componentStack: null !== c4 ? c4 : '' })
				})
			return c3
		}
		function Ti(a3, b3, c3) {
			var d3 = a3.pingCache
			if (null === d3) {
				d3 = a3.pingCache = new Ni()
				var e2 = /* @__PURE__ */ new Set()
				d3.set(b3, e2)
			} else (e2 = d3.get(b3)), void 0 === e2 && ((e2 = /* @__PURE__ */ new Set()), d3.set(b3, e2))
			e2.has(c3) || (e2.add(c3), (a3 = Ui.bind(null, a3, b3, c3)), b3.then(a3, a3))
		}
		function Vi(a3) {
			do {
				var b3
				if ((b3 = 13 === a3.tag))
					(b3 = a3.memoizedState),
						(b3 = null !== b3 ? (null !== b3.dehydrated ? true : false) : true)
				if (b3) return a3
				a3 = a3.return
			} while (null !== a3)
			return null
		}
		function Wi(a3, b3, c3, d3, e2) {
			if (0 === (a3.mode & 1))
				return (
					a3 === b3
						? (a3.flags |= 65536)
						: ((a3.flags |= 128),
						  (c3.flags |= 131072),
						  (c3.flags &= -52805),
						  1 === c3.tag &&
								(null === c3.alternate
									? (c3.tag = 17)
									: ((b3 = ch(-1, 1)), (b3.tag = 2), dh(c3, b3, 1))),
						  (c3.lanes |= 1)),
					a3
				)
			a3.flags |= 65536
			a3.lanes = e2
			return a3
		}
		var Xi = ua.ReactCurrentOwner
		var Ug = false
		function Yi(a3, b3, c3, d3) {
			b3.child = null === a3 ? Ch(b3, null, c3, d3) : Bh(b3, a3.child, c3, d3)
		}
		function Zi(a3, b3, c3, d3, e2) {
			c3 = c3.render
			var f3 = b3.ref
			Tg(b3, e2)
			d3 = Xh(a3, b3, c3, d3, f3, e2)
			c3 = bi()
			if (null !== a3 && !Ug)
				return (
					(b3.updateQueue = a3.updateQueue), (b3.flags &= -2053), (a3.lanes &= ~e2), $i(a3, b3, e2)
				)
			I && c3 && vg(b3)
			b3.flags |= 1
			Yi(a3, b3, d3, e2)
			return b3.child
		}
		function aj(a3, b3, c3, d3, e2) {
			if (null === a3) {
				var f3 = c3.type
				if (
					'function' === typeof f3 &&
					!bj(f3) &&
					void 0 === f3.defaultProps &&
					null === c3.compare &&
					void 0 === c3.defaultProps
				)
					return (b3.tag = 15), (b3.type = f3), cj(a3, b3, f3, d3, e2)
				a3 = yh(c3.type, null, d3, b3, b3.mode, e2)
				a3.ref = b3.ref
				a3.return = b3
				return (b3.child = a3)
			}
			f3 = a3.child
			if (0 === (a3.lanes & e2)) {
				var g3 = f3.memoizedProps
				c3 = c3.compare
				c3 = null !== c3 ? c3 : Ie
				if (c3(g3, d3) && a3.ref === b3.ref) return $i(a3, b3, e2)
			}
			b3.flags |= 1
			a3 = wh(f3, d3)
			a3.ref = b3.ref
			a3.return = b3
			return (b3.child = a3)
		}
		function cj(a3, b3, c3, d3, e2) {
			if (null !== a3) {
				var f3 = a3.memoizedProps
				if (Ie(f3, d3) && a3.ref === b3.ref)
					if (((Ug = false), (b3.pendingProps = d3 = f3), 0 !== (a3.lanes & e2)))
						0 !== (a3.flags & 131072) && (Ug = true)
					else return (b3.lanes = a3.lanes), $i(a3, b3, e2)
			}
			return dj(a3, b3, c3, d3, e2)
		}
		function ej(a3, b3, c3) {
			var d3 = b3.pendingProps,
				e2 = d3.children,
				f3 = null !== a3 ? a3.memoizedState : null
			if ('hidden' === d3.mode)
				if (0 === (b3.mode & 1))
					(b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
						G(fj, gj),
						(gj |= c3)
				else {
					if (0 === (c3 & 1073741824))
						return (
							(a3 = null !== f3 ? f3.baseLanes | c3 : c3),
							(b3.lanes = b3.childLanes = 1073741824),
							(b3.memoizedState = { baseLanes: a3, cachePool: null, transitions: null }),
							(b3.updateQueue = null),
							G(fj, gj),
							(gj |= a3),
							null
						)
					b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }
					d3 = null !== f3 ? f3.baseLanes : c3
					G(fj, gj)
					gj |= d3
				}
			else
				null !== f3 ? ((d3 = f3.baseLanes | c3), (b3.memoizedState = null)) : (d3 = c3),
					G(fj, gj),
					(gj |= d3)
			Yi(a3, b3, e2, c3)
			return b3.child
		}
		function hj(a3, b3) {
			var c3 = b3.ref
			if ((null === a3 && null !== c3) || (null !== a3 && a3.ref !== c3))
				(b3.flags |= 512), (b3.flags |= 2097152)
		}
		function dj(a3, b3, c3, d3, e2) {
			var f3 = Zf(c3) ? Xf : H2.current
			f3 = Yf(b3, f3)
			Tg(b3, e2)
			c3 = Xh(a3, b3, c3, d3, f3, e2)
			d3 = bi()
			if (null !== a3 && !Ug)
				return (
					(b3.updateQueue = a3.updateQueue), (b3.flags &= -2053), (a3.lanes &= ~e2), $i(a3, b3, e2)
				)
			I && d3 && vg(b3)
			b3.flags |= 1
			Yi(a3, b3, c3, e2)
			return b3.child
		}
		function ij(a3, b3, c3, d3, e2) {
			if (Zf(c3)) {
				var f3 = true
				cg(b3)
			} else f3 = false
			Tg(b3, e2)
			if (null === b3.stateNode) jj(a3, b3), ph(b3, c3, d3), rh(b3, c3, d3, e2), (d3 = true)
			else if (null === a3) {
				var g3 = b3.stateNode,
					h3 = b3.memoizedProps
				g3.props = h3
				var k2 = g3.context,
					l3 = c3.contextType
				'object' === typeof l3 && null !== l3
					? (l3 = Vg(l3))
					: ((l3 = Zf(c3) ? Xf : H2.current), (l3 = Yf(b3, l3)))
				var m3 = c3.getDerivedStateFromProps,
					q = 'function' === typeof m3 || 'function' === typeof g3.getSnapshotBeforeUpdate
				q ||
					('function' !== typeof g3.UNSAFE_componentWillReceiveProps &&
						'function' !== typeof g3.componentWillReceiveProps) ||
					((h3 !== d3 || k2 !== l3) && qh(b3, g3, d3, l3))
				$g = false
				var r3 = b3.memoizedState
				g3.state = r3
				gh(b3, d3, g3, e2)
				k2 = b3.memoizedState
				h3 !== d3 || r3 !== k2 || Wf.current || $g
					? ('function' === typeof m3 && (kh(b3, c3, m3, d3), (k2 = b3.memoizedState)),
					  (h3 = $g || oh(b3, c3, h3, d3, r3, k2, l3))
							? (q ||
									('function' !== typeof g3.UNSAFE_componentWillMount &&
										'function' !== typeof g3.componentWillMount) ||
									('function' === typeof g3.componentWillMount && g3.componentWillMount(),
									'function' === typeof g3.UNSAFE_componentWillMount &&
										g3.UNSAFE_componentWillMount()),
							  'function' === typeof g3.componentDidMount && (b3.flags |= 4194308))
							: ('function' === typeof g3.componentDidMount && (b3.flags |= 4194308),
							  (b3.memoizedProps = d3),
							  (b3.memoizedState = k2)),
					  (g3.props = d3),
					  (g3.state = k2),
					  (g3.context = l3),
					  (d3 = h3))
					: ('function' === typeof g3.componentDidMount && (b3.flags |= 4194308), (d3 = false))
			} else {
				g3 = b3.stateNode
				bh(a3, b3)
				h3 = b3.memoizedProps
				l3 = b3.type === b3.elementType ? h3 : Lg(b3.type, h3)
				g3.props = l3
				q = b3.pendingProps
				r3 = g3.context
				k2 = c3.contextType
				'object' === typeof k2 && null !== k2
					? (k2 = Vg(k2))
					: ((k2 = Zf(c3) ? Xf : H2.current), (k2 = Yf(b3, k2)))
				var y3 = c3.getDerivedStateFromProps
				;(m3 = 'function' === typeof y3 || 'function' === typeof g3.getSnapshotBeforeUpdate) ||
					('function' !== typeof g3.UNSAFE_componentWillReceiveProps &&
						'function' !== typeof g3.componentWillReceiveProps) ||
					((h3 !== q || r3 !== k2) && qh(b3, g3, d3, k2))
				$g = false
				r3 = b3.memoizedState
				g3.state = r3
				gh(b3, d3, g3, e2)
				var n3 = b3.memoizedState
				h3 !== q || r3 !== n3 || Wf.current || $g
					? ('function' === typeof y3 && (kh(b3, c3, y3, d3), (n3 = b3.memoizedState)),
					  (l3 = $g || oh(b3, c3, l3, d3, r3, n3, k2) || false)
							? (m3 ||
									('function' !== typeof g3.UNSAFE_componentWillUpdate &&
										'function' !== typeof g3.componentWillUpdate) ||
									('function' === typeof g3.componentWillUpdate &&
										g3.componentWillUpdate(d3, n3, k2),
									'function' === typeof g3.UNSAFE_componentWillUpdate &&
										g3.UNSAFE_componentWillUpdate(d3, n3, k2)),
							  'function' === typeof g3.componentDidUpdate && (b3.flags |= 4),
							  'function' === typeof g3.getSnapshotBeforeUpdate && (b3.flags |= 1024))
							: ('function' !== typeof g3.componentDidUpdate ||
									(h3 === a3.memoizedProps && r3 === a3.memoizedState) ||
									(b3.flags |= 4),
							  'function' !== typeof g3.getSnapshotBeforeUpdate ||
									(h3 === a3.memoizedProps && r3 === a3.memoizedState) ||
									(b3.flags |= 1024),
							  (b3.memoizedProps = d3),
							  (b3.memoizedState = n3)),
					  (g3.props = d3),
					  (g3.state = n3),
					  (g3.context = k2),
					  (d3 = l3))
					: ('function' !== typeof g3.componentDidUpdate ||
							(h3 === a3.memoizedProps && r3 === a3.memoizedState) ||
							(b3.flags |= 4),
					  'function' !== typeof g3.getSnapshotBeforeUpdate ||
							(h3 === a3.memoizedProps && r3 === a3.memoizedState) ||
							(b3.flags |= 1024),
					  (d3 = false))
			}
			return kj(a3, b3, c3, d3, f3, e2)
		}
		function kj(a3, b3, c3, d3, e2, f3) {
			hj(a3, b3)
			var g3 = 0 !== (b3.flags & 128)
			if (!d3 && !g3) return e2 && dg(b3, c3, false), $i(a3, b3, f3)
			d3 = b3.stateNode
			Xi.current = b3
			var h3 = g3 && 'function' !== typeof c3.getDerivedStateFromError ? null : d3.render()
			b3.flags |= 1
			null !== a3 && g3
				? ((b3.child = Bh(b3, a3.child, null, f3)), (b3.child = Bh(b3, null, h3, f3)))
				: Yi(a3, b3, h3, f3)
			b3.memoizedState = d3.state
			e2 && dg(b3, c3, true)
			return b3.child
		}
		function lj(a3) {
			var b3 = a3.stateNode
			b3.pendingContext
				? ag(a3, b3.pendingContext, b3.pendingContext !== b3.context)
				: b3.context && ag(a3, b3.context, false)
			Ih(a3, b3.containerInfo)
		}
		function mj(a3, b3, c3, d3, e2) {
			Ig()
			Jg(e2)
			b3.flags |= 256
			Yi(a3, b3, c3, d3)
			return b3.child
		}
		var nj = { dehydrated: null, treeContext: null, retryLane: 0 }
		function oj(a3) {
			return { baseLanes: a3, cachePool: null, transitions: null }
		}
		function pj(a3, b3, c3) {
			var d3 = b3.pendingProps,
				e2 = M.current,
				f3 = false,
				g3 = 0 !== (b3.flags & 128),
				h3
			;(h3 = g3) || (h3 = null !== a3 && null === a3.memoizedState ? false : 0 !== (e2 & 2))
			if (h3) (f3 = true), (b3.flags &= -129)
			else if (null === a3 || null !== a3.memoizedState) e2 |= 1
			G(M, e2 & 1)
			if (null === a3) {
				Eg(b3)
				a3 = b3.memoizedState
				if (null !== a3 && ((a3 = a3.dehydrated), null !== a3))
					return (
						0 === (b3.mode & 1)
							? (b3.lanes = 1)
							: '$!' === a3.data
							? (b3.lanes = 8)
							: (b3.lanes = 1073741824),
						null
					)
				g3 = d3.children
				a3 = d3.fallback
				return f3
					? ((d3 = b3.mode),
					  (f3 = b3.child),
					  (g3 = { mode: 'hidden', children: g3 }),
					  0 === (d3 & 1) && null !== f3
							? ((f3.childLanes = 0), (f3.pendingProps = g3))
							: (f3 = qj(g3, d3, 0, null)),
					  (a3 = Ah(a3, d3, c3, null)),
					  (f3.return = b3),
					  (a3.return = b3),
					  (f3.sibling = a3),
					  (b3.child = f3),
					  (b3.child.memoizedState = oj(c3)),
					  (b3.memoizedState = nj),
					  a3)
					: rj(b3, g3)
			}
			e2 = a3.memoizedState
			if (null !== e2 && ((h3 = e2.dehydrated), null !== h3)) return sj(a3, b3, g3, d3, h3, e2, c3)
			if (f3) {
				f3 = d3.fallback
				g3 = b3.mode
				e2 = a3.child
				h3 = e2.sibling
				var k2 = { mode: 'hidden', children: d3.children }
				0 === (g3 & 1) && b3.child !== e2
					? ((d3 = b3.child), (d3.childLanes = 0), (d3.pendingProps = k2), (b3.deletions = null))
					: ((d3 = wh(e2, k2)), (d3.subtreeFlags = e2.subtreeFlags & 14680064))
				null !== h3 ? (f3 = wh(h3, f3)) : ((f3 = Ah(f3, g3, c3, null)), (f3.flags |= 2))
				f3.return = b3
				d3.return = b3
				d3.sibling = f3
				b3.child = d3
				d3 = f3
				f3 = b3.child
				g3 = a3.child.memoizedState
				g3 =
					null === g3
						? oj(c3)
						: { baseLanes: g3.baseLanes | c3, cachePool: null, transitions: g3.transitions }
				f3.memoizedState = g3
				f3.childLanes = a3.childLanes & ~c3
				b3.memoizedState = nj
				return d3
			}
			f3 = a3.child
			a3 = f3.sibling
			d3 = wh(f3, { mode: 'visible', children: d3.children })
			0 === (b3.mode & 1) && (d3.lanes = c3)
			d3.return = b3
			d3.sibling = null
			null !== a3 &&
				((c3 = b3.deletions), null === c3 ? ((b3.deletions = [a3]), (b3.flags |= 16)) : c3.push(a3))
			b3.child = d3
			b3.memoizedState = null
			return d3
		}
		function rj(a3, b3) {
			b3 = qj({ mode: 'visible', children: b3 }, a3.mode, 0, null)
			b3.return = a3
			return (a3.child = b3)
		}
		function tj(a3, b3, c3, d3) {
			null !== d3 && Jg(d3)
			Bh(b3, a3.child, null, c3)
			a3 = rj(b3, b3.pendingProps.children)
			a3.flags |= 2
			b3.memoizedState = null
			return a3
		}
		function sj(a3, b3, c3, d3, e2, f3, g3) {
			if (c3) {
				if (b3.flags & 256) return (b3.flags &= -257), (d3 = Li(Error(p3(422)))), tj(a3, b3, g3, d3)
				if (null !== b3.memoizedState) return (b3.child = a3.child), (b3.flags |= 128), null
				f3 = d3.fallback
				e2 = b3.mode
				d3 = qj({ mode: 'visible', children: d3.children }, e2, 0, null)
				f3 = Ah(f3, e2, g3, null)
				f3.flags |= 2
				d3.return = b3
				f3.return = b3
				d3.sibling = f3
				b3.child = d3
				0 !== (b3.mode & 1) && Bh(b3, a3.child, null, g3)
				b3.child.memoizedState = oj(g3)
				b3.memoizedState = nj
				return f3
			}
			if (0 === (b3.mode & 1)) return tj(a3, b3, g3, null)
			if ('$!' === e2.data) {
				d3 = e2.nextSibling && e2.nextSibling.dataset
				if (d3) var h3 = d3.dgst
				d3 = h3
				f3 = Error(p3(419))
				d3 = Li(f3, d3, void 0)
				return tj(a3, b3, g3, d3)
			}
			h3 = 0 !== (g3 & a3.childLanes)
			if (Ug || h3) {
				d3 = R3
				if (null !== d3) {
					switch (g3 & -g3) {
						case 4:
							e2 = 2
							break
						case 16:
							e2 = 8
							break
						case 64:
						case 128:
						case 256:
						case 512:
						case 1024:
						case 2048:
						case 4096:
						case 8192:
						case 16384:
						case 32768:
						case 65536:
						case 131072:
						case 262144:
						case 524288:
						case 1048576:
						case 2097152:
						case 4194304:
						case 8388608:
						case 16777216:
						case 33554432:
						case 67108864:
							e2 = 32
							break
						case 536870912:
							e2 = 268435456
							break
						default:
							e2 = 0
					}
					e2 = 0 !== (e2 & (d3.suspendedLanes | g3)) ? 0 : e2
					0 !== e2 && e2 !== f3.retryLane && ((f3.retryLane = e2), Zg(a3, e2), mh(d3, a3, e2, -1))
				}
				uj()
				d3 = Li(Error(p3(421)))
				return tj(a3, b3, g3, d3)
			}
			if ('$?' === e2.data)
				return (
					(b3.flags |= 128),
					(b3.child = a3.child),
					(b3 = vj.bind(null, a3)),
					(e2._reactRetry = b3),
					null
				)
			a3 = f3.treeContext
			yg = Lf(e2.nextSibling)
			xg = b3
			I = true
			zg = null
			null !== a3 &&
				((og[pg++] = rg),
				(og[pg++] = sg),
				(og[pg++] = qg),
				(rg = a3.id),
				(sg = a3.overflow),
				(qg = b3))
			b3 = rj(b3, d3.children)
			b3.flags |= 4096
			return b3
		}
		function wj(a3, b3, c3) {
			a3.lanes |= b3
			var d3 = a3.alternate
			null !== d3 && (d3.lanes |= b3)
			Sg(a3.return, b3, c3)
		}
		function xj(a3, b3, c3, d3, e2) {
			var f3 = a3.memoizedState
			null === f3
				? (a3.memoizedState = {
						isBackwards: b3,
						rendering: null,
						renderingStartTime: 0,
						last: d3,
						tail: c3,
						tailMode: e2,
				  })
				: ((f3.isBackwards = b3),
				  (f3.rendering = null),
				  (f3.renderingStartTime = 0),
				  (f3.last = d3),
				  (f3.tail = c3),
				  (f3.tailMode = e2))
		}
		function yj(a3, b3, c3) {
			var d3 = b3.pendingProps,
				e2 = d3.revealOrder,
				f3 = d3.tail
			Yi(a3, b3, d3.children, c3)
			d3 = M.current
			if (0 !== (d3 & 2)) (d3 = (d3 & 1) | 2), (b3.flags |= 128)
			else {
				if (null !== a3 && 0 !== (a3.flags & 128))
					a: for (a3 = b3.child; null !== a3; ) {
						if (13 === a3.tag) null !== a3.memoizedState && wj(a3, c3, b3)
						else if (19 === a3.tag) wj(a3, c3, b3)
						else if (null !== a3.child) {
							a3.child.return = a3
							a3 = a3.child
							continue
						}
						if (a3 === b3) break a
						for (; null === a3.sibling; ) {
							if (null === a3.return || a3.return === b3) break a
							a3 = a3.return
						}
						a3.sibling.return = a3.return
						a3 = a3.sibling
					}
				d3 &= 1
			}
			G(M, d3)
			if (0 === (b3.mode & 1)) b3.memoizedState = null
			else
				switch (e2) {
					case 'forwards':
						c3 = b3.child
						for (e2 = null; null !== c3; )
							(a3 = c3.alternate), null !== a3 && null === Mh(a3) && (e2 = c3), (c3 = c3.sibling)
						c3 = e2
						null === c3
							? ((e2 = b3.child), (b3.child = null))
							: ((e2 = c3.sibling), (c3.sibling = null))
						xj(b3, false, e2, c3, f3)
						break
					case 'backwards':
						c3 = null
						e2 = b3.child
						for (b3.child = null; null !== e2; ) {
							a3 = e2.alternate
							if (null !== a3 && null === Mh(a3)) {
								b3.child = e2
								break
							}
							a3 = e2.sibling
							e2.sibling = c3
							c3 = e2
							e2 = a3
						}
						xj(b3, true, c3, null, f3)
						break
					case 'together':
						xj(b3, false, null, null, void 0)
						break
					default:
						b3.memoizedState = null
				}
			return b3.child
		}
		function jj(a3, b3) {
			0 === (b3.mode & 1) &&
				null !== a3 &&
				((a3.alternate = null), (b3.alternate = null), (b3.flags |= 2))
		}
		function $i(a3, b3, c3) {
			null !== a3 && (b3.dependencies = a3.dependencies)
			hh |= b3.lanes
			if (0 === (c3 & b3.childLanes)) return null
			if (null !== a3 && b3.child !== a3.child) throw Error(p3(153))
			if (null !== b3.child) {
				a3 = b3.child
				c3 = wh(a3, a3.pendingProps)
				b3.child = c3
				for (c3.return = b3; null !== a3.sibling; )
					(a3 = a3.sibling), (c3 = c3.sibling = wh(a3, a3.pendingProps)), (c3.return = b3)
				c3.sibling = null
			}
			return b3.child
		}
		function zj(a3, b3, c3) {
			switch (b3.tag) {
				case 3:
					lj(b3)
					Ig()
					break
				case 5:
					Kh(b3)
					break
				case 1:
					Zf(b3.type) && cg(b3)
					break
				case 4:
					Ih(b3, b3.stateNode.containerInfo)
					break
				case 10:
					var d3 = b3.type._context,
						e2 = b3.memoizedProps.value
					G(Mg, d3._currentValue)
					d3._currentValue = e2
					break
				case 13:
					d3 = b3.memoizedState
					if (null !== d3) {
						if (null !== d3.dehydrated) return G(M, M.current & 1), (b3.flags |= 128), null
						if (0 !== (c3 & b3.child.childLanes)) return pj(a3, b3, c3)
						G(M, M.current & 1)
						a3 = $i(a3, b3, c3)
						return null !== a3 ? a3.sibling : null
					}
					G(M, M.current & 1)
					break
				case 19:
					d3 = 0 !== (c3 & b3.childLanes)
					if (0 !== (a3.flags & 128)) {
						if (d3) return yj(a3, b3, c3)
						b3.flags |= 128
					}
					e2 = b3.memoizedState
					null !== e2 && ((e2.rendering = null), (e2.tail = null), (e2.lastEffect = null))
					G(M, M.current)
					if (d3) break
					else return null
				case 22:
				case 23:
					return (b3.lanes = 0), ej(a3, b3, c3)
			}
			return $i(a3, b3, c3)
		}
		var Aj
		var Bj
		var Cj
		var Dj
		Aj = function (a3, b3) {
			for (var c3 = b3.child; null !== c3; ) {
				if (5 === c3.tag || 6 === c3.tag) a3.appendChild(c3.stateNode)
				else if (4 !== c3.tag && null !== c3.child) {
					c3.child.return = c3
					c3 = c3.child
					continue
				}
				if (c3 === b3) break
				for (; null === c3.sibling; ) {
					if (null === c3.return || c3.return === b3) return
					c3 = c3.return
				}
				c3.sibling.return = c3.return
				c3 = c3.sibling
			}
		}
		Bj = function () {}
		Cj = function (a3, b3, c3, d3) {
			var e2 = a3.memoizedProps
			if (e2 !== d3) {
				a3 = b3.stateNode
				Hh(Eh.current)
				var f3 = null
				switch (c3) {
					case 'input':
						e2 = Ya(a3, e2)
						d3 = Ya(a3, d3)
						f3 = []
						break
					case 'select':
						e2 = A2({}, e2, { value: void 0 })
						d3 = A2({}, d3, { value: void 0 })
						f3 = []
						break
					case 'textarea':
						e2 = gb(a3, e2)
						d3 = gb(a3, d3)
						f3 = []
						break
					default:
						'function' !== typeof e2.onClick &&
							'function' === typeof d3.onClick &&
							(a3.onclick = Bf)
				}
				ub(c3, d3)
				var g3
				c3 = null
				for (l3 in e2)
					if (!d3.hasOwnProperty(l3) && e2.hasOwnProperty(l3) && null != e2[l3])
						if ('style' === l3) {
							var h3 = e2[l3]
							for (g3 in h3) h3.hasOwnProperty(g3) && (c3 || (c3 = {}), (c3[g3] = ''))
						} else
							'dangerouslySetInnerHTML' !== l3 &&
								'children' !== l3 &&
								'suppressContentEditableWarning' !== l3 &&
								'suppressHydrationWarning' !== l3 &&
								'autoFocus' !== l3 &&
								(ea.hasOwnProperty(l3) ? f3 || (f3 = []) : (f3 = f3 || []).push(l3, null))
				for (l3 in d3) {
					var k2 = d3[l3]
					h3 = null != e2 ? e2[l3] : void 0
					if (d3.hasOwnProperty(l3) && k2 !== h3 && (null != k2 || null != h3))
						if ('style' === l3)
							if (h3) {
								for (g3 in h3)
									!h3.hasOwnProperty(g3) ||
										(k2 && k2.hasOwnProperty(g3)) ||
										(c3 || (c3 = {}), (c3[g3] = ''))
								for (g3 in k2)
									k2.hasOwnProperty(g3) && h3[g3] !== k2[g3] && (c3 || (c3 = {}), (c3[g3] = k2[g3]))
							} else c3 || (f3 || (f3 = []), f3.push(l3, c3)), (c3 = k2)
						else
							'dangerouslySetInnerHTML' === l3
								? ((k2 = k2 ? k2.__html : void 0),
								  (h3 = h3 ? h3.__html : void 0),
								  null != k2 && h3 !== k2 && (f3 = f3 || []).push(l3, k2))
								: 'children' === l3
								? ('string' !== typeof k2 && 'number' !== typeof k2) ||
								  (f3 = f3 || []).push(l3, '' + k2)
								: 'suppressContentEditableWarning' !== l3 &&
								  'suppressHydrationWarning' !== l3 &&
								  (ea.hasOwnProperty(l3)
										? (null != k2 && 'onScroll' === l3 && D3('scroll', a3),
										  f3 || h3 === k2 || (f3 = []))
										: (f3 = f3 || []).push(l3, k2))
				}
				c3 && (f3 = f3 || []).push('style', c3)
				var l3 = f3
				if ((b3.updateQueue = l3)) b3.flags |= 4
			}
		}
		Dj = function (a3, b3, c3, d3) {
			c3 !== d3 && (b3.flags |= 4)
		}
		function Ej(a3, b3) {
			if (!I)
				switch (a3.tailMode) {
					case 'hidden':
						b3 = a3.tail
						for (var c3 = null; null !== b3; ) null !== b3.alternate && (c3 = b3), (b3 = b3.sibling)
						null === c3 ? (a3.tail = null) : (c3.sibling = null)
						break
					case 'collapsed':
						c3 = a3.tail
						for (var d3 = null; null !== c3; ) null !== c3.alternate && (d3 = c3), (c3 = c3.sibling)
						null === d3
							? b3 || null === a3.tail
								? (a3.tail = null)
								: (a3.tail.sibling = null)
							: (d3.sibling = null)
				}
		}
		function S2(a3) {
			var b3 = null !== a3.alternate && a3.alternate.child === a3.child,
				c3 = 0,
				d3 = 0
			if (b3)
				for (var e2 = a3.child; null !== e2; )
					(c3 |= e2.lanes | e2.childLanes),
						(d3 |= e2.subtreeFlags & 14680064),
						(d3 |= e2.flags & 14680064),
						(e2.return = a3),
						(e2 = e2.sibling)
			else
				for (e2 = a3.child; null !== e2; )
					(c3 |= e2.lanes | e2.childLanes),
						(d3 |= e2.subtreeFlags),
						(d3 |= e2.flags),
						(e2.return = a3),
						(e2 = e2.sibling)
			a3.subtreeFlags |= d3
			a3.childLanes = c3
			return b3
		}
		function Fj(a3, b3, c3) {
			var d3 = b3.pendingProps
			wg(b3)
			switch (b3.tag) {
				case 2:
				case 16:
				case 15:
				case 0:
				case 11:
				case 7:
				case 8:
				case 12:
				case 9:
				case 14:
					return S2(b3), null
				case 1:
					return Zf(b3.type) && $f(), S2(b3), null
				case 3:
					d3 = b3.stateNode
					Jh()
					E3(Wf)
					E3(H2)
					Oh()
					d3.pendingContext && ((d3.context = d3.pendingContext), (d3.pendingContext = null))
					if (null === a3 || null === a3.child)
						Gg(b3)
							? (b3.flags |= 4)
							: null === a3 ||
							  (a3.memoizedState.isDehydrated && 0 === (b3.flags & 256)) ||
							  ((b3.flags |= 1024), null !== zg && (Gj(zg), (zg = null)))
					Bj(a3, b3)
					S2(b3)
					return null
				case 5:
					Lh(b3)
					var e2 = Hh(Gh.current)
					c3 = b3.type
					if (null !== a3 && null != b3.stateNode)
						Cj(a3, b3, c3, d3, e2), a3.ref !== b3.ref && ((b3.flags |= 512), (b3.flags |= 2097152))
					else {
						if (!d3) {
							if (null === b3.stateNode) throw Error(p3(166))
							S2(b3)
							return null
						}
						a3 = Hh(Eh.current)
						if (Gg(b3)) {
							d3 = b3.stateNode
							c3 = b3.type
							var f3 = b3.memoizedProps
							d3[Of] = b3
							d3[Pf] = f3
							a3 = 0 !== (b3.mode & 1)
							switch (c3) {
								case 'dialog':
									D3('cancel', d3)
									D3('close', d3)
									break
								case 'iframe':
								case 'object':
								case 'embed':
									D3('load', d3)
									break
								case 'video':
								case 'audio':
									for (e2 = 0; e2 < lf.length; e2++) D3(lf[e2], d3)
									break
								case 'source':
									D3('error', d3)
									break
								case 'img':
								case 'image':
								case 'link':
									D3('error', d3)
									D3('load', d3)
									break
								case 'details':
									D3('toggle', d3)
									break
								case 'input':
									Za(d3, f3)
									D3('invalid', d3)
									break
								case 'select':
									d3._wrapperState = { wasMultiple: !!f3.multiple }
									D3('invalid', d3)
									break
								case 'textarea':
									hb(d3, f3), D3('invalid', d3)
							}
							ub(c3, f3)
							e2 = null
							for (var g3 in f3)
								if (f3.hasOwnProperty(g3)) {
									var h3 = f3[g3]
									'children' === g3
										? 'string' === typeof h3
											? d3.textContent !== h3 &&
											  (true !== f3.suppressHydrationWarning && Af(d3.textContent, h3, a3),
											  (e2 = ['children', h3]))
											: 'number' === typeof h3 &&
											  d3.textContent !== '' + h3 &&
											  (true !== f3.suppressHydrationWarning && Af(d3.textContent, h3, a3),
											  (e2 = ['children', '' + h3]))
										: ea.hasOwnProperty(g3) && null != h3 && 'onScroll' === g3 && D3('scroll', d3)
								}
							switch (c3) {
								case 'input':
									Va(d3)
									db(d3, f3, true)
									break
								case 'textarea':
									Va(d3)
									jb(d3)
									break
								case 'select':
								case 'option':
									break
								default:
									'function' === typeof f3.onClick && (d3.onclick = Bf)
							}
							d3 = e2
							b3.updateQueue = d3
							null !== d3 && (b3.flags |= 4)
						} else {
							g3 = 9 === e2.nodeType ? e2 : e2.ownerDocument
							'http://www.w3.org/1999/xhtml' === a3 && (a3 = kb(c3))
							'http://www.w3.org/1999/xhtml' === a3
								? 'script' === c3
									? ((a3 = g3.createElement('div')),
									  (a3.innerHTML = '<script></script>'),
									  (a3 = a3.removeChild(a3.firstChild)))
									: 'string' === typeof d3.is
									? (a3 = g3.createElement(c3, { is: d3.is }))
									: ((a3 = g3.createElement(c3)),
									  'select' === c3 &&
											((g3 = a3),
											d3.multiple ? (g3.multiple = true) : d3.size && (g3.size = d3.size)))
								: (a3 = g3.createElementNS(a3, c3))
							a3[Of] = b3
							a3[Pf] = d3
							Aj(a3, b3, false, false)
							b3.stateNode = a3
							a: {
								g3 = vb(c3, d3)
								switch (c3) {
									case 'dialog':
										D3('cancel', a3)
										D3('close', a3)
										e2 = d3
										break
									case 'iframe':
									case 'object':
									case 'embed':
										D3('load', a3)
										e2 = d3
										break
									case 'video':
									case 'audio':
										for (e2 = 0; e2 < lf.length; e2++) D3(lf[e2], a3)
										e2 = d3
										break
									case 'source':
										D3('error', a3)
										e2 = d3
										break
									case 'img':
									case 'image':
									case 'link':
										D3('error', a3)
										D3('load', a3)
										e2 = d3
										break
									case 'details':
										D3('toggle', a3)
										e2 = d3
										break
									case 'input':
										Za(a3, d3)
										e2 = Ya(a3, d3)
										D3('invalid', a3)
										break
									case 'option':
										e2 = d3
										break
									case 'select':
										a3._wrapperState = { wasMultiple: !!d3.multiple }
										e2 = A2({}, d3, { value: void 0 })
										D3('invalid', a3)
										break
									case 'textarea':
										hb(a3, d3)
										e2 = gb(a3, d3)
										D3('invalid', a3)
										break
									default:
										e2 = d3
								}
								ub(c3, e2)
								h3 = e2
								for (f3 in h3)
									if (h3.hasOwnProperty(f3)) {
										var k2 = h3[f3]
										'style' === f3
											? sb(a3, k2)
											: 'dangerouslySetInnerHTML' === f3
											? ((k2 = k2 ? k2.__html : void 0), null != k2 && nb(a3, k2))
											: 'children' === f3
											? 'string' === typeof k2
												? ('textarea' !== c3 || '' !== k2) && ob(a3, k2)
												: 'number' === typeof k2 && ob(a3, '' + k2)
											: 'suppressContentEditableWarning' !== f3 &&
											  'suppressHydrationWarning' !== f3 &&
											  'autoFocus' !== f3 &&
											  (ea.hasOwnProperty(f3)
													? null != k2 && 'onScroll' === f3 && D3('scroll', a3)
													: null != k2 && ta(a3, f3, k2, g3))
									}
								switch (c3) {
									case 'input':
										Va(a3)
										db(a3, d3, false)
										break
									case 'textarea':
										Va(a3)
										jb(a3)
										break
									case 'option':
										null != d3.value && a3.setAttribute('value', '' + Sa(d3.value))
										break
									case 'select':
										a3.multiple = !!d3.multiple
										f3 = d3.value
										null != f3
											? fb(a3, !!d3.multiple, f3, false)
											: null != d3.defaultValue && fb(a3, !!d3.multiple, d3.defaultValue, true)
										break
									default:
										'function' === typeof e2.onClick && (a3.onclick = Bf)
								}
								switch (c3) {
									case 'button':
									case 'input':
									case 'select':
									case 'textarea':
										d3 = !!d3.autoFocus
										break a
									case 'img':
										d3 = true
										break a
									default:
										d3 = false
								}
							}
							d3 && (b3.flags |= 4)
						}
						null !== b3.ref && ((b3.flags |= 512), (b3.flags |= 2097152))
					}
					S2(b3)
					return null
				case 6:
					if (a3 && null != b3.stateNode) Dj(a3, b3, a3.memoizedProps, d3)
					else {
						if ('string' !== typeof d3 && null === b3.stateNode) throw Error(p3(166))
						c3 = Hh(Gh.current)
						Hh(Eh.current)
						if (Gg(b3)) {
							d3 = b3.stateNode
							c3 = b3.memoizedProps
							d3[Of] = b3
							if ((f3 = d3.nodeValue !== c3)) {
								if (((a3 = xg), null !== a3))
									switch (a3.tag) {
										case 3:
											Af(d3.nodeValue, c3, 0 !== (a3.mode & 1))
											break
										case 5:
											true !== a3.memoizedProps.suppressHydrationWarning &&
												Af(d3.nodeValue, c3, 0 !== (a3.mode & 1))
									}
							}
							f3 && (b3.flags |= 4)
						} else
							(d3 = (9 === c3.nodeType ? c3 : c3.ownerDocument).createTextNode(d3)),
								(d3[Of] = b3),
								(b3.stateNode = d3)
					}
					S2(b3)
					return null
				case 13:
					E3(M)
					d3 = b3.memoizedState
					if (null === a3 || (null !== a3.memoizedState && null !== a3.memoizedState.dehydrated)) {
						if (I && null !== yg && 0 !== (b3.mode & 1) && 0 === (b3.flags & 128))
							Hg(), Ig(), (b3.flags |= 98560), (f3 = false)
						else if (((f3 = Gg(b3)), null !== d3 && null !== d3.dehydrated)) {
							if (null === a3) {
								if (!f3) throw Error(p3(318))
								f3 = b3.memoizedState
								f3 = null !== f3 ? f3.dehydrated : null
								if (!f3) throw Error(p3(317))
								f3[Of] = b3
							} else Ig(), 0 === (b3.flags & 128) && (b3.memoizedState = null), (b3.flags |= 4)
							S2(b3)
							f3 = false
						} else null !== zg && (Gj(zg), (zg = null)), (f3 = true)
						if (!f3) return b3.flags & 65536 ? b3 : null
					}
					if (0 !== (b3.flags & 128)) return (b3.lanes = c3), b3
					d3 = null !== d3
					d3 !== (null !== a3 && null !== a3.memoizedState) &&
						d3 &&
						((b3.child.flags |= 8192),
						0 !== (b3.mode & 1) &&
							(null === a3 || 0 !== (M.current & 1) ? 0 === T3 && (T3 = 3) : uj()))
					null !== b3.updateQueue && (b3.flags |= 4)
					S2(b3)
					return null
				case 4:
					return Jh(), Bj(a3, b3), null === a3 && sf(b3.stateNode.containerInfo), S2(b3), null
				case 10:
					return Rg(b3.type._context), S2(b3), null
				case 17:
					return Zf(b3.type) && $f(), S2(b3), null
				case 19:
					E3(M)
					f3 = b3.memoizedState
					if (null === f3) return S2(b3), null
					d3 = 0 !== (b3.flags & 128)
					g3 = f3.rendering
					if (null === g3)
						if (d3) Ej(f3, false)
						else {
							if (0 !== T3 || (null !== a3 && 0 !== (a3.flags & 128)))
								for (a3 = b3.child; null !== a3; ) {
									g3 = Mh(a3)
									if (null !== g3) {
										b3.flags |= 128
										Ej(f3, false)
										d3 = g3.updateQueue
										null !== d3 && ((b3.updateQueue = d3), (b3.flags |= 4))
										b3.subtreeFlags = 0
										d3 = c3
										for (c3 = b3.child; null !== c3; )
											(f3 = c3),
												(a3 = d3),
												(f3.flags &= 14680066),
												(g3 = f3.alternate),
												null === g3
													? ((f3.childLanes = 0),
													  (f3.lanes = a3),
													  (f3.child = null),
													  (f3.subtreeFlags = 0),
													  (f3.memoizedProps = null),
													  (f3.memoizedState = null),
													  (f3.updateQueue = null),
													  (f3.dependencies = null),
													  (f3.stateNode = null))
													: ((f3.childLanes = g3.childLanes),
													  (f3.lanes = g3.lanes),
													  (f3.child = g3.child),
													  (f3.subtreeFlags = 0),
													  (f3.deletions = null),
													  (f3.memoizedProps = g3.memoizedProps),
													  (f3.memoizedState = g3.memoizedState),
													  (f3.updateQueue = g3.updateQueue),
													  (f3.type = g3.type),
													  (a3 = g3.dependencies),
													  (f3.dependencies =
															null === a3
																? null
																: { lanes: a3.lanes, firstContext: a3.firstContext })),
												(c3 = c3.sibling)
										G(M, (M.current & 1) | 2)
										return b3.child
									}
									a3 = a3.sibling
								}
							null !== f3.tail &&
								B() > Hj &&
								((b3.flags |= 128), (d3 = true), Ej(f3, false), (b3.lanes = 4194304))
						}
					else {
						if (!d3)
							if (((a3 = Mh(g3)), null !== a3)) {
								if (
									((b3.flags |= 128),
									(d3 = true),
									(c3 = a3.updateQueue),
									null !== c3 && ((b3.updateQueue = c3), (b3.flags |= 4)),
									Ej(f3, true),
									null === f3.tail && 'hidden' === f3.tailMode && !g3.alternate && !I)
								)
									return S2(b3), null
							} else
								2 * B() - f3.renderingStartTime > Hj &&
									1073741824 !== c3 &&
									((b3.flags |= 128), (d3 = true), Ej(f3, false), (b3.lanes = 4194304))
						f3.isBackwards
							? ((g3.sibling = b3.child), (b3.child = g3))
							: ((c3 = f3.last), null !== c3 ? (c3.sibling = g3) : (b3.child = g3), (f3.last = g3))
					}
					if (null !== f3.tail)
						return (
							(b3 = f3.tail),
							(f3.rendering = b3),
							(f3.tail = b3.sibling),
							(f3.renderingStartTime = B()),
							(b3.sibling = null),
							(c3 = M.current),
							G(M, d3 ? (c3 & 1) | 2 : c3 & 1),
							b3
						)
					S2(b3)
					return null
				case 22:
				case 23:
					return (
						Ij(),
						(d3 = null !== b3.memoizedState),
						null !== a3 && (null !== a3.memoizedState) !== d3 && (b3.flags |= 8192),
						d3 && 0 !== (b3.mode & 1)
							? 0 !== (gj & 1073741824) && (S2(b3), b3.subtreeFlags & 6 && (b3.flags |= 8192))
							: S2(b3),
						null
					)
				case 24:
					return null
				case 25:
					return null
			}
			throw Error(p3(156, b3.tag))
		}
		function Jj(a3, b3) {
			wg(b3)
			switch (b3.tag) {
				case 1:
					return (
						Zf(b3.type) && $f(),
						(a3 = b3.flags),
						a3 & 65536 ? ((b3.flags = (a3 & -65537) | 128), b3) : null
					)
				case 3:
					return (
						Jh(),
						E3(Wf),
						E3(H2),
						Oh(),
						(a3 = b3.flags),
						0 !== (a3 & 65536) && 0 === (a3 & 128) ? ((b3.flags = (a3 & -65537) | 128), b3) : null
					)
				case 5:
					return Lh(b3), null
				case 13:
					E3(M)
					a3 = b3.memoizedState
					if (null !== a3 && null !== a3.dehydrated) {
						if (null === b3.alternate) throw Error(p3(340))
						Ig()
					}
					a3 = b3.flags
					return a3 & 65536 ? ((b3.flags = (a3 & -65537) | 128), b3) : null
				case 19:
					return E3(M), null
				case 4:
					return Jh(), null
				case 10:
					return Rg(b3.type._context), null
				case 22:
				case 23:
					return Ij(), null
				case 24:
					return null
				default:
					return null
			}
		}
		var Kj = false
		var U = false
		var Lj = 'function' === typeof WeakSet ? WeakSet : Set
		var V2 = null
		function Mj(a3, b3) {
			var c3 = a3.ref
			if (null !== c3)
				if ('function' === typeof c3)
					try {
						c3(null)
					} catch (d3) {
						W2(a3, b3, d3)
					}
				else c3.current = null
		}
		function Nj(a3, b3, c3) {
			try {
				c3()
			} catch (d3) {
				W2(a3, b3, d3)
			}
		}
		var Oj = false
		function Pj(a3, b3) {
			Cf = dd
			a3 = Me()
			if (Ne(a3)) {
				if ('selectionStart' in a3) var c3 = { start: a3.selectionStart, end: a3.selectionEnd }
				else
					a: {
						c3 = ((c3 = a3.ownerDocument) && c3.defaultView) || window
						var d3 = c3.getSelection && c3.getSelection()
						if (d3 && 0 !== d3.rangeCount) {
							c3 = d3.anchorNode
							var e2 = d3.anchorOffset,
								f3 = d3.focusNode
							d3 = d3.focusOffset
							try {
								c3.nodeType, f3.nodeType
							} catch (F) {
								c3 = null
								break a
							}
							var g3 = 0,
								h3 = -1,
								k2 = -1,
								l3 = 0,
								m3 = 0,
								q = a3,
								r3 = null
							b: for (;;) {
								for (var y3; ; ) {
									q !== c3 || (0 !== e2 && 3 !== q.nodeType) || (h3 = g3 + e2)
									q !== f3 || (0 !== d3 && 3 !== q.nodeType) || (k2 = g3 + d3)
									3 === q.nodeType && (g3 += q.nodeValue.length)
									if (null === (y3 = q.firstChild)) break
									r3 = q
									q = y3
								}
								for (;;) {
									if (q === a3) break b
									r3 === c3 && ++l3 === e2 && (h3 = g3)
									r3 === f3 && ++m3 === d3 && (k2 = g3)
									if (null !== (y3 = q.nextSibling)) break
									q = r3
									r3 = q.parentNode
								}
								q = y3
							}
							c3 = -1 === h3 || -1 === k2 ? null : { start: h3, end: k2 }
						} else c3 = null
					}
				c3 = c3 || { start: 0, end: 0 }
			} else c3 = null
			Df = { focusedElem: a3, selectionRange: c3 }
			dd = false
			for (V2 = b3; null !== V2; )
				if (((b3 = V2), (a3 = b3.child), 0 !== (b3.subtreeFlags & 1028) && null !== a3))
					(a3.return = b3), (V2 = a3)
				else
					for (; null !== V2; ) {
						b3 = V2
						try {
							var n3 = b3.alternate
							if (0 !== (b3.flags & 1024))
								switch (b3.tag) {
									case 0:
									case 11:
									case 15:
										break
									case 1:
										if (null !== n3) {
											var t4 = n3.memoizedProps,
												J = n3.memoizedState,
												x3 = b3.stateNode,
												w3 = x3.getSnapshotBeforeUpdate(
													b3.elementType === b3.type ? t4 : Lg(b3.type, t4),
													J
												)
											x3.__reactInternalSnapshotBeforeUpdate = w3
										}
										break
									case 3:
										var u3 = b3.stateNode.containerInfo
										1 === u3.nodeType
											? (u3.textContent = '')
											: 9 === u3.nodeType &&
											  u3.documentElement &&
											  u3.removeChild(u3.documentElement)
										break
									case 5:
									case 6:
									case 4:
									case 17:
										break
									default:
										throw Error(p3(163))
								}
						} catch (F) {
							W2(b3, b3.return, F)
						}
						a3 = b3.sibling
						if (null !== a3) {
							a3.return = b3.return
							V2 = a3
							break
						}
						V2 = b3.return
					}
			n3 = Oj
			Oj = false
			return n3
		}
		function Qj(a3, b3, c3) {
			var d3 = b3.updateQueue
			d3 = null !== d3 ? d3.lastEffect : null
			if (null !== d3) {
				var e2 = (d3 = d3.next)
				do {
					if ((e2.tag & a3) === a3) {
						var f3 = e2.destroy
						e2.destroy = void 0
						void 0 !== f3 && Nj(b3, c3, f3)
					}
					e2 = e2.next
				} while (e2 !== d3)
			}
		}
		function Rj(a3, b3) {
			b3 = b3.updateQueue
			b3 = null !== b3 ? b3.lastEffect : null
			if (null !== b3) {
				var c3 = (b3 = b3.next)
				do {
					if ((c3.tag & a3) === a3) {
						var d3 = c3.create
						c3.destroy = d3()
					}
					c3 = c3.next
				} while (c3 !== b3)
			}
		}
		function Sj(a3) {
			var b3 = a3.ref
			if (null !== b3) {
				var c3 = a3.stateNode
				switch (a3.tag) {
					case 5:
						a3 = c3
						break
					default:
						a3 = c3
				}
				'function' === typeof b3 ? b3(a3) : (b3.current = a3)
			}
		}
		function Tj(a3) {
			var b3 = a3.alternate
			null !== b3 && ((a3.alternate = null), Tj(b3))
			a3.child = null
			a3.deletions = null
			a3.sibling = null
			5 === a3.tag &&
				((b3 = a3.stateNode),
				null !== b3 && (delete b3[Of], delete b3[Pf], delete b3[of], delete b3[Qf], delete b3[Rf]))
			a3.stateNode = null
			a3.return = null
			a3.dependencies = null
			a3.memoizedProps = null
			a3.memoizedState = null
			a3.pendingProps = null
			a3.stateNode = null
			a3.updateQueue = null
		}
		function Uj(a3) {
			return 5 === a3.tag || 3 === a3.tag || 4 === a3.tag
		}
		function Vj(a3) {
			a: for (;;) {
				for (; null === a3.sibling; ) {
					if (null === a3.return || Uj(a3.return)) return null
					a3 = a3.return
				}
				a3.sibling.return = a3.return
				for (a3 = a3.sibling; 5 !== a3.tag && 6 !== a3.tag && 18 !== a3.tag; ) {
					if (a3.flags & 2) continue a
					if (null === a3.child || 4 === a3.tag) continue a
					else (a3.child.return = a3), (a3 = a3.child)
				}
				if (!(a3.flags & 2)) return a3.stateNode
			}
		}
		function Wj(a3, b3, c3) {
			var d3 = a3.tag
			if (5 === d3 || 6 === d3)
				(a3 = a3.stateNode),
					b3
						? 8 === c3.nodeType
							? c3.parentNode.insertBefore(a3, b3)
							: c3.insertBefore(a3, b3)
						: (8 === c3.nodeType
								? ((b3 = c3.parentNode), b3.insertBefore(a3, c3))
								: ((b3 = c3), b3.appendChild(a3)),
						  (c3 = c3._reactRootContainer),
						  (null !== c3 && void 0 !== c3) || null !== b3.onclick || (b3.onclick = Bf))
			else if (4 !== d3 && ((a3 = a3.child), null !== a3))
				for (Wj(a3, b3, c3), a3 = a3.sibling; null !== a3; ) Wj(a3, b3, c3), (a3 = a3.sibling)
		}
		function Xj(a3, b3, c3) {
			var d3 = a3.tag
			if (5 === d3 || 6 === d3)
				(a3 = a3.stateNode), b3 ? c3.insertBefore(a3, b3) : c3.appendChild(a3)
			else if (4 !== d3 && ((a3 = a3.child), null !== a3))
				for (Xj(a3, b3, c3), a3 = a3.sibling; null !== a3; ) Xj(a3, b3, c3), (a3 = a3.sibling)
		}
		var X = null
		var Yj = false
		function Zj(a3, b3, c3) {
			for (c3 = c3.child; null !== c3; ) ak(a3, b3, c3), (c3 = c3.sibling)
		}
		function ak(a3, b3, c3) {
			if (lc && 'function' === typeof lc.onCommitFiberUnmount)
				try {
					lc.onCommitFiberUnmount(kc, c3)
				} catch (h3) {}
			switch (c3.tag) {
				case 5:
					U || Mj(c3, b3)
				case 6:
					var d3 = X,
						e2 = Yj
					X = null
					Zj(a3, b3, c3)
					X = d3
					Yj = e2
					null !== X &&
						(Yj
							? ((a3 = X),
							  (c3 = c3.stateNode),
							  8 === a3.nodeType ? a3.parentNode.removeChild(c3) : a3.removeChild(c3))
							: X.removeChild(c3.stateNode))
					break
				case 18:
					null !== X &&
						(Yj
							? ((a3 = X),
							  (c3 = c3.stateNode),
							  8 === a3.nodeType ? Kf(a3.parentNode, c3) : 1 === a3.nodeType && Kf(a3, c3),
							  bd(a3))
							: Kf(X, c3.stateNode))
					break
				case 4:
					d3 = X
					e2 = Yj
					X = c3.stateNode.containerInfo
					Yj = true
					Zj(a3, b3, c3)
					X = d3
					Yj = e2
					break
				case 0:
				case 11:
				case 14:
				case 15:
					if (!U && ((d3 = c3.updateQueue), null !== d3 && ((d3 = d3.lastEffect), null !== d3))) {
						e2 = d3 = d3.next
						do {
							var f3 = e2,
								g3 = f3.destroy
							f3 = f3.tag
							void 0 !== g3 && (0 !== (f3 & 2) ? Nj(c3, b3, g3) : 0 !== (f3 & 4) && Nj(c3, b3, g3))
							e2 = e2.next
						} while (e2 !== d3)
					}
					Zj(a3, b3, c3)
					break
				case 1:
					if (
						!U &&
						(Mj(c3, b3), (d3 = c3.stateNode), 'function' === typeof d3.componentWillUnmount)
					)
						try {
							;(d3.props = c3.memoizedProps),
								(d3.state = c3.memoizedState),
								d3.componentWillUnmount()
						} catch (h3) {
							W2(c3, b3, h3)
						}
					Zj(a3, b3, c3)
					break
				case 21:
					Zj(a3, b3, c3)
					break
				case 22:
					c3.mode & 1
						? ((U = (d3 = U) || null !== c3.memoizedState), Zj(a3, b3, c3), (U = d3))
						: Zj(a3, b3, c3)
					break
				default:
					Zj(a3, b3, c3)
			}
		}
		function bk(a3) {
			var b3 = a3.updateQueue
			if (null !== b3) {
				a3.updateQueue = null
				var c3 = a3.stateNode
				null === c3 && (c3 = a3.stateNode = new Lj())
				b3.forEach(function (b4) {
					var d3 = ck.bind(null, a3, b4)
					c3.has(b4) || (c3.add(b4), b4.then(d3, d3))
				})
			}
		}
		function dk(a3, b3) {
			var c3 = b3.deletions
			if (null !== c3)
				for (var d3 = 0; d3 < c3.length; d3++) {
					var e2 = c3[d3]
					try {
						var f3 = a3,
							g3 = b3,
							h3 = g3
						a: for (; null !== h3; ) {
							switch (h3.tag) {
								case 5:
									X = h3.stateNode
									Yj = false
									break a
								case 3:
									X = h3.stateNode.containerInfo
									Yj = true
									break a
								case 4:
									X = h3.stateNode.containerInfo
									Yj = true
									break a
							}
							h3 = h3.return
						}
						if (null === X) throw Error(p3(160))
						ak(f3, g3, e2)
						X = null
						Yj = false
						var k2 = e2.alternate
						null !== k2 && (k2.return = null)
						e2.return = null
					} catch (l3) {
						W2(e2, b3, l3)
					}
				}
			if (b3.subtreeFlags & 12854) for (b3 = b3.child; null !== b3; ) ek(b3, a3), (b3 = b3.sibling)
		}
		function ek(a3, b3) {
			var c3 = a3.alternate,
				d3 = a3.flags
			switch (a3.tag) {
				case 0:
				case 11:
				case 14:
				case 15:
					dk(b3, a3)
					fk(a3)
					if (d3 & 4) {
						try {
							Qj(3, a3, a3.return), Rj(3, a3)
						} catch (t4) {
							W2(a3, a3.return, t4)
						}
						try {
							Qj(5, a3, a3.return)
						} catch (t4) {
							W2(a3, a3.return, t4)
						}
					}
					break
				case 1:
					dk(b3, a3)
					fk(a3)
					d3 & 512 && null !== c3 && Mj(c3, c3.return)
					break
				case 5:
					dk(b3, a3)
					fk(a3)
					d3 & 512 && null !== c3 && Mj(c3, c3.return)
					if (a3.flags & 32) {
						var e2 = a3.stateNode
						try {
							ob(e2, '')
						} catch (t4) {
							W2(a3, a3.return, t4)
						}
					}
					if (d3 & 4 && ((e2 = a3.stateNode), null != e2)) {
						var f3 = a3.memoizedProps,
							g3 = null !== c3 ? c3.memoizedProps : f3,
							h3 = a3.type,
							k2 = a3.updateQueue
						a3.updateQueue = null
						if (null !== k2)
							try {
								'input' === h3 && 'radio' === f3.type && null != f3.name && ab(e2, f3)
								vb(h3, g3)
								var l3 = vb(h3, f3)
								for (g3 = 0; g3 < k2.length; g3 += 2) {
									var m3 = k2[g3],
										q = k2[g3 + 1]
									'style' === m3
										? sb(e2, q)
										: 'dangerouslySetInnerHTML' === m3
										? nb(e2, q)
										: 'children' === m3
										? ob(e2, q)
										: ta(e2, m3, q, l3)
								}
								switch (h3) {
									case 'input':
										bb(e2, f3)
										break
									case 'textarea':
										ib(e2, f3)
										break
									case 'select':
										var r3 = e2._wrapperState.wasMultiple
										e2._wrapperState.wasMultiple = !!f3.multiple
										var y3 = f3.value
										null != y3
											? fb(e2, !!f3.multiple, y3, false)
											: r3 !== !!f3.multiple &&
											  (null != f3.defaultValue
													? fb(e2, !!f3.multiple, f3.defaultValue, true)
													: fb(e2, !!f3.multiple, f3.multiple ? [] : '', false))
								}
								e2[Pf] = f3
							} catch (t4) {
								W2(a3, a3.return, t4)
							}
					}
					break
				case 6:
					dk(b3, a3)
					fk(a3)
					if (d3 & 4) {
						if (null === a3.stateNode) throw Error(p3(162))
						e2 = a3.stateNode
						f3 = a3.memoizedProps
						try {
							e2.nodeValue = f3
						} catch (t4) {
							W2(a3, a3.return, t4)
						}
					}
					break
				case 3:
					dk(b3, a3)
					fk(a3)
					if (d3 & 4 && null !== c3 && c3.memoizedState.isDehydrated)
						try {
							bd(b3.containerInfo)
						} catch (t4) {
							W2(a3, a3.return, t4)
						}
					break
				case 4:
					dk(b3, a3)
					fk(a3)
					break
				case 13:
					dk(b3, a3)
					fk(a3)
					e2 = a3.child
					e2.flags & 8192 &&
						((f3 = null !== e2.memoizedState),
						(e2.stateNode.isHidden = f3),
						!f3 || (null !== e2.alternate && null !== e2.alternate.memoizedState) || (gk = B()))
					d3 & 4 && bk(a3)
					break
				case 22:
					m3 = null !== c3 && null !== c3.memoizedState
					a3.mode & 1 ? ((U = (l3 = U) || m3), dk(b3, a3), (U = l3)) : dk(b3, a3)
					fk(a3)
					if (d3 & 8192) {
						l3 = null !== a3.memoizedState
						if ((a3.stateNode.isHidden = l3) && !m3 && 0 !== (a3.mode & 1))
							for (V2 = a3, m3 = a3.child; null !== m3; ) {
								for (q = V2 = m3; null !== V2; ) {
									r3 = V2
									y3 = r3.child
									switch (r3.tag) {
										case 0:
										case 11:
										case 14:
										case 15:
											Qj(4, r3, r3.return)
											break
										case 1:
											Mj(r3, r3.return)
											var n3 = r3.stateNode
											if ('function' === typeof n3.componentWillUnmount) {
												d3 = r3
												c3 = r3.return
												try {
													;(b3 = d3),
														(n3.props = b3.memoizedProps),
														(n3.state = b3.memoizedState),
														n3.componentWillUnmount()
												} catch (t4) {
													W2(d3, c3, t4)
												}
											}
											break
										case 5:
											Mj(r3, r3.return)
											break
										case 22:
											if (null !== r3.memoizedState) {
												hk(q)
												continue
											}
									}
									null !== y3 ? ((y3.return = r3), (V2 = y3)) : hk(q)
								}
								m3 = m3.sibling
							}
						a: for (m3 = null, q = a3; ; ) {
							if (5 === q.tag) {
								if (null === m3) {
									m3 = q
									try {
										;(e2 = q.stateNode),
											l3
												? ((f3 = e2.style),
												  'function' === typeof f3.setProperty
														? f3.setProperty('display', 'none', 'important')
														: (f3.display = 'none'))
												: ((h3 = q.stateNode),
												  (k2 = q.memoizedProps.style),
												  (g3 =
														void 0 !== k2 && null !== k2 && k2.hasOwnProperty('display')
															? k2.display
															: null),
												  (h3.style.display = rb('display', g3)))
									} catch (t4) {
										W2(a3, a3.return, t4)
									}
								}
							} else if (6 === q.tag) {
								if (null === m3)
									try {
										q.stateNode.nodeValue = l3 ? '' : q.memoizedProps
									} catch (t4) {
										W2(a3, a3.return, t4)
									}
							} else if (
								((22 !== q.tag && 23 !== q.tag) || null === q.memoizedState || q === a3) &&
								null !== q.child
							) {
								q.child.return = q
								q = q.child
								continue
							}
							if (q === a3) break a
							for (; null === q.sibling; ) {
								if (null === q.return || q.return === a3) break a
								m3 === q && (m3 = null)
								q = q.return
							}
							m3 === q && (m3 = null)
							q.sibling.return = q.return
							q = q.sibling
						}
					}
					break
				case 19:
					dk(b3, a3)
					fk(a3)
					d3 & 4 && bk(a3)
					break
				case 21:
					break
				default:
					dk(b3, a3), fk(a3)
			}
		}
		function fk(a3) {
			var b3 = a3.flags
			if (b3 & 2) {
				try {
					a: {
						for (var c3 = a3.return; null !== c3; ) {
							if (Uj(c3)) {
								var d3 = c3
								break a
							}
							c3 = c3.return
						}
						throw Error(p3(160))
					}
					switch (d3.tag) {
						case 5:
							var e2 = d3.stateNode
							d3.flags & 32 && (ob(e2, ''), (d3.flags &= -33))
							var f3 = Vj(a3)
							Xj(a3, f3, e2)
							break
						case 3:
						case 4:
							var g3 = d3.stateNode.containerInfo,
								h3 = Vj(a3)
							Wj(a3, h3, g3)
							break
						default:
							throw Error(p3(161))
					}
				} catch (k2) {
					W2(a3, a3.return, k2)
				}
				a3.flags &= -3
			}
			b3 & 4096 && (a3.flags &= -4097)
		}
		function ik(a3, b3, c3) {
			V2 = a3
			jk(a3, b3, c3)
		}
		function jk(a3, b3, c3) {
			for (var d3 = 0 !== (a3.mode & 1); null !== V2; ) {
				var e2 = V2,
					f3 = e2.child
				if (22 === e2.tag && d3) {
					var g3 = null !== e2.memoizedState || Kj
					if (!g3) {
						var h3 = e2.alternate,
							k2 = (null !== h3 && null !== h3.memoizedState) || U
						h3 = Kj
						var l3 = U
						Kj = g3
						if ((U = k2) && !l3)
							for (V2 = e2; null !== V2; )
								(g3 = V2),
									(k2 = g3.child),
									22 === g3.tag && null !== g3.memoizedState
										? kk(e2)
										: null !== k2
										? ((k2.return = g3), (V2 = k2))
										: kk(e2)
						for (; null !== f3; ) (V2 = f3), jk(f3, b3, c3), (f3 = f3.sibling)
						V2 = e2
						Kj = h3
						U = l3
					}
					lk(a3, b3, c3)
				} else
					0 !== (e2.subtreeFlags & 8772) && null !== f3
						? ((f3.return = e2), (V2 = f3))
						: lk(a3, b3, c3)
			}
		}
		function lk(a3) {
			for (; null !== V2; ) {
				var b3 = V2
				if (0 !== (b3.flags & 8772)) {
					var c3 = b3.alternate
					try {
						if (0 !== (b3.flags & 8772))
							switch (b3.tag) {
								case 0:
								case 11:
								case 15:
									U || Rj(5, b3)
									break
								case 1:
									var d3 = b3.stateNode
									if (b3.flags & 4 && !U)
										if (null === c3) d3.componentDidMount()
										else {
											var e2 =
												b3.elementType === b3.type
													? c3.memoizedProps
													: Lg(b3.type, c3.memoizedProps)
											d3.componentDidUpdate(
												e2,
												c3.memoizedState,
												d3.__reactInternalSnapshotBeforeUpdate
											)
										}
									var f3 = b3.updateQueue
									null !== f3 && ih(b3, f3, d3)
									break
								case 3:
									var g3 = b3.updateQueue
									if (null !== g3) {
										c3 = null
										if (null !== b3.child)
											switch (b3.child.tag) {
												case 5:
													c3 = b3.child.stateNode
													break
												case 1:
													c3 = b3.child.stateNode
											}
										ih(b3, g3, c3)
									}
									break
								case 5:
									var h3 = b3.stateNode
									if (null === c3 && b3.flags & 4) {
										c3 = h3
										var k2 = b3.memoizedProps
										switch (b3.type) {
											case 'button':
											case 'input':
											case 'select':
											case 'textarea':
												k2.autoFocus && c3.focus()
												break
											case 'img':
												k2.src && (c3.src = k2.src)
										}
									}
									break
								case 6:
									break
								case 4:
									break
								case 12:
									break
								case 13:
									if (null === b3.memoizedState) {
										var l3 = b3.alternate
										if (null !== l3) {
											var m3 = l3.memoizedState
											if (null !== m3) {
												var q = m3.dehydrated
												null !== q && bd(q)
											}
										}
									}
									break
								case 19:
								case 17:
								case 21:
								case 22:
								case 23:
								case 25:
									break
								default:
									throw Error(p3(163))
							}
						U || (b3.flags & 512 && Sj(b3))
					} catch (r3) {
						W2(b3, b3.return, r3)
					}
				}
				if (b3 === a3) {
					V2 = null
					break
				}
				c3 = b3.sibling
				if (null !== c3) {
					c3.return = b3.return
					V2 = c3
					break
				}
				V2 = b3.return
			}
		}
		function hk(a3) {
			for (; null !== V2; ) {
				var b3 = V2
				if (b3 === a3) {
					V2 = null
					break
				}
				var c3 = b3.sibling
				if (null !== c3) {
					c3.return = b3.return
					V2 = c3
					break
				}
				V2 = b3.return
			}
		}
		function kk(a3) {
			for (; null !== V2; ) {
				var b3 = V2
				try {
					switch (b3.tag) {
						case 0:
						case 11:
						case 15:
							var c3 = b3.return
							try {
								Rj(4, b3)
							} catch (k2) {
								W2(b3, c3, k2)
							}
							break
						case 1:
							var d3 = b3.stateNode
							if ('function' === typeof d3.componentDidMount) {
								var e2 = b3.return
								try {
									d3.componentDidMount()
								} catch (k2) {
									W2(b3, e2, k2)
								}
							}
							var f3 = b3.return
							try {
								Sj(b3)
							} catch (k2) {
								W2(b3, f3, k2)
							}
							break
						case 5:
							var g3 = b3.return
							try {
								Sj(b3)
							} catch (k2) {
								W2(b3, g3, k2)
							}
					}
				} catch (k2) {
					W2(b3, b3.return, k2)
				}
				if (b3 === a3) {
					V2 = null
					break
				}
				var h3 = b3.sibling
				if (null !== h3) {
					h3.return = b3.return
					V2 = h3
					break
				}
				V2 = b3.return
			}
		}
		var mk = Math.ceil
		var nk = ua.ReactCurrentDispatcher
		var ok = ua.ReactCurrentOwner
		var pk = ua.ReactCurrentBatchConfig
		var K = 0
		var R3 = null
		var Y = null
		var Z = 0
		var gj = 0
		var fj = Uf(0)
		var T3 = 0
		var qk = null
		var hh = 0
		var rk = 0
		var sk = 0
		var tk = null
		var uk = null
		var gk = 0
		var Hj = Infinity
		var vk = null
		var Pi = false
		var Qi = null
		var Si = null
		var wk = false
		var xk = null
		var yk = 0
		var zk = 0
		var Ak = null
		var Bk = -1
		var Ck = 0
		function L3() {
			return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : (Bk = B())
		}
		function lh(a3) {
			if (0 === (a3.mode & 1)) return 1
			if (0 !== (K & 2) && 0 !== Z) return Z & -Z
			if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck
			a3 = C2
			if (0 !== a3) return a3
			a3 = window.event
			a3 = void 0 === a3 ? 16 : jd(a3.type)
			return a3
		}
		function mh(a3, b3, c3, d3) {
			if (50 < zk) throw ((zk = 0), (Ak = null), Error(p3(185)))
			Ac(a3, c3, d3)
			if (0 === (K & 2) || a3 !== R3)
				a3 === R3 && (0 === (K & 2) && (rk |= c3), 4 === T3 && Dk(a3, Z)),
					Ek(a3, d3),
					1 === c3 && 0 === K && 0 === (b3.mode & 1) && ((Hj = B() + 500), fg && jg())
		}
		function Ek(a3, b3) {
			var c3 = a3.callbackNode
			wc(a3, b3)
			var d3 = uc(a3, a3 === R3 ? Z : 0)
			if (0 === d3) null !== c3 && bc(c3), (a3.callbackNode = null), (a3.callbackPriority = 0)
			else if (((b3 = d3 & -d3), a3.callbackPriority !== b3)) {
				null != c3 && bc(c3)
				if (1 === b3)
					0 === a3.tag ? ig(Fk.bind(null, a3)) : hg(Fk.bind(null, a3)),
						Jf(function () {
							0 === (K & 6) && jg()
						}),
						(c3 = null)
				else {
					switch (Dc(d3)) {
						case 1:
							c3 = fc
							break
						case 4:
							c3 = gc
							break
						case 16:
							c3 = hc
							break
						case 536870912:
							c3 = jc
							break
						default:
							c3 = hc
					}
					c3 = Gk(c3, Hk.bind(null, a3))
				}
				a3.callbackPriority = b3
				a3.callbackNode = c3
			}
		}
		function Hk(a3, b3) {
			Bk = -1
			Ck = 0
			if (0 !== (K & 6)) throw Error(p3(327))
			var c3 = a3.callbackNode
			if (Ik() && a3.callbackNode !== c3) return null
			var d3 = uc(a3, a3 === R3 ? Z : 0)
			if (0 === d3) return null
			if (0 !== (d3 & 30) || 0 !== (d3 & a3.expiredLanes) || b3) b3 = Jk(a3, d3)
			else {
				b3 = d3
				var e2 = K
				K |= 2
				var f3 = Kk()
				if (R3 !== a3 || Z !== b3) (vk = null), (Hj = B() + 500), Lk(a3, b3)
				do
					try {
						Mk()
						break
					} catch (h3) {
						Nk(a3, h3)
					}
				while (1)
				Qg()
				nk.current = f3
				K = e2
				null !== Y ? (b3 = 0) : ((R3 = null), (Z = 0), (b3 = T3))
			}
			if (0 !== b3) {
				2 === b3 && ((e2 = xc(a3)), 0 !== e2 && ((d3 = e2), (b3 = Ok(a3, e2))))
				if (1 === b3) throw ((c3 = qk), Lk(a3, 0), Dk(a3, d3), Ek(a3, B()), c3)
				if (6 === b3) Dk(a3, d3)
				else {
					e2 = a3.current.alternate
					if (
						0 === (d3 & 30) &&
						!Pk(e2) &&
						((b3 = Jk(a3, d3)),
						2 === b3 && ((f3 = xc(a3)), 0 !== f3 && ((d3 = f3), (b3 = Ok(a3, f3)))),
						1 === b3)
					)
						throw ((c3 = qk), Lk(a3, 0), Dk(a3, d3), Ek(a3, B()), c3)
					a3.finishedWork = e2
					a3.finishedLanes = d3
					switch (b3) {
						case 0:
						case 1:
							throw Error(p3(345))
						case 2:
							Qk(a3, uk, vk)
							break
						case 3:
							Dk(a3, d3)
							if ((d3 & 130023424) === d3 && ((b3 = gk + 500 - B()), 10 < b3)) {
								if (0 !== uc(a3, 0)) break
								e2 = a3.suspendedLanes
								if ((e2 & d3) !== d3) {
									L3()
									a3.pingedLanes |= a3.suspendedLanes & e2
									break
								}
								a3.timeoutHandle = Ff(Qk.bind(null, a3, uk, vk), b3)
								break
							}
							Qk(a3, uk, vk)
							break
						case 4:
							Dk(a3, d3)
							if ((d3 & 4194240) === d3) break
							b3 = a3.eventTimes
							for (e2 = -1; 0 < d3; ) {
								var g3 = 31 - oc(d3)
								f3 = 1 << g3
								g3 = b3[g3]
								g3 > e2 && (e2 = g3)
								d3 &= ~f3
							}
							d3 = e2
							d3 = B() - d3
							d3 =
								(120 > d3
									? 120
									: 480 > d3
									? 480
									: 1080 > d3
									? 1080
									: 1920 > d3
									? 1920
									: 3e3 > d3
									? 3e3
									: 4320 > d3
									? 4320
									: 1960 * mk(d3 / 1960)) - d3
							if (10 < d3) {
								a3.timeoutHandle = Ff(Qk.bind(null, a3, uk, vk), d3)
								break
							}
							Qk(a3, uk, vk)
							break
						case 5:
							Qk(a3, uk, vk)
							break
						default:
							throw Error(p3(329))
					}
				}
			}
			Ek(a3, B())
			return a3.callbackNode === c3 ? Hk.bind(null, a3) : null
		}
		function Ok(a3, b3) {
			var c3 = tk
			a3.current.memoizedState.isDehydrated && (Lk(a3, b3).flags |= 256)
			a3 = Jk(a3, b3)
			2 !== a3 && ((b3 = uk), (uk = c3), null !== b3 && Gj(b3))
			return a3
		}
		function Gj(a3) {
			null === uk ? (uk = a3) : uk.push.apply(uk, a3)
		}
		function Pk(a3) {
			for (var b3 = a3; ; ) {
				if (b3.flags & 16384) {
					var c3 = b3.updateQueue
					if (null !== c3 && ((c3 = c3.stores), null !== c3))
						for (var d3 = 0; d3 < c3.length; d3++) {
							var e2 = c3[d3],
								f3 = e2.getSnapshot
							e2 = e2.value
							try {
								if (!He(f3(), e2)) return false
							} catch (g3) {
								return false
							}
						}
				}
				c3 = b3.child
				if (b3.subtreeFlags & 16384 && null !== c3) (c3.return = b3), (b3 = c3)
				else {
					if (b3 === a3) break
					for (; null === b3.sibling; ) {
						if (null === b3.return || b3.return === a3) return true
						b3 = b3.return
					}
					b3.sibling.return = b3.return
					b3 = b3.sibling
				}
			}
			return true
		}
		function Dk(a3, b3) {
			b3 &= ~sk
			b3 &= ~rk
			a3.suspendedLanes |= b3
			a3.pingedLanes &= ~b3
			for (a3 = a3.expirationTimes; 0 < b3; ) {
				var c3 = 31 - oc(b3),
					d3 = 1 << c3
				a3[c3] = -1
				b3 &= ~d3
			}
		}
		function Fk(a3) {
			if (0 !== (K & 6)) throw Error(p3(327))
			Ik()
			var b3 = uc(a3, 0)
			if (0 === (b3 & 1)) return Ek(a3, B()), null
			var c3 = Jk(a3, b3)
			if (0 !== a3.tag && 2 === c3) {
				var d3 = xc(a3)
				0 !== d3 && ((b3 = d3), (c3 = Ok(a3, d3)))
			}
			if (1 === c3) throw ((c3 = qk), Lk(a3, 0), Dk(a3, b3), Ek(a3, B()), c3)
			if (6 === c3) throw Error(p3(345))
			a3.finishedWork = a3.current.alternate
			a3.finishedLanes = b3
			Qk(a3, uk, vk)
			Ek(a3, B())
			return null
		}
		function Rk(a3, b3) {
			var c3 = K
			K |= 1
			try {
				return a3(b3)
			} finally {
				;(K = c3), 0 === K && ((Hj = B() + 500), fg && jg())
			}
		}
		function Sk(a3) {
			null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik()
			var b3 = K
			K |= 1
			var c3 = pk.transition,
				d3 = C2
			try {
				if (((pk.transition = null), (C2 = 1), a3)) return a3()
			} finally {
				;(C2 = d3), (pk.transition = c3), (K = b3), 0 === (K & 6) && jg()
			}
		}
		function Ij() {
			gj = fj.current
			E3(fj)
		}
		function Lk(a3, b3) {
			a3.finishedWork = null
			a3.finishedLanes = 0
			var c3 = a3.timeoutHandle
			;-1 !== c3 && ((a3.timeoutHandle = -1), Gf(c3))
			if (null !== Y)
				for (c3 = Y.return; null !== c3; ) {
					var d3 = c3
					wg(d3)
					switch (d3.tag) {
						case 1:
							d3 = d3.type.childContextTypes
							null !== d3 && void 0 !== d3 && $f()
							break
						case 3:
							Jh()
							E3(Wf)
							E3(H2)
							Oh()
							break
						case 5:
							Lh(d3)
							break
						case 4:
							Jh()
							break
						case 13:
							E3(M)
							break
						case 19:
							E3(M)
							break
						case 10:
							Rg(d3.type._context)
							break
						case 22:
						case 23:
							Ij()
					}
					c3 = c3.return
				}
			R3 = a3
			Y = a3 = wh(a3.current, null)
			Z = gj = b3
			T3 = 0
			qk = null
			sk = rk = hh = 0
			uk = tk = null
			if (null !== Wg) {
				for (b3 = 0; b3 < Wg.length; b3++)
					if (((c3 = Wg[b3]), (d3 = c3.interleaved), null !== d3)) {
						c3.interleaved = null
						var e2 = d3.next,
							f3 = c3.pending
						if (null !== f3) {
							var g3 = f3.next
							f3.next = e2
							d3.next = g3
						}
						c3.pending = d3
					}
				Wg = null
			}
			return a3
		}
		function Nk(a3, b3) {
			do {
				var c3 = Y
				try {
					Qg()
					Ph.current = ai
					if (Sh) {
						for (var d3 = N2.memoizedState; null !== d3; ) {
							var e2 = d3.queue
							null !== e2 && (e2.pending = null)
							d3 = d3.next
						}
						Sh = false
					}
					Rh = 0
					P2 = O2 = N2 = null
					Th = false
					Uh = 0
					ok.current = null
					if (null === c3 || null === c3.return) {
						T3 = 1
						qk = b3
						Y = null
						break
					}
					a: {
						var f3 = a3,
							g3 = c3.return,
							h3 = c3,
							k2 = b3
						b3 = Z
						h3.flags |= 32768
						if (null !== k2 && 'object' === typeof k2 && 'function' === typeof k2.then) {
							var l3 = k2,
								m3 = h3,
								q = m3.tag
							if (0 === (m3.mode & 1) && (0 === q || 11 === q || 15 === q)) {
								var r3 = m3.alternate
								r3
									? ((m3.updateQueue = r3.updateQueue),
									  (m3.memoizedState = r3.memoizedState),
									  (m3.lanes = r3.lanes))
									: ((m3.updateQueue = null), (m3.memoizedState = null))
							}
							var y3 = Vi(g3)
							if (null !== y3) {
								y3.flags &= -257
								Wi(y3, g3, h3, f3, b3)
								y3.mode & 1 && Ti(f3, l3, b3)
								b3 = y3
								k2 = l3
								var n3 = b3.updateQueue
								if (null === n3) {
									var t4 = /* @__PURE__ */ new Set()
									t4.add(k2)
									b3.updateQueue = t4
								} else n3.add(k2)
								break a
							} else {
								if (0 === (b3 & 1)) {
									Ti(f3, l3, b3)
									uj()
									break a
								}
								k2 = Error(p3(426))
							}
						} else if (I && h3.mode & 1) {
							var J = Vi(g3)
							if (null !== J) {
								0 === (J.flags & 65536) && (J.flags |= 256)
								Wi(J, g3, h3, f3, b3)
								Jg(Ki(k2, h3))
								break a
							}
						}
						f3 = k2 = Ki(k2, h3)
						4 !== T3 && (T3 = 2)
						null === tk ? (tk = [f3]) : tk.push(f3)
						f3 = g3
						do {
							switch (f3.tag) {
								case 3:
									f3.flags |= 65536
									b3 &= -b3
									f3.lanes |= b3
									var x3 = Oi(f3, k2, b3)
									fh(f3, x3)
									break a
								case 1:
									h3 = k2
									var w3 = f3.type,
										u3 = f3.stateNode
									if (
										0 === (f3.flags & 128) &&
										('function' === typeof w3.getDerivedStateFromError ||
											(null !== u3 &&
												'function' === typeof u3.componentDidCatch &&
												(null === Si || !Si.has(u3))))
									) {
										f3.flags |= 65536
										b3 &= -b3
										f3.lanes |= b3
										var F = Ri(f3, h3, b3)
										fh(f3, F)
										break a
									}
							}
							f3 = f3.return
						} while (null !== f3)
					}
					Tk(c3)
				} catch (na) {
					b3 = na
					Y === c3 && null !== c3 && (Y = c3 = c3.return)
					continue
				}
				break
			} while (1)
		}
		function Kk() {
			var a3 = nk.current
			nk.current = ai
			return null === a3 ? ai : a3
		}
		function uj() {
			if (0 === T3 || 3 === T3 || 2 === T3) T3 = 4
			null === R3 || (0 === (hh & 268435455) && 0 === (rk & 268435455)) || Dk(R3, Z)
		}
		function Jk(a3, b3) {
			var c3 = K
			K |= 2
			var d3 = Kk()
			if (R3 !== a3 || Z !== b3) (vk = null), Lk(a3, b3)
			do
				try {
					Uk()
					break
				} catch (e2) {
					Nk(a3, e2)
				}
			while (1)
			Qg()
			K = c3
			nk.current = d3
			if (null !== Y) throw Error(p3(261))
			R3 = null
			Z = 0
			return T3
		}
		function Uk() {
			for (; null !== Y; ) Vk(Y)
		}
		function Mk() {
			for (; null !== Y && !cc(); ) Vk(Y)
		}
		function Vk(a3) {
			var b3 = Wk(a3.alternate, a3, gj)
			a3.memoizedProps = a3.pendingProps
			null === b3 ? Tk(a3) : (Y = b3)
			ok.current = null
		}
		function Tk(a3) {
			var b3 = a3
			do {
				var c3 = b3.alternate
				a3 = b3.return
				if (0 === (b3.flags & 32768)) {
					if (((c3 = Fj(c3, b3, gj)), null !== c3)) {
						Y = c3
						return
					}
				} else {
					c3 = Jj(c3, b3)
					if (null !== c3) {
						c3.flags &= 32767
						Y = c3
						return
					}
					if (null !== a3) (a3.flags |= 32768), (a3.subtreeFlags = 0), (a3.deletions = null)
					else {
						T3 = 6
						Y = null
						return
					}
				}
				b3 = b3.sibling
				if (null !== b3) {
					Y = b3
					return
				}
				Y = b3 = a3
			} while (null !== b3)
			0 === T3 && (T3 = 5)
		}
		function Qk(a3, b3, c3) {
			var d3 = C2,
				e2 = pk.transition
			try {
				;(pk.transition = null), (C2 = 1), Xk(a3, b3, c3, d3)
			} finally {
				;(pk.transition = e2), (C2 = d3)
			}
			return null
		}
		function Xk(a3, b3, c3, d3) {
			do Ik()
			while (null !== xk)
			if (0 !== (K & 6)) throw Error(p3(327))
			c3 = a3.finishedWork
			var e2 = a3.finishedLanes
			if (null === c3) return null
			a3.finishedWork = null
			a3.finishedLanes = 0
			if (c3 === a3.current) throw Error(p3(177))
			a3.callbackNode = null
			a3.callbackPriority = 0
			var f3 = c3.lanes | c3.childLanes
			Bc(a3, f3)
			a3 === R3 && ((Y = R3 = null), (Z = 0))
			;(0 === (c3.subtreeFlags & 2064) && 0 === (c3.flags & 2064)) ||
				wk ||
				((wk = true),
				Gk(hc, function () {
					Ik()
					return null
				}))
			f3 = 0 !== (c3.flags & 15990)
			if (0 !== (c3.subtreeFlags & 15990) || f3) {
				f3 = pk.transition
				pk.transition = null
				var g3 = C2
				C2 = 1
				var h3 = K
				K |= 4
				ok.current = null
				Pj(a3, c3)
				ek(c3, a3)
				Oe(Df)
				dd = !!Cf
				Df = Cf = null
				a3.current = c3
				ik(c3, a3, e2)
				dc()
				K = h3
				C2 = g3
				pk.transition = f3
			} else a3.current = c3
			wk && ((wk = false), (xk = a3), (yk = e2))
			f3 = a3.pendingLanes
			0 === f3 && (Si = null)
			mc(c3.stateNode, d3)
			Ek(a3, B())
			if (null !== b3)
				for (d3 = a3.onRecoverableError, c3 = 0; c3 < b3.length; c3++)
					(e2 = b3[c3]), d3(e2.value, { componentStack: e2.stack, digest: e2.digest })
			if (Pi) throw ((Pi = false), (a3 = Qi), (Qi = null), a3)
			0 !== (yk & 1) && 0 !== a3.tag && Ik()
			f3 = a3.pendingLanes
			0 !== (f3 & 1) ? (a3 === Ak ? zk++ : ((zk = 0), (Ak = a3))) : (zk = 0)
			jg()
			return null
		}
		function Ik() {
			if (null !== xk) {
				var a3 = Dc(yk),
					b3 = pk.transition,
					c3 = C2
				try {
					pk.transition = null
					C2 = 16 > a3 ? 16 : a3
					if (null === xk) var d3 = false
					else {
						a3 = xk
						xk = null
						yk = 0
						if (0 !== (K & 6)) throw Error(p3(331))
						var e2 = K
						K |= 4
						for (V2 = a3.current; null !== V2; ) {
							var f3 = V2,
								g3 = f3.child
							if (0 !== (V2.flags & 16)) {
								var h3 = f3.deletions
								if (null !== h3) {
									for (var k2 = 0; k2 < h3.length; k2++) {
										var l3 = h3[k2]
										for (V2 = l3; null !== V2; ) {
											var m3 = V2
											switch (m3.tag) {
												case 0:
												case 11:
												case 15:
													Qj(8, m3, f3)
											}
											var q = m3.child
											if (null !== q) (q.return = m3), (V2 = q)
											else
												for (; null !== V2; ) {
													m3 = V2
													var r3 = m3.sibling,
														y3 = m3.return
													Tj(m3)
													if (m3 === l3) {
														V2 = null
														break
													}
													if (null !== r3) {
														r3.return = y3
														V2 = r3
														break
													}
													V2 = y3
												}
										}
									}
									var n3 = f3.alternate
									if (null !== n3) {
										var t4 = n3.child
										if (null !== t4) {
											n3.child = null
											do {
												var J = t4.sibling
												t4.sibling = null
												t4 = J
											} while (null !== t4)
										}
									}
									V2 = f3
								}
							}
							if (0 !== (f3.subtreeFlags & 2064) && null !== g3) (g3.return = f3), (V2 = g3)
							else
								b: for (; null !== V2; ) {
									f3 = V2
									if (0 !== (f3.flags & 2048))
										switch (f3.tag) {
											case 0:
											case 11:
											case 15:
												Qj(9, f3, f3.return)
										}
									var x3 = f3.sibling
									if (null !== x3) {
										x3.return = f3.return
										V2 = x3
										break b
									}
									V2 = f3.return
								}
						}
						var w3 = a3.current
						for (V2 = w3; null !== V2; ) {
							g3 = V2
							var u3 = g3.child
							if (0 !== (g3.subtreeFlags & 2064) && null !== u3) (u3.return = g3), (V2 = u3)
							else
								b: for (g3 = w3; null !== V2; ) {
									h3 = V2
									if (0 !== (h3.flags & 2048))
										try {
											switch (h3.tag) {
												case 0:
												case 11:
												case 15:
													Rj(9, h3)
											}
										} catch (na) {
											W2(h3, h3.return, na)
										}
									if (h3 === g3) {
										V2 = null
										break b
									}
									var F = h3.sibling
									if (null !== F) {
										F.return = h3.return
										V2 = F
										break b
									}
									V2 = h3.return
								}
						}
						K = e2
						jg()
						if (lc && 'function' === typeof lc.onPostCommitFiberRoot)
							try {
								lc.onPostCommitFiberRoot(kc, a3)
							} catch (na) {}
						d3 = true
					}
					return d3
				} finally {
					;(C2 = c3), (pk.transition = b3)
				}
			}
			return false
		}
		function Yk(a3, b3, c3) {
			b3 = Ki(c3, b3)
			b3 = Oi(a3, b3, 1)
			a3 = dh(a3, b3, 1)
			b3 = L3()
			null !== a3 && (Ac(a3, 1, b3), Ek(a3, b3))
		}
		function W2(a3, b3, c3) {
			if (3 === a3.tag) Yk(a3, a3, c3)
			else
				for (; null !== b3; ) {
					if (3 === b3.tag) {
						Yk(b3, a3, c3)
						break
					} else if (1 === b3.tag) {
						var d3 = b3.stateNode
						if (
							'function' === typeof b3.type.getDerivedStateFromError ||
							('function' === typeof d3.componentDidCatch && (null === Si || !Si.has(d3)))
						) {
							a3 = Ki(c3, a3)
							a3 = Ri(b3, a3, 1)
							b3 = dh(b3, a3, 1)
							a3 = L3()
							null !== b3 && (Ac(b3, 1, a3), Ek(b3, a3))
							break
						}
					}
					b3 = b3.return
				}
		}
		function Ui(a3, b3, c3) {
			var d3 = a3.pingCache
			null !== d3 && d3.delete(b3)
			b3 = L3()
			a3.pingedLanes |= a3.suspendedLanes & c3
			R3 === a3 &&
				(Z & c3) === c3 &&
				(4 === T3 || (3 === T3 && (Z & 130023424) === Z && 500 > B() - gk) ? Lk(a3, 0) : (sk |= c3))
			Ek(a3, b3)
		}
		function Zk(a3, b3) {
			0 === b3 &&
				(0 === (a3.mode & 1)
					? (b3 = 1)
					: ((b3 = sc), (sc <<= 1), 0 === (sc & 130023424) && (sc = 4194304)))
			var c3 = L3()
			a3 = Zg(a3, b3)
			null !== a3 && (Ac(a3, b3, c3), Ek(a3, c3))
		}
		function vj(a3) {
			var b3 = a3.memoizedState,
				c3 = 0
			null !== b3 && (c3 = b3.retryLane)
			Zk(a3, c3)
		}
		function ck(a3, b3) {
			var c3 = 0
			switch (a3.tag) {
				case 13:
					var d3 = a3.stateNode
					var e2 = a3.memoizedState
					null !== e2 && (c3 = e2.retryLane)
					break
				case 19:
					d3 = a3.stateNode
					break
				default:
					throw Error(p3(314))
			}
			null !== d3 && d3.delete(b3)
			Zk(a3, c3)
		}
		var Wk
		Wk = function (a3, b3, c3) {
			if (null !== a3)
				if (a3.memoizedProps !== b3.pendingProps || Wf.current) Ug = true
				else {
					if (0 === (a3.lanes & c3) && 0 === (b3.flags & 128)) return (Ug = false), zj(a3, b3, c3)
					Ug = 0 !== (a3.flags & 131072) ? true : false
				}
			else (Ug = false), I && 0 !== (b3.flags & 1048576) && ug(b3, ng, b3.index)
			b3.lanes = 0
			switch (b3.tag) {
				case 2:
					var d3 = b3.type
					jj(a3, b3)
					a3 = b3.pendingProps
					var e2 = Yf(b3, H2.current)
					Tg(b3, c3)
					e2 = Xh(null, b3, d3, a3, e2, c3)
					var f3 = bi()
					b3.flags |= 1
					'object' === typeof e2 &&
					null !== e2 &&
					'function' === typeof e2.render &&
					void 0 === e2.$$typeof
						? ((b3.tag = 1),
						  (b3.memoizedState = null),
						  (b3.updateQueue = null),
						  Zf(d3) ? ((f3 = true), cg(b3)) : (f3 = false),
						  (b3.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null),
						  ah(b3),
						  (e2.updater = nh),
						  (b3.stateNode = e2),
						  (e2._reactInternals = b3),
						  rh(b3, d3, a3, c3),
						  (b3 = kj(null, b3, d3, true, f3, c3)))
						: ((b3.tag = 0), I && f3 && vg(b3), Yi(null, b3, e2, c3), (b3 = b3.child))
					return b3
				case 16:
					d3 = b3.elementType
					a: {
						jj(a3, b3)
						a3 = b3.pendingProps
						e2 = d3._init
						d3 = e2(d3._payload)
						b3.type = d3
						e2 = b3.tag = $k(d3)
						a3 = Lg(d3, a3)
						switch (e2) {
							case 0:
								b3 = dj(null, b3, d3, a3, c3)
								break a
							case 1:
								b3 = ij(null, b3, d3, a3, c3)
								break a
							case 11:
								b3 = Zi(null, b3, d3, a3, c3)
								break a
							case 14:
								b3 = aj(null, b3, d3, Lg(d3.type, a3), c3)
								break a
						}
						throw Error(p3(306, d3, ''))
					}
					return b3
				case 0:
					return (
						(d3 = b3.type),
						(e2 = b3.pendingProps),
						(e2 = b3.elementType === d3 ? e2 : Lg(d3, e2)),
						dj(a3, b3, d3, e2, c3)
					)
				case 1:
					return (
						(d3 = b3.type),
						(e2 = b3.pendingProps),
						(e2 = b3.elementType === d3 ? e2 : Lg(d3, e2)),
						ij(a3, b3, d3, e2, c3)
					)
				case 3:
					a: {
						lj(b3)
						if (null === a3) throw Error(p3(387))
						d3 = b3.pendingProps
						f3 = b3.memoizedState
						e2 = f3.element
						bh(a3, b3)
						gh(b3, d3, null, c3)
						var g3 = b3.memoizedState
						d3 = g3.element
						if (f3.isDehydrated)
							if (
								((f3 = {
									element: d3,
									isDehydrated: false,
									cache: g3.cache,
									pendingSuspenseBoundaries: g3.pendingSuspenseBoundaries,
									transitions: g3.transitions,
								}),
								(b3.updateQueue.baseState = f3),
								(b3.memoizedState = f3),
								b3.flags & 256)
							) {
								e2 = Ki(Error(p3(423)), b3)
								b3 = mj(a3, b3, d3, c3, e2)
								break a
							} else if (d3 !== e2) {
								e2 = Ki(Error(p3(424)), b3)
								b3 = mj(a3, b3, d3, c3, e2)
								break a
							} else
								for (
									yg = Lf(b3.stateNode.containerInfo.firstChild),
										xg = b3,
										I = true,
										zg = null,
										c3 = Ch(b3, null, d3, c3),
										b3.child = c3;
									c3;

								)
									(c3.flags = (c3.flags & -3) | 4096), (c3 = c3.sibling)
						else {
							Ig()
							if (d3 === e2) {
								b3 = $i(a3, b3, c3)
								break a
							}
							Yi(a3, b3, d3, c3)
						}
						b3 = b3.child
					}
					return b3
				case 5:
					return (
						Kh(b3),
						null === a3 && Eg(b3),
						(d3 = b3.type),
						(e2 = b3.pendingProps),
						(f3 = null !== a3 ? a3.memoizedProps : null),
						(g3 = e2.children),
						Ef(d3, e2) ? (g3 = null) : null !== f3 && Ef(d3, f3) && (b3.flags |= 32),
						hj(a3, b3),
						Yi(a3, b3, g3, c3),
						b3.child
					)
				case 6:
					return null === a3 && Eg(b3), null
				case 13:
					return pj(a3, b3, c3)
				case 4:
					return (
						Ih(b3, b3.stateNode.containerInfo),
						(d3 = b3.pendingProps),
						null === a3 ? (b3.child = Bh(b3, null, d3, c3)) : Yi(a3, b3, d3, c3),
						b3.child
					)
				case 11:
					return (
						(d3 = b3.type),
						(e2 = b3.pendingProps),
						(e2 = b3.elementType === d3 ? e2 : Lg(d3, e2)),
						Zi(a3, b3, d3, e2, c3)
					)
				case 7:
					return Yi(a3, b3, b3.pendingProps, c3), b3.child
				case 8:
					return Yi(a3, b3, b3.pendingProps.children, c3), b3.child
				case 12:
					return Yi(a3, b3, b3.pendingProps.children, c3), b3.child
				case 10:
					a: {
						d3 = b3.type._context
						e2 = b3.pendingProps
						f3 = b3.memoizedProps
						g3 = e2.value
						G(Mg, d3._currentValue)
						d3._currentValue = g3
						if (null !== f3)
							if (He(f3.value, g3)) {
								if (f3.children === e2.children && !Wf.current) {
									b3 = $i(a3, b3, c3)
									break a
								}
							} else
								for (f3 = b3.child, null !== f3 && (f3.return = b3); null !== f3; ) {
									var h3 = f3.dependencies
									if (null !== h3) {
										g3 = f3.child
										for (var k2 = h3.firstContext; null !== k2; ) {
											if (k2.context === d3) {
												if (1 === f3.tag) {
													k2 = ch(-1, c3 & -c3)
													k2.tag = 2
													var l3 = f3.updateQueue
													if (null !== l3) {
														l3 = l3.shared
														var m3 = l3.pending
														null === m3 ? (k2.next = k2) : ((k2.next = m3.next), (m3.next = k2))
														l3.pending = k2
													}
												}
												f3.lanes |= c3
												k2 = f3.alternate
												null !== k2 && (k2.lanes |= c3)
												Sg(f3.return, c3, b3)
												h3.lanes |= c3
												break
											}
											k2 = k2.next
										}
									} else if (10 === f3.tag) g3 = f3.type === b3.type ? null : f3.child
									else if (18 === f3.tag) {
										g3 = f3.return
										if (null === g3) throw Error(p3(341))
										g3.lanes |= c3
										h3 = g3.alternate
										null !== h3 && (h3.lanes |= c3)
										Sg(g3, c3, b3)
										g3 = f3.sibling
									} else g3 = f3.child
									if (null !== g3) g3.return = f3
									else
										for (g3 = f3; null !== g3; ) {
											if (g3 === b3) {
												g3 = null
												break
											}
											f3 = g3.sibling
											if (null !== f3) {
												f3.return = g3.return
												g3 = f3
												break
											}
											g3 = g3.return
										}
									f3 = g3
								}
						Yi(a3, b3, e2.children, c3)
						b3 = b3.child
					}
					return b3
				case 9:
					return (
						(e2 = b3.type),
						(d3 = b3.pendingProps.children),
						Tg(b3, c3),
						(e2 = Vg(e2)),
						(d3 = d3(e2)),
						(b3.flags |= 1),
						Yi(a3, b3, d3, c3),
						b3.child
					)
				case 14:
					return (
						(d3 = b3.type),
						(e2 = Lg(d3, b3.pendingProps)),
						(e2 = Lg(d3.type, e2)),
						aj(a3, b3, d3, e2, c3)
					)
				case 15:
					return cj(a3, b3, b3.type, b3.pendingProps, c3)
				case 17:
					return (
						(d3 = b3.type),
						(e2 = b3.pendingProps),
						(e2 = b3.elementType === d3 ? e2 : Lg(d3, e2)),
						jj(a3, b3),
						(b3.tag = 1),
						Zf(d3) ? ((a3 = true), cg(b3)) : (a3 = false),
						Tg(b3, c3),
						ph(b3, d3, e2),
						rh(b3, d3, e2, c3),
						kj(null, b3, d3, true, a3, c3)
					)
				case 19:
					return yj(a3, b3, c3)
				case 22:
					return ej(a3, b3, c3)
			}
			throw Error(p3(156, b3.tag))
		}
		function Gk(a3, b3) {
			return ac(a3, b3)
		}
		function al(a3, b3, c3, d3) {
			this.tag = a3
			this.key = c3
			this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null
			this.index = 0
			this.ref = null
			this.pendingProps = b3
			this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null
			this.mode = d3
			this.subtreeFlags = this.flags = 0
			this.deletions = null
			this.childLanes = this.lanes = 0
			this.alternate = null
		}
		function Bg(a3, b3, c3, d3) {
			return new al(a3, b3, c3, d3)
		}
		function bj(a3) {
			a3 = a3.prototype
			return !(!a3 || !a3.isReactComponent)
		}
		function $k(a3) {
			if ('function' === typeof a3) return bj(a3) ? 1 : 0
			if (void 0 !== a3 && null !== a3) {
				a3 = a3.$$typeof
				if (a3 === Da) return 11
				if (a3 === Ga) return 14
			}
			return 2
		}
		function wh(a3, b3) {
			var c3 = a3.alternate
			null === c3
				? ((c3 = Bg(a3.tag, b3, a3.key, a3.mode)),
				  (c3.elementType = a3.elementType),
				  (c3.type = a3.type),
				  (c3.stateNode = a3.stateNode),
				  (c3.alternate = a3),
				  (a3.alternate = c3))
				: ((c3.pendingProps = b3),
				  (c3.type = a3.type),
				  (c3.flags = 0),
				  (c3.subtreeFlags = 0),
				  (c3.deletions = null))
			c3.flags = a3.flags & 14680064
			c3.childLanes = a3.childLanes
			c3.lanes = a3.lanes
			c3.child = a3.child
			c3.memoizedProps = a3.memoizedProps
			c3.memoizedState = a3.memoizedState
			c3.updateQueue = a3.updateQueue
			b3 = a3.dependencies
			c3.dependencies = null === b3 ? null : { lanes: b3.lanes, firstContext: b3.firstContext }
			c3.sibling = a3.sibling
			c3.index = a3.index
			c3.ref = a3.ref
			return c3
		}
		function yh(a3, b3, c3, d3, e2, f3) {
			var g3 = 2
			d3 = a3
			if ('function' === typeof a3) bj(a3) && (g3 = 1)
			else if ('string' === typeof a3) g3 = 5
			else
				a: switch (a3) {
					case ya:
						return Ah(c3.children, e2, f3, b3)
					case za:
						g3 = 8
						e2 |= 8
						break
					case Aa:
						return (a3 = Bg(12, c3, b3, e2 | 2)), (a3.elementType = Aa), (a3.lanes = f3), a3
					case Ea:
						return (a3 = Bg(13, c3, b3, e2)), (a3.elementType = Ea), (a3.lanes = f3), a3
					case Fa:
						return (a3 = Bg(19, c3, b3, e2)), (a3.elementType = Fa), (a3.lanes = f3), a3
					case Ia:
						return qj(c3, e2, f3, b3)
					default:
						if ('object' === typeof a3 && null !== a3)
							switch (a3.$$typeof) {
								case Ba:
									g3 = 10
									break a
								case Ca:
									g3 = 9
									break a
								case Da:
									g3 = 11
									break a
								case Ga:
									g3 = 14
									break a
								case Ha:
									g3 = 16
									d3 = null
									break a
							}
						throw Error(p3(130, null == a3 ? a3 : typeof a3, ''))
				}
			b3 = Bg(g3, c3, b3, e2)
			b3.elementType = a3
			b3.type = d3
			b3.lanes = f3
			return b3
		}
		function Ah(a3, b3, c3, d3) {
			a3 = Bg(7, a3, d3, b3)
			a3.lanes = c3
			return a3
		}
		function qj(a3, b3, c3, d3) {
			a3 = Bg(22, a3, d3, b3)
			a3.elementType = Ia
			a3.lanes = c3
			a3.stateNode = { isHidden: false }
			return a3
		}
		function xh(a3, b3, c3) {
			a3 = Bg(6, a3, null, b3)
			a3.lanes = c3
			return a3
		}
		function zh(a3, b3, c3) {
			b3 = Bg(4, null !== a3.children ? a3.children : [], a3.key, b3)
			b3.lanes = c3
			b3.stateNode = {
				containerInfo: a3.containerInfo,
				pendingChildren: null,
				implementation: a3.implementation,
			}
			return b3
		}
		function bl(a3, b3, c3, d3, e2) {
			this.tag = b3
			this.containerInfo = a3
			this.finishedWork = this.pingCache = this.current = this.pendingChildren = null
			this.timeoutHandle = -1
			this.callbackNode = this.pendingContext = this.context = null
			this.callbackPriority = 0
			this.eventTimes = zc(0)
			this.expirationTimes = zc(-1)
			this.entangledLanes =
				this.finishedLanes =
				this.mutableReadLanes =
				this.expiredLanes =
				this.pingedLanes =
				this.suspendedLanes =
				this.pendingLanes =
					0
			this.entanglements = zc(0)
			this.identifierPrefix = d3
			this.onRecoverableError = e2
			this.mutableSourceEagerHydrationData = null
		}
		function cl(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
			a3 = new bl(a3, b3, c3, h3, k2)
			1 === b3 ? ((b3 = 1), true === f3 && (b3 |= 8)) : (b3 = 0)
			f3 = Bg(3, null, null, b3)
			a3.current = f3
			f3.stateNode = a3
			f3.memoizedState = {
				element: d3,
				isDehydrated: c3,
				cache: null,
				transitions: null,
				pendingSuspenseBoundaries: null,
			}
			ah(f3)
			return a3
		}
		function dl(a3, b3, c3) {
			var d3 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null
			return {
				$$typeof: wa,
				key: null == d3 ? null : '' + d3,
				children: a3,
				containerInfo: b3,
				implementation: c3,
			}
		}
		function el(a3) {
			if (!a3) return Vf
			a3 = a3._reactInternals
			a: {
				if (Vb(a3) !== a3 || 1 !== a3.tag) throw Error(p3(170))
				var b3 = a3
				do {
					switch (b3.tag) {
						case 3:
							b3 = b3.stateNode.context
							break a
						case 1:
							if (Zf(b3.type)) {
								b3 = b3.stateNode.__reactInternalMemoizedMergedChildContext
								break a
							}
					}
					b3 = b3.return
				} while (null !== b3)
				throw Error(p3(171))
			}
			if (1 === a3.tag) {
				var c3 = a3.type
				if (Zf(c3)) return bg(a3, c3, b3)
			}
			return b3
		}
		function fl(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
			a3 = cl(c3, d3, true, a3, e2, f3, g3, h3, k2)
			a3.context = el(null)
			c3 = a3.current
			d3 = L3()
			e2 = lh(c3)
			f3 = ch(d3, e2)
			f3.callback = void 0 !== b3 && null !== b3 ? b3 : null
			dh(c3, f3, e2)
			a3.current.lanes = e2
			Ac(a3, e2, d3)
			Ek(a3, d3)
			return a3
		}
		function gl(a3, b3, c3, d3) {
			var e2 = b3.current,
				f3 = L3(),
				g3 = lh(e2)
			c3 = el(c3)
			null === b3.context ? (b3.context = c3) : (b3.pendingContext = c3)
			b3 = ch(f3, g3)
			b3.payload = { element: a3 }
			d3 = void 0 === d3 ? null : d3
			null !== d3 && (b3.callback = d3)
			a3 = dh(e2, b3, g3)
			null !== a3 && (mh(a3, e2, g3, f3), eh(a3, e2, g3))
			return g3
		}
		function hl(a3) {
			a3 = a3.current
			if (!a3.child) return null
			switch (a3.child.tag) {
				case 5:
					return a3.child.stateNode
				default:
					return a3.child.stateNode
			}
		}
		function il(a3, b3) {
			a3 = a3.memoizedState
			if (null !== a3 && null !== a3.dehydrated) {
				var c3 = a3.retryLane
				a3.retryLane = 0 !== c3 && c3 < b3 ? c3 : b3
			}
		}
		function jl(a3, b3) {
			il(a3, b3)
			;(a3 = a3.alternate) && il(a3, b3)
		}
		function kl() {
			return null
		}
		var ll =
			'function' === typeof reportError
				? reportError
				: function (a3) {
						console.error(a3)
				  }
		function ml(a3) {
			this._internalRoot = a3
		}
		nl.prototype.render = ml.prototype.render = function (a3) {
			var b3 = this._internalRoot
			if (null === b3) throw Error(p3(409))
			gl(a3, b3, null, null)
		}
		nl.prototype.unmount = ml.prototype.unmount = function () {
			var a3 = this._internalRoot
			if (null !== a3) {
				this._internalRoot = null
				var b3 = a3.containerInfo
				Sk(function () {
					gl(null, a3, null, null)
				})
				b3[uf] = null
			}
		}
		function nl(a3) {
			this._internalRoot = a3
		}
		nl.prototype.unstable_scheduleHydration = function (a3) {
			if (a3) {
				var b3 = Hc()
				a3 = { blockedOn: null, target: a3, priority: b3 }
				for (var c3 = 0; c3 < Qc.length && 0 !== b3 && b3 < Qc[c3].priority; c3++);
				Qc.splice(c3, 0, a3)
				0 === c3 && Vc(a3)
			}
		}
		function ol(a3) {
			return !(!a3 || (1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType))
		}
		function pl(a3) {
			return !(
				!a3 ||
				(1 !== a3.nodeType &&
					9 !== a3.nodeType &&
					11 !== a3.nodeType &&
					(8 !== a3.nodeType || ' react-mount-point-unstable ' !== a3.nodeValue))
			)
		}
		function ql() {}
		function rl(a3, b3, c3, d3, e2) {
			if (e2) {
				if ('function' === typeof d3) {
					var f3 = d3
					d3 = function () {
						var a4 = hl(g3)
						f3.call(a4)
					}
				}
				var g3 = fl(b3, d3, a3, 0, null, false, false, '', ql)
				a3._reactRootContainer = g3
				a3[uf] = g3.current
				sf(8 === a3.nodeType ? a3.parentNode : a3)
				Sk()
				return g3
			}
			for (; (e2 = a3.lastChild); ) a3.removeChild(e2)
			if ('function' === typeof d3) {
				var h3 = d3
				d3 = function () {
					var a4 = hl(k2)
					h3.call(a4)
				}
			}
			var k2 = cl(a3, 0, false, null, null, false, false, '', ql)
			a3._reactRootContainer = k2
			a3[uf] = k2.current
			sf(8 === a3.nodeType ? a3.parentNode : a3)
			Sk(function () {
				gl(b3, k2, c3, d3)
			})
			return k2
		}
		function sl(a3, b3, c3, d3, e2) {
			var f3 = c3._reactRootContainer
			if (f3) {
				var g3 = f3
				if ('function' === typeof e2) {
					var h3 = e2
					e2 = function () {
						var a4 = hl(g3)
						h3.call(a4)
					}
				}
				gl(b3, g3, a3, e2)
			} else g3 = rl(c3, b3, a3, e2, d3)
			return hl(g3)
		}
		Ec = function (a3) {
			switch (a3.tag) {
				case 3:
					var b3 = a3.stateNode
					if (b3.current.memoizedState.isDehydrated) {
						var c3 = tc(b3.pendingLanes)
						0 !== c3 && (Cc(b3, c3 | 1), Ek(b3, B()), 0 === (K & 6) && ((Hj = B() + 500), jg()))
					}
					break
				case 13:
					Sk(function () {
						var b4 = Zg(a3, 1)
						if (null !== b4) {
							var c4 = L3()
							mh(b4, a3, 1, c4)
						}
					}),
						jl(a3, 1)
			}
		}
		Fc = function (a3) {
			if (13 === a3.tag) {
				var b3 = Zg(a3, 134217728)
				if (null !== b3) {
					var c3 = L3()
					mh(b3, a3, 134217728, c3)
				}
				jl(a3, 134217728)
			}
		}
		Gc = function (a3) {
			if (13 === a3.tag) {
				var b3 = lh(a3),
					c3 = Zg(a3, b3)
				if (null !== c3) {
					var d3 = L3()
					mh(c3, a3, b3, d3)
				}
				jl(a3, b3)
			}
		}
		Hc = function () {
			return C2
		}
		Ic = function (a3, b3) {
			var c3 = C2
			try {
				return (C2 = a3), b3()
			} finally {
				C2 = c3
			}
		}
		yb = function (a3, b3, c3) {
			switch (b3) {
				case 'input':
					bb(a3, c3)
					b3 = c3.name
					if ('radio' === c3.type && null != b3) {
						for (c3 = a3; c3.parentNode; ) c3 = c3.parentNode
						c3 = c3.querySelectorAll('input[name=' + JSON.stringify('' + b3) + '][type="radio"]')
						for (b3 = 0; b3 < c3.length; b3++) {
							var d3 = c3[b3]
							if (d3 !== a3 && d3.form === a3.form) {
								var e2 = Db(d3)
								if (!e2) throw Error(p3(90))
								Wa(d3)
								bb(d3, e2)
							}
						}
					}
					break
				case 'textarea':
					ib(a3, c3)
					break
				case 'select':
					;(b3 = c3.value), null != b3 && fb(a3, !!c3.multiple, b3, false)
			}
		}
		Gb = Rk
		Hb = Sk
		var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }
		var ul = {
			findFiberByHostInstance: Wc,
			bundleType: 0,
			version: '18.2.0',
			rendererPackageName: 'react-dom',
		}
		var vl = {
			bundleType: ul.bundleType,
			version: ul.version,
			rendererPackageName: ul.rendererPackageName,
			rendererConfig: ul.rendererConfig,
			overrideHookState: null,
			overrideHookStateDeletePath: null,
			overrideHookStateRenamePath: null,
			overrideProps: null,
			overridePropsDeletePath: null,
			overridePropsRenamePath: null,
			setErrorHandler: null,
			setSuspenseHandler: null,
			scheduleUpdate: null,
			currentDispatcherRef: ua.ReactCurrentDispatcher,
			findHostInstanceByFiber: function (a3) {
				a3 = Zb(a3)
				return null === a3 ? null : a3.stateNode
			},
			findFiberByHostInstance: ul.findFiberByHostInstance || kl,
			findHostInstancesForRefresh: null,
			scheduleRefresh: null,
			scheduleRoot: null,
			setRefreshHandler: null,
			getCurrentFiber: null,
			reconcilerVersion: '18.2.0-next-9e3b772b8-20220608',
		}
		if ('undefined' !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
			wl = __REACT_DEVTOOLS_GLOBAL_HOOK__
			if (!wl.isDisabled && wl.supportsFiber)
				try {
					;(kc = wl.inject(vl)), (lc = wl)
				} catch (a3) {}
		}
		var wl
		exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl
		exports.createPortal = function (a3, b3) {
			var c3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null
			if (!ol(b3)) throw Error(p3(200))
			return dl(a3, b3, null, c3)
		}
		exports.createRoot = function (a3, b3) {
			if (!ol(a3)) throw Error(p3(299))
			var c3 = false,
				d3 = '',
				e2 = ll
			null !== b3 &&
				void 0 !== b3 &&
				(true === b3.unstable_strictMode && (c3 = true),
				void 0 !== b3.identifierPrefix && (d3 = b3.identifierPrefix),
				void 0 !== b3.onRecoverableError && (e2 = b3.onRecoverableError))
			b3 = cl(a3, 1, false, null, null, c3, false, d3, e2)
			a3[uf] = b3.current
			sf(8 === a3.nodeType ? a3.parentNode : a3)
			return new ml(b3)
		}
		exports.findDOMNode = function (a3) {
			if (null == a3) return null
			if (1 === a3.nodeType) return a3
			var b3 = a3._reactInternals
			if (void 0 === b3) {
				if ('function' === typeof a3.render) throw Error(p3(188))
				a3 = Object.keys(a3).join(',')
				throw Error(p3(268, a3))
			}
			a3 = Zb(b3)
			a3 = null === a3 ? null : a3.stateNode
			return a3
		}
		exports.flushSync = function (a3) {
			return Sk(a3)
		}
		exports.hydrate = function (a3, b3, c3) {
			if (!pl(b3)) throw Error(p3(200))
			return sl(null, a3, b3, true, c3)
		}
		exports.hydrateRoot = function (a3, b3, c3) {
			if (!ol(a3)) throw Error(p3(405))
			var d3 = (null != c3 && c3.hydratedSources) || null,
				e2 = false,
				f3 = '',
				g3 = ll
			null !== c3 &&
				void 0 !== c3 &&
				(true === c3.unstable_strictMode && (e2 = true),
				void 0 !== c3.identifierPrefix && (f3 = c3.identifierPrefix),
				void 0 !== c3.onRecoverableError && (g3 = c3.onRecoverableError))
			b3 = fl(b3, null, a3, 1, null != c3 ? c3 : null, e2, false, f3, g3)
			a3[uf] = b3.current
			sf(a3)
			if (d3)
				for (a3 = 0; a3 < d3.length; a3++)
					(c3 = d3[a3]),
						(e2 = c3._getVersion),
						(e2 = e2(c3._source)),
						null == b3.mutableSourceEagerHydrationData
							? (b3.mutableSourceEagerHydrationData = [c3, e2])
							: b3.mutableSourceEagerHydrationData.push(c3, e2)
			return new nl(b3)
		}
		exports.render = function (a3, b3, c3) {
			if (!pl(b3)) throw Error(p3(200))
			return sl(null, a3, b3, false, c3)
		}
		exports.unmountComponentAtNode = function (a3) {
			if (!pl(a3)) throw Error(p3(40))
			return a3._reactRootContainer
				? (Sk(function () {
						sl(null, null, a3, false, function () {
							a3._reactRootContainer = null
							a3[uf] = null
						})
				  }),
				  true)
				: false
		}
		exports.unstable_batchedUpdates = Rk
		exports.unstable_renderSubtreeIntoContainer = function (a3, b3, c3, d3) {
			if (!pl(c3)) throw Error(p3(200))
			if (null == a3 || void 0 === a3._reactInternals) throw Error(p3(38))
			return sl(a3, b3, c3, false, d3)
		}
		exports.version = '18.2.0-next-9e3b772b8-20220608'
	},
})

// ../node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
	'../node_modules/react-dom/cjs/react-dom.development.js'(exports) {
		'use strict'
		init_define_process()
		if (define_process_default.env.NODE_ENV !== 'production') {
			;(function () {
				'use strict'
				if (
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function'
				) {
					__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error())
				}
				var React70 = require_react()
				var Scheduler = require_scheduler()
				var ReactSharedInternals = React70.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
				var suppressWarning = false
				function setSuppressWarning(newSuppressWarning) {
					{
						suppressWarning = newSuppressWarning
					}
				}
				function warn(format) {
					{
						if (!suppressWarning) {
							for (
								var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
								_key < _len;
								_key++
							) {
								args[_key - 1] = arguments[_key]
							}
							printWarning('warn', format, args)
						}
					}
				}
				function error(format) {
					{
						if (!suppressWarning) {
							for (
								var _len2 = arguments.length,
									args = new Array(_len2 > 1 ? _len2 - 1 : 0),
									_key2 = 1;
								_key2 < _len2;
								_key2++
							) {
								args[_key2 - 1] = arguments[_key2]
							}
							printWarning('error', format, args)
						}
					}
				}
				function printWarning(level, format, args) {
					{
						var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame
						var stack3 = ReactDebugCurrentFrame2.getStackAddendum()
						if (stack3 !== '') {
							format += '%s'
							args = args.concat([stack3])
						}
						var argsWithFormat = args.map(function (item) {
							return String(item)
						})
						argsWithFormat.unshift('Warning: ' + format)
						Function.prototype.apply.call(console[level], console, argsWithFormat)
					}
				}
				var FunctionComponent = 0
				var ClassComponent = 1
				var IndeterminateComponent = 2
				var HostRoot = 3
				var HostPortal = 4
				var HostComponent = 5
				var HostText = 6
				var Fragment41 = 7
				var Mode = 8
				var ContextConsumer = 9
				var ContextProvider = 10
				var ForwardRef = 11
				var Profiler = 12
				var SuspenseComponent = 13
				var MemoComponent = 14
				var SimpleMemoComponent = 15
				var LazyComponent = 16
				var IncompleteClassComponent = 17
				var DehydratedFragment = 18
				var SuspenseListComponent = 19
				var ScopeComponent = 21
				var OffscreenComponent = 22
				var LegacyHiddenComponent = 23
				var CacheComponent = 24
				var TracingMarkerComponent = 25
				var enableClientRenderFallbackOnTextMismatch = true
				var enableNewReconciler = false
				var enableLazyContextPropagation = false
				var enableLegacyHidden = false
				var enableSuspenseAvoidThisFallback = false
				var disableCommentsAsDOMContainers = true
				var enableCustomElementPropertySupport = false
				var warnAboutStringRefs = false
				var enableSchedulingProfiler = true
				var enableProfilerTimer = true
				var enableProfilerCommitHooks = true
				var allNativeEvents = /* @__PURE__ */ new Set()
				var registrationNameDependencies = {}
				var possibleRegistrationNames = {}
				function registerTwoPhaseEvent(registrationName, dependencies) {
					registerDirectEvent(registrationName, dependencies)
					registerDirectEvent(registrationName + 'Capture', dependencies)
				}
				function registerDirectEvent(registrationName, dependencies) {
					{
						if (registrationNameDependencies[registrationName]) {
							error(
								'EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.',
								registrationName
							)
						}
					}
					registrationNameDependencies[registrationName] = dependencies
					{
						var lowerCasedName = registrationName.toLowerCase()
						possibleRegistrationNames[lowerCasedName] = registrationName
						if (registrationName === 'onDoubleClick') {
							possibleRegistrationNames.ondblclick = registrationName
						}
					}
					for (var i3 = 0; i3 < dependencies.length; i3++) {
						allNativeEvents.add(dependencies[i3])
					}
				}
				var canUseDOM = !!(
					typeof window !== 'undefined' &&
					typeof window.document !== 'undefined' &&
					typeof window.document.createElement !== 'undefined'
				)
				var hasOwnProperty2 = Object.prototype.hasOwnProperty
				function typeName(value) {
					{
						var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag
						var type =
							(hasToStringTag && value[Symbol.toStringTag]) || value.constructor.name || 'Object'
						return type
					}
				}
				function willCoercionThrow(value) {
					{
						try {
							testStringCoercion(value)
							return false
						} catch (e2) {
							return true
						}
					}
				}
				function testStringCoercion(value) {
					return '' + value
				}
				function checkAttributeStringCoercion(value, attributeName) {
					{
						if (willCoercionThrow(value)) {
							error(
								'The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.',
								attributeName,
								typeName(value)
							)
							return testStringCoercion(value)
						}
					}
				}
				function checkKeyStringCoercion(value) {
					{
						if (willCoercionThrow(value)) {
							error(
								'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
								typeName(value)
							)
							return testStringCoercion(value)
						}
					}
				}
				function checkPropStringCoercion(value, propName) {
					{
						if (willCoercionThrow(value)) {
							error(
								'The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.',
								propName,
								typeName(value)
							)
							return testStringCoercion(value)
						}
					}
				}
				function checkCSSPropertyStringCoercion(value, propName) {
					{
						if (willCoercionThrow(value)) {
							error(
								'The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.',
								propName,
								typeName(value)
							)
							return testStringCoercion(value)
						}
					}
				}
				function checkHtmlStringCoercion(value) {
					{
						if (willCoercionThrow(value)) {
							error(
								'The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.',
								typeName(value)
							)
							return testStringCoercion(value)
						}
					}
				}
				function checkFormFieldValueStringCoercion(value) {
					{
						if (willCoercionThrow(value)) {
							error(
								'Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.',
								typeName(value)
							)
							return testStringCoercion(value)
						}
					}
				}
				var RESERVED = 0
				var STRING = 1
				var BOOLEANISH_STRING = 2
				var BOOLEAN = 3
				var OVERLOADED_BOOLEAN = 4
				var NUMERIC = 5
				var POSITIVE_NUMERIC = 6
				var ATTRIBUTE_NAME_START_CHAR =
					':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD'
				var ATTRIBUTE_NAME_CHAR =
					ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040'
				var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(
					'^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$'
				)
				var illegalAttributeNameCache = {}
				var validatedAttributeNameCache = {}
				function isAttributeNameSafe(attributeName) {
					if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
						return true
					}
					if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
						return false
					}
					if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
						validatedAttributeNameCache[attributeName] = true
						return true
					}
					illegalAttributeNameCache[attributeName] = true
					{
						error('Invalid attribute name: `%s`', attributeName)
					}
					return false
				}
				function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
					if (propertyInfo !== null) {
						return propertyInfo.type === RESERVED
					}
					if (isCustomComponentTag) {
						return false
					}
					if (
						name.length > 2 &&
						(name[0] === 'o' || name[0] === 'O') &&
						(name[1] === 'n' || name[1] === 'N')
					) {
						return true
					}
					return false
				}
				function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
					if (propertyInfo !== null && propertyInfo.type === RESERVED) {
						return false
					}
					switch (typeof value) {
						case 'function':
						case 'symbol':
							return true
						case 'boolean': {
							if (isCustomComponentTag) {
								return false
							}
							if (propertyInfo !== null) {
								return !propertyInfo.acceptsBooleans
							} else {
								var prefix2 = name.toLowerCase().slice(0, 5)
								return prefix2 !== 'data-' && prefix2 !== 'aria-'
							}
						}
						default:
							return false
					}
				}
				function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
					if (value === null || typeof value === 'undefined') {
						return true
					}
					if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
						return true
					}
					if (isCustomComponentTag) {
						return false
					}
					if (propertyInfo !== null) {
						switch (propertyInfo.type) {
							case BOOLEAN:
								return !value
							case OVERLOADED_BOOLEAN:
								return value === false
							case NUMERIC:
								return isNaN(value)
							case POSITIVE_NUMERIC:
								return isNaN(value) || value < 1
						}
					}
					return false
				}
				function getPropertyInfo(name) {
					return properties.hasOwnProperty(name) ? properties[name] : null
				}
				function PropertyInfoRecord(
					name,
					type,
					mustUseProperty,
					attributeName,
					attributeNamespace,
					sanitizeURL2,
					removeEmptyString
				) {
					this.acceptsBooleans =
						type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN
					this.attributeName = attributeName
					this.attributeNamespace = attributeNamespace
					this.mustUseProperty = mustUseProperty
					this.propertyName = name
					this.type = type
					this.sanitizeURL = sanitizeURL2
					this.removeEmptyString = removeEmptyString
				}
				var properties = {}
				var reservedProps = [
					'children',
					'dangerouslySetInnerHTML',
					// TODO: This prevents the assignment of defaultValue to regular
					// elements (not just inputs). Now that ReactDOMInput assigns to the
					// defaultValue property -- do we need this?
					'defaultValue',
					'defaultChecked',
					'innerHTML',
					'suppressContentEditableWarning',
					'suppressHydrationWarning',
					'style',
				]
				reservedProps.forEach(function (name) {
					properties[name] = new PropertyInfoRecord(
						name,
						RESERVED,
						false,
						// mustUseProperty
						name,
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				;[
					['acceptCharset', 'accept-charset'],
					['className', 'class'],
					['htmlFor', 'for'],
					['httpEquiv', 'http-equiv'],
				].forEach(function (_ref) {
					var name = _ref[0],
						attributeName = _ref[1]
					properties[name] = new PropertyInfoRecord(
						name,
						STRING,
						false,
						// mustUseProperty
						attributeName,
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
					properties[name] = new PropertyInfoRecord(
						name,
						BOOLEANISH_STRING,
						false,
						// mustUseProperty
						name.toLowerCase(),
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				;['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(
					function (name) {
						properties[name] = new PropertyInfoRecord(
							name,
							BOOLEANISH_STRING,
							false,
							// mustUseProperty
							name,
							// attributeName
							null,
							// attributeNamespace
							false,
							// sanitizeURL
							false
						)
					}
				)
				;[
					'allowFullScreen',
					'async',
					// Note: there is a special case that prevents it from being written to the DOM
					// on the client side because the browsers are inconsistent. Instead we call focus().
					'autoFocus',
					'autoPlay',
					'controls',
					'default',
					'defer',
					'disabled',
					'disablePictureInPicture',
					'disableRemotePlayback',
					'formNoValidate',
					'hidden',
					'loop',
					'noModule',
					'noValidate',
					'open',
					'playsInline',
					'readOnly',
					'required',
					'reversed',
					'scoped',
					'seamless',
					// Microdata
					'itemScope',
				].forEach(function (name) {
					properties[name] = new PropertyInfoRecord(
						name,
						BOOLEAN,
						false,
						// mustUseProperty
						name.toLowerCase(),
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				;[
					'checked',
					// Note: `option.selected` is not updated if `select.multiple` is
					// disabled with `removeAttribute`. We have special logic for handling this.
					'multiple',
					'muted',
					'selected',
					// NOTE: if you add a camelCased prop to this list,
					// you'll need to set attributeName to name.toLowerCase()
					// instead in the assignment below.
				].forEach(function (name) {
					properties[name] = new PropertyInfoRecord(
						name,
						BOOLEAN,
						true,
						// mustUseProperty
						name,
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				;[
					'capture',
					'download',
					// NOTE: if you add a camelCased prop to this list,
					// you'll need to set attributeName to name.toLowerCase()
					// instead in the assignment below.
				].forEach(function (name) {
					properties[name] = new PropertyInfoRecord(
						name,
						OVERLOADED_BOOLEAN,
						false,
						// mustUseProperty
						name,
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				;[
					'cols',
					'rows',
					'size',
					'span',
					// NOTE: if you add a camelCased prop to this list,
					// you'll need to set attributeName to name.toLowerCase()
					// instead in the assignment below.
				].forEach(function (name) {
					properties[name] = new PropertyInfoRecord(
						name,
						POSITIVE_NUMERIC,
						false,
						// mustUseProperty
						name,
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				;['rowSpan', 'start'].forEach(function (name) {
					properties[name] = new PropertyInfoRecord(
						name,
						NUMERIC,
						false,
						// mustUseProperty
						name.toLowerCase(),
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				var CAMELIZE = /[\-\:]([a-z])/g
				var capitalize2 = function (token) {
					return token[1].toUpperCase()
				}
				;[
					'accent-height',
					'alignment-baseline',
					'arabic-form',
					'baseline-shift',
					'cap-height',
					'clip-path',
					'clip-rule',
					'color-interpolation',
					'color-interpolation-filters',
					'color-profile',
					'color-rendering',
					'dominant-baseline',
					'enable-background',
					'fill-opacity',
					'fill-rule',
					'flood-color',
					'flood-opacity',
					'font-family',
					'font-size',
					'font-size-adjust',
					'font-stretch',
					'font-style',
					'font-variant',
					'font-weight',
					'glyph-name',
					'glyph-orientation-horizontal',
					'glyph-orientation-vertical',
					'horiz-adv-x',
					'horiz-origin-x',
					'image-rendering',
					'letter-spacing',
					'lighting-color',
					'marker-end',
					'marker-mid',
					'marker-start',
					'overline-position',
					'overline-thickness',
					'paint-order',
					'panose-1',
					'pointer-events',
					'rendering-intent',
					'shape-rendering',
					'stop-color',
					'stop-opacity',
					'strikethrough-position',
					'strikethrough-thickness',
					'stroke-dasharray',
					'stroke-dashoffset',
					'stroke-linecap',
					'stroke-linejoin',
					'stroke-miterlimit',
					'stroke-opacity',
					'stroke-width',
					'text-anchor',
					'text-decoration',
					'text-rendering',
					'underline-position',
					'underline-thickness',
					'unicode-bidi',
					'unicode-range',
					'units-per-em',
					'v-alphabetic',
					'v-hanging',
					'v-ideographic',
					'v-mathematical',
					'vector-effect',
					'vert-adv-y',
					'vert-origin-x',
					'vert-origin-y',
					'word-spacing',
					'writing-mode',
					'xmlns:xlink',
					'x-height',
					// NOTE: if you add a camelCased prop to this list,
					// you'll need to set attributeName to name.toLowerCase()
					// instead in the assignment below.
				].forEach(function (attributeName) {
					var name = attributeName.replace(CAMELIZE, capitalize2)
					properties[name] = new PropertyInfoRecord(
						name,
						STRING,
						false,
						// mustUseProperty
						attributeName,
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				;[
					'xlink:actuate',
					'xlink:arcrole',
					'xlink:role',
					'xlink:show',
					'xlink:title',
					'xlink:type',
					// NOTE: if you add a camelCased prop to this list,
					// you'll need to set attributeName to name.toLowerCase()
					// instead in the assignment below.
				].forEach(function (attributeName) {
					var name = attributeName.replace(CAMELIZE, capitalize2)
					properties[name] = new PropertyInfoRecord(
						name,
						STRING,
						false,
						// mustUseProperty
						attributeName,
						'http://www.w3.org/1999/xlink',
						false,
						// sanitizeURL
						false
					)
				})
				;[
					'xml:base',
					'xml:lang',
					'xml:space',
					// NOTE: if you add a camelCased prop to this list,
					// you'll need to set attributeName to name.toLowerCase()
					// instead in the assignment below.
				].forEach(function (attributeName) {
					var name = attributeName.replace(CAMELIZE, capitalize2)
					properties[name] = new PropertyInfoRecord(
						name,
						STRING,
						false,
						// mustUseProperty
						attributeName,
						'http://www.w3.org/XML/1998/namespace',
						false,
						// sanitizeURL
						false
					)
				})
				;['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
					properties[attributeName] = new PropertyInfoRecord(
						attributeName,
						STRING,
						false,
						// mustUseProperty
						attributeName.toLowerCase(),
						// attributeName
						null,
						// attributeNamespace
						false,
						// sanitizeURL
						false
					)
				})
				var xlinkHref = 'xlinkHref'
				properties[xlinkHref] = new PropertyInfoRecord(
					'xlinkHref',
					STRING,
					false,
					// mustUseProperty
					'xlink:href',
					'http://www.w3.org/1999/xlink',
					true,
					// sanitizeURL
					false
				)
				;['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
					properties[attributeName] = new PropertyInfoRecord(
						attributeName,
						STRING,
						false,
						// mustUseProperty
						attributeName.toLowerCase(),
						// attributeName
						null,
						// attributeNamespace
						true,
						// sanitizeURL
						true
					)
				})
				var isJavaScriptProtocol =
					/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i
				var didWarn = false
				function sanitizeURL(url) {
					{
						if (!didWarn && isJavaScriptProtocol.test(url)) {
							didWarn = true
							error(
								'A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.',
								JSON.stringify(url)
							)
						}
					}
				}
				function getValueForProperty(node, name, expected, propertyInfo) {
					{
						if (propertyInfo.mustUseProperty) {
							var propertyName = propertyInfo.propertyName
							return node[propertyName]
						} else {
							{
								checkAttributeStringCoercion(expected, name)
							}
							if (propertyInfo.sanitizeURL) {
								sanitizeURL('' + expected)
							}
							var attributeName = propertyInfo.attributeName
							var stringValue = null
							if (propertyInfo.type === OVERLOADED_BOOLEAN) {
								if (node.hasAttribute(attributeName)) {
									var value = node.getAttribute(attributeName)
									if (value === '') {
										return true
									}
									if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
										return value
									}
									if (value === '' + expected) {
										return expected
									}
									return value
								}
							} else if (node.hasAttribute(attributeName)) {
								if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
									return node.getAttribute(attributeName)
								}
								if (propertyInfo.type === BOOLEAN) {
									return expected
								}
								stringValue = node.getAttribute(attributeName)
							}
							if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
								return stringValue === null ? expected : stringValue
							} else if (stringValue === '' + expected) {
								return expected
							} else {
								return stringValue
							}
						}
					}
				}
				function getValueForAttribute(node, name, expected, isCustomComponentTag) {
					{
						if (!isAttributeNameSafe(name)) {
							return
						}
						if (!node.hasAttribute(name)) {
							return expected === void 0 ? void 0 : null
						}
						var value = node.getAttribute(name)
						{
							checkAttributeStringCoercion(expected, name)
						}
						if (value === '' + expected) {
							return expected
						}
						return value
					}
				}
				function setValueForProperty(node, name, value, isCustomComponentTag) {
					var propertyInfo = getPropertyInfo(name)
					if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
						return
					}
					if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
						value = null
					}
					if (isCustomComponentTag || propertyInfo === null) {
						if (isAttributeNameSafe(name)) {
							var _attributeName = name
							if (value === null) {
								node.removeAttribute(_attributeName)
							} else {
								{
									checkAttributeStringCoercion(value, name)
								}
								node.setAttribute(_attributeName, '' + value)
							}
						}
						return
					}
					var mustUseProperty = propertyInfo.mustUseProperty
					if (mustUseProperty) {
						var propertyName = propertyInfo.propertyName
						if (value === null) {
							var type = propertyInfo.type
							node[propertyName] = type === BOOLEAN ? false : ''
						} else {
							node[propertyName] = value
						}
						return
					}
					var attributeName = propertyInfo.attributeName,
						attributeNamespace = propertyInfo.attributeNamespace
					if (value === null) {
						node.removeAttribute(attributeName)
					} else {
						var _type = propertyInfo.type
						var attributeValue
						if (_type === BOOLEAN || (_type === OVERLOADED_BOOLEAN && value === true)) {
							attributeValue = ''
						} else {
							{
								{
									checkAttributeStringCoercion(value, attributeName)
								}
								attributeValue = '' + value
							}
							if (propertyInfo.sanitizeURL) {
								sanitizeURL(attributeValue.toString())
							}
						}
						if (attributeNamespace) {
							node.setAttributeNS(attributeNamespace, attributeName, attributeValue)
						} else {
							node.setAttribute(attributeName, attributeValue)
						}
					}
				}
				var REACT_ELEMENT_TYPE = Symbol.for('react.element')
				var REACT_PORTAL_TYPE = Symbol.for('react.portal')
				var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')
				var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')
				var REACT_PROFILER_TYPE = Symbol.for('react.profiler')
				var REACT_PROVIDER_TYPE = Symbol.for('react.provider')
				var REACT_CONTEXT_TYPE = Symbol.for('react.context')
				var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')
				var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')
				var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')
				var REACT_MEMO_TYPE = Symbol.for('react.memo')
				var REACT_LAZY_TYPE = Symbol.for('react.lazy')
				var REACT_SCOPE_TYPE = Symbol.for('react.scope')
				var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode')
				var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen')
				var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden')
				var REACT_CACHE_TYPE = Symbol.for('react.cache')
				var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker')
				var MAYBE_ITERATOR_SYMBOL = Symbol.iterator
				var FAUX_ITERATOR_SYMBOL = '@@iterator'
				function getIteratorFn(maybeIterable) {
					if (maybeIterable === null || typeof maybeIterable !== 'object') {
						return null
					}
					var maybeIterator =
						(MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
						maybeIterable[FAUX_ITERATOR_SYMBOL]
					if (typeof maybeIterator === 'function') {
						return maybeIterator
					}
					return null
				}
				var assign = Object.assign
				var disabledDepth = 0
				var prevLog
				var prevInfo
				var prevWarn
				var prevError
				var prevGroup
				var prevGroupCollapsed
				var prevGroupEnd
				function disabledLog() {}
				disabledLog.__reactDisabledLog = true
				function disableLogs() {
					{
						if (disabledDepth === 0) {
							prevLog = console.log
							prevInfo = console.info
							prevWarn = console.warn
							prevError = console.error
							prevGroup = console.group
							prevGroupCollapsed = console.groupCollapsed
							prevGroupEnd = console.groupEnd
							var props = {
								configurable: true,
								enumerable: true,
								value: disabledLog,
								writable: true,
							}
							Object.defineProperties(console, {
								info: props,
								log: props,
								warn: props,
								error: props,
								group: props,
								groupCollapsed: props,
								groupEnd: props,
							})
						}
						disabledDepth++
					}
				}
				function reenableLogs() {
					{
						disabledDepth--
						if (disabledDepth === 0) {
							var props = {
								configurable: true,
								enumerable: true,
								writable: true,
							}
							Object.defineProperties(console, {
								log: assign({}, props, {
									value: prevLog,
								}),
								info: assign({}, props, {
									value: prevInfo,
								}),
								warn: assign({}, props, {
									value: prevWarn,
								}),
								error: assign({}, props, {
									value: prevError,
								}),
								group: assign({}, props, {
									value: prevGroup,
								}),
								groupCollapsed: assign({}, props, {
									value: prevGroupCollapsed,
								}),
								groupEnd: assign({}, props, {
									value: prevGroupEnd,
								}),
							})
						}
						if (disabledDepth < 0) {
							error('disabledDepth fell below zero. This is a bug in React. Please file an issue.')
						}
					}
				}
				var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
				var prefix
				function describeBuiltInComponentFrame(name, source, ownerFn) {
					{
						if (prefix === void 0) {
							try {
								throw Error()
							} catch (x3) {
								var match = x3.stack.trim().match(/\n( *(at )?)/)
								prefix = (match && match[1]) || ''
							}
						}
						return '\n' + prefix + name
					}
				}
				var reentry = false
				var componentFrameCache
				{
					var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map
					componentFrameCache = new PossiblyWeakMap()
				}
				function describeNativeComponentFrame(fn, construct) {
					if (!fn || reentry) {
						return ''
					}
					{
						var frame2 = componentFrameCache.get(fn)
						if (frame2 !== void 0) {
							return frame2
						}
					}
					var control
					reentry = true
					var previousPrepareStackTrace = Error.prepareStackTrace
					Error.prepareStackTrace = void 0
					var previousDispatcher
					{
						previousDispatcher = ReactCurrentDispatcher.current
						ReactCurrentDispatcher.current = null
						disableLogs()
					}
					try {
						if (construct) {
							var Fake = function () {
								throw Error()
							}
							Object.defineProperty(Fake.prototype, 'props', {
								set: function () {
									throw Error()
								},
							})
							if (typeof Reflect === 'object' && Reflect.construct) {
								try {
									Reflect.construct(Fake, [])
								} catch (x3) {
									control = x3
								}
								Reflect.construct(fn, [], Fake)
							} else {
								try {
									Fake.call()
								} catch (x3) {
									control = x3
								}
								fn.call(Fake.prototype)
							}
						} else {
							try {
								throw Error()
							} catch (x3) {
								control = x3
							}
							fn()
						}
					} catch (sample) {
						if (sample && control && typeof sample.stack === 'string') {
							var sampleLines = sample.stack.split('\n')
							var controlLines = control.stack.split('\n')
							var s3 = sampleLines.length - 1
							var c3 = controlLines.length - 1
							while (s3 >= 1 && c3 >= 0 && sampleLines[s3] !== controlLines[c3]) {
								c3--
							}
							for (; s3 >= 1 && c3 >= 0; s3--, c3--) {
								if (sampleLines[s3] !== controlLines[c3]) {
									if (s3 !== 1 || c3 !== 1) {
										do {
											s3--
											c3--
											if (c3 < 0 || sampleLines[s3] !== controlLines[c3]) {
												var _frame = '\n' + sampleLines[s3].replace(' at new ', ' at ')
												if (fn.displayName && _frame.includes('<anonymous>')) {
													_frame = _frame.replace('<anonymous>', fn.displayName)
												}
												{
													if (typeof fn === 'function') {
														componentFrameCache.set(fn, _frame)
													}
												}
												return _frame
											}
										} while (s3 >= 1 && c3 >= 0)
									}
									break
								}
							}
						}
					} finally {
						reentry = false
						{
							ReactCurrentDispatcher.current = previousDispatcher
							reenableLogs()
						}
						Error.prepareStackTrace = previousPrepareStackTrace
					}
					var name = fn ? fn.displayName || fn.name : ''
					var syntheticFrame = name ? describeBuiltInComponentFrame(name) : ''
					{
						if (typeof fn === 'function') {
							componentFrameCache.set(fn, syntheticFrame)
						}
					}
					return syntheticFrame
				}
				function describeClassComponentFrame(ctor, source, ownerFn) {
					{
						return describeNativeComponentFrame(ctor, true)
					}
				}
				function describeFunctionComponentFrame(fn, source, ownerFn) {
					{
						return describeNativeComponentFrame(fn, false)
					}
				}
				function shouldConstruct(Component3) {
					var prototype = Component3.prototype
					return !!(prototype && prototype.isReactComponent)
				}
				function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
					if (type == null) {
						return ''
					}
					if (typeof type === 'function') {
						{
							return describeNativeComponentFrame(type, shouldConstruct(type))
						}
					}
					if (typeof type === 'string') {
						return describeBuiltInComponentFrame(type)
					}
					switch (type) {
						case REACT_SUSPENSE_TYPE:
							return describeBuiltInComponentFrame('Suspense')
						case REACT_SUSPENSE_LIST_TYPE:
							return describeBuiltInComponentFrame('SuspenseList')
					}
					if (typeof type === 'object') {
						switch (type.$$typeof) {
							case REACT_FORWARD_REF_TYPE:
								return describeFunctionComponentFrame(type.render)
							case REACT_MEMO_TYPE:
								return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn)
							case REACT_LAZY_TYPE: {
								var lazyComponent = type
								var payload = lazyComponent._payload
								var init = lazyComponent._init
								try {
									return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn)
								} catch (x3) {}
							}
						}
					}
					return ''
				}
				function describeFiber(fiber) {
					var owner = fiber._debugOwner ? fiber._debugOwner.type : null
					var source = fiber._debugSource
					switch (fiber.tag) {
						case HostComponent:
							return describeBuiltInComponentFrame(fiber.type)
						case LazyComponent:
							return describeBuiltInComponentFrame('Lazy')
						case SuspenseComponent:
							return describeBuiltInComponentFrame('Suspense')
						case SuspenseListComponent:
							return describeBuiltInComponentFrame('SuspenseList')
						case FunctionComponent:
						case IndeterminateComponent:
						case SimpleMemoComponent:
							return describeFunctionComponentFrame(fiber.type)
						case ForwardRef:
							return describeFunctionComponentFrame(fiber.type.render)
						case ClassComponent:
							return describeClassComponentFrame(fiber.type)
						default:
							return ''
					}
				}
				function getStackByFiberInDevAndProd(workInProgress2) {
					try {
						var info = ''
						var node = workInProgress2
						do {
							info += describeFiber(node)
							node = node.return
						} while (node)
						return info
					} catch (x3) {
						return '\nError generating stack: ' + x3.message + '\n' + x3.stack
					}
				}
				function getWrappedName(outerType, innerType, wrapperName) {
					var displayName = outerType.displayName
					if (displayName) {
						return displayName
					}
					var functionName = innerType.displayName || innerType.name || ''
					return functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName
				}
				function getContextName(type) {
					return type.displayName || 'Context'
				}
				function getComponentNameFromType(type) {
					if (type == null) {
						return null
					}
					{
						if (typeof type.tag === 'number') {
							error(
								'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.'
							)
						}
					}
					if (typeof type === 'function') {
						return type.displayName || type.name || null
					}
					if (typeof type === 'string') {
						return type
					}
					switch (type) {
						case REACT_FRAGMENT_TYPE:
							return 'Fragment'
						case REACT_PORTAL_TYPE:
							return 'Portal'
						case REACT_PROFILER_TYPE:
							return 'Profiler'
						case REACT_STRICT_MODE_TYPE:
							return 'StrictMode'
						case REACT_SUSPENSE_TYPE:
							return 'Suspense'
						case REACT_SUSPENSE_LIST_TYPE:
							return 'SuspenseList'
					}
					if (typeof type === 'object') {
						switch (type.$$typeof) {
							case REACT_CONTEXT_TYPE:
								var context = type
								return getContextName(context) + '.Consumer'
							case REACT_PROVIDER_TYPE:
								var provider = type
								return getContextName(provider._context) + '.Provider'
							case REACT_FORWARD_REF_TYPE:
								return getWrappedName(type, type.render, 'ForwardRef')
							case REACT_MEMO_TYPE:
								var outerName = type.displayName || null
								if (outerName !== null) {
									return outerName
								}
								return getComponentNameFromType(type.type) || 'Memo'
							case REACT_LAZY_TYPE: {
								var lazyComponent = type
								var payload = lazyComponent._payload
								var init = lazyComponent._init
								try {
									return getComponentNameFromType(init(payload))
								} catch (x3) {
									return null
								}
							}
						}
					}
					return null
				}
				function getWrappedName$1(outerType, innerType, wrapperName) {
					var functionName = innerType.displayName || innerType.name || ''
					return (
						outerType.displayName ||
						(functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName)
					)
				}
				function getContextName$1(type) {
					return type.displayName || 'Context'
				}
				function getComponentNameFromFiber(fiber) {
					var tag = fiber.tag,
						type = fiber.type
					switch (tag) {
						case CacheComponent:
							return 'Cache'
						case ContextConsumer:
							var context = type
							return getContextName$1(context) + '.Consumer'
						case ContextProvider:
							var provider = type
							return getContextName$1(provider._context) + '.Provider'
						case DehydratedFragment:
							return 'DehydratedFragment'
						case ForwardRef:
							return getWrappedName$1(type, type.render, 'ForwardRef')
						case Fragment41:
							return 'Fragment'
						case HostComponent:
							return type
						case HostPortal:
							return 'Portal'
						case HostRoot:
							return 'Root'
						case HostText:
							return 'Text'
						case LazyComponent:
							return getComponentNameFromType(type)
						case Mode:
							if (type === REACT_STRICT_MODE_TYPE) {
								return 'StrictMode'
							}
							return 'Mode'
						case OffscreenComponent:
							return 'Offscreen'
						case Profiler:
							return 'Profiler'
						case ScopeComponent:
							return 'Scope'
						case SuspenseComponent:
							return 'Suspense'
						case SuspenseListComponent:
							return 'SuspenseList'
						case TracingMarkerComponent:
							return 'TracingMarker'
						case ClassComponent:
						case FunctionComponent:
						case IncompleteClassComponent:
						case IndeterminateComponent:
						case MemoComponent:
						case SimpleMemoComponent:
							if (typeof type === 'function') {
								return type.displayName || type.name || null
							}
							if (typeof type === 'string') {
								return type
							}
							break
					}
					return null
				}
				var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame
				var current = null
				var isRendering = false
				function getCurrentFiberOwnerNameInDevOrNull() {
					{
						if (current === null) {
							return null
						}
						var owner = current._debugOwner
						if (owner !== null && typeof owner !== 'undefined') {
							return getComponentNameFromFiber(owner)
						}
					}
					return null
				}
				function getCurrentFiberStackInDev() {
					{
						if (current === null) {
							return ''
						}
						return getStackByFiberInDevAndProd(current)
					}
				}
				function resetCurrentFiber() {
					{
						ReactDebugCurrentFrame.getCurrentStack = null
						current = null
						isRendering = false
					}
				}
				function setCurrentFiber(fiber) {
					{
						ReactDebugCurrentFrame.getCurrentStack =
							fiber === null ? null : getCurrentFiberStackInDev
						current = fiber
						isRendering = false
					}
				}
				function getCurrentFiber() {
					{
						return current
					}
				}
				function setIsRendering(rendering) {
					{
						isRendering = rendering
					}
				}
				function toString(value) {
					return '' + value
				}
				function getToStringValue(value) {
					switch (typeof value) {
						case 'boolean':
						case 'number':
						case 'string':
						case 'undefined':
							return value
						case 'object':
							{
								checkFormFieldValueStringCoercion(value)
							}
							return value
						default:
							return ''
					}
				}
				var hasReadOnlyValue = {
					button: true,
					checkbox: true,
					image: true,
					hidden: true,
					radio: true,
					reset: true,
					submit: true,
				}
				function checkControlledValueProps(tagName, props) {
					{
						if (
							!(
								hasReadOnlyValue[props.type] ||
								props.onChange ||
								props.onInput ||
								props.readOnly ||
								props.disabled ||
								props.value == null
							)
						) {
							error(
								'You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.'
							)
						}
						if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
							error(
								'You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.'
							)
						}
					}
				}
				function isCheckable(elem) {
					var type = elem.type
					var nodeName = elem.nodeName
					return (
						nodeName &&
						nodeName.toLowerCase() === 'input' &&
						(type === 'checkbox' || type === 'radio')
					)
				}
				function getTracker(node) {
					return node._valueTracker
				}
				function detachTracker(node) {
					node._valueTracker = null
				}
				function getValueFromNode(node) {
					var value = ''
					if (!node) {
						return value
					}
					if (isCheckable(node)) {
						value = node.checked ? 'true' : 'false'
					} else {
						value = node.value
					}
					return value
				}
				function trackValueOnNode(node) {
					var valueField = isCheckable(node) ? 'checked' : 'value'
					var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField)
					{
						checkFormFieldValueStringCoercion(node[valueField])
					}
					var currentValue = '' + node[valueField]
					if (
						node.hasOwnProperty(valueField) ||
						typeof descriptor === 'undefined' ||
						typeof descriptor.get !== 'function' ||
						typeof descriptor.set !== 'function'
					) {
						return
					}
					var get2 = descriptor.get,
						set2 = descriptor.set
					Object.defineProperty(node, valueField, {
						configurable: true,
						get: function () {
							return get2.call(this)
						},
						set: function (value) {
							{
								checkFormFieldValueStringCoercion(value)
							}
							currentValue = '' + value
							set2.call(this, value)
						},
					})
					Object.defineProperty(node, valueField, {
						enumerable: descriptor.enumerable,
					})
					var tracker = {
						getValue: function () {
							return currentValue
						},
						setValue: function (value) {
							{
								checkFormFieldValueStringCoercion(value)
							}
							currentValue = '' + value
						},
						stopTracking: function () {
							detachTracker(node)
							delete node[valueField]
						},
					}
					return tracker
				}
				function track2(node) {
					if (getTracker(node)) {
						return
					}
					node._valueTracker = trackValueOnNode(node)
				}
				function updateValueIfChanged(node) {
					if (!node) {
						return false
					}
					var tracker = getTracker(node)
					if (!tracker) {
						return true
					}
					var lastValue = tracker.getValue()
					var nextValue = getValueFromNode(node)
					if (nextValue !== lastValue) {
						tracker.setValue(nextValue)
						return true
					}
					return false
				}
				function getActiveElement(doc) {
					doc = doc || (typeof document !== 'undefined' ? document : void 0)
					if (typeof doc === 'undefined') {
						return null
					}
					try {
						return doc.activeElement || doc.body
					} catch (e2) {
						return doc.body
					}
				}
				var didWarnValueDefaultValue = false
				var didWarnCheckedDefaultChecked = false
				var didWarnControlledToUncontrolled = false
				var didWarnUncontrolledToControlled = false
				function isControlled(props) {
					var usesChecked = props.type === 'checkbox' || props.type === 'radio'
					return usesChecked ? props.checked != null : props.value != null
				}
				function getHostProps(element, props) {
					var node = element
					var checked = props.checked
					var hostProps = assign({}, props, {
						defaultChecked: void 0,
						defaultValue: void 0,
						value: void 0,
						checked: checked != null ? checked : node._wrapperState.initialChecked,
					})
					return hostProps
				}
				function initWrapperState(element, props) {
					{
						checkControlledValueProps('input', props)
						if (
							props.checked !== void 0 &&
							props.defaultChecked !== void 0 &&
							!didWarnCheckedDefaultChecked
						) {
							error(
								'%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
								getCurrentFiberOwnerNameInDevOrNull() || 'A component',
								props.type
							)
							didWarnCheckedDefaultChecked = true
						}
						if (
							props.value !== void 0 &&
							props.defaultValue !== void 0 &&
							!didWarnValueDefaultValue
						) {
							error(
								'%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
								getCurrentFiberOwnerNameInDevOrNull() || 'A component',
								props.type
							)
							didWarnValueDefaultValue = true
						}
					}
					var node = element
					var defaultValue = props.defaultValue == null ? '' : props.defaultValue
					node._wrapperState = {
						initialChecked: props.checked != null ? props.checked : props.defaultChecked,
						initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
						controlled: isControlled(props),
					}
				}
				function updateChecked(element, props) {
					var node = element
					var checked = props.checked
					if (checked != null) {
						setValueForProperty(node, 'checked', checked, false)
					}
				}
				function updateWrapper(element, props) {
					var node = element
					{
						var controlled = isControlled(props)
						if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
							error(
								'A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components'
							)
							didWarnUncontrolledToControlled = true
						}
						if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
							error(
								'A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components'
							)
							didWarnControlledToUncontrolled = true
						}
					}
					updateChecked(element, props)
					var value = getToStringValue(props.value)
					var type = props.type
					if (value != null) {
						if (type === 'number') {
							if (
								(value === 0 && node.value === '') || // We explicitly want to coerce to number here if possible.
								// eslint-disable-next-line
								node.value != value
							) {
								node.value = toString(value)
							}
						} else if (node.value !== toString(value)) {
							node.value = toString(value)
						}
					} else if (type === 'submit' || type === 'reset') {
						node.removeAttribute('value')
						return
					}
					{
						if (props.hasOwnProperty('value')) {
							setDefaultValue(node, props.type, value)
						} else if (props.hasOwnProperty('defaultValue')) {
							setDefaultValue(node, props.type, getToStringValue(props.defaultValue))
						}
					}
					{
						if (props.checked == null && props.defaultChecked != null) {
							node.defaultChecked = !!props.defaultChecked
						}
					}
				}
				function postMountWrapper(element, props, isHydrating2) {
					var node = element
					if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
						var type = props.type
						var isButton = type === 'submit' || type === 'reset'
						if (isButton && (props.value === void 0 || props.value === null)) {
							return
						}
						var initialValue = toString(node._wrapperState.initialValue)
						if (!isHydrating2) {
							{
								if (initialValue !== node.value) {
									node.value = initialValue
								}
							}
						}
						{
							node.defaultValue = initialValue
						}
					}
					var name = node.name
					if (name !== '') {
						node.name = ''
					}
					{
						node.defaultChecked = !node.defaultChecked
						node.defaultChecked = !!node._wrapperState.initialChecked
					}
					if (name !== '') {
						node.name = name
					}
				}
				function restoreControlledState(element, props) {
					var node = element
					updateWrapper(node, props)
					updateNamedCousins(node, props)
				}
				function updateNamedCousins(rootNode, props) {
					var name = props.name
					if (props.type === 'radio' && name != null) {
						var queryRoot = rootNode
						while (queryRoot.parentNode) {
							queryRoot = queryRoot.parentNode
						}
						{
							checkAttributeStringCoercion(name, 'name')
						}
						var group = queryRoot.querySelectorAll(
							'input[name=' + JSON.stringify('' + name) + '][type="radio"]'
						)
						for (var i3 = 0; i3 < group.length; i3++) {
							var otherNode = group[i3]
							if (otherNode === rootNode || otherNode.form !== rootNode.form) {
								continue
							}
							var otherProps = getFiberCurrentPropsFromNode(otherNode)
							if (!otherProps) {
								throw new Error(
									'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'
								)
							}
							updateValueIfChanged(otherNode)
							updateWrapper(otherNode, otherProps)
						}
					}
				}
				function setDefaultValue(node, type, value) {
					if (
						// Focused number inputs synchronize on blur. See ChangeEventPlugin.js
						type !== 'number' ||
						getActiveElement(node.ownerDocument) !== node
					) {
						if (value == null) {
							node.defaultValue = toString(node._wrapperState.initialValue)
						} else if (node.defaultValue !== toString(value)) {
							node.defaultValue = toString(value)
						}
					}
				}
				var didWarnSelectedSetOnOption = false
				var didWarnInvalidChild = false
				var didWarnInvalidInnerHTML = false
				function validateProps(element, props) {
					{
						if (props.value == null) {
							if (typeof props.children === 'object' && props.children !== null) {
								React70.Children.forEach(props.children, function (child) {
									if (child == null) {
										return
									}
									if (typeof child === 'string' || typeof child === 'number') {
										return
									}
									if (!didWarnInvalidChild) {
										didWarnInvalidChild = true
										error(
											'Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.'
										)
									}
								})
							} else if (props.dangerouslySetInnerHTML != null) {
								if (!didWarnInvalidInnerHTML) {
									didWarnInvalidInnerHTML = true
									error(
										'Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.'
									)
								}
							}
						}
						if (props.selected != null && !didWarnSelectedSetOnOption) {
							error(
								'Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.'
							)
							didWarnSelectedSetOnOption = true
						}
					}
				}
				function postMountWrapper$1(element, props) {
					if (props.value != null) {
						element.setAttribute('value', toString(getToStringValue(props.value)))
					}
				}
				var isArrayImpl = Array.isArray
				function isArray(a3) {
					return isArrayImpl(a3)
				}
				var didWarnValueDefaultValue$1
				{
					didWarnValueDefaultValue$1 = false
				}
				function getDeclarationErrorAddendum() {
					var ownerName = getCurrentFiberOwnerNameInDevOrNull()
					if (ownerName) {
						return '\n\nCheck the render method of `' + ownerName + '`.'
					}
					return ''
				}
				var valuePropNames = ['value', 'defaultValue']
				function checkSelectPropTypes(props) {
					{
						checkControlledValueProps('select', props)
						for (var i3 = 0; i3 < valuePropNames.length; i3++) {
							var propName = valuePropNames[i3]
							if (props[propName] == null) {
								continue
							}
							var propNameIsArray = isArray(props[propName])
							if (props.multiple && !propNameIsArray) {
								error(
									'The `%s` prop supplied to <select> must be an array if `multiple` is true.%s',
									propName,
									getDeclarationErrorAddendum()
								)
							} else if (!props.multiple && propNameIsArray) {
								error(
									'The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s',
									propName,
									getDeclarationErrorAddendum()
								)
							}
						}
					}
				}
				function updateOptions(node, multiple, propValue, setDefaultSelected) {
					var options2 = node.options
					if (multiple) {
						var selectedValues = propValue
						var selectedValue = {}
						for (var i3 = 0; i3 < selectedValues.length; i3++) {
							selectedValue['$' + selectedValues[i3]] = true
						}
						for (var _i = 0; _i < options2.length; _i++) {
							var selected = selectedValue.hasOwnProperty('$' + options2[_i].value)
							if (options2[_i].selected !== selected) {
								options2[_i].selected = selected
							}
							if (selected && setDefaultSelected) {
								options2[_i].defaultSelected = true
							}
						}
					} else {
						var _selectedValue = toString(getToStringValue(propValue))
						var defaultSelected = null
						for (var _i2 = 0; _i2 < options2.length; _i2++) {
							if (options2[_i2].value === _selectedValue) {
								options2[_i2].selected = true
								if (setDefaultSelected) {
									options2[_i2].defaultSelected = true
								}
								return
							}
							if (defaultSelected === null && !options2[_i2].disabled) {
								defaultSelected = options2[_i2]
							}
						}
						if (defaultSelected !== null) {
							defaultSelected.selected = true
						}
					}
				}
				function getHostProps$1(element, props) {
					return assign({}, props, {
						value: void 0,
					})
				}
				function initWrapperState$1(element, props) {
					var node = element
					{
						checkSelectPropTypes(props)
					}
					node._wrapperState = {
						wasMultiple: !!props.multiple,
					}
					{
						if (
							props.value !== void 0 &&
							props.defaultValue !== void 0 &&
							!didWarnValueDefaultValue$1
						) {
							error(
								'Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components'
							)
							didWarnValueDefaultValue$1 = true
						}
					}
				}
				function postMountWrapper$2(element, props) {
					var node = element
					node.multiple = !!props.multiple
					var value = props.value
					if (value != null) {
						updateOptions(node, !!props.multiple, value, false)
					} else if (props.defaultValue != null) {
						updateOptions(node, !!props.multiple, props.defaultValue, true)
					}
				}
				function postUpdateWrapper(element, props) {
					var node = element
					var wasMultiple = node._wrapperState.wasMultiple
					node._wrapperState.wasMultiple = !!props.multiple
					var value = props.value
					if (value != null) {
						updateOptions(node, !!props.multiple, value, false)
					} else if (wasMultiple !== !!props.multiple) {
						if (props.defaultValue != null) {
							updateOptions(node, !!props.multiple, props.defaultValue, true)
						} else {
							updateOptions(node, !!props.multiple, props.multiple ? [] : '', false)
						}
					}
				}
				function restoreControlledState$1(element, props) {
					var node = element
					var value = props.value
					if (value != null) {
						updateOptions(node, !!props.multiple, value, false)
					}
				}
				var didWarnValDefaultVal = false
				function getHostProps$2(element, props) {
					var node = element
					if (props.dangerouslySetInnerHTML != null) {
						throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.')
					}
					var hostProps = assign({}, props, {
						value: void 0,
						defaultValue: void 0,
						children: toString(node._wrapperState.initialValue),
					})
					return hostProps
				}
				function initWrapperState$2(element, props) {
					var node = element
					{
						checkControlledValueProps('textarea', props)
						if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
							error(
								'%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components',
								getCurrentFiberOwnerNameInDevOrNull() || 'A component'
							)
							didWarnValDefaultVal = true
						}
					}
					var initialValue = props.value
					if (initialValue == null) {
						var children = props.children,
							defaultValue = props.defaultValue
						if (children != null) {
							{
								error(
									'Use the `defaultValue` or `value` props instead of setting children on <textarea>.'
								)
							}
							{
								if (defaultValue != null) {
									throw new Error(
										'If you supply `defaultValue` on a <textarea>, do not pass children.'
									)
								}
								if (isArray(children)) {
									if (children.length > 1) {
										throw new Error('<textarea> can only have at most one child.')
									}
									children = children[0]
								}
								defaultValue = children
							}
						}
						if (defaultValue == null) {
							defaultValue = ''
						}
						initialValue = defaultValue
					}
					node._wrapperState = {
						initialValue: getToStringValue(initialValue),
					}
				}
				function updateWrapper$1(element, props) {
					var node = element
					var value = getToStringValue(props.value)
					var defaultValue = getToStringValue(props.defaultValue)
					if (value != null) {
						var newValue = toString(value)
						if (newValue !== node.value) {
							node.value = newValue
						}
						if (props.defaultValue == null && node.defaultValue !== newValue) {
							node.defaultValue = newValue
						}
					}
					if (defaultValue != null) {
						node.defaultValue = toString(defaultValue)
					}
				}
				function postMountWrapper$3(element, props) {
					var node = element
					var textContent = node.textContent
					if (textContent === node._wrapperState.initialValue) {
						if (textContent !== '' && textContent !== null) {
							node.value = textContent
						}
					}
				}
				function restoreControlledState$2(element, props) {
					updateWrapper$1(element, props)
				}
				var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml'
				var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML'
				var SVG_NAMESPACE = 'http://www.w3.org/2000/svg'
				function getIntrinsicNamespace(type) {
					switch (type) {
						case 'svg':
							return SVG_NAMESPACE
						case 'math':
							return MATH_NAMESPACE
						default:
							return HTML_NAMESPACE
					}
				}
				function getChildNamespace(parentNamespace, type) {
					if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
						return getIntrinsicNamespace(type)
					}
					if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
						return HTML_NAMESPACE
					}
					return parentNamespace
				}
				var createMicrosoftUnsafeLocalFunction = function (func) {
					if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
						return function (arg0, arg1, arg2, arg3) {
							MSApp.execUnsafeLocalFunction(function () {
								return func(arg0, arg1, arg2, arg3)
							})
						}
					} else {
						return func
					}
				}
				var reusableSVGContainer
				var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
					if (node.namespaceURI === SVG_NAMESPACE) {
						if (!('innerHTML' in node)) {
							reusableSVGContainer = reusableSVGContainer || document.createElement('div')
							reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>'
							var svgNode = reusableSVGContainer.firstChild
							while (node.firstChild) {
								node.removeChild(node.firstChild)
							}
							while (svgNode.firstChild) {
								node.appendChild(svgNode.firstChild)
							}
							return
						}
					}
					node.innerHTML = html
				})
				var ELEMENT_NODE = 1
				var TEXT_NODE = 3
				var COMMENT_NODE = 8
				var DOCUMENT_NODE = 9
				var DOCUMENT_FRAGMENT_NODE = 11
				var setTextContent = function (node, text) {
					if (text) {
						var firstChild = node.firstChild
						if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
							firstChild.nodeValue = text
							return
						}
					}
					node.textContent = text
				}
				var shorthandToLonghand = {
					animation: [
						'animationDelay',
						'animationDirection',
						'animationDuration',
						'animationFillMode',
						'animationIterationCount',
						'animationName',
						'animationPlayState',
						'animationTimingFunction',
					],
					background: [
						'backgroundAttachment',
						'backgroundClip',
						'backgroundColor',
						'backgroundImage',
						'backgroundOrigin',
						'backgroundPositionX',
						'backgroundPositionY',
						'backgroundRepeat',
						'backgroundSize',
					],
					backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
					border: [
						'borderBottomColor',
						'borderBottomStyle',
						'borderBottomWidth',
						'borderImageOutset',
						'borderImageRepeat',
						'borderImageSlice',
						'borderImageSource',
						'borderImageWidth',
						'borderLeftColor',
						'borderLeftStyle',
						'borderLeftWidth',
						'borderRightColor',
						'borderRightStyle',
						'borderRightWidth',
						'borderTopColor',
						'borderTopStyle',
						'borderTopWidth',
					],
					borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
					borderBlockStart: [
						'borderBlockStartColor',
						'borderBlockStartStyle',
						'borderBlockStartWidth',
					],
					borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
					borderColor: [
						'borderBottomColor',
						'borderLeftColor',
						'borderRightColor',
						'borderTopColor',
					],
					borderImage: [
						'borderImageOutset',
						'borderImageRepeat',
						'borderImageSlice',
						'borderImageSource',
						'borderImageWidth',
					],
					borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
					borderInlineStart: [
						'borderInlineStartColor',
						'borderInlineStartStyle',
						'borderInlineStartWidth',
					],
					borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
					borderRadius: [
						'borderBottomLeftRadius',
						'borderBottomRightRadius',
						'borderTopLeftRadius',
						'borderTopRightRadius',
					],
					borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
					borderStyle: [
						'borderBottomStyle',
						'borderLeftStyle',
						'borderRightStyle',
						'borderTopStyle',
					],
					borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
					borderWidth: [
						'borderBottomWidth',
						'borderLeftWidth',
						'borderRightWidth',
						'borderTopWidth',
					],
					columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
					columns: ['columnCount', 'columnWidth'],
					flex: ['flexBasis', 'flexGrow', 'flexShrink'],
					flexFlow: ['flexDirection', 'flexWrap'],
					font: [
						'fontFamily',
						'fontFeatureSettings',
						'fontKerning',
						'fontLanguageOverride',
						'fontSize',
						'fontSizeAdjust',
						'fontStretch',
						'fontStyle',
						'fontVariant',
						'fontVariantAlternates',
						'fontVariantCaps',
						'fontVariantEastAsian',
						'fontVariantLigatures',
						'fontVariantNumeric',
						'fontVariantPosition',
						'fontWeight',
						'lineHeight',
					],
					fontVariant: [
						'fontVariantAlternates',
						'fontVariantCaps',
						'fontVariantEastAsian',
						'fontVariantLigatures',
						'fontVariantNumeric',
						'fontVariantPosition',
					],
					gap: ['columnGap', 'rowGap'],
					grid: [
						'gridAutoColumns',
						'gridAutoFlow',
						'gridAutoRows',
						'gridTemplateAreas',
						'gridTemplateColumns',
						'gridTemplateRows',
					],
					gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
					gridColumn: ['gridColumnEnd', 'gridColumnStart'],
					gridColumnGap: ['columnGap'],
					gridGap: ['columnGap', 'rowGap'],
					gridRow: ['gridRowEnd', 'gridRowStart'],
					gridRowGap: ['rowGap'],
					gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
					listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
					margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
					marker: ['markerEnd', 'markerMid', 'markerStart'],
					mask: [
						'maskClip',
						'maskComposite',
						'maskImage',
						'maskMode',
						'maskOrigin',
						'maskPositionX',
						'maskPositionY',
						'maskRepeat',
						'maskSize',
					],
					maskPosition: ['maskPositionX', 'maskPositionY'],
					outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
					overflow: ['overflowX', 'overflowY'],
					padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
					placeContent: ['alignContent', 'justifyContent'],
					placeItems: ['alignItems', 'justifyItems'],
					placeSelf: ['alignSelf', 'justifySelf'],
					textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
					textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
					transition: [
						'transitionDelay',
						'transitionDuration',
						'transitionProperty',
						'transitionTimingFunction',
					],
					wordWrap: ['overflowWrap'],
				}
				var isUnitlessNumber = {
					animationIterationCount: true,
					aspectRatio: true,
					borderImageOutset: true,
					borderImageSlice: true,
					borderImageWidth: true,
					boxFlex: true,
					boxFlexGroup: true,
					boxOrdinalGroup: true,
					columnCount: true,
					columns: true,
					flex: true,
					flexGrow: true,
					flexPositive: true,
					flexShrink: true,
					flexNegative: true,
					flexOrder: true,
					gridArea: true,
					gridRow: true,
					gridRowEnd: true,
					gridRowSpan: true,
					gridRowStart: true,
					gridColumn: true,
					gridColumnEnd: true,
					gridColumnSpan: true,
					gridColumnStart: true,
					fontWeight: true,
					lineClamp: true,
					lineHeight: true,
					opacity: true,
					order: true,
					orphans: true,
					tabSize: true,
					widows: true,
					zIndex: true,
					zoom: true,
					// SVG-related properties
					fillOpacity: true,
					floodOpacity: true,
					stopOpacity: true,
					strokeDasharray: true,
					strokeDashoffset: true,
					strokeMiterlimit: true,
					strokeOpacity: true,
					strokeWidth: true,
				}
				function prefixKey(prefix2, key) {
					return prefix2 + key.charAt(0).toUpperCase() + key.substring(1)
				}
				var prefixes = ['Webkit', 'ms', 'Moz', 'O']
				Object.keys(isUnitlessNumber).forEach(function (prop) {
					prefixes.forEach(function (prefix2) {
						isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop]
					})
				})
				function dangerousStyleValue(name, value, isCustomProperty) {
					var isEmpty = value == null || typeof value === 'boolean' || value === ''
					if (isEmpty) {
						return ''
					}
					if (
						!isCustomProperty &&
						typeof value === 'number' &&
						value !== 0 &&
						!(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])
					) {
						return value + 'px'
					}
					{
						checkCSSPropertyStringCoercion(value, name)
					}
					return ('' + value).trim()
				}
				var uppercasePattern = /([A-Z])/g
				var msPattern = /^ms-/
				function hyphenateStyleName(name) {
					return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-')
				}
				var warnValidStyle = function () {}
				{
					var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/
					var msPattern$1 = /^-ms-/
					var hyphenPattern = /-(.)/g
					var badStyleValueWithSemicolonPattern = /;\s*$/
					var warnedStyleNames = {}
					var warnedStyleValues = {}
					var warnedForNaNValue = false
					var warnedForInfinityValue = false
					var camelize = function (string2) {
						return string2.replace(hyphenPattern, function (_, character) {
							return character.toUpperCase()
						})
					}
					var warnHyphenatedStyleName = function (name) {
						if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
							return
						}
						warnedStyleNames[name] = true
						error(
							'Unsupported style property %s. Did you mean %s?',
							name,
							// As Andi Smith suggests
							// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
							// is converted to lowercase `ms`.
							camelize(name.replace(msPattern$1, 'ms-'))
						)
					}
					var warnBadVendoredStyleName = function (name) {
						if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
							return
						}
						warnedStyleNames[name] = true
						error(
							'Unsupported vendor-prefixed style property %s. Did you mean %s?',
							name,
							name.charAt(0).toUpperCase() + name.slice(1)
						)
					}
					var warnStyleValueWithSemicolon = function (name, value) {
						if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
							return
						}
						warnedStyleValues[value] = true
						error(
							`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
							name,
							value.replace(badStyleValueWithSemicolonPattern, '')
						)
					}
					var warnStyleValueIsNaN = function (name, value) {
						if (warnedForNaNValue) {
							return
						}
						warnedForNaNValue = true
						error('`NaN` is an invalid value for the `%s` css style property.', name)
					}
					var warnStyleValueIsInfinity = function (name, value) {
						if (warnedForInfinityValue) {
							return
						}
						warnedForInfinityValue = true
						error('`Infinity` is an invalid value for the `%s` css style property.', name)
					}
					warnValidStyle = function (name, value) {
						if (name.indexOf('-') > -1) {
							warnHyphenatedStyleName(name)
						} else if (badVendoredStyleNamePattern.test(name)) {
							warnBadVendoredStyleName(name)
						} else if (badStyleValueWithSemicolonPattern.test(value)) {
							warnStyleValueWithSemicolon(name, value)
						}
						if (typeof value === 'number') {
							if (isNaN(value)) {
								warnStyleValueIsNaN(name, value)
							} else if (!isFinite(value)) {
								warnStyleValueIsInfinity(name, value)
							}
						}
					}
				}
				var warnValidStyle$1 = warnValidStyle
				function createDangerousStringForStyles(styles2) {
					{
						var serialized = ''
						var delimiter = ''
						for (var styleName in styles2) {
							if (!styles2.hasOwnProperty(styleName)) {
								continue
							}
							var styleValue = styles2[styleName]
							if (styleValue != null) {
								var isCustomProperty = styleName.indexOf('--') === 0
								serialized +=
									delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':'
								serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty)
								delimiter = ';'
							}
						}
						return serialized || null
					}
				}
				function setValueForStyles(node, styles2) {
					var style2 = node.style
					for (var styleName in styles2) {
						if (!styles2.hasOwnProperty(styleName)) {
							continue
						}
						var isCustomProperty = styleName.indexOf('--') === 0
						{
							if (!isCustomProperty) {
								warnValidStyle$1(styleName, styles2[styleName])
							}
						}
						var styleValue = dangerousStyleValue(styleName, styles2[styleName], isCustomProperty)
						if (styleName === 'float') {
							styleName = 'cssFloat'
						}
						if (isCustomProperty) {
							style2.setProperty(styleName, styleValue)
						} else {
							style2[styleName] = styleValue
						}
					}
				}
				function isValueEmpty(value) {
					return value == null || typeof value === 'boolean' || value === ''
				}
				function expandShorthandMap(styles2) {
					var expanded = {}
					for (var key in styles2) {
						var longhands = shorthandToLonghand[key] || [key]
						for (var i3 = 0; i3 < longhands.length; i3++) {
							expanded[longhands[i3]] = key
						}
					}
					return expanded
				}
				function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
					{
						if (!nextStyles) {
							return
						}
						var expandedUpdates = expandShorthandMap(styleUpdates)
						var expandedStyles = expandShorthandMap(nextStyles)
						var warnedAbout = {}
						for (var key in expandedUpdates) {
							var originalKey = expandedUpdates[key]
							var correctOriginalKey = expandedStyles[key]
							if (correctOriginalKey && originalKey !== correctOriginalKey) {
								var warningKey = originalKey + ',' + correctOriginalKey
								if (warnedAbout[warningKey]) {
									continue
								}
								warnedAbout[warningKey] = true
								error(
									"%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
									isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating',
									originalKey,
									correctOriginalKey
								)
							}
						}
					}
				}
				var omittedCloseTags = {
					area: true,
					base: true,
					br: true,
					col: true,
					embed: true,
					hr: true,
					img: true,
					input: true,
					keygen: true,
					link: true,
					meta: true,
					param: true,
					source: true,
					track: true,
					wbr: true,
					// NOTE: menuitem's close tag should be omitted, but that causes problems.
				}
				var voidElementTags = assign(
					{
						menuitem: true,
					},
					omittedCloseTags
				)
				var HTML = '__html'
				function assertValidProps(tag, props) {
					if (!props) {
						return
					}
					if (voidElementTags[tag]) {
						if (props.children != null || props.dangerouslySetInnerHTML != null) {
							throw new Error(
								tag +
									' is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.'
							)
						}
					}
					if (props.dangerouslySetInnerHTML != null) {
						if (props.children != null) {
							throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.')
						}
						if (
							typeof props.dangerouslySetInnerHTML !== 'object' ||
							!(HTML in props.dangerouslySetInnerHTML)
						) {
							throw new Error(
								'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.'
							)
						}
					}
					{
						if (
							!props.suppressContentEditableWarning &&
							props.contentEditable &&
							props.children != null
						) {
							error(
								'A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.'
							)
						}
					}
					if (props.style != null && typeof props.style !== 'object') {
						throw new Error(
							"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
						)
					}
				}
				function isCustomComponent(tagName, props) {
					if (tagName.indexOf('-') === -1) {
						return typeof props.is === 'string'
					}
					switch (tagName) {
						case 'annotation-xml':
						case 'color-profile':
						case 'font-face':
						case 'font-face-src':
						case 'font-face-uri':
						case 'font-face-format':
						case 'font-face-name':
						case 'missing-glyph':
							return false
						default:
							return true
					}
				}
				var possibleStandardNames = {
					// HTML
					accept: 'accept',
					acceptcharset: 'acceptCharset',
					'accept-charset': 'acceptCharset',
					accesskey: 'accessKey',
					action: 'action',
					allowfullscreen: 'allowFullScreen',
					alt: 'alt',
					as: 'as',
					async: 'async',
					autocapitalize: 'autoCapitalize',
					autocomplete: 'autoComplete',
					autocorrect: 'autoCorrect',
					autofocus: 'autoFocus',
					autoplay: 'autoPlay',
					autosave: 'autoSave',
					capture: 'capture',
					cellpadding: 'cellPadding',
					cellspacing: 'cellSpacing',
					challenge: 'challenge',
					charset: 'charSet',
					checked: 'checked',
					children: 'children',
					cite: 'cite',
					class: 'className',
					classid: 'classID',
					classname: 'className',
					cols: 'cols',
					colspan: 'colSpan',
					content: 'content',
					contenteditable: 'contentEditable',
					contextmenu: 'contextMenu',
					controls: 'controls',
					controlslist: 'controlsList',
					coords: 'coords',
					crossorigin: 'crossOrigin',
					dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
					data: 'data',
					datetime: 'dateTime',
					default: 'default',
					defaultchecked: 'defaultChecked',
					defaultvalue: 'defaultValue',
					defer: 'defer',
					dir: 'dir',
					disabled: 'disabled',
					disablepictureinpicture: 'disablePictureInPicture',
					disableremoteplayback: 'disableRemotePlayback',
					download: 'download',
					draggable: 'draggable',
					enctype: 'encType',
					enterkeyhint: 'enterKeyHint',
					for: 'htmlFor',
					form: 'form',
					formmethod: 'formMethod',
					formaction: 'formAction',
					formenctype: 'formEncType',
					formnovalidate: 'formNoValidate',
					formtarget: 'formTarget',
					frameborder: 'frameBorder',
					headers: 'headers',
					height: 'height',
					hidden: 'hidden',
					high: 'high',
					href: 'href',
					hreflang: 'hrefLang',
					htmlfor: 'htmlFor',
					httpequiv: 'httpEquiv',
					'http-equiv': 'httpEquiv',
					icon: 'icon',
					id: 'id',
					imagesizes: 'imageSizes',
					imagesrcset: 'imageSrcSet',
					innerhtml: 'innerHTML',
					inputmode: 'inputMode',
					integrity: 'integrity',
					is: 'is',
					itemid: 'itemID',
					itemprop: 'itemProp',
					itemref: 'itemRef',
					itemscope: 'itemScope',
					itemtype: 'itemType',
					keyparams: 'keyParams',
					keytype: 'keyType',
					kind: 'kind',
					label: 'label',
					lang: 'lang',
					list: 'list',
					loop: 'loop',
					low: 'low',
					manifest: 'manifest',
					marginwidth: 'marginWidth',
					marginheight: 'marginHeight',
					max: 'max',
					maxlength: 'maxLength',
					media: 'media',
					mediagroup: 'mediaGroup',
					method: 'method',
					min: 'min',
					minlength: 'minLength',
					multiple: 'multiple',
					muted: 'muted',
					name: 'name',
					nomodule: 'noModule',
					nonce: 'nonce',
					novalidate: 'noValidate',
					open: 'open',
					optimum: 'optimum',
					pattern: 'pattern',
					placeholder: 'placeholder',
					playsinline: 'playsInline',
					poster: 'poster',
					preload: 'preload',
					profile: 'profile',
					radiogroup: 'radioGroup',
					readonly: 'readOnly',
					referrerpolicy: 'referrerPolicy',
					rel: 'rel',
					required: 'required',
					reversed: 'reversed',
					role: 'role',
					rows: 'rows',
					rowspan: 'rowSpan',
					sandbox: 'sandbox',
					scope: 'scope',
					scoped: 'scoped',
					scrolling: 'scrolling',
					seamless: 'seamless',
					selected: 'selected',
					shape: 'shape',
					size: 'size',
					sizes: 'sizes',
					span: 'span',
					spellcheck: 'spellCheck',
					src: 'src',
					srcdoc: 'srcDoc',
					srclang: 'srcLang',
					srcset: 'srcSet',
					start: 'start',
					step: 'step',
					style: 'style',
					summary: 'summary',
					tabindex: 'tabIndex',
					target: 'target',
					title: 'title',
					type: 'type',
					usemap: 'useMap',
					value: 'value',
					width: 'width',
					wmode: 'wmode',
					wrap: 'wrap',
					// SVG
					about: 'about',
					accentheight: 'accentHeight',
					'accent-height': 'accentHeight',
					accumulate: 'accumulate',
					additive: 'additive',
					alignmentbaseline: 'alignmentBaseline',
					'alignment-baseline': 'alignmentBaseline',
					allowreorder: 'allowReorder',
					alphabetic: 'alphabetic',
					amplitude: 'amplitude',
					arabicform: 'arabicForm',
					'arabic-form': 'arabicForm',
					ascent: 'ascent',
					attributename: 'attributeName',
					attributetype: 'attributeType',
					autoreverse: 'autoReverse',
					azimuth: 'azimuth',
					basefrequency: 'baseFrequency',
					baselineshift: 'baselineShift',
					'baseline-shift': 'baselineShift',
					baseprofile: 'baseProfile',
					bbox: 'bbox',
					begin: 'begin',
					bias: 'bias',
					by: 'by',
					calcmode: 'calcMode',
					capheight: 'capHeight',
					'cap-height': 'capHeight',
					clip: 'clip',
					clippath: 'clipPath',
					'clip-path': 'clipPath',
					clippathunits: 'clipPathUnits',
					cliprule: 'clipRule',
					'clip-rule': 'clipRule',
					color: 'color',
					colorinterpolation: 'colorInterpolation',
					'color-interpolation': 'colorInterpolation',
					colorinterpolationfilters: 'colorInterpolationFilters',
					'color-interpolation-filters': 'colorInterpolationFilters',
					colorprofile: 'colorProfile',
					'color-profile': 'colorProfile',
					colorrendering: 'colorRendering',
					'color-rendering': 'colorRendering',
					contentscripttype: 'contentScriptType',
					contentstyletype: 'contentStyleType',
					cursor: 'cursor',
					cx: 'cx',
					cy: 'cy',
					d: 'd',
					datatype: 'datatype',
					decelerate: 'decelerate',
					descent: 'descent',
					diffuseconstant: 'diffuseConstant',
					direction: 'direction',
					display: 'display',
					divisor: 'divisor',
					dominantbaseline: 'dominantBaseline',
					'dominant-baseline': 'dominantBaseline',
					dur: 'dur',
					dx: 'dx',
					dy: 'dy',
					edgemode: 'edgeMode',
					elevation: 'elevation',
					enablebackground: 'enableBackground',
					'enable-background': 'enableBackground',
					end: 'end',
					exponent: 'exponent',
					externalresourcesrequired: 'externalResourcesRequired',
					fill: 'fill',
					fillopacity: 'fillOpacity',
					'fill-opacity': 'fillOpacity',
					fillrule: 'fillRule',
					'fill-rule': 'fillRule',
					filter: 'filter',
					filterres: 'filterRes',
					filterunits: 'filterUnits',
					floodopacity: 'floodOpacity',
					'flood-opacity': 'floodOpacity',
					floodcolor: 'floodColor',
					'flood-color': 'floodColor',
					focusable: 'focusable',
					fontfamily: 'fontFamily',
					'font-family': 'fontFamily',
					fontsize: 'fontSize',
					'font-size': 'fontSize',
					fontsizeadjust: 'fontSizeAdjust',
					'font-size-adjust': 'fontSizeAdjust',
					fontstretch: 'fontStretch',
					'font-stretch': 'fontStretch',
					fontstyle: 'fontStyle',
					'font-style': 'fontStyle',
					fontvariant: 'fontVariant',
					'font-variant': 'fontVariant',
					fontweight: 'fontWeight',
					'font-weight': 'fontWeight',
					format: 'format',
					from: 'from',
					fx: 'fx',
					fy: 'fy',
					g1: 'g1',
					g2: 'g2',
					glyphname: 'glyphName',
					'glyph-name': 'glyphName',
					glyphorientationhorizontal: 'glyphOrientationHorizontal',
					'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
					glyphorientationvertical: 'glyphOrientationVertical',
					'glyph-orientation-vertical': 'glyphOrientationVertical',
					glyphref: 'glyphRef',
					gradienttransform: 'gradientTransform',
					gradientunits: 'gradientUnits',
					hanging: 'hanging',
					horizadvx: 'horizAdvX',
					'horiz-adv-x': 'horizAdvX',
					horizoriginx: 'horizOriginX',
					'horiz-origin-x': 'horizOriginX',
					ideographic: 'ideographic',
					imagerendering: 'imageRendering',
					'image-rendering': 'imageRendering',
					in2: 'in2',
					in: 'in',
					inlist: 'inlist',
					intercept: 'intercept',
					k1: 'k1',
					k2: 'k2',
					k3: 'k3',
					k4: 'k4',
					k: 'k',
					kernelmatrix: 'kernelMatrix',
					kernelunitlength: 'kernelUnitLength',
					kerning: 'kerning',
					keypoints: 'keyPoints',
					keysplines: 'keySplines',
					keytimes: 'keyTimes',
					lengthadjust: 'lengthAdjust',
					letterspacing: 'letterSpacing',
					'letter-spacing': 'letterSpacing',
					lightingcolor: 'lightingColor',
					'lighting-color': 'lightingColor',
					limitingconeangle: 'limitingConeAngle',
					local: 'local',
					markerend: 'markerEnd',
					'marker-end': 'markerEnd',
					markerheight: 'markerHeight',
					markermid: 'markerMid',
					'marker-mid': 'markerMid',
					markerstart: 'markerStart',
					'marker-start': 'markerStart',
					markerunits: 'markerUnits',
					markerwidth: 'markerWidth',
					mask: 'mask',
					maskcontentunits: 'maskContentUnits',
					maskunits: 'maskUnits',
					mathematical: 'mathematical',
					mode: 'mode',
					numoctaves: 'numOctaves',
					offset: 'offset',
					opacity: 'opacity',
					operator: 'operator',
					order: 'order',
					orient: 'orient',
					orientation: 'orientation',
					origin: 'origin',
					overflow: 'overflow',
					overlineposition: 'overlinePosition',
					'overline-position': 'overlinePosition',
					overlinethickness: 'overlineThickness',
					'overline-thickness': 'overlineThickness',
					paintorder: 'paintOrder',
					'paint-order': 'paintOrder',
					panose1: 'panose1',
					'panose-1': 'panose1',
					pathlength: 'pathLength',
					patterncontentunits: 'patternContentUnits',
					patterntransform: 'patternTransform',
					patternunits: 'patternUnits',
					pointerevents: 'pointerEvents',
					'pointer-events': 'pointerEvents',
					points: 'points',
					pointsatx: 'pointsAtX',
					pointsaty: 'pointsAtY',
					pointsatz: 'pointsAtZ',
					prefix: 'prefix',
					preservealpha: 'preserveAlpha',
					preserveaspectratio: 'preserveAspectRatio',
					primitiveunits: 'primitiveUnits',
					property: 'property',
					r: 'r',
					radius: 'radius',
					refx: 'refX',
					refy: 'refY',
					renderingintent: 'renderingIntent',
					'rendering-intent': 'renderingIntent',
					repeatcount: 'repeatCount',
					repeatdur: 'repeatDur',
					requiredextensions: 'requiredExtensions',
					requiredfeatures: 'requiredFeatures',
					resource: 'resource',
					restart: 'restart',
					result: 'result',
					results: 'results',
					rotate: 'rotate',
					rx: 'rx',
					ry: 'ry',
					scale: 'scale',
					security: 'security',
					seed: 'seed',
					shaperendering: 'shapeRendering',
					'shape-rendering': 'shapeRendering',
					slope: 'slope',
					spacing: 'spacing',
					specularconstant: 'specularConstant',
					specularexponent: 'specularExponent',
					speed: 'speed',
					spreadmethod: 'spreadMethod',
					startoffset: 'startOffset',
					stddeviation: 'stdDeviation',
					stemh: 'stemh',
					stemv: 'stemv',
					stitchtiles: 'stitchTiles',
					stopcolor: 'stopColor',
					'stop-color': 'stopColor',
					stopopacity: 'stopOpacity',
					'stop-opacity': 'stopOpacity',
					strikethroughposition: 'strikethroughPosition',
					'strikethrough-position': 'strikethroughPosition',
					strikethroughthickness: 'strikethroughThickness',
					'strikethrough-thickness': 'strikethroughThickness',
					string: 'string',
					stroke: 'stroke',
					strokedasharray: 'strokeDasharray',
					'stroke-dasharray': 'strokeDasharray',
					strokedashoffset: 'strokeDashoffset',
					'stroke-dashoffset': 'strokeDashoffset',
					strokelinecap: 'strokeLinecap',
					'stroke-linecap': 'strokeLinecap',
					strokelinejoin: 'strokeLinejoin',
					'stroke-linejoin': 'strokeLinejoin',
					strokemiterlimit: 'strokeMiterlimit',
					'stroke-miterlimit': 'strokeMiterlimit',
					strokewidth: 'strokeWidth',
					'stroke-width': 'strokeWidth',
					strokeopacity: 'strokeOpacity',
					'stroke-opacity': 'strokeOpacity',
					suppresscontenteditablewarning: 'suppressContentEditableWarning',
					suppresshydrationwarning: 'suppressHydrationWarning',
					surfacescale: 'surfaceScale',
					systemlanguage: 'systemLanguage',
					tablevalues: 'tableValues',
					targetx: 'targetX',
					targety: 'targetY',
					textanchor: 'textAnchor',
					'text-anchor': 'textAnchor',
					textdecoration: 'textDecoration',
					'text-decoration': 'textDecoration',
					textlength: 'textLength',
					textrendering: 'textRendering',
					'text-rendering': 'textRendering',
					to: 'to',
					transform: 'transform',
					typeof: 'typeof',
					u1: 'u1',
					u2: 'u2',
					underlineposition: 'underlinePosition',
					'underline-position': 'underlinePosition',
					underlinethickness: 'underlineThickness',
					'underline-thickness': 'underlineThickness',
					unicode: 'unicode',
					unicodebidi: 'unicodeBidi',
					'unicode-bidi': 'unicodeBidi',
					unicoderange: 'unicodeRange',
					'unicode-range': 'unicodeRange',
					unitsperem: 'unitsPerEm',
					'units-per-em': 'unitsPerEm',
					unselectable: 'unselectable',
					valphabetic: 'vAlphabetic',
					'v-alphabetic': 'vAlphabetic',
					values: 'values',
					vectoreffect: 'vectorEffect',
					'vector-effect': 'vectorEffect',
					version: 'version',
					vertadvy: 'vertAdvY',
					'vert-adv-y': 'vertAdvY',
					vertoriginx: 'vertOriginX',
					'vert-origin-x': 'vertOriginX',
					vertoriginy: 'vertOriginY',
					'vert-origin-y': 'vertOriginY',
					vhanging: 'vHanging',
					'v-hanging': 'vHanging',
					videographic: 'vIdeographic',
					'v-ideographic': 'vIdeographic',
					viewbox: 'viewBox',
					viewtarget: 'viewTarget',
					visibility: 'visibility',
					vmathematical: 'vMathematical',
					'v-mathematical': 'vMathematical',
					vocab: 'vocab',
					widths: 'widths',
					wordspacing: 'wordSpacing',
					'word-spacing': 'wordSpacing',
					writingmode: 'writingMode',
					'writing-mode': 'writingMode',
					x1: 'x1',
					x2: 'x2',
					x: 'x',
					xchannelselector: 'xChannelSelector',
					xheight: 'xHeight',
					'x-height': 'xHeight',
					xlinkactuate: 'xlinkActuate',
					'xlink:actuate': 'xlinkActuate',
					xlinkarcrole: 'xlinkArcrole',
					'xlink:arcrole': 'xlinkArcrole',
					xlinkhref: 'xlinkHref',
					'xlink:href': 'xlinkHref',
					xlinkrole: 'xlinkRole',
					'xlink:role': 'xlinkRole',
					xlinkshow: 'xlinkShow',
					'xlink:show': 'xlinkShow',
					xlinktitle: 'xlinkTitle',
					'xlink:title': 'xlinkTitle',
					xlinktype: 'xlinkType',
					'xlink:type': 'xlinkType',
					xmlbase: 'xmlBase',
					'xml:base': 'xmlBase',
					xmllang: 'xmlLang',
					'xml:lang': 'xmlLang',
					xmlns: 'xmlns',
					'xml:space': 'xmlSpace',
					xmlnsxlink: 'xmlnsXlink',
					'xmlns:xlink': 'xmlnsXlink',
					xmlspace: 'xmlSpace',
					y1: 'y1',
					y2: 'y2',
					y: 'y',
					ychannelselector: 'yChannelSelector',
					z: 'z',
					zoomandpan: 'zoomAndPan',
				}
				var ariaProperties = {
					'aria-current': 0,
					// state
					'aria-description': 0,
					'aria-details': 0,
					'aria-disabled': 0,
					// state
					'aria-hidden': 0,
					// state
					'aria-invalid': 0,
					// state
					'aria-keyshortcuts': 0,
					'aria-label': 0,
					'aria-roledescription': 0,
					// Widget Attributes
					'aria-autocomplete': 0,
					'aria-checked': 0,
					'aria-expanded': 0,
					'aria-haspopup': 0,
					'aria-level': 0,
					'aria-modal': 0,
					'aria-multiline': 0,
					'aria-multiselectable': 0,
					'aria-orientation': 0,
					'aria-placeholder': 0,
					'aria-pressed': 0,
					'aria-readonly': 0,
					'aria-required': 0,
					'aria-selected': 0,
					'aria-sort': 0,
					'aria-valuemax': 0,
					'aria-valuemin': 0,
					'aria-valuenow': 0,
					'aria-valuetext': 0,
					// Live Region Attributes
					'aria-atomic': 0,
					'aria-busy': 0,
					'aria-live': 0,
					'aria-relevant': 0,
					// Drag-and-Drop Attributes
					'aria-dropeffect': 0,
					'aria-grabbed': 0,
					// Relationship Attributes
					'aria-activedescendant': 0,
					'aria-colcount': 0,
					'aria-colindex': 0,
					'aria-colspan': 0,
					'aria-controls': 0,
					'aria-describedby': 0,
					'aria-errormessage': 0,
					'aria-flowto': 0,
					'aria-labelledby': 0,
					'aria-owns': 0,
					'aria-posinset': 0,
					'aria-rowcount': 0,
					'aria-rowindex': 0,
					'aria-rowspan': 0,
					'aria-setsize': 0,
				}
				var warnedProperties = {}
				var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$')
				var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$')
				function validateProperty(tagName, name) {
					{
						if (hasOwnProperty2.call(warnedProperties, name) && warnedProperties[name]) {
							return true
						}
						if (rARIACamel.test(name)) {
							var ariaName = 'aria-' + name.slice(4).toLowerCase()
							var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null
							if (correctName == null) {
								error(
									'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',
									name
								)
								warnedProperties[name] = true
								return true
							}
							if (name !== correctName) {
								error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName)
								warnedProperties[name] = true
								return true
							}
						}
						if (rARIA.test(name)) {
							var lowerCasedName = name.toLowerCase()
							var standardName = ariaProperties.hasOwnProperty(lowerCasedName)
								? lowerCasedName
								: null
							if (standardName == null) {
								warnedProperties[name] = true
								return false
							}
							if (name !== standardName) {
								error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName)
								warnedProperties[name] = true
								return true
							}
						}
					}
					return true
				}
				function warnInvalidARIAProps(type, props) {
					{
						var invalidProps = []
						for (var key in props) {
							var isValid = validateProperty(type, key)
							if (!isValid) {
								invalidProps.push(key)
							}
						}
						var unknownPropString = invalidProps
							.map(function (prop) {
								return '`' + prop + '`'
							})
							.join(', ')
						if (invalidProps.length === 1) {
							error(
								'Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
								unknownPropString,
								type
							)
						} else if (invalidProps.length > 1) {
							error(
								'Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
								unknownPropString,
								type
							)
						}
					}
				}
				function validateProperties(type, props) {
					if (isCustomComponent(type, props)) {
						return
					}
					warnInvalidARIAProps(type, props)
				}
				var didWarnValueNull = false
				function validateProperties$1(type, props) {
					{
						if (type !== 'input' && type !== 'textarea' && type !== 'select') {
							return
						}
						if (props != null && props.value === null && !didWarnValueNull) {
							didWarnValueNull = true
							if (type === 'select' && props.multiple) {
								error(
									'`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.',
									type
								)
							} else {
								error(
									'`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.',
									type
								)
							}
						}
					}
				}
				var validateProperty$1 = function () {}
				{
					var warnedProperties$1 = {}
					var EVENT_NAME_REGEX = /^on./
					var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/
					var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$')
					var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$')
					validateProperty$1 = function (tagName, name, value, eventRegistry) {
						if (hasOwnProperty2.call(warnedProperties$1, name) && warnedProperties$1[name]) {
							return true
						}
						var lowerCasedName = name.toLowerCase()
						if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
							error(
								'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.'
							)
							warnedProperties$1[name] = true
							return true
						}
						if (eventRegistry != null) {
							var registrationNameDependencies2 = eventRegistry.registrationNameDependencies,
								possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames
							if (registrationNameDependencies2.hasOwnProperty(name)) {
								return true
							}
							var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName)
								? possibleRegistrationNames2[lowerCasedName]
								: null
							if (registrationName != null) {
								error(
									'Invalid event handler property `%s`. Did you mean `%s`?',
									name,
									registrationName
								)
								warnedProperties$1[name] = true
								return true
							}
							if (EVENT_NAME_REGEX.test(name)) {
								error('Unknown event handler property `%s`. It will be ignored.', name)
								warnedProperties$1[name] = true
								return true
							}
						} else if (EVENT_NAME_REGEX.test(name)) {
							if (INVALID_EVENT_NAME_REGEX.test(name)) {
								error(
									'Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.',
									name
								)
							}
							warnedProperties$1[name] = true
							return true
						}
						if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
							return true
						}
						if (lowerCasedName === 'innerhtml') {
							error(
								'Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.'
							)
							warnedProperties$1[name] = true
							return true
						}
						if (lowerCasedName === 'aria') {
							error(
								'The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.'
							)
							warnedProperties$1[name] = true
							return true
						}
						if (
							lowerCasedName === 'is' &&
							value !== null &&
							value !== void 0 &&
							typeof value !== 'string'
						) {
							error(
								'Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.',
								typeof value
							)
							warnedProperties$1[name] = true
							return true
						}
						if (typeof value === 'number' && isNaN(value)) {
							error(
								'Received NaN for the `%s` attribute. If this is expected, cast the value to a string.',
								name
							)
							warnedProperties$1[name] = true
							return true
						}
						var propertyInfo = getPropertyInfo(name)
						var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED
						if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
							var standardName = possibleStandardNames[lowerCasedName]
							if (standardName !== name) {
								error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName)
								warnedProperties$1[name] = true
								return true
							}
						} else if (!isReserved && name !== lowerCasedName) {
							error(
								'React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.',
								name,
								lowerCasedName
							)
							warnedProperties$1[name] = true
							return true
						}
						if (
							typeof value === 'boolean' &&
							shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)
						) {
							if (value) {
								error(
									'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
									value,
									name,
									name,
									value,
									name
								)
							} else {
								error(
									'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
									value,
									name,
									name,
									value,
									name,
									name,
									name
								)
							}
							warnedProperties$1[name] = true
							return true
						}
						if (isReserved) {
							return true
						}
						if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
							warnedProperties$1[name] = true
							return false
						}
						if (
							(value === 'false' || value === 'true') &&
							propertyInfo !== null &&
							propertyInfo.type === BOOLEAN
						) {
							error(
								'Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?',
								value,
								name,
								value === 'false'
									? 'The browser will interpret it as a truthy value.'
									: 'Although this works, it will not work as expected if you pass the string "false".',
								name,
								value
							)
							warnedProperties$1[name] = true
							return true
						}
						return true
					}
				}
				var warnUnknownProperties = function (type, props, eventRegistry) {
					{
						var unknownProps = []
						for (var key in props) {
							var isValid = validateProperty$1(type, key, props[key], eventRegistry)
							if (!isValid) {
								unknownProps.push(key)
							}
						}
						var unknownPropString = unknownProps
							.map(function (prop) {
								return '`' + prop + '`'
							})
							.join(', ')
						if (unknownProps.length === 1) {
							error(
								'Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
								unknownPropString,
								type
							)
						} else if (unknownProps.length > 1) {
							error(
								'Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
								unknownPropString,
								type
							)
						}
					}
				}
				function validateProperties$2(type, props, eventRegistry) {
					if (isCustomComponent(type, props)) {
						return
					}
					warnUnknownProperties(type, props, eventRegistry)
				}
				var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1
				var IS_NON_DELEGATED = 1 << 1
				var IS_CAPTURE_PHASE = 1 << 2
				var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS =
					IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE
				var currentReplayingEvent = null
				function setReplayingEvent(event) {
					{
						if (currentReplayingEvent !== null) {
							error(
								'Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
					}
					currentReplayingEvent = event
				}
				function resetReplayingEvent() {
					{
						if (currentReplayingEvent === null) {
							error(
								'Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
					}
					currentReplayingEvent = null
				}
				function isReplayingEvent(event) {
					return event === currentReplayingEvent
				}
				function getEventTarget(nativeEvent) {
					var target = nativeEvent.target || nativeEvent.srcElement || window
					if (target.correspondingUseElement) {
						target = target.correspondingUseElement
					}
					return target.nodeType === TEXT_NODE ? target.parentNode : target
				}
				var restoreImpl = null
				var restoreTarget = null
				var restoreQueue = null
				function restoreStateOfTarget(target) {
					var internalInstance = getInstanceFromNode(target)
					if (!internalInstance) {
						return
					}
					if (typeof restoreImpl !== 'function') {
						throw new Error(
							'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.'
						)
					}
					var stateNode = internalInstance.stateNode
					if (stateNode) {
						var _props = getFiberCurrentPropsFromNode(stateNode)
						restoreImpl(internalInstance.stateNode, internalInstance.type, _props)
					}
				}
				function setRestoreImplementation(impl) {
					restoreImpl = impl
				}
				function enqueueStateRestore(target) {
					if (restoreTarget) {
						if (restoreQueue) {
							restoreQueue.push(target)
						} else {
							restoreQueue = [target]
						}
					} else {
						restoreTarget = target
					}
				}
				function needsStateRestore() {
					return restoreTarget !== null || restoreQueue !== null
				}
				function restoreStateIfNeeded() {
					if (!restoreTarget) {
						return
					}
					var target = restoreTarget
					var queuedTargets = restoreQueue
					restoreTarget = null
					restoreQueue = null
					restoreStateOfTarget(target)
					if (queuedTargets) {
						for (var i3 = 0; i3 < queuedTargets.length; i3++) {
							restoreStateOfTarget(queuedTargets[i3])
						}
					}
				}
				var batchedUpdatesImpl = function (fn, bookkeeping) {
					return fn(bookkeeping)
				}
				var flushSyncImpl = function () {}
				var isInsideEventHandler = false
				function finishEventHandler() {
					var controlledComponentsHavePendingUpdates = needsStateRestore()
					if (controlledComponentsHavePendingUpdates) {
						flushSyncImpl()
						restoreStateIfNeeded()
					}
				}
				function batchedUpdates(fn, a3, b3) {
					if (isInsideEventHandler) {
						return fn(a3, b3)
					}
					isInsideEventHandler = true
					try {
						return batchedUpdatesImpl(fn, a3, b3)
					} finally {
						isInsideEventHandler = false
						finishEventHandler()
					}
				}
				function setBatchingImplementation(
					_batchedUpdatesImpl,
					_discreteUpdatesImpl,
					_flushSyncImpl
				) {
					batchedUpdatesImpl = _batchedUpdatesImpl
					flushSyncImpl = _flushSyncImpl
				}
				function isInteractive(tag) {
					return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea'
				}
				function shouldPreventMouseEvent(name, type, props) {
					switch (name) {
						case 'onClick':
						case 'onClickCapture':
						case 'onDoubleClick':
						case 'onDoubleClickCapture':
						case 'onMouseDown':
						case 'onMouseDownCapture':
						case 'onMouseMove':
						case 'onMouseMoveCapture':
						case 'onMouseUp':
						case 'onMouseUpCapture':
						case 'onMouseEnter':
							return !!(props.disabled && isInteractive(type))
						default:
							return false
					}
				}
				function getListener(inst, registrationName) {
					var stateNode = inst.stateNode
					if (stateNode === null) {
						return null
					}
					var props = getFiberCurrentPropsFromNode(stateNode)
					if (props === null) {
						return null
					}
					var listener = props[registrationName]
					if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
						return null
					}
					if (listener && typeof listener !== 'function') {
						throw new Error(
							'Expected `' +
								registrationName +
								'` listener to be a function, instead got a value of `' +
								typeof listener +
								'` type.'
						)
					}
					return listener
				}
				var passiveBrowserEventsSupported = false
				if (canUseDOM) {
					try {
						var options = {}
						Object.defineProperty(options, 'passive', {
							get: function () {
								passiveBrowserEventsSupported = true
							},
						})
						window.addEventListener('test', options, options)
						window.removeEventListener('test', options, options)
					} catch (e2) {
						passiveBrowserEventsSupported = false
					}
				}
				function invokeGuardedCallbackProd(name, func, context, a3, b3, c3, d3, e2, f3) {
					var funcArgs = Array.prototype.slice.call(arguments, 3)
					try {
						func.apply(context, funcArgs)
					} catch (error2) {
						this.onError(error2)
					}
				}
				var invokeGuardedCallbackImpl = invokeGuardedCallbackProd
				{
					if (
						typeof window !== 'undefined' &&
						typeof window.dispatchEvent === 'function' &&
						typeof document !== 'undefined' &&
						typeof document.createEvent === 'function'
					) {
						var fakeNode = document.createElement('react')
						invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(
							name,
							func,
							context,
							a3,
							b3,
							c3,
							d3,
							e2,
							f3
						) {
							if (typeof document === 'undefined' || document === null) {
								throw new Error(
									'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.'
								)
							}
							var evt = document.createEvent('Event')
							var didCall = false
							var didError = true
							var windowEvent = window.event
							var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event')
							function restoreAfterDispatch() {
								fakeNode.removeEventListener(evtType, callCallback2, false)
								if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
									window.event = windowEvent
								}
							}
							var funcArgs = Array.prototype.slice.call(arguments, 3)
							function callCallback2() {
								didCall = true
								restoreAfterDispatch()
								func.apply(context, funcArgs)
								didError = false
							}
							var error2
							var didSetError = false
							var isCrossOriginError = false
							function handleWindowError(event) {
								error2 = event.error
								didSetError = true
								if (error2 === null && event.colno === 0 && event.lineno === 0) {
									isCrossOriginError = true
								}
								if (event.defaultPrevented) {
									if (error2 != null && typeof error2 === 'object') {
										try {
											error2._suppressLogging = true
										} catch (inner) {}
									}
								}
							}
							var evtType = 'react-' + (name ? name : 'invokeguardedcallback')
							window.addEventListener('error', handleWindowError)
							fakeNode.addEventListener(evtType, callCallback2, false)
							evt.initEvent(evtType, false, false)
							fakeNode.dispatchEvent(evt)
							if (windowEventDescriptor) {
								Object.defineProperty(window, 'event', windowEventDescriptor)
							}
							if (didCall && didError) {
								if (!didSetError) {
									error2 = new Error(
										`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`
									)
								} else if (isCrossOriginError) {
									error2 = new Error(
										"A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information."
									)
								}
								this.onError(error2)
							}
							window.removeEventListener('error', handleWindowError)
							if (!didCall) {
								restoreAfterDispatch()
								return invokeGuardedCallbackProd.apply(this, arguments)
							}
						}
					}
				}
				var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl
				var hasError = false
				var caughtError = null
				var hasRethrowError = false
				var rethrowError = null
				var reporter = {
					onError: function (error2) {
						hasError = true
						caughtError = error2
					},
				}
				function invokeGuardedCallback(name, func, context, a3, b3, c3, d3, e2, f3) {
					hasError = false
					caughtError = null
					invokeGuardedCallbackImpl$1.apply(reporter, arguments)
				}
				function invokeGuardedCallbackAndCatchFirstError(
					name,
					func,
					context,
					a3,
					b3,
					c3,
					d3,
					e2,
					f3
				) {
					invokeGuardedCallback.apply(this, arguments)
					if (hasError) {
						var error2 = clearCaughtError()
						if (!hasRethrowError) {
							hasRethrowError = true
							rethrowError = error2
						}
					}
				}
				function rethrowCaughtError() {
					if (hasRethrowError) {
						var error2 = rethrowError
						hasRethrowError = false
						rethrowError = null
						throw error2
					}
				}
				function hasCaughtError() {
					return hasError
				}
				function clearCaughtError() {
					if (hasError) {
						var error2 = caughtError
						hasError = false
						caughtError = null
						return error2
					} else {
						throw new Error(
							'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.'
						)
					}
				}
				function get(key) {
					return key._reactInternals
				}
				function has(key) {
					return key._reactInternals !== void 0
				}
				function set(key, value) {
					key._reactInternals = value
				}
				var NoFlags =
					/*                      */
					0
				var PerformedWork =
					/*                */
					1
				var Placement =
					/*                    */
					2
				var Update =
					/*                       */
					4
				var ChildDeletion =
					/*                */
					16
				var ContentReset =
					/*                 */
					32
				var Callback =
					/*                     */
					64
				var DidCapture =
					/*                   */
					128
				var ForceClientRender =
					/*            */
					256
				var Ref =
					/*                          */
					512
				var Snapshot =
					/*                     */
					1024
				var Passive =
					/*                      */
					2048
				var Hydrating =
					/*                    */
					4096
				var Visibility =
					/*                   */
					8192
				var StoreConsistency =
					/*             */
					16384
				var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency
				var HostEffectMask =
					/*               */
					32767
				var Incomplete =
					/*                   */
					32768
				var ShouldCapture =
					/*                */
					65536
				var ForceUpdateForLegacySuspense =
					/* */
					131072
				var Forked =
					/*                       */
					1048576
				var RefStatic =
					/*                    */
					2097152
				var LayoutStatic =
					/*                 */
					4194304
				var PassiveStatic =
					/*                */
					8388608
				var MountLayoutDev =
					/*               */
					16777216
				var MountPassiveDev =
					/*              */
					33554432
				var BeforeMutationMask =
					// TODO: Remove Update flag from before mutation phase by re-landing Visibility
					// flag logic (see #20043)
					Update | Snapshot | 0
				var MutationMask =
					Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility
				var LayoutMask = Update | Callback | Ref | Visibility
				var PassiveMask = Passive | ChildDeletion
				var StaticMask = LayoutStatic | PassiveStatic | RefStatic
				var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner
				function getNearestMountedFiber(fiber) {
					var node = fiber
					var nearestMounted = fiber
					if (!fiber.alternate) {
						var nextNode = node
						do {
							node = nextNode
							if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
								nearestMounted = node.return
							}
							nextNode = node.return
						} while (nextNode)
					} else {
						while (node.return) {
							node = node.return
						}
					}
					if (node.tag === HostRoot) {
						return nearestMounted
					}
					return null
				}
				function getSuspenseInstanceFromFiber(fiber) {
					if (fiber.tag === SuspenseComponent) {
						var suspenseState = fiber.memoizedState
						if (suspenseState === null) {
							var current2 = fiber.alternate
							if (current2 !== null) {
								suspenseState = current2.memoizedState
							}
						}
						if (suspenseState !== null) {
							return suspenseState.dehydrated
						}
					}
					return null
				}
				function getContainerFromFiber(fiber) {
					return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null
				}
				function isFiberMounted(fiber) {
					return getNearestMountedFiber(fiber) === fiber
				}
				function isMounted(component) {
					{
						var owner = ReactCurrentOwner.current
						if (owner !== null && owner.tag === ClassComponent) {
							var ownerFiber = owner
							var instance = ownerFiber.stateNode
							if (!instance._warnedAboutRefsInRender) {
								error(
									'%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.',
									getComponentNameFromFiber(ownerFiber) || 'A component'
								)
							}
							instance._warnedAboutRefsInRender = true
						}
					}
					var fiber = get(component)
					if (!fiber) {
						return false
					}
					return getNearestMountedFiber(fiber) === fiber
				}
				function assertIsMounted(fiber) {
					if (getNearestMountedFiber(fiber) !== fiber) {
						throw new Error('Unable to find node on an unmounted component.')
					}
				}
				function findCurrentFiberUsingSlowPath(fiber) {
					var alternate = fiber.alternate
					if (!alternate) {
						var nearestMounted = getNearestMountedFiber(fiber)
						if (nearestMounted === null) {
							throw new Error('Unable to find node on an unmounted component.')
						}
						if (nearestMounted !== fiber) {
							return null
						}
						return fiber
					}
					var a3 = fiber
					var b3 = alternate
					while (true) {
						var parentA = a3.return
						if (parentA === null) {
							break
						}
						var parentB = parentA.alternate
						if (parentB === null) {
							var nextParent = parentA.return
							if (nextParent !== null) {
								a3 = b3 = nextParent
								continue
							}
							break
						}
						if (parentA.child === parentB.child) {
							var child = parentA.child
							while (child) {
								if (child === a3) {
									assertIsMounted(parentA)
									return fiber
								}
								if (child === b3) {
									assertIsMounted(parentA)
									return alternate
								}
								child = child.sibling
							}
							throw new Error('Unable to find node on an unmounted component.')
						}
						if (a3.return !== b3.return) {
							a3 = parentA
							b3 = parentB
						} else {
							var didFindChild = false
							var _child = parentA.child
							while (_child) {
								if (_child === a3) {
									didFindChild = true
									a3 = parentA
									b3 = parentB
									break
								}
								if (_child === b3) {
									didFindChild = true
									b3 = parentA
									a3 = parentB
									break
								}
								_child = _child.sibling
							}
							if (!didFindChild) {
								_child = parentB.child
								while (_child) {
									if (_child === a3) {
										didFindChild = true
										a3 = parentB
										b3 = parentA
										break
									}
									if (_child === b3) {
										didFindChild = true
										b3 = parentB
										a3 = parentA
										break
									}
									_child = _child.sibling
								}
								if (!didFindChild) {
									throw new Error(
										'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'
									)
								}
							}
						}
						if (a3.alternate !== b3) {
							throw new Error(
								"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
							)
						}
					}
					if (a3.tag !== HostRoot) {
						throw new Error('Unable to find node on an unmounted component.')
					}
					if (a3.stateNode.current === a3) {
						return fiber
					}
					return alternate
				}
				function findCurrentHostFiber(parent) {
					var currentParent = findCurrentFiberUsingSlowPath(parent)
					return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null
				}
				function findCurrentHostFiberImpl(node) {
					if (node.tag === HostComponent || node.tag === HostText) {
						return node
					}
					var child = node.child
					while (child !== null) {
						var match = findCurrentHostFiberImpl(child)
						if (match !== null) {
							return match
						}
						child = child.sibling
					}
					return null
				}
				function findCurrentHostFiberWithNoPortals(parent) {
					var currentParent = findCurrentFiberUsingSlowPath(parent)
					return currentParent !== null
						? findCurrentHostFiberWithNoPortalsImpl(currentParent)
						: null
				}
				function findCurrentHostFiberWithNoPortalsImpl(node) {
					if (node.tag === HostComponent || node.tag === HostText) {
						return node
					}
					var child = node.child
					while (child !== null) {
						if (child.tag !== HostPortal) {
							var match = findCurrentHostFiberWithNoPortalsImpl(child)
							if (match !== null) {
								return match
							}
						}
						child = child.sibling
					}
					return null
				}
				var scheduleCallback = Scheduler.unstable_scheduleCallback
				var cancelCallback = Scheduler.unstable_cancelCallback
				var shouldYield = Scheduler.unstable_shouldYield
				var requestPaint = Scheduler.unstable_requestPaint
				var now = Scheduler.unstable_now
				var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel
				var ImmediatePriority = Scheduler.unstable_ImmediatePriority
				var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority
				var NormalPriority = Scheduler.unstable_NormalPriority
				var LowPriority = Scheduler.unstable_LowPriority
				var IdlePriority = Scheduler.unstable_IdlePriority
				var unstable_yieldValue = Scheduler.unstable_yieldValue
				var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue
				var rendererID = null
				var injectedHook = null
				var injectedProfilingHooks = null
				var hasLoggedError = false
				var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined'
				function injectInternals(internals) {
					if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
						return false
					}
					var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__
					if (hook.isDisabled) {
						return true
					}
					if (!hook.supportsFiber) {
						{
							error(
								'The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools'
							)
						}
						return true
					}
					try {
						if (enableSchedulingProfiler) {
							internals = assign({}, internals, {
								getLaneLabelMap,
								injectProfilingHooks,
							})
						}
						rendererID = hook.inject(internals)
						injectedHook = hook
					} catch (err) {
						{
							error('React instrumentation encountered an error: %s.', err)
						}
					}
					if (hook.checkDCE) {
						return true
					} else {
						return false
					}
				}
				function onScheduleRoot(root3, children) {
					{
						if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {
							try {
								injectedHook.onScheduleFiberRoot(rendererID, root3, children)
							} catch (err) {
								if (!hasLoggedError) {
									hasLoggedError = true
									error('React instrumentation encountered an error: %s', err)
								}
							}
						}
					}
				}
				function onCommitRoot(root3, eventPriority) {
					if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {
						try {
							var didError = (root3.current.flags & DidCapture) === DidCapture
							if (enableProfilerTimer) {
								var schedulerPriority
								switch (eventPriority) {
									case DiscreteEventPriority:
										schedulerPriority = ImmediatePriority
										break
									case ContinuousEventPriority:
										schedulerPriority = UserBlockingPriority
										break
									case DefaultEventPriority:
										schedulerPriority = NormalPriority
										break
									case IdleEventPriority:
										schedulerPriority = IdlePriority
										break
									default:
										schedulerPriority = NormalPriority
										break
								}
								injectedHook.onCommitFiberRoot(rendererID, root3, schedulerPriority, didError)
							} else {
								injectedHook.onCommitFiberRoot(rendererID, root3, void 0, didError)
							}
						} catch (err) {
							{
								if (!hasLoggedError) {
									hasLoggedError = true
									error('React instrumentation encountered an error: %s', err)
								}
							}
						}
					}
				}
				function onPostCommitRoot(root3) {
					if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {
						try {
							injectedHook.onPostCommitFiberRoot(rendererID, root3)
						} catch (err) {
							{
								if (!hasLoggedError) {
									hasLoggedError = true
									error('React instrumentation encountered an error: %s', err)
								}
							}
						}
					}
				}
				function onCommitUnmount(fiber) {
					if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {
						try {
							injectedHook.onCommitFiberUnmount(rendererID, fiber)
						} catch (err) {
							{
								if (!hasLoggedError) {
									hasLoggedError = true
									error('React instrumentation encountered an error: %s', err)
								}
							}
						}
					}
				}
				function setIsStrictModeForDevtools(newIsStrictMode) {
					{
						if (typeof unstable_yieldValue === 'function') {
							unstable_setDisableYieldValue(newIsStrictMode)
							setSuppressWarning(newIsStrictMode)
						}
						if (injectedHook && typeof injectedHook.setStrictMode === 'function') {
							try {
								injectedHook.setStrictMode(rendererID, newIsStrictMode)
							} catch (err) {
								{
									if (!hasLoggedError) {
										hasLoggedError = true
										error('React instrumentation encountered an error: %s', err)
									}
								}
							}
						}
					}
				}
				function injectProfilingHooks(profilingHooks) {
					injectedProfilingHooks = profilingHooks
				}
				function getLaneLabelMap() {
					{
						var map = /* @__PURE__ */ new Map()
						var lane = 1
						for (var index3 = 0; index3 < TotalLanes; index3++) {
							var label = getLabelForLane(lane)
							map.set(lane, label)
							lane *= 2
						}
						return map
					}
				}
				function markCommitStarted(lanes) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markCommitStarted === 'function'
						) {
							injectedProfilingHooks.markCommitStarted(lanes)
						}
					}
				}
				function markCommitStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markCommitStopped === 'function'
						) {
							injectedProfilingHooks.markCommitStopped()
						}
					}
				}
				function markComponentRenderStarted(fiber) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentRenderStarted === 'function'
						) {
							injectedProfilingHooks.markComponentRenderStarted(fiber)
						}
					}
				}
				function markComponentRenderStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentRenderStopped === 'function'
						) {
							injectedProfilingHooks.markComponentRenderStopped()
						}
					}
				}
				function markComponentPassiveEffectMountStarted(fiber) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function'
						) {
							injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber)
						}
					}
				}
				function markComponentPassiveEffectMountStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function'
						) {
							injectedProfilingHooks.markComponentPassiveEffectMountStopped()
						}
					}
				}
				function markComponentPassiveEffectUnmountStarted(fiber) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function'
						) {
							injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber)
						}
					}
				}
				function markComponentPassiveEffectUnmountStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function'
						) {
							injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()
						}
					}
				}
				function markComponentLayoutEffectMountStarted(fiber) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function'
						) {
							injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber)
						}
					}
				}
				function markComponentLayoutEffectMountStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function'
						) {
							injectedProfilingHooks.markComponentLayoutEffectMountStopped()
						}
					}
				}
				function markComponentLayoutEffectUnmountStarted(fiber) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function'
						) {
							injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber)
						}
					}
				}
				function markComponentLayoutEffectUnmountStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function'
						) {
							injectedProfilingHooks.markComponentLayoutEffectUnmountStopped()
						}
					}
				}
				function markComponentErrored(fiber, thrownValue, lanes) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentErrored === 'function'
						) {
							injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes)
						}
					}
				}
				function markComponentSuspended(fiber, wakeable, lanes) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markComponentSuspended === 'function'
						) {
							injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes)
						}
					}
				}
				function markLayoutEffectsStarted(lanes) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function'
						) {
							injectedProfilingHooks.markLayoutEffectsStarted(lanes)
						}
					}
				}
				function markLayoutEffectsStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function'
						) {
							injectedProfilingHooks.markLayoutEffectsStopped()
						}
					}
				}
				function markPassiveEffectsStarted(lanes) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function'
						) {
							injectedProfilingHooks.markPassiveEffectsStarted(lanes)
						}
					}
				}
				function markPassiveEffectsStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function'
						) {
							injectedProfilingHooks.markPassiveEffectsStopped()
						}
					}
				}
				function markRenderStarted(lanes) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markRenderStarted === 'function'
						) {
							injectedProfilingHooks.markRenderStarted(lanes)
						}
					}
				}
				function markRenderYielded() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markRenderYielded === 'function'
						) {
							injectedProfilingHooks.markRenderYielded()
						}
					}
				}
				function markRenderStopped() {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markRenderStopped === 'function'
						) {
							injectedProfilingHooks.markRenderStopped()
						}
					}
				}
				function markRenderScheduled(lane) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markRenderScheduled === 'function'
						) {
							injectedProfilingHooks.markRenderScheduled(lane)
						}
					}
				}
				function markForceUpdateScheduled(fiber, lane) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markForceUpdateScheduled === 'function'
						) {
							injectedProfilingHooks.markForceUpdateScheduled(fiber, lane)
						}
					}
				}
				function markStateUpdateScheduled(fiber, lane) {
					{
						if (
							injectedProfilingHooks !== null &&
							typeof injectedProfilingHooks.markStateUpdateScheduled === 'function'
						) {
							injectedProfilingHooks.markStateUpdateScheduled(fiber, lane)
						}
					}
				}
				var NoMode =
					/*                         */
					0
				var ConcurrentMode =
					/*                 */
					1
				var ProfileMode =
					/*                    */
					2
				var StrictLegacyMode =
					/*               */
					8
				var StrictEffectsMode =
					/*              */
					16
				var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback
				var log = Math.log
				var LN2 = Math.LN2
				function clz32Fallback(x3) {
					var asUint = x3 >>> 0
					if (asUint === 0) {
						return 32
					}
					return (31 - ((log(asUint) / LN2) | 0)) | 0
				}
				var TotalLanes = 31
				var NoLanes =
					/*                        */
					0
				var NoLane =
					/*                          */
					0
				var SyncLane =
					/*                        */
					1
				var InputContinuousHydrationLane =
					/*    */
					2
				var InputContinuousLane =
					/*             */
					4
				var DefaultHydrationLane =
					/*            */
					8
				var DefaultLane =
					/*                     */
					16
				var TransitionHydrationLane =
					/*                */
					32
				var TransitionLanes =
					/*                       */
					4194240
				var TransitionLane1 =
					/*                        */
					64
				var TransitionLane2 =
					/*                        */
					128
				var TransitionLane3 =
					/*                        */
					256
				var TransitionLane4 =
					/*                        */
					512
				var TransitionLane5 =
					/*                        */
					1024
				var TransitionLane6 =
					/*                        */
					2048
				var TransitionLane7 =
					/*                        */
					4096
				var TransitionLane8 =
					/*                        */
					8192
				var TransitionLane9 =
					/*                        */
					16384
				var TransitionLane10 =
					/*                       */
					32768
				var TransitionLane11 =
					/*                       */
					65536
				var TransitionLane12 =
					/*                       */
					131072
				var TransitionLane13 =
					/*                       */
					262144
				var TransitionLane14 =
					/*                       */
					524288
				var TransitionLane15 =
					/*                       */
					1048576
				var TransitionLane16 =
					/*                       */
					2097152
				var RetryLanes =
					/*                            */
					130023424
				var RetryLane1 =
					/*                             */
					4194304
				var RetryLane2 =
					/*                             */
					8388608
				var RetryLane3 =
					/*                             */
					16777216
				var RetryLane4 =
					/*                             */
					33554432
				var RetryLane5 =
					/*                             */
					67108864
				var SomeRetryLane = RetryLane1
				var SelectiveHydrationLane =
					/*          */
					134217728
				var NonIdleLanes =
					/*                          */
					268435455
				var IdleHydrationLane =
					/*               */
					268435456
				var IdleLane =
					/*                        */
					536870912
				var OffscreenLane =
					/*                   */
					1073741824
				function getLabelForLane(lane) {
					{
						if (lane & SyncLane) {
							return 'Sync'
						}
						if (lane & InputContinuousHydrationLane) {
							return 'InputContinuousHydration'
						}
						if (lane & InputContinuousLane) {
							return 'InputContinuous'
						}
						if (lane & DefaultHydrationLane) {
							return 'DefaultHydration'
						}
						if (lane & DefaultLane) {
							return 'Default'
						}
						if (lane & TransitionHydrationLane) {
							return 'TransitionHydration'
						}
						if (lane & TransitionLanes) {
							return 'Transition'
						}
						if (lane & RetryLanes) {
							return 'Retry'
						}
						if (lane & SelectiveHydrationLane) {
							return 'SelectiveHydration'
						}
						if (lane & IdleHydrationLane) {
							return 'IdleHydration'
						}
						if (lane & IdleLane) {
							return 'Idle'
						}
						if (lane & OffscreenLane) {
							return 'Offscreen'
						}
					}
				}
				var NoTimestamp = -1
				var nextTransitionLane = TransitionLane1
				var nextRetryLane = RetryLane1
				function getHighestPriorityLanes(lanes) {
					switch (getHighestPriorityLane(lanes)) {
						case SyncLane:
							return SyncLane
						case InputContinuousHydrationLane:
							return InputContinuousHydrationLane
						case InputContinuousLane:
							return InputContinuousLane
						case DefaultHydrationLane:
							return DefaultHydrationLane
						case DefaultLane:
							return DefaultLane
						case TransitionHydrationLane:
							return TransitionHydrationLane
						case TransitionLane1:
						case TransitionLane2:
						case TransitionLane3:
						case TransitionLane4:
						case TransitionLane5:
						case TransitionLane6:
						case TransitionLane7:
						case TransitionLane8:
						case TransitionLane9:
						case TransitionLane10:
						case TransitionLane11:
						case TransitionLane12:
						case TransitionLane13:
						case TransitionLane14:
						case TransitionLane15:
						case TransitionLane16:
							return lanes & TransitionLanes
						case RetryLane1:
						case RetryLane2:
						case RetryLane3:
						case RetryLane4:
						case RetryLane5:
							return lanes & RetryLanes
						case SelectiveHydrationLane:
							return SelectiveHydrationLane
						case IdleHydrationLane:
							return IdleHydrationLane
						case IdleLane:
							return IdleLane
						case OffscreenLane:
							return OffscreenLane
						default:
							{
								error('Should have found matching lanes. This is a bug in React.')
							}
							return lanes
					}
				}
				function getNextLanes(root3, wipLanes) {
					var pendingLanes = root3.pendingLanes
					if (pendingLanes === NoLanes) {
						return NoLanes
					}
					var nextLanes = NoLanes
					var suspendedLanes = root3.suspendedLanes
					var pingedLanes = root3.pingedLanes
					var nonIdlePendingLanes = pendingLanes & NonIdleLanes
					if (nonIdlePendingLanes !== NoLanes) {
						var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes
						if (nonIdleUnblockedLanes !== NoLanes) {
							nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes)
						} else {
							var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes
							if (nonIdlePingedLanes !== NoLanes) {
								nextLanes = getHighestPriorityLanes(nonIdlePingedLanes)
							}
						}
					} else {
						var unblockedLanes = pendingLanes & ~suspendedLanes
						if (unblockedLanes !== NoLanes) {
							nextLanes = getHighestPriorityLanes(unblockedLanes)
						} else {
							if (pingedLanes !== NoLanes) {
								nextLanes = getHighestPriorityLanes(pingedLanes)
							}
						}
					}
					if (nextLanes === NoLanes) {
						return NoLanes
					}
					if (
						wipLanes !== NoLanes &&
						wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
						// bother waiting until the root is complete.
						(wipLanes & suspendedLanes) === NoLanes
					) {
						var nextLane = getHighestPriorityLane(nextLanes)
						var wipLane = getHighestPriorityLane(wipLanes)
						if (
							// Tests whether the next lane is equal or lower priority than the wip
							// one. This works because the bits decrease in priority as you go left.
							nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
							// only difference between default updates and transition updates is that
							// default updates do not support refresh transitions.
							(nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes)
						) {
							return wipLanes
						}
					}
					if ((nextLanes & InputContinuousLane) !== NoLanes) {
						nextLanes |= pendingLanes & DefaultLane
					}
					var entangledLanes = root3.entangledLanes
					if (entangledLanes !== NoLanes) {
						var entanglements = root3.entanglements
						var lanes = nextLanes & entangledLanes
						while (lanes > 0) {
							var index3 = pickArbitraryLaneIndex(lanes)
							var lane = 1 << index3
							nextLanes |= entanglements[index3]
							lanes &= ~lane
						}
					}
					return nextLanes
				}
				function getMostRecentEventTime(root3, lanes) {
					var eventTimes = root3.eventTimes
					var mostRecentEventTime = NoTimestamp
					while (lanes > 0) {
						var index3 = pickArbitraryLaneIndex(lanes)
						var lane = 1 << index3
						var eventTime = eventTimes[index3]
						if (eventTime > mostRecentEventTime) {
							mostRecentEventTime = eventTime
						}
						lanes &= ~lane
					}
					return mostRecentEventTime
				}
				function computeExpirationTime(lane, currentTime) {
					switch (lane) {
						case SyncLane:
						case InputContinuousHydrationLane:
						case InputContinuousLane:
							return currentTime + 250
						case DefaultHydrationLane:
						case DefaultLane:
						case TransitionHydrationLane:
						case TransitionLane1:
						case TransitionLane2:
						case TransitionLane3:
						case TransitionLane4:
						case TransitionLane5:
						case TransitionLane6:
						case TransitionLane7:
						case TransitionLane8:
						case TransitionLane9:
						case TransitionLane10:
						case TransitionLane11:
						case TransitionLane12:
						case TransitionLane13:
						case TransitionLane14:
						case TransitionLane15:
						case TransitionLane16:
							return currentTime + 5e3
						case RetryLane1:
						case RetryLane2:
						case RetryLane3:
						case RetryLane4:
						case RetryLane5:
							return NoTimestamp
						case SelectiveHydrationLane:
						case IdleHydrationLane:
						case IdleLane:
						case OffscreenLane:
							return NoTimestamp
						default:
							{
								error('Should have found matching lanes. This is a bug in React.')
							}
							return NoTimestamp
					}
				}
				function markStarvedLanesAsExpired(root3, currentTime) {
					var pendingLanes = root3.pendingLanes
					var suspendedLanes = root3.suspendedLanes
					var pingedLanes = root3.pingedLanes
					var expirationTimes = root3.expirationTimes
					var lanes = pendingLanes
					while (lanes > 0) {
						var index3 = pickArbitraryLaneIndex(lanes)
						var lane = 1 << index3
						var expirationTime = expirationTimes[index3]
						if (expirationTime === NoTimestamp) {
							if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
								expirationTimes[index3] = computeExpirationTime(lane, currentTime)
							}
						} else if (expirationTime <= currentTime) {
							root3.expiredLanes |= lane
						}
						lanes &= ~lane
					}
				}
				function getHighestPriorityPendingLanes(root3) {
					return getHighestPriorityLanes(root3.pendingLanes)
				}
				function getLanesToRetrySynchronouslyOnError(root3) {
					var everythingButOffscreen = root3.pendingLanes & ~OffscreenLane
					if (everythingButOffscreen !== NoLanes) {
						return everythingButOffscreen
					}
					if (everythingButOffscreen & OffscreenLane) {
						return OffscreenLane
					}
					return NoLanes
				}
				function includesSyncLane(lanes) {
					return (lanes & SyncLane) !== NoLanes
				}
				function includesNonIdleWork(lanes) {
					return (lanes & NonIdleLanes) !== NoLanes
				}
				function includesOnlyRetries(lanes) {
					return (lanes & RetryLanes) === lanes
				}
				function includesOnlyNonUrgentLanes(lanes) {
					var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane
					return (lanes & UrgentLanes) === NoLanes
				}
				function includesOnlyTransitions(lanes) {
					return (lanes & TransitionLanes) === lanes
				}
				function includesBlockingLane(root3, lanes) {
					var SyncDefaultLanes =
						InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane
					return (lanes & SyncDefaultLanes) !== NoLanes
				}
				function includesExpiredLane(root3, lanes) {
					return (lanes & root3.expiredLanes) !== NoLanes
				}
				function isTransitionLane(lane) {
					return (lane & TransitionLanes) !== NoLanes
				}
				function claimNextTransitionLane() {
					var lane = nextTransitionLane
					nextTransitionLane <<= 1
					if ((nextTransitionLane & TransitionLanes) === NoLanes) {
						nextTransitionLane = TransitionLane1
					}
					return lane
				}
				function claimNextRetryLane() {
					var lane = nextRetryLane
					nextRetryLane <<= 1
					if ((nextRetryLane & RetryLanes) === NoLanes) {
						nextRetryLane = RetryLane1
					}
					return lane
				}
				function getHighestPriorityLane(lanes) {
					return lanes & -lanes
				}
				function pickArbitraryLane(lanes) {
					return getHighestPriorityLane(lanes)
				}
				function pickArbitraryLaneIndex(lanes) {
					return 31 - clz32(lanes)
				}
				function laneToIndex(lane) {
					return pickArbitraryLaneIndex(lane)
				}
				function includesSomeLane(a3, b3) {
					return (a3 & b3) !== NoLanes
				}
				function isSubsetOfLanes(set2, subset) {
					return (set2 & subset) === subset
				}
				function mergeLanes(a3, b3) {
					return a3 | b3
				}
				function removeLanes(set2, subset) {
					return set2 & ~subset
				}
				function intersectLanes(a3, b3) {
					return a3 & b3
				}
				function laneToLanes(lane) {
					return lane
				}
				function higherPriorityLane(a3, b3) {
					return a3 !== NoLane && a3 < b3 ? a3 : b3
				}
				function createLaneMap(initial) {
					var laneMap = []
					for (var i3 = 0; i3 < TotalLanes; i3++) {
						laneMap.push(initial)
					}
					return laneMap
				}
				function markRootUpdated(root3, updateLane, eventTime) {
					root3.pendingLanes |= updateLane
					if (updateLane !== IdleLane) {
						root3.suspendedLanes = NoLanes
						root3.pingedLanes = NoLanes
					}
					var eventTimes = root3.eventTimes
					var index3 = laneToIndex(updateLane)
					eventTimes[index3] = eventTime
				}
				function markRootSuspended(root3, suspendedLanes) {
					root3.suspendedLanes |= suspendedLanes
					root3.pingedLanes &= ~suspendedLanes
					var expirationTimes = root3.expirationTimes
					var lanes = suspendedLanes
					while (lanes > 0) {
						var index3 = pickArbitraryLaneIndex(lanes)
						var lane = 1 << index3
						expirationTimes[index3] = NoTimestamp
						lanes &= ~lane
					}
				}
				function markRootPinged(root3, pingedLanes, eventTime) {
					root3.pingedLanes |= root3.suspendedLanes & pingedLanes
				}
				function markRootFinished(root3, remainingLanes) {
					var noLongerPendingLanes = root3.pendingLanes & ~remainingLanes
					root3.pendingLanes = remainingLanes
					root3.suspendedLanes = NoLanes
					root3.pingedLanes = NoLanes
					root3.expiredLanes &= remainingLanes
					root3.mutableReadLanes &= remainingLanes
					root3.entangledLanes &= remainingLanes
					var entanglements = root3.entanglements
					var eventTimes = root3.eventTimes
					var expirationTimes = root3.expirationTimes
					var lanes = noLongerPendingLanes
					while (lanes > 0) {
						var index3 = pickArbitraryLaneIndex(lanes)
						var lane = 1 << index3
						entanglements[index3] = NoLanes
						eventTimes[index3] = NoTimestamp
						expirationTimes[index3] = NoTimestamp
						lanes &= ~lane
					}
				}
				function markRootEntangled(root3, entangledLanes) {
					var rootEntangledLanes = (root3.entangledLanes |= entangledLanes)
					var entanglements = root3.entanglements
					var lanes = rootEntangledLanes
					while (lanes) {
						var index3 = pickArbitraryLaneIndex(lanes)
						var lane = 1 << index3
						if (
							// Is this one of the newly entangled lanes?
							(lane & entangledLanes) | // Is this lane transitively entangled with the newly entangled lanes?
							(entanglements[index3] & entangledLanes)
						) {
							entanglements[index3] |= entangledLanes
						}
						lanes &= ~lane
					}
				}
				function getBumpedLaneForHydration(root3, renderLanes2) {
					var renderLane = getHighestPriorityLane(renderLanes2)
					var lane
					switch (renderLane) {
						case InputContinuousLane:
							lane = InputContinuousHydrationLane
							break
						case DefaultLane:
							lane = DefaultHydrationLane
							break
						case TransitionLane1:
						case TransitionLane2:
						case TransitionLane3:
						case TransitionLane4:
						case TransitionLane5:
						case TransitionLane6:
						case TransitionLane7:
						case TransitionLane8:
						case TransitionLane9:
						case TransitionLane10:
						case TransitionLane11:
						case TransitionLane12:
						case TransitionLane13:
						case TransitionLane14:
						case TransitionLane15:
						case TransitionLane16:
						case RetryLane1:
						case RetryLane2:
						case RetryLane3:
						case RetryLane4:
						case RetryLane5:
							lane = TransitionHydrationLane
							break
						case IdleLane:
							lane = IdleHydrationLane
							break
						default:
							lane = NoLane
							break
					}
					if ((lane & (root3.suspendedLanes | renderLanes2)) !== NoLane) {
						return NoLane
					}
					return lane
				}
				function addFiberToLanesMap(root3, fiber, lanes) {
					if (!isDevToolsPresent) {
						return
					}
					var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap
					while (lanes > 0) {
						var index3 = laneToIndex(lanes)
						var lane = 1 << index3
						var updaters = pendingUpdatersLaneMap[index3]
						updaters.add(fiber)
						lanes &= ~lane
					}
				}
				function movePendingFibersToMemoized(root3, lanes) {
					if (!isDevToolsPresent) {
						return
					}
					var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap
					var memoizedUpdaters = root3.memoizedUpdaters
					while (lanes > 0) {
						var index3 = laneToIndex(lanes)
						var lane = 1 << index3
						var updaters = pendingUpdatersLaneMap[index3]
						if (updaters.size > 0) {
							updaters.forEach(function (fiber) {
								var alternate = fiber.alternate
								if (alternate === null || !memoizedUpdaters.has(alternate)) {
									memoizedUpdaters.add(fiber)
								}
							})
							updaters.clear()
						}
						lanes &= ~lane
					}
				}
				function getTransitionsForLanes(root3, lanes) {
					{
						return null
					}
				}
				var DiscreteEventPriority = SyncLane
				var ContinuousEventPriority = InputContinuousLane
				var DefaultEventPriority = DefaultLane
				var IdleEventPriority = IdleLane
				var currentUpdatePriority = NoLane
				function getCurrentUpdatePriority() {
					return currentUpdatePriority
				}
				function setCurrentUpdatePriority(newPriority) {
					currentUpdatePriority = newPriority
				}
				function runWithPriority(priority, fn) {
					var previousPriority = currentUpdatePriority
					try {
						currentUpdatePriority = priority
						return fn()
					} finally {
						currentUpdatePriority = previousPriority
					}
				}
				function higherEventPriority(a3, b3) {
					return a3 !== 0 && a3 < b3 ? a3 : b3
				}
				function lowerEventPriority(a3, b3) {
					return a3 === 0 || a3 > b3 ? a3 : b3
				}
				function isHigherEventPriority(a3, b3) {
					return a3 !== 0 && a3 < b3
				}
				function lanesToEventPriority(lanes) {
					var lane = getHighestPriorityLane(lanes)
					if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
						return DiscreteEventPriority
					}
					if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
						return ContinuousEventPriority
					}
					if (includesNonIdleWork(lane)) {
						return DefaultEventPriority
					}
					return IdleEventPriority
				}
				function isRootDehydrated(root3) {
					var currentState = root3.current.memoizedState
					return currentState.isDehydrated
				}
				var _attemptSynchronousHydration
				function setAttemptSynchronousHydration(fn) {
					_attemptSynchronousHydration = fn
				}
				function attemptSynchronousHydration(fiber) {
					_attemptSynchronousHydration(fiber)
				}
				var attemptContinuousHydration
				function setAttemptContinuousHydration(fn) {
					attemptContinuousHydration = fn
				}
				var attemptHydrationAtCurrentPriority
				function setAttemptHydrationAtCurrentPriority(fn) {
					attemptHydrationAtCurrentPriority = fn
				}
				var getCurrentUpdatePriority$1
				function setGetCurrentUpdatePriority(fn) {
					getCurrentUpdatePriority$1 = fn
				}
				var attemptHydrationAtPriority
				function setAttemptHydrationAtPriority(fn) {
					attemptHydrationAtPriority = fn
				}
				var hasScheduledReplayAttempt = false
				var queuedDiscreteEvents = []
				var queuedFocus = null
				var queuedDrag = null
				var queuedMouse = null
				var queuedPointers = /* @__PURE__ */ new Map()
				var queuedPointerCaptures = /* @__PURE__ */ new Map()
				var queuedExplicitHydrationTargets = []
				var discreteReplayableEvents = [
					'mousedown',
					'mouseup',
					'touchcancel',
					'touchend',
					'touchstart',
					'auxclick',
					'dblclick',
					'pointercancel',
					'pointerdown',
					'pointerup',
					'dragend',
					'dragstart',
					'drop',
					'compositionend',
					'compositionstart',
					'keydown',
					'keypress',
					'keyup',
					'input',
					'textInput',
					// Intentionally camelCase
					'copy',
					'cut',
					'paste',
					'click',
					'change',
					'contextmenu',
					'reset',
					'submit',
				]
				function isDiscreteEventThatRequiresHydration(eventType) {
					return discreteReplayableEvents.indexOf(eventType) > -1
				}
				function createQueuedReplayableEvent(
					blockedOn,
					domEventName,
					eventSystemFlags,
					targetContainer,
					nativeEvent
				) {
					return {
						blockedOn,
						domEventName,
						eventSystemFlags,
						nativeEvent,
						targetContainers: [targetContainer],
					}
				}
				function clearIfContinuousEvent(domEventName, nativeEvent) {
					switch (domEventName) {
						case 'focusin':
						case 'focusout':
							queuedFocus = null
							break
						case 'dragenter':
						case 'dragleave':
							queuedDrag = null
							break
						case 'mouseover':
						case 'mouseout':
							queuedMouse = null
							break
						case 'pointerover':
						case 'pointerout': {
							var pointerId = nativeEvent.pointerId
							queuedPointers.delete(pointerId)
							break
						}
						case 'gotpointercapture':
						case 'lostpointercapture': {
							var _pointerId = nativeEvent.pointerId
							queuedPointerCaptures.delete(_pointerId)
							break
						}
					}
				}
				function accumulateOrCreateContinuousQueuedReplayableEvent(
					existingQueuedEvent,
					blockedOn,
					domEventName,
					eventSystemFlags,
					targetContainer,
					nativeEvent
				) {
					if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
						var queuedEvent = createQueuedReplayableEvent(
							blockedOn,
							domEventName,
							eventSystemFlags,
							targetContainer,
							nativeEvent
						)
						if (blockedOn !== null) {
							var _fiber2 = getInstanceFromNode(blockedOn)
							if (_fiber2 !== null) {
								attemptContinuousHydration(_fiber2)
							}
						}
						return queuedEvent
					}
					existingQueuedEvent.eventSystemFlags |= eventSystemFlags
					var targetContainers = existingQueuedEvent.targetContainers
					if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
						targetContainers.push(targetContainer)
					}
					return existingQueuedEvent
				}
				function queueIfContinuousEvent(
					blockedOn,
					domEventName,
					eventSystemFlags,
					targetContainer,
					nativeEvent
				) {
					switch (domEventName) {
						case 'focusin': {
							var focusEvent = nativeEvent
							queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
								queuedFocus,
								blockedOn,
								domEventName,
								eventSystemFlags,
								targetContainer,
								focusEvent
							)
							return true
						}
						case 'dragenter': {
							var dragEvent = nativeEvent
							queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
								queuedDrag,
								blockedOn,
								domEventName,
								eventSystemFlags,
								targetContainer,
								dragEvent
							)
							return true
						}
						case 'mouseover': {
							var mouseEvent = nativeEvent
							queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
								queuedMouse,
								blockedOn,
								domEventName,
								eventSystemFlags,
								targetContainer,
								mouseEvent
							)
							return true
						}
						case 'pointerover': {
							var pointerEvent = nativeEvent
							var pointerId = pointerEvent.pointerId
							queuedPointers.set(
								pointerId,
								accumulateOrCreateContinuousQueuedReplayableEvent(
									queuedPointers.get(pointerId) || null,
									blockedOn,
									domEventName,
									eventSystemFlags,
									targetContainer,
									pointerEvent
								)
							)
							return true
						}
						case 'gotpointercapture': {
							var _pointerEvent = nativeEvent
							var _pointerId2 = _pointerEvent.pointerId
							queuedPointerCaptures.set(
								_pointerId2,
								accumulateOrCreateContinuousQueuedReplayableEvent(
									queuedPointerCaptures.get(_pointerId2) || null,
									blockedOn,
									domEventName,
									eventSystemFlags,
									targetContainer,
									_pointerEvent
								)
							)
							return true
						}
					}
					return false
				}
				function attemptExplicitHydrationTarget(queuedTarget) {
					var targetInst = getClosestInstanceFromNode(queuedTarget.target)
					if (targetInst !== null) {
						var nearestMounted = getNearestMountedFiber(targetInst)
						if (nearestMounted !== null) {
							var tag = nearestMounted.tag
							if (tag === SuspenseComponent) {
								var instance = getSuspenseInstanceFromFiber(nearestMounted)
								if (instance !== null) {
									queuedTarget.blockedOn = instance
									attemptHydrationAtPriority(queuedTarget.priority, function () {
										attemptHydrationAtCurrentPriority(nearestMounted)
									})
									return
								}
							} else if (tag === HostRoot) {
								var root3 = nearestMounted.stateNode
								if (isRootDehydrated(root3)) {
									queuedTarget.blockedOn = getContainerFromFiber(nearestMounted)
									return
								}
							}
						}
					}
					queuedTarget.blockedOn = null
				}
				function queueExplicitHydrationTarget(target) {
					var updatePriority = getCurrentUpdatePriority$1()
					var queuedTarget = {
						blockedOn: null,
						target,
						priority: updatePriority,
					}
					var i3 = 0
					for (; i3 < queuedExplicitHydrationTargets.length; i3++) {
						if (
							!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i3].priority)
						) {
							break
						}
					}
					queuedExplicitHydrationTargets.splice(i3, 0, queuedTarget)
					if (i3 === 0) {
						attemptExplicitHydrationTarget(queuedTarget)
					}
				}
				function attemptReplayContinuousQueuedEvent(queuedEvent) {
					if (queuedEvent.blockedOn !== null) {
						return false
					}
					var targetContainers = queuedEvent.targetContainers
					while (targetContainers.length > 0) {
						var targetContainer = targetContainers[0]
						var nextBlockedOn = findInstanceBlockingEvent(
							queuedEvent.domEventName,
							queuedEvent.eventSystemFlags,
							targetContainer,
							queuedEvent.nativeEvent
						)
						if (nextBlockedOn === null) {
							{
								var nativeEvent = queuedEvent.nativeEvent
								var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent)
								setReplayingEvent(nativeEventClone)
								nativeEvent.target.dispatchEvent(nativeEventClone)
								resetReplayingEvent()
							}
						} else {
							var _fiber3 = getInstanceFromNode(nextBlockedOn)
							if (_fiber3 !== null) {
								attemptContinuousHydration(_fiber3)
							}
							queuedEvent.blockedOn = nextBlockedOn
							return false
						}
						targetContainers.shift()
					}
					return true
				}
				function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
					if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
						map.delete(key)
					}
				}
				function replayUnblockedEvents() {
					hasScheduledReplayAttempt = false
					if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
						queuedFocus = null
					}
					if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
						queuedDrag = null
					}
					if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
						queuedMouse = null
					}
					queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap)
					queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap)
				}
				function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
					if (queuedEvent.blockedOn === unblocked) {
						queuedEvent.blockedOn = null
						if (!hasScheduledReplayAttempt) {
							hasScheduledReplayAttempt = true
							Scheduler.unstable_scheduleCallback(
								Scheduler.unstable_NormalPriority,
								replayUnblockedEvents
							)
						}
					}
				}
				function retryIfBlockedOn(unblocked) {
					if (queuedDiscreteEvents.length > 0) {
						scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked)
						for (var i3 = 1; i3 < queuedDiscreteEvents.length; i3++) {
							var queuedEvent = queuedDiscreteEvents[i3]
							if (queuedEvent.blockedOn === unblocked) {
								queuedEvent.blockedOn = null
							}
						}
					}
					if (queuedFocus !== null) {
						scheduleCallbackIfUnblocked(queuedFocus, unblocked)
					}
					if (queuedDrag !== null) {
						scheduleCallbackIfUnblocked(queuedDrag, unblocked)
					}
					if (queuedMouse !== null) {
						scheduleCallbackIfUnblocked(queuedMouse, unblocked)
					}
					var unblock = function (queuedEvent2) {
						return scheduleCallbackIfUnblocked(queuedEvent2, unblocked)
					}
					queuedPointers.forEach(unblock)
					queuedPointerCaptures.forEach(unblock)
					for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
						var queuedTarget = queuedExplicitHydrationTargets[_i]
						if (queuedTarget.blockedOn === unblocked) {
							queuedTarget.blockedOn = null
						}
					}
					while (queuedExplicitHydrationTargets.length > 0) {
						var nextExplicitTarget = queuedExplicitHydrationTargets[0]
						if (nextExplicitTarget.blockedOn !== null) {
							break
						} else {
							attemptExplicitHydrationTarget(nextExplicitTarget)
							if (nextExplicitTarget.blockedOn === null) {
								queuedExplicitHydrationTargets.shift()
							}
						}
					}
				}
				var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig
				var _enabled = true
				function setEnabled(enabled) {
					_enabled = !!enabled
				}
				function isEnabled() {
					return _enabled
				}
				function createEventListenerWrapperWithPriority(
					targetContainer,
					domEventName,
					eventSystemFlags
				) {
					var eventPriority = getEventPriority(domEventName)
					var listenerWrapper
					switch (eventPriority) {
						case DiscreteEventPriority:
							listenerWrapper = dispatchDiscreteEvent
							break
						case ContinuousEventPriority:
							listenerWrapper = dispatchContinuousEvent
							break
						case DefaultEventPriority:
						default:
							listenerWrapper = dispatchEvent
							break
					}
					return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer)
				}
				function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
					var previousPriority = getCurrentUpdatePriority()
					var prevTransition = ReactCurrentBatchConfig.transition
					ReactCurrentBatchConfig.transition = null
					try {
						setCurrentUpdatePriority(DiscreteEventPriority)
						dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent)
					} finally {
						setCurrentUpdatePriority(previousPriority)
						ReactCurrentBatchConfig.transition = prevTransition
					}
				}
				function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
					var previousPriority = getCurrentUpdatePriority()
					var prevTransition = ReactCurrentBatchConfig.transition
					ReactCurrentBatchConfig.transition = null
					try {
						setCurrentUpdatePriority(ContinuousEventPriority)
						dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent)
					} finally {
						setCurrentUpdatePriority(previousPriority)
						ReactCurrentBatchConfig.transition = prevTransition
					}
				}
				function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
					if (!_enabled) {
						return
					}
					{
						dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(
							domEventName,
							eventSystemFlags,
							targetContainer,
							nativeEvent
						)
					}
				}
				function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(
					domEventName,
					eventSystemFlags,
					targetContainer,
					nativeEvent
				) {
					var blockedOn = findInstanceBlockingEvent(
						domEventName,
						eventSystemFlags,
						targetContainer,
						nativeEvent
					)
					if (blockedOn === null) {
						dispatchEventForPluginEventSystem(
							domEventName,
							eventSystemFlags,
							nativeEvent,
							return_targetInst,
							targetContainer
						)
						clearIfContinuousEvent(domEventName, nativeEvent)
						return
					}
					if (
						queueIfContinuousEvent(
							blockedOn,
							domEventName,
							eventSystemFlags,
							targetContainer,
							nativeEvent
						)
					) {
						nativeEvent.stopPropagation()
						return
					}
					clearIfContinuousEvent(domEventName, nativeEvent)
					if (
						eventSystemFlags & IS_CAPTURE_PHASE &&
						isDiscreteEventThatRequiresHydration(domEventName)
					) {
						while (blockedOn !== null) {
							var fiber = getInstanceFromNode(blockedOn)
							if (fiber !== null) {
								attemptSynchronousHydration(fiber)
							}
							var nextBlockedOn = findInstanceBlockingEvent(
								domEventName,
								eventSystemFlags,
								targetContainer,
								nativeEvent
							)
							if (nextBlockedOn === null) {
								dispatchEventForPluginEventSystem(
									domEventName,
									eventSystemFlags,
									nativeEvent,
									return_targetInst,
									targetContainer
								)
							}
							if (nextBlockedOn === blockedOn) {
								break
							}
							blockedOn = nextBlockedOn
						}
						if (blockedOn !== null) {
							nativeEvent.stopPropagation()
						}
						return
					}
					dispatchEventForPluginEventSystem(
						domEventName,
						eventSystemFlags,
						nativeEvent,
						null,
						targetContainer
					)
				}
				var return_targetInst = null
				function findInstanceBlockingEvent(
					domEventName,
					eventSystemFlags,
					targetContainer,
					nativeEvent
				) {
					return_targetInst = null
					var nativeEventTarget = getEventTarget(nativeEvent)
					var targetInst = getClosestInstanceFromNode(nativeEventTarget)
					if (targetInst !== null) {
						var nearestMounted = getNearestMountedFiber(targetInst)
						if (nearestMounted === null) {
							targetInst = null
						} else {
							var tag = nearestMounted.tag
							if (tag === SuspenseComponent) {
								var instance = getSuspenseInstanceFromFiber(nearestMounted)
								if (instance !== null) {
									return instance
								}
								targetInst = null
							} else if (tag === HostRoot) {
								var root3 = nearestMounted.stateNode
								if (isRootDehydrated(root3)) {
									return getContainerFromFiber(nearestMounted)
								}
								targetInst = null
							} else if (nearestMounted !== targetInst) {
								targetInst = null
							}
						}
					}
					return_targetInst = targetInst
					return null
				}
				function getEventPriority(domEventName) {
					switch (domEventName) {
						case 'cancel':
						case 'click':
						case 'close':
						case 'contextmenu':
						case 'copy':
						case 'cut':
						case 'auxclick':
						case 'dblclick':
						case 'dragend':
						case 'dragstart':
						case 'drop':
						case 'focusin':
						case 'focusout':
						case 'input':
						case 'invalid':
						case 'keydown':
						case 'keypress':
						case 'keyup':
						case 'mousedown':
						case 'mouseup':
						case 'paste':
						case 'pause':
						case 'play':
						case 'pointercancel':
						case 'pointerdown':
						case 'pointerup':
						case 'ratechange':
						case 'reset':
						case 'resize':
						case 'seeked':
						case 'submit':
						case 'touchcancel':
						case 'touchend':
						case 'touchstart':
						case 'volumechange':
						case 'change':
						case 'selectionchange':
						case 'textInput':
						case 'compositionstart':
						case 'compositionend':
						case 'compositionupdate':
						case 'beforeblur':
						case 'afterblur':
						case 'beforeinput':
						case 'blur':
						case 'fullscreenchange':
						case 'focus':
						case 'hashchange':
						case 'popstate':
						case 'select':
						case 'selectstart':
							return DiscreteEventPriority
						case 'drag':
						case 'dragenter':
						case 'dragexit':
						case 'dragleave':
						case 'dragover':
						case 'mousemove':
						case 'mouseout':
						case 'mouseover':
						case 'pointermove':
						case 'pointerout':
						case 'pointerover':
						case 'scroll':
						case 'toggle':
						case 'touchmove':
						case 'wheel':
						case 'mouseenter':
						case 'mouseleave':
						case 'pointerenter':
						case 'pointerleave':
							return ContinuousEventPriority
						case 'message': {
							var schedulerPriority = getCurrentPriorityLevel()
							switch (schedulerPriority) {
								case ImmediatePriority:
									return DiscreteEventPriority
								case UserBlockingPriority:
									return ContinuousEventPriority
								case NormalPriority:
								case LowPriority:
									return DefaultEventPriority
								case IdlePriority:
									return IdleEventPriority
								default:
									return DefaultEventPriority
							}
						}
						default:
							return DefaultEventPriority
					}
				}
				function addEventBubbleListener(target, eventType, listener) {
					target.addEventListener(eventType, listener, false)
					return listener
				}
				function addEventCaptureListener(target, eventType, listener) {
					target.addEventListener(eventType, listener, true)
					return listener
				}
				function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
					target.addEventListener(eventType, listener, {
						capture: true,
						passive,
					})
					return listener
				}
				function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
					target.addEventListener(eventType, listener, {
						passive,
					})
					return listener
				}
				var root2 = null
				var startText = null
				var fallbackText = null
				function initialize(nativeEventTarget) {
					root2 = nativeEventTarget
					startText = getText()
					return true
				}
				function reset() {
					root2 = null
					startText = null
					fallbackText = null
				}
				function getData() {
					if (fallbackText) {
						return fallbackText
					}
					var start
					var startValue = startText
					var startLength = startValue.length
					var end
					var endValue = getText()
					var endLength = endValue.length
					for (start = 0; start < startLength; start++) {
						if (startValue[start] !== endValue[start]) {
							break
						}
					}
					var minEnd = startLength - start
					for (end = 1; end <= minEnd; end++) {
						if (startValue[startLength - end] !== endValue[endLength - end]) {
							break
						}
					}
					var sliceTail = end > 1 ? 1 - end : void 0
					fallbackText = endValue.slice(start, sliceTail)
					return fallbackText
				}
				function getText() {
					if ('value' in root2) {
						return root2.value
					}
					return root2.textContent
				}
				function getEventCharCode(nativeEvent) {
					var charCode
					var keyCode = nativeEvent.keyCode
					if ('charCode' in nativeEvent) {
						charCode = nativeEvent.charCode
						if (charCode === 0 && keyCode === 13) {
							charCode = 13
						}
					} else {
						charCode = keyCode
					}
					if (charCode === 10) {
						charCode = 13
					}
					if (charCode >= 32 || charCode === 13) {
						return charCode
					}
					return 0
				}
				function functionThatReturnsTrue() {
					return true
				}
				function functionThatReturnsFalse() {
					return false
				}
				function createSyntheticEvent(Interface) {
					function SyntheticBaseEvent(
						reactName,
						reactEventType,
						targetInst,
						nativeEvent,
						nativeEventTarget
					) {
						this._reactName = reactName
						this._targetInst = targetInst
						this.type = reactEventType
						this.nativeEvent = nativeEvent
						this.target = nativeEventTarget
						this.currentTarget = null
						for (var _propName in Interface) {
							if (!Interface.hasOwnProperty(_propName)) {
								continue
							}
							var normalize = Interface[_propName]
							if (normalize) {
								this[_propName] = normalize(nativeEvent)
							} else {
								this[_propName] = nativeEvent[_propName]
							}
						}
						var defaultPrevented =
							nativeEvent.defaultPrevented != null
								? nativeEvent.defaultPrevented
								: nativeEvent.returnValue === false
						if (defaultPrevented) {
							this.isDefaultPrevented = functionThatReturnsTrue
						} else {
							this.isDefaultPrevented = functionThatReturnsFalse
						}
						this.isPropagationStopped = functionThatReturnsFalse
						return this
					}
					assign(SyntheticBaseEvent.prototype, {
						preventDefault: function () {
							this.defaultPrevented = true
							var event = this.nativeEvent
							if (!event) {
								return
							}
							if (event.preventDefault) {
								event.preventDefault()
							} else if (typeof event.returnValue !== 'unknown') {
								event.returnValue = false
							}
							this.isDefaultPrevented = functionThatReturnsTrue
						},
						stopPropagation: function () {
							var event = this.nativeEvent
							if (!event) {
								return
							}
							if (event.stopPropagation) {
								event.stopPropagation()
							} else if (typeof event.cancelBubble !== 'unknown') {
								event.cancelBubble = true
							}
							this.isPropagationStopped = functionThatReturnsTrue
						},
						/**
						 * We release all dispatched `SyntheticEvent`s after each event loop, adding
						 * them back into the pool. This allows a way to hold onto a reference that
						 * won't be added back into the pool.
						 */
						persist: function () {},
						/**
						 * Checks if this event should be released back into the pool.
						 *
						 * @return {boolean} True if this should not be released, false otherwise.
						 */
						isPersistent: functionThatReturnsTrue,
					})
					return SyntheticBaseEvent
				}
				var EventInterface = {
					eventPhase: 0,
					bubbles: 0,
					cancelable: 0,
					timeStamp: function (event) {
						return event.timeStamp || Date.now()
					},
					defaultPrevented: 0,
					isTrusted: 0,
				}
				var SyntheticEvent = createSyntheticEvent(EventInterface)
				var UIEventInterface = assign({}, EventInterface, {
					view: 0,
					detail: 0,
				})
				var SyntheticUIEvent = createSyntheticEvent(UIEventInterface)
				var lastMovementX
				var lastMovementY
				var lastMouseEvent
				function updateMouseMovementPolyfillState(event) {
					if (event !== lastMouseEvent) {
						if (lastMouseEvent && event.type === 'mousemove') {
							lastMovementX = event.screenX - lastMouseEvent.screenX
							lastMovementY = event.screenY - lastMouseEvent.screenY
						} else {
							lastMovementX = 0
							lastMovementY = 0
						}
						lastMouseEvent = event
					}
				}
				var MouseEventInterface = assign({}, UIEventInterface, {
					screenX: 0,
					screenY: 0,
					clientX: 0,
					clientY: 0,
					pageX: 0,
					pageY: 0,
					ctrlKey: 0,
					shiftKey: 0,
					altKey: 0,
					metaKey: 0,
					getModifierState: getEventModifierState,
					button: 0,
					buttons: 0,
					relatedTarget: function (event) {
						if (event.relatedTarget === void 0)
							return event.fromElement === event.srcElement ? event.toElement : event.fromElement
						return event.relatedTarget
					},
					movementX: function (event) {
						if ('movementX' in event) {
							return event.movementX
						}
						updateMouseMovementPolyfillState(event)
						return lastMovementX
					},
					movementY: function (event) {
						if ('movementY' in event) {
							return event.movementY
						}
						return lastMovementY
					},
				})
				var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface)
				var DragEventInterface = assign({}, MouseEventInterface, {
					dataTransfer: 0,
				})
				var SyntheticDragEvent = createSyntheticEvent(DragEventInterface)
				var FocusEventInterface = assign({}, UIEventInterface, {
					relatedTarget: 0,
				})
				var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface)
				var AnimationEventInterface = assign({}, EventInterface, {
					animationName: 0,
					elapsedTime: 0,
					pseudoElement: 0,
				})
				var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface)
				var ClipboardEventInterface = assign({}, EventInterface, {
					clipboardData: function (event) {
						return 'clipboardData' in event ? event.clipboardData : window.clipboardData
					},
				})
				var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface)
				var CompositionEventInterface = assign({}, EventInterface, {
					data: 0,
				})
				var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface)
				var SyntheticInputEvent = SyntheticCompositionEvent
				var normalizeKey = {
					Esc: 'Escape',
					Spacebar: ' ',
					Left: 'ArrowLeft',
					Up: 'ArrowUp',
					Right: 'ArrowRight',
					Down: 'ArrowDown',
					Del: 'Delete',
					Win: 'OS',
					Menu: 'ContextMenu',
					Apps: 'ContextMenu',
					Scroll: 'ScrollLock',
					MozPrintableKey: 'Unidentified',
				}
				var translateToKey = {
					8: 'Backspace',
					9: 'Tab',
					12: 'Clear',
					13: 'Enter',
					16: 'Shift',
					17: 'Control',
					18: 'Alt',
					19: 'Pause',
					20: 'CapsLock',
					27: 'Escape',
					32: ' ',
					33: 'PageUp',
					34: 'PageDown',
					35: 'End',
					36: 'Home',
					37: 'ArrowLeft',
					38: 'ArrowUp',
					39: 'ArrowRight',
					40: 'ArrowDown',
					45: 'Insert',
					46: 'Delete',
					112: 'F1',
					113: 'F2',
					114: 'F3',
					115: 'F4',
					116: 'F5',
					117: 'F6',
					118: 'F7',
					119: 'F8',
					120: 'F9',
					121: 'F10',
					122: 'F11',
					123: 'F12',
					144: 'NumLock',
					145: 'ScrollLock',
					224: 'Meta',
				}
				function getEventKey(nativeEvent) {
					if (nativeEvent.key) {
						var key = normalizeKey[nativeEvent.key] || nativeEvent.key
						if (key !== 'Unidentified') {
							return key
						}
					}
					if (nativeEvent.type === 'keypress') {
						var charCode = getEventCharCode(nativeEvent)
						return charCode === 13 ? 'Enter' : String.fromCharCode(charCode)
					}
					if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
						return translateToKey[nativeEvent.keyCode] || 'Unidentified'
					}
					return ''
				}
				var modifierKeyToProp = {
					Alt: 'altKey',
					Control: 'ctrlKey',
					Meta: 'metaKey',
					Shift: 'shiftKey',
				}
				function modifierStateGetter(keyArg) {
					var syntheticEvent = this
					var nativeEvent = syntheticEvent.nativeEvent
					if (nativeEvent.getModifierState) {
						return nativeEvent.getModifierState(keyArg)
					}
					var keyProp = modifierKeyToProp[keyArg]
					return keyProp ? !!nativeEvent[keyProp] : false
				}
				function getEventModifierState(nativeEvent) {
					return modifierStateGetter
				}
				var KeyboardEventInterface = assign({}, UIEventInterface, {
					key: getEventKey,
					code: 0,
					location: 0,
					ctrlKey: 0,
					shiftKey: 0,
					altKey: 0,
					metaKey: 0,
					repeat: 0,
					locale: 0,
					getModifierState: getEventModifierState,
					// Legacy Interface
					charCode: function (event) {
						if (event.type === 'keypress') {
							return getEventCharCode(event)
						}
						return 0
					},
					keyCode: function (event) {
						if (event.type === 'keydown' || event.type === 'keyup') {
							return event.keyCode
						}
						return 0
					},
					which: function (event) {
						if (event.type === 'keypress') {
							return getEventCharCode(event)
						}
						if (event.type === 'keydown' || event.type === 'keyup') {
							return event.keyCode
						}
						return 0
					},
				})
				var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface)
				var PointerEventInterface = assign({}, MouseEventInterface, {
					pointerId: 0,
					width: 0,
					height: 0,
					pressure: 0,
					tangentialPressure: 0,
					tiltX: 0,
					tiltY: 0,
					twist: 0,
					pointerType: 0,
					isPrimary: 0,
				})
				var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface)
				var TouchEventInterface = assign({}, UIEventInterface, {
					touches: 0,
					targetTouches: 0,
					changedTouches: 0,
					altKey: 0,
					metaKey: 0,
					ctrlKey: 0,
					shiftKey: 0,
					getModifierState: getEventModifierState,
				})
				var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface)
				var TransitionEventInterface = assign({}, EventInterface, {
					propertyName: 0,
					elapsedTime: 0,
					pseudoElement: 0,
				})
				var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface)
				var WheelEventInterface = assign({}, MouseEventInterface, {
					deltaX: function (event) {
						return 'deltaX' in event
							? event.deltaX
							: // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
							'wheelDeltaX' in event
							? -event.wheelDeltaX
							: 0
					},
					deltaY: function (event) {
						return 'deltaY' in event
							? event.deltaY
							: // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
							'wheelDeltaY' in event
							? -event.wheelDeltaY
							: // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
							'wheelDelta' in event
							? -event.wheelDelta
							: 0
					},
					deltaZ: 0,
					// Browsers without "deltaMode" is reporting in raw wheel delta where one
					// notch on the scroll is always +/- 120, roughly equivalent to pixels.
					// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
					// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
					deltaMode: 0,
				})
				var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface)
				var END_KEYCODES = [9, 13, 27, 32]
				var START_KEYCODE = 229
				var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window
				var documentMode = null
				if (canUseDOM && 'documentMode' in document) {
					documentMode = document.documentMode
				}
				var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode
				var useFallbackCompositionData =
					canUseDOM &&
					(!canUseCompositionEvent || (documentMode && documentMode > 8 && documentMode <= 11))
				var SPACEBAR_CODE = 32
				var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE)
				function registerEvents() {
					registerTwoPhaseEvent('onBeforeInput', [
						'compositionend',
						'keypress',
						'textInput',
						'paste',
					])
					registerTwoPhaseEvent('onCompositionEnd', [
						'compositionend',
						'focusout',
						'keydown',
						'keypress',
						'keyup',
						'mousedown',
					])
					registerTwoPhaseEvent('onCompositionStart', [
						'compositionstart',
						'focusout',
						'keydown',
						'keypress',
						'keyup',
						'mousedown',
					])
					registerTwoPhaseEvent('onCompositionUpdate', [
						'compositionupdate',
						'focusout',
						'keydown',
						'keypress',
						'keyup',
						'mousedown',
					])
				}
				var hasSpaceKeypress = false
				function isKeypressCommand(nativeEvent) {
					return (
						(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
						!(nativeEvent.ctrlKey && nativeEvent.altKey)
					)
				}
				function getCompositionEventType(domEventName) {
					switch (domEventName) {
						case 'compositionstart':
							return 'onCompositionStart'
						case 'compositionend':
							return 'onCompositionEnd'
						case 'compositionupdate':
							return 'onCompositionUpdate'
					}
				}
				function isFallbackCompositionStart(domEventName, nativeEvent) {
					return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE
				}
				function isFallbackCompositionEnd(domEventName, nativeEvent) {
					switch (domEventName) {
						case 'keyup':
							return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1
						case 'keydown':
							return nativeEvent.keyCode !== START_KEYCODE
						case 'keypress':
						case 'mousedown':
						case 'focusout':
							return true
						default:
							return false
					}
				}
				function getDataFromCustomEvent(nativeEvent) {
					var detail = nativeEvent.detail
					if (typeof detail === 'object' && 'data' in detail) {
						return detail.data
					}
					return null
				}
				function isUsingKoreanIME(nativeEvent) {
					return nativeEvent.locale === 'ko'
				}
				var isComposing = false
				function extractCompositionEvent(
					dispatchQueue,
					domEventName,
					targetInst,
					nativeEvent,
					nativeEventTarget
				) {
					var eventType
					var fallbackData
					if (canUseCompositionEvent) {
						eventType = getCompositionEventType(domEventName)
					} else if (!isComposing) {
						if (isFallbackCompositionStart(domEventName, nativeEvent)) {
							eventType = 'onCompositionStart'
						}
					} else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
						eventType = 'onCompositionEnd'
					}
					if (!eventType) {
						return null
					}
					if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
						if (!isComposing && eventType === 'onCompositionStart') {
							isComposing = initialize(nativeEventTarget)
						} else if (eventType === 'onCompositionEnd') {
							if (isComposing) {
								fallbackData = getData()
							}
						}
					}
					var listeners = accumulateTwoPhaseListeners(targetInst, eventType)
					if (listeners.length > 0) {
						var event = new SyntheticCompositionEvent(
							eventType,
							domEventName,
							null,
							nativeEvent,
							nativeEventTarget
						)
						dispatchQueue.push({
							event,
							listeners,
						})
						if (fallbackData) {
							event.data = fallbackData
						} else {
							var customData = getDataFromCustomEvent(nativeEvent)
							if (customData !== null) {
								event.data = customData
							}
						}
					}
				}
				function getNativeBeforeInputChars(domEventName, nativeEvent) {
					switch (domEventName) {
						case 'compositionend':
							return getDataFromCustomEvent(nativeEvent)
						case 'keypress':
							var which = nativeEvent.which
							if (which !== SPACEBAR_CODE) {
								return null
							}
							hasSpaceKeypress = true
							return SPACEBAR_CHAR
						case 'textInput':
							var chars = nativeEvent.data
							if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
								return null
							}
							return chars
						default:
							return null
					}
				}
				function getFallbackBeforeInputChars(domEventName, nativeEvent) {
					if (isComposing) {
						if (
							domEventName === 'compositionend' ||
							(!canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent))
						) {
							var chars = getData()
							reset()
							isComposing = false
							return chars
						}
						return null
					}
					switch (domEventName) {
						case 'paste':
							return null
						case 'keypress':
							if (!isKeypressCommand(nativeEvent)) {
								if (nativeEvent.char && nativeEvent.char.length > 1) {
									return nativeEvent.char
								} else if (nativeEvent.which) {
									return String.fromCharCode(nativeEvent.which)
								}
							}
							return null
						case 'compositionend':
							return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)
								? null
								: nativeEvent.data
						default:
							return null
					}
				}
				function extractBeforeInputEvent(
					dispatchQueue,
					domEventName,
					targetInst,
					nativeEvent,
					nativeEventTarget
				) {
					var chars
					if (canUseTextInputEvent) {
						chars = getNativeBeforeInputChars(domEventName, nativeEvent)
					} else {
						chars = getFallbackBeforeInputChars(domEventName, nativeEvent)
					}
					if (!chars) {
						return null
					}
					var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput')
					if (listeners.length > 0) {
						var event = new SyntheticInputEvent(
							'onBeforeInput',
							'beforeinput',
							null,
							nativeEvent,
							nativeEventTarget
						)
						dispatchQueue.push({
							event,
							listeners,
						})
						event.data = chars
					}
				}
				function extractEvents(
					dispatchQueue,
					domEventName,
					targetInst,
					nativeEvent,
					nativeEventTarget,
					eventSystemFlags,
					targetContainer
				) {
					extractCompositionEvent(
						dispatchQueue,
						domEventName,
						targetInst,
						nativeEvent,
						nativeEventTarget
					)
					extractBeforeInputEvent(
						dispatchQueue,
						domEventName,
						targetInst,
						nativeEvent,
						nativeEventTarget
					)
				}
				var supportedInputTypes = {
					color: true,
					date: true,
					datetime: true,
					'datetime-local': true,
					email: true,
					month: true,
					number: true,
					password: true,
					range: true,
					search: true,
					tel: true,
					text: true,
					time: true,
					url: true,
					week: true,
				}
				function isTextInputElement(elem) {
					var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase()
					if (nodeName === 'input') {
						return !!supportedInputTypes[elem.type]
					}
					if (nodeName === 'textarea') {
						return true
					}
					return false
				}
				function isEventSupported(eventNameSuffix) {
					if (!canUseDOM) {
						return false
					}
					var eventName = 'on' + eventNameSuffix
					var isSupported = eventName in document
					if (!isSupported) {
						var element = document.createElement('div')
						element.setAttribute(eventName, 'return;')
						isSupported = typeof element[eventName] === 'function'
					}
					return isSupported
				}
				function registerEvents$1() {
					registerTwoPhaseEvent('onChange', [
						'change',
						'click',
						'focusin',
						'focusout',
						'input',
						'keydown',
						'keyup',
						'selectionchange',
					])
				}
				function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
					enqueueStateRestore(target)
					var listeners = accumulateTwoPhaseListeners(inst, 'onChange')
					if (listeners.length > 0) {
						var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target)
						dispatchQueue.push({
							event,
							listeners,
						})
					}
				}
				var activeElement = null
				var activeElementInst = null
				function shouldUseChangeEvent(elem) {
					var nodeName = elem.nodeName && elem.nodeName.toLowerCase()
					return nodeName === 'select' || (nodeName === 'input' && elem.type === 'file')
				}
				function manualDispatchChangeEvent(nativeEvent) {
					var dispatchQueue = []
					createAndAccumulateChangeEvent(
						dispatchQueue,
						activeElementInst,
						nativeEvent,
						getEventTarget(nativeEvent)
					)
					batchedUpdates(runEventInBatch, dispatchQueue)
				}
				function runEventInBatch(dispatchQueue) {
					processDispatchQueue(dispatchQueue, 0)
				}
				function getInstIfValueChanged(targetInst) {
					var targetNode = getNodeFromInstance(targetInst)
					if (updateValueIfChanged(targetNode)) {
						return targetInst
					}
				}
				function getTargetInstForChangeEvent(domEventName, targetInst) {
					if (domEventName === 'change') {
						return targetInst
					}
				}
				var isInputEventSupported = false
				if (canUseDOM) {
					isInputEventSupported =
						isEventSupported('input') && (!document.documentMode || document.documentMode > 9)
				}
				function startWatchingForValueChange(target, targetInst) {
					activeElement = target
					activeElementInst = targetInst
					activeElement.attachEvent('onpropertychange', handlePropertyChange)
				}
				function stopWatchingForValueChange() {
					if (!activeElement) {
						return
					}
					activeElement.detachEvent('onpropertychange', handlePropertyChange)
					activeElement = null
					activeElementInst = null
				}
				function handlePropertyChange(nativeEvent) {
					if (nativeEvent.propertyName !== 'value') {
						return
					}
					if (getInstIfValueChanged(activeElementInst)) {
						manualDispatchChangeEvent(nativeEvent)
					}
				}
				function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
					if (domEventName === 'focusin') {
						stopWatchingForValueChange()
						startWatchingForValueChange(target, targetInst)
					} else if (domEventName === 'focusout') {
						stopWatchingForValueChange()
					}
				}
				function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
					if (
						domEventName === 'selectionchange' ||
						domEventName === 'keyup' ||
						domEventName === 'keydown'
					) {
						return getInstIfValueChanged(activeElementInst)
					}
				}
				function shouldUseClickEvent(elem) {
					var nodeName = elem.nodeName
					return (
						nodeName &&
						nodeName.toLowerCase() === 'input' &&
						(elem.type === 'checkbox' || elem.type === 'radio')
					)
				}
				function getTargetInstForClickEvent(domEventName, targetInst) {
					if (domEventName === 'click') {
						return getInstIfValueChanged(targetInst)
					}
				}
				function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
					if (domEventName === 'input' || domEventName === 'change') {
						return getInstIfValueChanged(targetInst)
					}
				}
				function handleControlledInputBlur(node) {
					var state = node._wrapperState
					if (!state || !state.controlled || node.type !== 'number') {
						return
					}
					{
						setDefaultValue(node, 'number', node.value)
					}
				}
				function extractEvents$1(
					dispatchQueue,
					domEventName,
					targetInst,
					nativeEvent,
					nativeEventTarget,
					eventSystemFlags,
					targetContainer
				) {
					var targetNode = targetInst ? getNodeFromInstance(targetInst) : window
					var getTargetInstFunc, handleEventFunc
					if (shouldUseChangeEvent(targetNode)) {
						getTargetInstFunc = getTargetInstForChangeEvent
					} else if (isTextInputElement(targetNode)) {
						if (isInputEventSupported) {
							getTargetInstFunc = getTargetInstForInputOrChangeEvent
						} else {
							getTargetInstFunc = getTargetInstForInputEventPolyfill
							handleEventFunc = handleEventsForInputEventPolyfill
						}
					} else if (shouldUseClickEvent(targetNode)) {
						getTargetInstFunc = getTargetInstForClickEvent
					}
					if (getTargetInstFunc) {
						var inst = getTargetInstFunc(domEventName, targetInst)
						if (inst) {
							createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget)
							return
						}
					}
					if (handleEventFunc) {
						handleEventFunc(domEventName, targetNode, targetInst)
					}
					if (domEventName === 'focusout') {
						handleControlledInputBlur(targetNode)
					}
				}
				function registerEvents$2() {
					registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover'])
					registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover'])
					registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover'])
					registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover'])
				}
				function extractEvents$2(
					dispatchQueue,
					domEventName,
					targetInst,
					nativeEvent,
					nativeEventTarget,
					eventSystemFlags,
					targetContainer
				) {
					var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover'
					var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout'
					if (isOverEvent && !isReplayingEvent(nativeEvent)) {
						var related = nativeEvent.relatedTarget || nativeEvent.fromElement
						if (related) {
							if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
								return
							}
						}
					}
					if (!isOutEvent && !isOverEvent) {
						return
					}
					var win
					if (nativeEventTarget.window === nativeEventTarget) {
						win = nativeEventTarget
					} else {
						var doc = nativeEventTarget.ownerDocument
						if (doc) {
							win = doc.defaultView || doc.parentWindow
						} else {
							win = window
						}
					}
					var from
					var to
					if (isOutEvent) {
						var _related = nativeEvent.relatedTarget || nativeEvent.toElement
						from = targetInst
						to = _related ? getClosestInstanceFromNode(_related) : null
						if (to !== null) {
							var nearestMounted = getNearestMountedFiber(to)
							if (to !== nearestMounted || (to.tag !== HostComponent && to.tag !== HostText)) {
								to = null
							}
						}
					} else {
						from = null
						to = targetInst
					}
					if (from === to) {
						return
					}
					var SyntheticEventCtor = SyntheticMouseEvent
					var leaveEventType = 'onMouseLeave'
					var enterEventType = 'onMouseEnter'
					var eventTypePrefix = 'mouse'
					if (domEventName === 'pointerout' || domEventName === 'pointerover') {
						SyntheticEventCtor = SyntheticPointerEvent
						leaveEventType = 'onPointerLeave'
						enterEventType = 'onPointerEnter'
						eventTypePrefix = 'pointer'
					}
					var fromNode = from == null ? win : getNodeFromInstance(from)
					var toNode = to == null ? win : getNodeFromInstance(to)
					var leave = new SyntheticEventCtor(
						leaveEventType,
						eventTypePrefix + 'leave',
						from,
						nativeEvent,
						nativeEventTarget
					)
					leave.target = fromNode
					leave.relatedTarget = toNode
					var enter = null
					var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget)
					if (nativeTargetInst === targetInst) {
						var enterEvent = new SyntheticEventCtor(
							enterEventType,
							eventTypePrefix + 'enter',
							to,
							nativeEvent,
							nativeEventTarget
						)
						enterEvent.target = toNode
						enterEvent.relatedTarget = fromNode
						enter = enterEvent
					}
					accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to)
				}
				function is(x3, y3) {
					return (x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3)) || (x3 !== x3 && y3 !== y3)
				}
				var objectIs = typeof Object.is === 'function' ? Object.is : is
				function shallowEqual(objA, objB) {
					if (objectIs(objA, objB)) {
						return true
					}
					if (
						typeof objA !== 'object' ||
						objA === null ||
						typeof objB !== 'object' ||
						objB === null
					) {
						return false
					}
					var keysA = Object.keys(objA)
					var keysB = Object.keys(objB)
					if (keysA.length !== keysB.length) {
						return false
					}
					for (var i3 = 0; i3 < keysA.length; i3++) {
						var currentKey = keysA[i3]
						if (
							!hasOwnProperty2.call(objB, currentKey) ||
							!objectIs(objA[currentKey], objB[currentKey])
						) {
							return false
						}
					}
					return true
				}
				function getLeafNode(node) {
					while (node && node.firstChild) {
						node = node.firstChild
					}
					return node
				}
				function getSiblingNode(node) {
					while (node) {
						if (node.nextSibling) {
							return node.nextSibling
						}
						node = node.parentNode
					}
				}
				function getNodeForCharacterOffset(root3, offset) {
					var node = getLeafNode(root3)
					var nodeStart = 0
					var nodeEnd = 0
					while (node) {
						if (node.nodeType === TEXT_NODE) {
							nodeEnd = nodeStart + node.textContent.length
							if (nodeStart <= offset && nodeEnd >= offset) {
								return {
									node,
									offset: offset - nodeStart,
								}
							}
							nodeStart = nodeEnd
						}
						node = getLeafNode(getSiblingNode(node))
					}
				}
				function getOffsets(outerNode) {
					var ownerDocument = outerNode.ownerDocument
					var win = (ownerDocument && ownerDocument.defaultView) || window
					var selection = win.getSelection && win.getSelection()
					if (!selection || selection.rangeCount === 0) {
						return null
					}
					var anchorNode = selection.anchorNode,
						anchorOffset = selection.anchorOffset,
						focusNode = selection.focusNode,
						focusOffset = selection.focusOffset
					try {
						anchorNode.nodeType
						focusNode.nodeType
					} catch (e2) {
						return null
					}
					return getModernOffsetsFromPoints(
						outerNode,
						anchorNode,
						anchorOffset,
						focusNode,
						focusOffset
					)
				}
				function getModernOffsetsFromPoints(
					outerNode,
					anchorNode,
					anchorOffset,
					focusNode,
					focusOffset
				) {
					var length = 0
					var start = -1
					var end = -1
					var indexWithinAnchor = 0
					var indexWithinFocus = 0
					var node = outerNode
					var parentNode = null
					outer: while (true) {
						var next = null
						while (true) {
							if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
								start = length + anchorOffset
							}
							if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
								end = length + focusOffset
							}
							if (node.nodeType === TEXT_NODE) {
								length += node.nodeValue.length
							}
							if ((next = node.firstChild) === null) {
								break
							}
							parentNode = node
							node = next
						}
						while (true) {
							if (node === outerNode) {
								break outer
							}
							if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
								start = length
							}
							if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
								end = length
							}
							if ((next = node.nextSibling) !== null) {
								break
							}
							node = parentNode
							parentNode = node.parentNode
						}
						node = next
					}
					if (start === -1 || end === -1) {
						return null
					}
					return {
						start,
						end,
					}
				}
				function setOffsets(node, offsets) {
					var doc = node.ownerDocument || document
					var win = (doc && doc.defaultView) || window
					if (!win.getSelection) {
						return
					}
					var selection = win.getSelection()
					var length = node.textContent.length
					var start = Math.min(offsets.start, length)
					var end = offsets.end === void 0 ? start : Math.min(offsets.end, length)
					if (!selection.extend && start > end) {
						var temp = end
						end = start
						start = temp
					}
					var startMarker = getNodeForCharacterOffset(node, start)
					var endMarker = getNodeForCharacterOffset(node, end)
					if (startMarker && endMarker) {
						if (
							selection.rangeCount === 1 &&
							selection.anchorNode === startMarker.node &&
							selection.anchorOffset === startMarker.offset &&
							selection.focusNode === endMarker.node &&
							selection.focusOffset === endMarker.offset
						) {
							return
						}
						var range = doc.createRange()
						range.setStart(startMarker.node, startMarker.offset)
						selection.removeAllRanges()
						if (start > end) {
							selection.addRange(range)
							selection.extend(endMarker.node, endMarker.offset)
						} else {
							range.setEnd(endMarker.node, endMarker.offset)
							selection.addRange(range)
						}
					}
				}
				function isTextNode(node) {
					return node && node.nodeType === TEXT_NODE
				}
				function containsNode(outerNode, innerNode) {
					if (!outerNode || !innerNode) {
						return false
					} else if (outerNode === innerNode) {
						return true
					} else if (isTextNode(outerNode)) {
						return false
					} else if (isTextNode(innerNode)) {
						return containsNode(outerNode, innerNode.parentNode)
					} else if ('contains' in outerNode) {
						return outerNode.contains(innerNode)
					} else if (outerNode.compareDocumentPosition) {
						return !!(outerNode.compareDocumentPosition(innerNode) & 16)
					} else {
						return false
					}
				}
				function isInDocument(node) {
					return (
						node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node)
					)
				}
				function isSameOriginFrame(iframe) {
					try {
						return typeof iframe.contentWindow.location.href === 'string'
					} catch (err) {
						return false
					}
				}
				function getActiveElementDeep() {
					var win = window
					var element = getActiveElement()
					while (element instanceof win.HTMLIFrameElement) {
						if (isSameOriginFrame(element)) {
							win = element.contentWindow
						} else {
							return element
						}
						element = getActiveElement(win.document)
					}
					return element
				}
				function hasSelectionCapabilities(elem) {
					var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase()
					return (
						nodeName &&
						((nodeName === 'input' &&
							(elem.type === 'text' ||
								elem.type === 'search' ||
								elem.type === 'tel' ||
								elem.type === 'url' ||
								elem.type === 'password')) ||
							nodeName === 'textarea' ||
							elem.contentEditable === 'true')
					)
				}
				function getSelectionInformation() {
					var focusedElem = getActiveElementDeep()
					return {
						focusedElem,
						selectionRange: hasSelectionCapabilities(focusedElem)
							? getSelection(focusedElem)
							: null,
					}
				}
				function restoreSelection(priorSelectionInformation) {
					var curFocusedElem = getActiveElementDeep()
					var priorFocusedElem = priorSelectionInformation.focusedElem
					var priorSelectionRange = priorSelectionInformation.selectionRange
					if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
						if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
							setSelection(priorFocusedElem, priorSelectionRange)
						}
						var ancestors = []
						var ancestor = priorFocusedElem
						while ((ancestor = ancestor.parentNode)) {
							if (ancestor.nodeType === ELEMENT_NODE) {
								ancestors.push({
									element: ancestor,
									left: ancestor.scrollLeft,
									top: ancestor.scrollTop,
								})
							}
						}
						if (typeof priorFocusedElem.focus === 'function') {
							priorFocusedElem.focus()
						}
						for (var i3 = 0; i3 < ancestors.length; i3++) {
							var info = ancestors[i3]
							info.element.scrollLeft = info.left
							info.element.scrollTop = info.top
						}
					}
				}
				function getSelection(input) {
					var selection
					if ('selectionStart' in input) {
						selection = {
							start: input.selectionStart,
							end: input.selectionEnd,
						}
					} else {
						selection = getOffsets(input)
					}
					return (
						selection || {
							start: 0,
							end: 0,
						}
					)
				}
				function setSelection(input, offsets) {
					var start = offsets.start
					var end = offsets.end
					if (end === void 0) {
						end = start
					}
					if ('selectionStart' in input) {
						input.selectionStart = start
						input.selectionEnd = Math.min(end, input.value.length)
					} else {
						setOffsets(input, offsets)
					}
				}
				var skipSelectionChangeEvent =
					canUseDOM && 'documentMode' in document && document.documentMode <= 11
				function registerEvents$3() {
					registerTwoPhaseEvent('onSelect', [
						'focusout',
						'contextmenu',
						'dragend',
						'focusin',
						'keydown',
						'keyup',
						'mousedown',
						'mouseup',
						'selectionchange',
					])
				}
				var activeElement$1 = null
				var activeElementInst$1 = null
				var lastSelection = null
				var mouseDown = false
				function getSelection$1(node) {
					if ('selectionStart' in node && hasSelectionCapabilities(node)) {
						return {
							start: node.selectionStart,
							end: node.selectionEnd,
						}
					} else {
						var win = (node.ownerDocument && node.ownerDocument.defaultView) || window
						var selection = win.getSelection()
						return {
							anchorNode: selection.anchorNode,
							anchorOffset: selection.anchorOffset,
							focusNode: selection.focusNode,
							focusOffset: selection.focusOffset,
						}
					}
				}
				function getEventTargetDocument(eventTarget) {
					return eventTarget.window === eventTarget
						? eventTarget.document
						: eventTarget.nodeType === DOCUMENT_NODE
						? eventTarget
						: eventTarget.ownerDocument
				}
				function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
					var doc = getEventTargetDocument(nativeEventTarget)
					if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
						return
					}
					var currentSelection = getSelection$1(activeElement$1)
					if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
						lastSelection = currentSelection
						var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect')
						if (listeners.length > 0) {
							var event = new SyntheticEvent(
								'onSelect',
								'select',
								null,
								nativeEvent,
								nativeEventTarget
							)
							dispatchQueue.push({
								event,
								listeners,
							})
							event.target = activeElement$1
						}
					}
				}
				function extractEvents$3(
					dispatchQueue,
					domEventName,
					targetInst,
					nativeEvent,
					nativeEventTarget,
					eventSystemFlags,
					targetContainer
				) {
					var targetNode = targetInst ? getNodeFromInstance(targetInst) : window
					switch (domEventName) {
						case 'focusin':
							if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
								activeElement$1 = targetNode
								activeElementInst$1 = targetInst
								lastSelection = null
							}
							break
						case 'focusout':
							activeElement$1 = null
							activeElementInst$1 = null
							lastSelection = null
							break
						case 'mousedown':
							mouseDown = true
							break
						case 'contextmenu':
						case 'mouseup':
						case 'dragend':
							mouseDown = false
							constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget)
							break
						case 'selectionchange':
							if (skipSelectionChangeEvent) {
								break
							}
						case 'keydown':
						case 'keyup':
							constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget)
					}
				}
				function makePrefixMap(styleProp, eventName) {
					var prefixes2 = {}
					prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase()
					prefixes2['Webkit' + styleProp] = 'webkit' + eventName
					prefixes2['Moz' + styleProp] = 'moz' + eventName
					return prefixes2
				}
				var vendorPrefixes = {
					animationend: makePrefixMap('Animation', 'AnimationEnd'),
					animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
					animationstart: makePrefixMap('Animation', 'AnimationStart'),
					transitionend: makePrefixMap('Transition', 'TransitionEnd'),
				}
				var prefixedEventNames = {}
				var style = {}
				if (canUseDOM) {
					style = document.createElement('div').style
					if (!('AnimationEvent' in window)) {
						delete vendorPrefixes.animationend.animation
						delete vendorPrefixes.animationiteration.animation
						delete vendorPrefixes.animationstart.animation
					}
					if (!('TransitionEvent' in window)) {
						delete vendorPrefixes.transitionend.transition
					}
				}
				function getVendorPrefixedEventName(eventName) {
					if (prefixedEventNames[eventName]) {
						return prefixedEventNames[eventName]
					} else if (!vendorPrefixes[eventName]) {
						return eventName
					}
					var prefixMap = vendorPrefixes[eventName]
					for (var styleProp in prefixMap) {
						if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
							return (prefixedEventNames[eventName] = prefixMap[styleProp])
						}
					}
					return eventName
				}
				var ANIMATION_END = getVendorPrefixedEventName('animationend')
				var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration')
				var ANIMATION_START = getVendorPrefixedEventName('animationstart')
				var TRANSITION_END = getVendorPrefixedEventName('transitionend')
				var topLevelEventsToReactNames = /* @__PURE__ */ new Map()
				var simpleEventPluginEvents = [
					'abort',
					'auxClick',
					'cancel',
					'canPlay',
					'canPlayThrough',
					'click',
					'close',
					'contextMenu',
					'copy',
					'cut',
					'drag',
					'dragEnd',
					'dragEnter',
					'dragExit',
					'dragLeave',
					'dragOver',
					'dragStart',
					'drop',
					'durationChange',
					'emptied',
					'encrypted',
					'ended',
					'error',
					'gotPointerCapture',
					'input',
					'invalid',
					'keyDown',
					'keyPress',
					'keyUp',
					'load',
					'loadedData',
					'loadedMetadata',
					'loadStart',
					'lostPointerCapture',
					'mouseDown',
					'mouseMove',
					'mouseOut',
					'mouseOver',
					'mouseUp',
					'paste',
					'pause',
					'play',
					'playing',
					'pointerCancel',
					'pointerDown',
					'pointerMove',
					'pointerOut',
					'pointerOver',
					'pointerUp',
					'progress',
					'rateChange',
					'reset',
					'resize',
					'seeked',
					'seeking',
					'stalled',
					'submit',
					'suspend',
					'timeUpdate',
					'touchCancel',
					'touchEnd',
					'touchStart',
					'volumeChange',
					'scroll',
					'toggle',
					'touchMove',
					'waiting',
					'wheel',
				]
				function registerSimpleEvent(domEventName, reactName) {
					topLevelEventsToReactNames.set(domEventName, reactName)
					registerTwoPhaseEvent(reactName, [domEventName])
				}
				function registerSimpleEvents() {
					for (var i3 = 0; i3 < simpleEventPluginEvents.length; i3++) {
						var eventName = simpleEventPluginEvents[i3]
						var domEventName = eventName.toLowerCase()
						var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1)
						registerSimpleEvent(domEventName, 'on' + capitalizedEvent)
					}
					registerSimpleEvent(ANIMATION_END, 'onAnimationEnd')
					registerSimpleEvent(ANIMATION_ITERATION, 'onAnimationIteration')
					registerSimpleEvent(ANIMATION_START, 'onAnimationStart')
					registerSimpleEvent('dblclick', 'onDoubleClick')
					registerSimpleEvent('focusin', 'onFocus')
					registerSimpleEvent('focusout', 'onBlur')
					registerSimpleEvent(TRANSITION_END, 'onTransitionEnd')
				}
				function extractEvents$4(
					dispatchQueue,
					domEventName,
					targetInst,
					nativeEvent,
					nativeEventTarget,
					eventSystemFlags,
					targetContainer
				) {
					var reactName = topLevelEventsToReactNames.get(domEventName)
					if (reactName === void 0) {
						return
					}
					var SyntheticEventCtor = SyntheticEvent
					var reactEventType = domEventName
					switch (domEventName) {
						case 'keypress':
							if (getEventCharCode(nativeEvent) === 0) {
								return
							}
						case 'keydown':
						case 'keyup':
							SyntheticEventCtor = SyntheticKeyboardEvent
							break
						case 'focusin':
							reactEventType = 'focus'
							SyntheticEventCtor = SyntheticFocusEvent
							break
						case 'focusout':
							reactEventType = 'blur'
							SyntheticEventCtor = SyntheticFocusEvent
							break
						case 'beforeblur':
						case 'afterblur':
							SyntheticEventCtor = SyntheticFocusEvent
							break
						case 'click':
							if (nativeEvent.button === 2) {
								return
							}
						case 'auxclick':
						case 'dblclick':
						case 'mousedown':
						case 'mousemove':
						case 'mouseup':
						case 'mouseout':
						case 'mouseover':
						case 'contextmenu':
							SyntheticEventCtor = SyntheticMouseEvent
							break
						case 'drag':
						case 'dragend':
						case 'dragenter':
						case 'dragexit':
						case 'dragleave':
						case 'dragover':
						case 'dragstart':
						case 'drop':
							SyntheticEventCtor = SyntheticDragEvent
							break
						case 'touchcancel':
						case 'touchend':
						case 'touchmove':
						case 'touchstart':
							SyntheticEventCtor = SyntheticTouchEvent
							break
						case ANIMATION_END:
						case ANIMATION_ITERATION:
						case ANIMATION_START:
							SyntheticEventCtor = SyntheticAnimationEvent
							break
						case TRANSITION_END:
							SyntheticEventCtor = SyntheticTransitionEvent
							break
						case 'scroll':
							SyntheticEventCtor = SyntheticUIEvent
							break
						case 'wheel':
							SyntheticEventCtor = SyntheticWheelEvent
							break
						case 'copy':
						case 'cut':
						case 'paste':
							SyntheticEventCtor = SyntheticClipboardEvent
							break
						case 'gotpointercapture':
						case 'lostpointercapture':
						case 'pointercancel':
						case 'pointerdown':
						case 'pointermove':
						case 'pointerout':
						case 'pointerover':
						case 'pointerup':
							SyntheticEventCtor = SyntheticPointerEvent
							break
					}
					var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0
					{
						var accumulateTargetOnly =
							!inCapturePhase && // TODO: ideally, we'd eventually add all events from
							// nonDelegatedEvents list in DOMPluginEventSystem.
							// Then we can remove this special list.
							// This is a breaking change that can wait until React 18.
							domEventName === 'scroll'
						var _listeners = accumulateSinglePhaseListeners(
							targetInst,
							reactName,
							nativeEvent.type,
							inCapturePhase,
							accumulateTargetOnly
						)
						if (_listeners.length > 0) {
							var _event = new SyntheticEventCtor(
								reactName,
								reactEventType,
								null,
								nativeEvent,
								nativeEventTarget
							)
							dispatchQueue.push({
								event: _event,
								listeners: _listeners,
							})
						}
					}
				}
				registerSimpleEvents()
				registerEvents$2()
				registerEvents$1()
				registerEvents$3()
				registerEvents()
				function extractEvents$5(
					dispatchQueue,
					domEventName,
					targetInst,
					nativeEvent,
					nativeEventTarget,
					eventSystemFlags,
					targetContainer
				) {
					extractEvents$4(
						dispatchQueue,
						domEventName,
						targetInst,
						nativeEvent,
						nativeEventTarget,
						eventSystemFlags
					)
					var shouldProcessPolyfillPlugins =
						(eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0
					if (shouldProcessPolyfillPlugins) {
						extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget)
						extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget)
						extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget)
						extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget)
					}
				}
				var mediaEventTypes = [
					'abort',
					'canplay',
					'canplaythrough',
					'durationchange',
					'emptied',
					'encrypted',
					'ended',
					'error',
					'loadeddata',
					'loadedmetadata',
					'loadstart',
					'pause',
					'play',
					'playing',
					'progress',
					'ratechange',
					'resize',
					'seeked',
					'seeking',
					'stalled',
					'suspend',
					'timeupdate',
					'volumechange',
					'waiting',
				]
				var nonDelegatedEvents = new Set(
					['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(mediaEventTypes)
				)
				function executeDispatch(event, listener, currentTarget) {
					var type = event.type || 'unknown-event'
					event.currentTarget = currentTarget
					invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event)
					event.currentTarget = null
				}
				function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
					var previousInstance
					if (inCapturePhase) {
						for (var i3 = dispatchListeners.length - 1; i3 >= 0; i3--) {
							var _dispatchListeners$i = dispatchListeners[i3],
								instance = _dispatchListeners$i.instance,
								currentTarget = _dispatchListeners$i.currentTarget,
								listener = _dispatchListeners$i.listener
							if (instance !== previousInstance && event.isPropagationStopped()) {
								return
							}
							executeDispatch(event, listener, currentTarget)
							previousInstance = instance
						}
					} else {
						for (var _i = 0; _i < dispatchListeners.length; _i++) {
							var _dispatchListeners$_i = dispatchListeners[_i],
								_instance = _dispatchListeners$_i.instance,
								_currentTarget = _dispatchListeners$_i.currentTarget,
								_listener = _dispatchListeners$_i.listener
							if (_instance !== previousInstance && event.isPropagationStopped()) {
								return
							}
							executeDispatch(event, _listener, _currentTarget)
							previousInstance = _instance
						}
					}
				}
				function processDispatchQueue(dispatchQueue, eventSystemFlags) {
					var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0
					for (var i3 = 0; i3 < dispatchQueue.length; i3++) {
						var _dispatchQueue$i = dispatchQueue[i3],
							event = _dispatchQueue$i.event,
							listeners = _dispatchQueue$i.listeners
						processDispatchQueueItemsInOrder(event, listeners, inCapturePhase)
					}
					rethrowCaughtError()
				}
				function dispatchEventsForPlugins(
					domEventName,
					eventSystemFlags,
					nativeEvent,
					targetInst,
					targetContainer
				) {
					var nativeEventTarget = getEventTarget(nativeEvent)
					var dispatchQueue = []
					extractEvents$5(
						dispatchQueue,
						domEventName,
						targetInst,
						nativeEvent,
						nativeEventTarget,
						eventSystemFlags
					)
					processDispatchQueue(dispatchQueue, eventSystemFlags)
				}
				function listenToNonDelegatedEvent(domEventName, targetElement) {
					{
						if (!nonDelegatedEvents.has(domEventName)) {
							error(
								'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
								domEventName
							)
						}
					}
					var isCapturePhaseListener = false
					var listenerSet = getEventListenerSet(targetElement)
					var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener)
					if (!listenerSet.has(listenerSetKey)) {
						addTrappedEventListener(
							targetElement,
							domEventName,
							IS_NON_DELEGATED,
							isCapturePhaseListener
						)
						listenerSet.add(listenerSetKey)
					}
				}
				function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
					{
						if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
							error(
								'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
								domEventName
							)
						}
					}
					var eventSystemFlags = 0
					if (isCapturePhaseListener) {
						eventSystemFlags |= IS_CAPTURE_PHASE
					}
					addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener)
				}
				var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2)
				function listenToAllSupportedEvents(rootContainerElement) {
					if (!rootContainerElement[listeningMarker]) {
						rootContainerElement[listeningMarker] = true
						allNativeEvents.forEach(function (domEventName) {
							if (domEventName !== 'selectionchange') {
								if (!nonDelegatedEvents.has(domEventName)) {
									listenToNativeEvent(domEventName, false, rootContainerElement)
								}
								listenToNativeEvent(domEventName, true, rootContainerElement)
							}
						})
						var ownerDocument =
							rootContainerElement.nodeType === DOCUMENT_NODE
								? rootContainerElement
								: rootContainerElement.ownerDocument
						if (ownerDocument !== null) {
							if (!ownerDocument[listeningMarker]) {
								ownerDocument[listeningMarker] = true
								listenToNativeEvent('selectionchange', false, ownerDocument)
							}
						}
					}
				}
				function addTrappedEventListener(
					targetContainer,
					domEventName,
					eventSystemFlags,
					isCapturePhaseListener,
					isDeferredListenerForLegacyFBSupport
				) {
					var listener = createEventListenerWrapperWithPriority(
						targetContainer,
						domEventName,
						eventSystemFlags
					)
					var isPassiveListener = void 0
					if (passiveBrowserEventsSupported) {
						if (
							domEventName === 'touchstart' ||
							domEventName === 'touchmove' ||
							domEventName === 'wheel'
						) {
							isPassiveListener = true
						}
					}
					targetContainer = targetContainer
					var unsubscribeListener
					if (isCapturePhaseListener) {
						if (isPassiveListener !== void 0) {
							unsubscribeListener = addEventCaptureListenerWithPassiveFlag(
								targetContainer,
								domEventName,
								listener,
								isPassiveListener
							)
						} else {
							unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener)
						}
					} else {
						if (isPassiveListener !== void 0) {
							unsubscribeListener = addEventBubbleListenerWithPassiveFlag(
								targetContainer,
								domEventName,
								listener,
								isPassiveListener
							)
						} else {
							unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener)
						}
					}
				}
				function isMatchingRootContainer(grandContainer, targetContainer) {
					return (
						grandContainer === targetContainer ||
						(grandContainer.nodeType === COMMENT_NODE &&
							grandContainer.parentNode === targetContainer)
					)
				}
				function dispatchEventForPluginEventSystem(
					domEventName,
					eventSystemFlags,
					nativeEvent,
					targetInst,
					targetContainer
				) {
					var ancestorInst = targetInst
					if (
						(eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 &&
						(eventSystemFlags & IS_NON_DELEGATED) === 0
					) {
						var targetContainerNode = targetContainer
						if (targetInst !== null) {
							var node = targetInst
							mainLoop: while (true) {
								if (node === null) {
									return
								}
								var nodeTag = node.tag
								if (nodeTag === HostRoot || nodeTag === HostPortal) {
									var container = node.stateNode.containerInfo
									if (isMatchingRootContainer(container, targetContainerNode)) {
										break
									}
									if (nodeTag === HostPortal) {
										var grandNode = node.return
										while (grandNode !== null) {
											var grandTag = grandNode.tag
											if (grandTag === HostRoot || grandTag === HostPortal) {
												var grandContainer = grandNode.stateNode.containerInfo
												if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
													return
												}
											}
											grandNode = grandNode.return
										}
									}
									while (container !== null) {
										var parentNode = getClosestInstanceFromNode(container)
										if (parentNode === null) {
											return
										}
										var parentTag = parentNode.tag
										if (parentTag === HostComponent || parentTag === HostText) {
											node = ancestorInst = parentNode
											continue mainLoop
										}
										container = container.parentNode
									}
								}
								node = node.return
							}
						}
					}
					batchedUpdates(function () {
						return dispatchEventsForPlugins(
							domEventName,
							eventSystemFlags,
							nativeEvent,
							ancestorInst
						)
					})
				}
				function createDispatchListener(instance, listener, currentTarget) {
					return {
						instance,
						listener,
						currentTarget,
					}
				}
				function accumulateSinglePhaseListeners(
					targetFiber,
					reactName,
					nativeEventType,
					inCapturePhase,
					accumulateTargetOnly,
					nativeEvent
				) {
					var captureName = reactName !== null ? reactName + 'Capture' : null
					var reactEventName = inCapturePhase ? captureName : reactName
					var listeners = []
					var instance = targetFiber
					var lastHostComponent = null
					while (instance !== null) {
						var _instance2 = instance,
							stateNode = _instance2.stateNode,
							tag = _instance2.tag
						if (tag === HostComponent && stateNode !== null) {
							lastHostComponent = stateNode
							if (reactEventName !== null) {
								var listener = getListener(instance, reactEventName)
								if (listener != null) {
									listeners.push(createDispatchListener(instance, listener, lastHostComponent))
								}
							}
						}
						if (accumulateTargetOnly) {
							break
						}
						instance = instance.return
					}
					return listeners
				}
				function accumulateTwoPhaseListeners(targetFiber, reactName) {
					var captureName = reactName + 'Capture'
					var listeners = []
					var instance = targetFiber
					while (instance !== null) {
						var _instance3 = instance,
							stateNode = _instance3.stateNode,
							tag = _instance3.tag
						if (tag === HostComponent && stateNode !== null) {
							var currentTarget = stateNode
							var captureListener = getListener(instance, captureName)
							if (captureListener != null) {
								listeners.unshift(createDispatchListener(instance, captureListener, currentTarget))
							}
							var bubbleListener = getListener(instance, reactName)
							if (bubbleListener != null) {
								listeners.push(createDispatchListener(instance, bubbleListener, currentTarget))
							}
						}
						instance = instance.return
					}
					return listeners
				}
				function getParent(inst) {
					if (inst === null) {
						return null
					}
					do {
						inst = inst.return
					} while (inst && inst.tag !== HostComponent)
					if (inst) {
						return inst
					}
					return null
				}
				function getLowestCommonAncestor(instA, instB) {
					var nodeA = instA
					var nodeB = instB
					var depthA = 0
					for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
						depthA++
					}
					var depthB = 0
					for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
						depthB++
					}
					while (depthA - depthB > 0) {
						nodeA = getParent(nodeA)
						depthA--
					}
					while (depthB - depthA > 0) {
						nodeB = getParent(nodeB)
						depthB--
					}
					var depth = depthA
					while (depth--) {
						if (nodeA === nodeB || (nodeB !== null && nodeA === nodeB.alternate)) {
							return nodeA
						}
						nodeA = getParent(nodeA)
						nodeB = getParent(nodeB)
					}
					return null
				}
				function accumulateEnterLeaveListenersForEvent(
					dispatchQueue,
					event,
					target,
					common,
					inCapturePhase
				) {
					var registrationName = event._reactName
					var listeners = []
					var instance = target
					while (instance !== null) {
						if (instance === common) {
							break
						}
						var _instance4 = instance,
							alternate = _instance4.alternate,
							stateNode = _instance4.stateNode,
							tag = _instance4.tag
						if (alternate !== null && alternate === common) {
							break
						}
						if (tag === HostComponent && stateNode !== null) {
							var currentTarget = stateNode
							if (inCapturePhase) {
								var captureListener = getListener(instance, registrationName)
								if (captureListener != null) {
									listeners.unshift(
										createDispatchListener(instance, captureListener, currentTarget)
									)
								}
							} else if (!inCapturePhase) {
								var bubbleListener = getListener(instance, registrationName)
								if (bubbleListener != null) {
									listeners.push(createDispatchListener(instance, bubbleListener, currentTarget))
								}
							}
						}
						instance = instance.return
					}
					if (listeners.length !== 0) {
						dispatchQueue.push({
							event,
							listeners,
						})
					}
				}
				function accumulateEnterLeaveTwoPhaseListeners(
					dispatchQueue,
					leaveEvent,
					enterEvent,
					from,
					to
				) {
					var common = from && to ? getLowestCommonAncestor(from, to) : null
					if (from !== null) {
						accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false)
					}
					if (to !== null && enterEvent !== null) {
						accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true)
					}
				}
				function getListenerSetKey(domEventName, capture) {
					return domEventName + '__' + (capture ? 'capture' : 'bubble')
				}
				var didWarnInvalidHydration = false
				var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML'
				var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning'
				var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning'
				var AUTOFOCUS = 'autoFocus'
				var CHILDREN = 'children'
				var STYLE = 'style'
				var HTML$1 = '__html'
				var warnedUnknownTags
				var validatePropertiesInDevelopment
				var warnForPropDifference
				var warnForExtraAttributes
				var warnForInvalidEventListener
				var canDiffStyleForHydrationWarning
				var normalizeHTML
				{
					warnedUnknownTags = {
						// There are working polyfills for <dialog>. Let people use it.
						dialog: true,
						// Electron ships a custom <webview> tag to display external web content in
						// an isolated frame and process.
						// This tag is not present in non Electron environments such as JSDom which
						// is often used for testing purposes.
						// @see https://electronjs.org/docs/api/webview-tag
						webview: true,
					}
					validatePropertiesInDevelopment = function (type, props) {
						validateProperties(type, props)
						validateProperties$1(type, props)
						validateProperties$2(type, props, {
							registrationNameDependencies,
							possibleRegistrationNames,
						})
					}
					canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode
					warnForPropDifference = function (propName, serverValue, clientValue) {
						if (didWarnInvalidHydration) {
							return
						}
						var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue)
						var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue)
						if (normalizedServerValue === normalizedClientValue) {
							return
						}
						didWarnInvalidHydration = true
						error(
							'Prop `%s` did not match. Server: %s Client: %s',
							propName,
							JSON.stringify(normalizedServerValue),
							JSON.stringify(normalizedClientValue)
						)
					}
					warnForExtraAttributes = function (attributeNames) {
						if (didWarnInvalidHydration) {
							return
						}
						didWarnInvalidHydration = true
						var names = []
						attributeNames.forEach(function (name) {
							names.push(name)
						})
						error('Extra attributes from the server: %s', names)
					}
					warnForInvalidEventListener = function (registrationName, listener) {
						if (listener === false) {
							error(
								'Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
								registrationName,
								registrationName,
								registrationName
							)
						} else {
							error(
								'Expected `%s` listener to be a function, instead got a value of `%s` type.',
								registrationName,
								typeof listener
							)
						}
					}
					normalizeHTML = function (parent, html) {
						var testElement =
							parent.namespaceURI === HTML_NAMESPACE
								? parent.ownerDocument.createElement(parent.tagName)
								: parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName)
						testElement.innerHTML = html
						return testElement.innerHTML
					}
				}
				var NORMALIZE_NEWLINES_REGEX = /\r\n?/g
				var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g
				function normalizeMarkupForTextOrAttribute(markup) {
					{
						checkHtmlStringCoercion(markup)
					}
					var markupString = typeof markup === 'string' ? markup : '' + markup
					return markupString
						.replace(NORMALIZE_NEWLINES_REGEX, '\n')
						.replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '')
				}
				function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
					var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText)
					var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText)
					if (normalizedServerText === normalizedClientText) {
						return
					}
					if (shouldWarnDev) {
						{
							if (!didWarnInvalidHydration) {
								didWarnInvalidHydration = true
								error(
									'Text content did not match. Server: "%s" Client: "%s"',
									normalizedServerText,
									normalizedClientText
								)
							}
						}
					}
					if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
						throw new Error('Text content does not match server-rendered HTML.')
					}
				}
				function getOwnerDocumentFromRootContainer(rootContainerElement) {
					return rootContainerElement.nodeType === DOCUMENT_NODE
						? rootContainerElement
						: rootContainerElement.ownerDocument
				}
				function noop3() {}
				function trapClickOnNonInteractiveElement(node) {
					node.onclick = noop3
				}
				function setInitialDOMProperties(
					tag,
					domElement,
					rootContainerElement,
					nextProps,
					isCustomComponentTag
				) {
					for (var propKey in nextProps) {
						if (!nextProps.hasOwnProperty(propKey)) {
							continue
						}
						var nextProp = nextProps[propKey]
						if (propKey === STYLE) {
							{
								if (nextProp) {
									Object.freeze(nextProp)
								}
							}
							setValueForStyles(domElement, nextProp)
						} else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
							var nextHtml = nextProp ? nextProp[HTML$1] : void 0
							if (nextHtml != null) {
								setInnerHTML(domElement, nextHtml)
							}
						} else if (propKey === CHILDREN) {
							if (typeof nextProp === 'string') {
								var canSetTextContent = tag !== 'textarea' || nextProp !== ''
								if (canSetTextContent) {
									setTextContent(domElement, nextProp)
								}
							} else if (typeof nextProp === 'number') {
								setTextContent(domElement, '' + nextProp)
							}
						} else if (
							propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
							propKey === SUPPRESS_HYDRATION_WARNING
						);
						else if (propKey === AUTOFOCUS);
						else if (registrationNameDependencies.hasOwnProperty(propKey)) {
							if (nextProp != null) {
								if (typeof nextProp !== 'function') {
									warnForInvalidEventListener(propKey, nextProp)
								}
								if (propKey === 'onScroll') {
									listenToNonDelegatedEvent('scroll', domElement)
								}
							}
						} else if (nextProp != null) {
							setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag)
						}
					}
				}
				function updateDOMProperties(
					domElement,
					updatePayload,
					wasCustomComponentTag,
					isCustomComponentTag
				) {
					for (var i3 = 0; i3 < updatePayload.length; i3 += 2) {
						var propKey = updatePayload[i3]
						var propValue = updatePayload[i3 + 1]
						if (propKey === STYLE) {
							setValueForStyles(domElement, propValue)
						} else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
							setInnerHTML(domElement, propValue)
						} else if (propKey === CHILDREN) {
							setTextContent(domElement, propValue)
						} else {
							setValueForProperty(domElement, propKey, propValue, isCustomComponentTag)
						}
					}
				}
				function createElement6(type, props, rootContainerElement, parentNamespace) {
					var isCustomComponentTag
					var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement)
					var domElement
					var namespaceURI = parentNamespace
					if (namespaceURI === HTML_NAMESPACE) {
						namespaceURI = getIntrinsicNamespace(type)
					}
					if (namespaceURI === HTML_NAMESPACE) {
						{
							isCustomComponentTag = isCustomComponent(type, props)
							if (!isCustomComponentTag && type !== type.toLowerCase()) {
								error(
									'<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.',
									type
								)
							}
						}
						if (type === 'script') {
							var div = ownerDocument.createElement('div')
							div.innerHTML = '<script></script>'
							var firstChild = div.firstChild
							domElement = div.removeChild(firstChild)
						} else if (typeof props.is === 'string') {
							domElement = ownerDocument.createElement(type, {
								is: props.is,
							})
						} else {
							domElement = ownerDocument.createElement(type)
							if (type === 'select') {
								var node = domElement
								if (props.multiple) {
									node.multiple = true
								} else if (props.size) {
									node.size = props.size
								}
							}
						}
					} else {
						domElement = ownerDocument.createElementNS(namespaceURI, type)
					}
					{
						if (namespaceURI === HTML_NAMESPACE) {
							if (
								!isCustomComponentTag &&
								Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' &&
								!hasOwnProperty2.call(warnedUnknownTags, type)
							) {
								warnedUnknownTags[type] = true
								error(
									'The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.',
									type
								)
							}
						}
					}
					return domElement
				}
				function createTextNode(text, rootContainerElement) {
					return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text)
				}
				function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
					var isCustomComponentTag = isCustomComponent(tag, rawProps)
					{
						validatePropertiesInDevelopment(tag, rawProps)
					}
					var props
					switch (tag) {
						case 'dialog':
							listenToNonDelegatedEvent('cancel', domElement)
							listenToNonDelegatedEvent('close', domElement)
							props = rawProps
							break
						case 'iframe':
						case 'object':
						case 'embed':
							listenToNonDelegatedEvent('load', domElement)
							props = rawProps
							break
						case 'video':
						case 'audio':
							for (var i3 = 0; i3 < mediaEventTypes.length; i3++) {
								listenToNonDelegatedEvent(mediaEventTypes[i3], domElement)
							}
							props = rawProps
							break
						case 'source':
							listenToNonDelegatedEvent('error', domElement)
							props = rawProps
							break
						case 'img':
						case 'image':
						case 'link':
							listenToNonDelegatedEvent('error', domElement)
							listenToNonDelegatedEvent('load', domElement)
							props = rawProps
							break
						case 'details':
							listenToNonDelegatedEvent('toggle', domElement)
							props = rawProps
							break
						case 'input':
							initWrapperState(domElement, rawProps)
							props = getHostProps(domElement, rawProps)
							listenToNonDelegatedEvent('invalid', domElement)
							break
						case 'option':
							validateProps(domElement, rawProps)
							props = rawProps
							break
						case 'select':
							initWrapperState$1(domElement, rawProps)
							props = getHostProps$1(domElement, rawProps)
							listenToNonDelegatedEvent('invalid', domElement)
							break
						case 'textarea':
							initWrapperState$2(domElement, rawProps)
							props = getHostProps$2(domElement, rawProps)
							listenToNonDelegatedEvent('invalid', domElement)
							break
						default:
							props = rawProps
					}
					assertValidProps(tag, props)
					setInitialDOMProperties(
						tag,
						domElement,
						rootContainerElement,
						props,
						isCustomComponentTag
					)
					switch (tag) {
						case 'input':
							track2(domElement)
							postMountWrapper(domElement, rawProps, false)
							break
						case 'textarea':
							track2(domElement)
							postMountWrapper$3(domElement)
							break
						case 'option':
							postMountWrapper$1(domElement, rawProps)
							break
						case 'select':
							postMountWrapper$2(domElement, rawProps)
							break
						default:
							if (typeof props.onClick === 'function') {
								trapClickOnNonInteractiveElement(domElement)
							}
							break
					}
				}
				function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
					{
						validatePropertiesInDevelopment(tag, nextRawProps)
					}
					var updatePayload = null
					var lastProps
					var nextProps
					switch (tag) {
						case 'input':
							lastProps = getHostProps(domElement, lastRawProps)
							nextProps = getHostProps(domElement, nextRawProps)
							updatePayload = []
							break
						case 'select':
							lastProps = getHostProps$1(domElement, lastRawProps)
							nextProps = getHostProps$1(domElement, nextRawProps)
							updatePayload = []
							break
						case 'textarea':
							lastProps = getHostProps$2(domElement, lastRawProps)
							nextProps = getHostProps$2(domElement, nextRawProps)
							updatePayload = []
							break
						default:
							lastProps = lastRawProps
							nextProps = nextRawProps
							if (
								typeof lastProps.onClick !== 'function' &&
								typeof nextProps.onClick === 'function'
							) {
								trapClickOnNonInteractiveElement(domElement)
							}
							break
					}
					assertValidProps(tag, nextProps)
					var propKey
					var styleName
					var styleUpdates = null
					for (propKey in lastProps) {
						if (
							nextProps.hasOwnProperty(propKey) ||
							!lastProps.hasOwnProperty(propKey) ||
							lastProps[propKey] == null
						) {
							continue
						}
						if (propKey === STYLE) {
							var lastStyle = lastProps[propKey]
							for (styleName in lastStyle) {
								if (lastStyle.hasOwnProperty(styleName)) {
									if (!styleUpdates) {
										styleUpdates = {}
									}
									styleUpdates[styleName] = ''
								}
							}
						} else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN);
						else if (
							propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
							propKey === SUPPRESS_HYDRATION_WARNING
						);
						else if (propKey === AUTOFOCUS);
						else if (registrationNameDependencies.hasOwnProperty(propKey)) {
							if (!updatePayload) {
								updatePayload = []
							}
						} else {
							;(updatePayload = updatePayload || []).push(propKey, null)
						}
					}
					for (propKey in nextProps) {
						var nextProp = nextProps[propKey]
						var lastProp = lastProps != null ? lastProps[propKey] : void 0
						if (
							!nextProps.hasOwnProperty(propKey) ||
							nextProp === lastProp ||
							(nextProp == null && lastProp == null)
						) {
							continue
						}
						if (propKey === STYLE) {
							{
								if (nextProp) {
									Object.freeze(nextProp)
								}
							}
							if (lastProp) {
								for (styleName in lastProp) {
									if (
										lastProp.hasOwnProperty(styleName) &&
										(!nextProp || !nextProp.hasOwnProperty(styleName))
									) {
										if (!styleUpdates) {
											styleUpdates = {}
										}
										styleUpdates[styleName] = ''
									}
								}
								for (styleName in nextProp) {
									if (
										nextProp.hasOwnProperty(styleName) &&
										lastProp[styleName] !== nextProp[styleName]
									) {
										if (!styleUpdates) {
											styleUpdates = {}
										}
										styleUpdates[styleName] = nextProp[styleName]
									}
								}
							} else {
								if (!styleUpdates) {
									if (!updatePayload) {
										updatePayload = []
									}
									updatePayload.push(propKey, styleUpdates)
								}
								styleUpdates = nextProp
							}
						} else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
							var nextHtml = nextProp ? nextProp[HTML$1] : void 0
							var lastHtml = lastProp ? lastProp[HTML$1] : void 0
							if (nextHtml != null) {
								if (lastHtml !== nextHtml) {
									;(updatePayload = updatePayload || []).push(propKey, nextHtml)
								}
							}
						} else if (propKey === CHILDREN) {
							if (typeof nextProp === 'string' || typeof nextProp === 'number') {
								;(updatePayload = updatePayload || []).push(propKey, '' + nextProp)
							}
						} else if (
							propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
							propKey === SUPPRESS_HYDRATION_WARNING
						);
						else if (registrationNameDependencies.hasOwnProperty(propKey)) {
							if (nextProp != null) {
								if (typeof nextProp !== 'function') {
									warnForInvalidEventListener(propKey, nextProp)
								}
								if (propKey === 'onScroll') {
									listenToNonDelegatedEvent('scroll', domElement)
								}
							}
							if (!updatePayload && lastProp !== nextProp) {
								updatePayload = []
							}
						} else {
							;(updatePayload = updatePayload || []).push(propKey, nextProp)
						}
					}
					if (styleUpdates) {
						{
							validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE])
						}
						;(updatePayload = updatePayload || []).push(STYLE, styleUpdates)
					}
					return updatePayload
				}
				function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
					if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
						updateChecked(domElement, nextRawProps)
					}
					var wasCustomComponentTag = isCustomComponent(tag, lastRawProps)
					var isCustomComponentTag = isCustomComponent(tag, nextRawProps)
					updateDOMProperties(
						domElement,
						updatePayload,
						wasCustomComponentTag,
						isCustomComponentTag
					)
					switch (tag) {
						case 'input':
							updateWrapper(domElement, nextRawProps)
							break
						case 'textarea':
							updateWrapper$1(domElement, nextRawProps)
							break
						case 'select':
							postUpdateWrapper(domElement, nextRawProps)
							break
					}
				}
				function getPossibleStandardName(propName) {
					{
						var lowerCasedName = propName.toLowerCase()
						if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
							return null
						}
						return possibleStandardNames[lowerCasedName] || null
					}
				}
				function diffHydratedProperties(
					domElement,
					tag,
					rawProps,
					parentNamespace,
					rootContainerElement,
					isConcurrentMode,
					shouldWarnDev
				) {
					var isCustomComponentTag
					var extraAttributeNames
					{
						isCustomComponentTag = isCustomComponent(tag, rawProps)
						validatePropertiesInDevelopment(tag, rawProps)
					}
					switch (tag) {
						case 'dialog':
							listenToNonDelegatedEvent('cancel', domElement)
							listenToNonDelegatedEvent('close', domElement)
							break
						case 'iframe':
						case 'object':
						case 'embed':
							listenToNonDelegatedEvent('load', domElement)
							break
						case 'video':
						case 'audio':
							for (var i3 = 0; i3 < mediaEventTypes.length; i3++) {
								listenToNonDelegatedEvent(mediaEventTypes[i3], domElement)
							}
							break
						case 'source':
							listenToNonDelegatedEvent('error', domElement)
							break
						case 'img':
						case 'image':
						case 'link':
							listenToNonDelegatedEvent('error', domElement)
							listenToNonDelegatedEvent('load', domElement)
							break
						case 'details':
							listenToNonDelegatedEvent('toggle', domElement)
							break
						case 'input':
							initWrapperState(domElement, rawProps)
							listenToNonDelegatedEvent('invalid', domElement)
							break
						case 'option':
							validateProps(domElement, rawProps)
							break
						case 'select':
							initWrapperState$1(domElement, rawProps)
							listenToNonDelegatedEvent('invalid', domElement)
							break
						case 'textarea':
							initWrapperState$2(domElement, rawProps)
							listenToNonDelegatedEvent('invalid', domElement)
							break
					}
					assertValidProps(tag, rawProps)
					{
						extraAttributeNames = /* @__PURE__ */ new Set()
						var attributes = domElement.attributes
						for (var _i = 0; _i < attributes.length; _i++) {
							var name = attributes[_i].name.toLowerCase()
							switch (name) {
								case 'value':
									break
								case 'checked':
									break
								case 'selected':
									break
								default:
									extraAttributeNames.add(attributes[_i].name)
							}
						}
					}
					var updatePayload = null
					for (var propKey in rawProps) {
						if (!rawProps.hasOwnProperty(propKey)) {
							continue
						}
						var nextProp = rawProps[propKey]
						if (propKey === CHILDREN) {
							if (typeof nextProp === 'string') {
								if (domElement.textContent !== nextProp) {
									if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
										checkForUnmatchedText(
											domElement.textContent,
											nextProp,
											isConcurrentMode,
											shouldWarnDev
										)
									}
									updatePayload = [CHILDREN, nextProp]
								}
							} else if (typeof nextProp === 'number') {
								if (domElement.textContent !== '' + nextProp) {
									if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
										checkForUnmatchedText(
											domElement.textContent,
											nextProp,
											isConcurrentMode,
											shouldWarnDev
										)
									}
									updatePayload = [CHILDREN, '' + nextProp]
								}
							}
						} else if (registrationNameDependencies.hasOwnProperty(propKey)) {
							if (nextProp != null) {
								if (typeof nextProp !== 'function') {
									warnForInvalidEventListener(propKey, nextProp)
								}
								if (propKey === 'onScroll') {
									listenToNonDelegatedEvent('scroll', domElement)
								}
							}
						} else if (
							shouldWarnDev &&
							true && // Convince Flow we've calculated it (it's DEV-only in this method.)
							typeof isCustomComponentTag === 'boolean'
						) {
							var serverValue = void 0
							var propertyInfo =
								isCustomComponentTag && enableCustomElementPropertySupport
									? null
									: getPropertyInfo(propKey)
							if (rawProps[SUPPRESS_HYDRATION_WARNING] === true);
							else if (
								propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
								propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
								// TODO: Only ignore them on controlled tags.
								propKey === 'value' ||
								propKey === 'checked' ||
								propKey === 'selected'
							);
							else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
								var serverHTML = domElement.innerHTML
								var nextHtml = nextProp ? nextProp[HTML$1] : void 0
								if (nextHtml != null) {
									var expectedHTML = normalizeHTML(domElement, nextHtml)
									if (expectedHTML !== serverHTML) {
										warnForPropDifference(propKey, serverHTML, expectedHTML)
									}
								}
							} else if (propKey === STYLE) {
								extraAttributeNames.delete(propKey)
								if (canDiffStyleForHydrationWarning) {
									var expectedStyle = createDangerousStringForStyles(nextProp)
									serverValue = domElement.getAttribute('style')
									if (expectedStyle !== serverValue) {
										warnForPropDifference(propKey, serverValue, expectedStyle)
									}
								}
							} else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
								extraAttributeNames.delete(propKey.toLowerCase())
								serverValue = getValueForAttribute(domElement, propKey, nextProp)
								if (nextProp !== serverValue) {
									warnForPropDifference(propKey, serverValue, nextProp)
								}
							} else if (
								!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) &&
								!shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)
							) {
								var isMismatchDueToBadCasing = false
								if (propertyInfo !== null) {
									extraAttributeNames.delete(propertyInfo.attributeName)
									serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo)
								} else {
									var ownNamespace = parentNamespace
									if (ownNamespace === HTML_NAMESPACE) {
										ownNamespace = getIntrinsicNamespace(tag)
									}
									if (ownNamespace === HTML_NAMESPACE) {
										extraAttributeNames.delete(propKey.toLowerCase())
									} else {
										var standardName = getPossibleStandardName(propKey)
										if (standardName !== null && standardName !== propKey) {
											isMismatchDueToBadCasing = true
											extraAttributeNames.delete(standardName)
										}
										extraAttributeNames.delete(propKey)
									}
									serverValue = getValueForAttribute(domElement, propKey, nextProp)
								}
								var dontWarnCustomElement = enableCustomElementPropertySupport
								if (
									!dontWarnCustomElement &&
									nextProp !== serverValue &&
									!isMismatchDueToBadCasing
								) {
									warnForPropDifference(propKey, serverValue, nextProp)
								}
							}
						}
					}
					{
						if (shouldWarnDev) {
							if (
								// $FlowFixMe - Should be inferred as not undefined.
								extraAttributeNames.size > 0 &&
								rawProps[SUPPRESS_HYDRATION_WARNING] !== true
							) {
								warnForExtraAttributes(extraAttributeNames)
							}
						}
					}
					switch (tag) {
						case 'input':
							track2(domElement)
							postMountWrapper(domElement, rawProps, true)
							break
						case 'textarea':
							track2(domElement)
							postMountWrapper$3(domElement)
							break
						case 'select':
						case 'option':
							break
						default:
							if (typeof rawProps.onClick === 'function') {
								trapClickOnNonInteractiveElement(domElement)
							}
							break
					}
					return updatePayload
				}
				function diffHydratedText(textNode, text, isConcurrentMode) {
					var isDifferent = textNode.nodeValue !== text
					return isDifferent
				}
				function warnForDeletedHydratableElement(parentNode, child) {
					{
						if (didWarnInvalidHydration) {
							return
						}
						didWarnInvalidHydration = true
						error(
							'Did not expect server HTML to contain a <%s> in <%s>.',
							child.nodeName.toLowerCase(),
							parentNode.nodeName.toLowerCase()
						)
					}
				}
				function warnForDeletedHydratableText(parentNode, child) {
					{
						if (didWarnInvalidHydration) {
							return
						}
						didWarnInvalidHydration = true
						error(
							'Did not expect server HTML to contain the text node "%s" in <%s>.',
							child.nodeValue,
							parentNode.nodeName.toLowerCase()
						)
					}
				}
				function warnForInsertedHydratedElement(parentNode, tag, props) {
					{
						if (didWarnInvalidHydration) {
							return
						}
						didWarnInvalidHydration = true
						error(
							'Expected server HTML to contain a matching <%s> in <%s>.',
							tag,
							parentNode.nodeName.toLowerCase()
						)
					}
				}
				function warnForInsertedHydratedText(parentNode, text) {
					{
						if (text === '') {
							return
						}
						if (didWarnInvalidHydration) {
							return
						}
						didWarnInvalidHydration = true
						error(
							'Expected server HTML to contain a matching text node for "%s" in <%s>.',
							text,
							parentNode.nodeName.toLowerCase()
						)
					}
				}
				function restoreControlledState$3(domElement, tag, props) {
					switch (tag) {
						case 'input':
							restoreControlledState(domElement, props)
							return
						case 'textarea':
							restoreControlledState$2(domElement, props)
							return
						case 'select':
							restoreControlledState$1(domElement, props)
							return
					}
				}
				var validateDOMNesting = function () {}
				var updatedAncestorInfo = function () {}
				{
					var specialTags = [
						'address',
						'applet',
						'area',
						'article',
						'aside',
						'base',
						'basefont',
						'bgsound',
						'blockquote',
						'body',
						'br',
						'button',
						'caption',
						'center',
						'col',
						'colgroup',
						'dd',
						'details',
						'dir',
						'div',
						'dl',
						'dt',
						'embed',
						'fieldset',
						'figcaption',
						'figure',
						'footer',
						'form',
						'frame',
						'frameset',
						'h1',
						'h2',
						'h3',
						'h4',
						'h5',
						'h6',
						'head',
						'header',
						'hgroup',
						'hr',
						'html',
						'iframe',
						'img',
						'input',
						'isindex',
						'li',
						'link',
						'listing',
						'main',
						'marquee',
						'menu',
						'menuitem',
						'meta',
						'nav',
						'noembed',
						'noframes',
						'noscript',
						'object',
						'ol',
						'p',
						'param',
						'plaintext',
						'pre',
						'script',
						'section',
						'select',
						'source',
						'style',
						'summary',
						'table',
						'tbody',
						'td',
						'template',
						'textarea',
						'tfoot',
						'th',
						'thead',
						'title',
						'tr',
						'track',
						'ul',
						'wbr',
						'xmp',
					]
					var inScopeTags = [
						'applet',
						'caption',
						'html',
						'table',
						'td',
						'th',
						'marquee',
						'object',
						'template',
						// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
						// TODO: Distinguish by namespace here -- for <title>, including it here
						// errs on the side of fewer warnings
						'foreignObject',
						'desc',
						'title',
					]
					var buttonScopeTags = inScopeTags.concat(['button'])
					var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt']
					var emptyAncestorInfo = {
						current: null,
						formTag: null,
						aTagInScope: null,
						buttonTagInScope: null,
						nobrTagInScope: null,
						pTagInButtonScope: null,
						listItemTagAutoclosing: null,
						dlItemTagAutoclosing: null,
					}
					updatedAncestorInfo = function (oldInfo, tag) {
						var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo)
						var info = {
							tag,
						}
						if (inScopeTags.indexOf(tag) !== -1) {
							ancestorInfo.aTagInScope = null
							ancestorInfo.buttonTagInScope = null
							ancestorInfo.nobrTagInScope = null
						}
						if (buttonScopeTags.indexOf(tag) !== -1) {
							ancestorInfo.pTagInButtonScope = null
						}
						if (
							specialTags.indexOf(tag) !== -1 &&
							tag !== 'address' &&
							tag !== 'div' &&
							tag !== 'p'
						) {
							ancestorInfo.listItemTagAutoclosing = null
							ancestorInfo.dlItemTagAutoclosing = null
						}
						ancestorInfo.current = info
						if (tag === 'form') {
							ancestorInfo.formTag = info
						}
						if (tag === 'a') {
							ancestorInfo.aTagInScope = info
						}
						if (tag === 'button') {
							ancestorInfo.buttonTagInScope = info
						}
						if (tag === 'nobr') {
							ancestorInfo.nobrTagInScope = info
						}
						if (tag === 'p') {
							ancestorInfo.pTagInButtonScope = info
						}
						if (tag === 'li') {
							ancestorInfo.listItemTagAutoclosing = info
						}
						if (tag === 'dd' || tag === 'dt') {
							ancestorInfo.dlItemTagAutoclosing = info
						}
						return ancestorInfo
					}
					var isTagValidWithParent = function (tag, parentTag) {
						switch (parentTag) {
							case 'select':
								return tag === 'option' || tag === 'optgroup' || tag === '#text'
							case 'optgroup':
								return tag === 'option' || tag === '#text'
							case 'option':
								return tag === '#text'
							case 'tr':
								return (
									tag === 'th' ||
									tag === 'td' ||
									tag === 'style' ||
									tag === 'script' ||
									tag === 'template'
								)
							case 'tbody':
							case 'thead':
							case 'tfoot':
								return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template'
							case 'colgroup':
								return tag === 'col' || tag === 'template'
							case 'table':
								return (
									tag === 'caption' ||
									tag === 'colgroup' ||
									tag === 'tbody' ||
									tag === 'tfoot' ||
									tag === 'thead' ||
									tag === 'style' ||
									tag === 'script' ||
									tag === 'template'
								)
							case 'head':
								return (
									tag === 'base' ||
									tag === 'basefont' ||
									tag === 'bgsound' ||
									tag === 'link' ||
									tag === 'meta' ||
									tag === 'title' ||
									tag === 'noscript' ||
									tag === 'noframes' ||
									tag === 'style' ||
									tag === 'script' ||
									tag === 'template'
								)
							case 'html':
								return tag === 'head' || tag === 'body' || tag === 'frameset'
							case 'frameset':
								return tag === 'frame'
							case '#document':
								return tag === 'html'
						}
						switch (tag) {
							case 'h1':
							case 'h2':
							case 'h3':
							case 'h4':
							case 'h5':
							case 'h6':
								return (
									parentTag !== 'h1' &&
									parentTag !== 'h2' &&
									parentTag !== 'h3' &&
									parentTag !== 'h4' &&
									parentTag !== 'h5' &&
									parentTag !== 'h6'
								)
							case 'rp':
							case 'rt':
								return impliedEndTags.indexOf(parentTag) === -1
							case 'body':
							case 'caption':
							case 'col':
							case 'colgroup':
							case 'frameset':
							case 'frame':
							case 'head':
							case 'html':
							case 'tbody':
							case 'td':
							case 'tfoot':
							case 'th':
							case 'thead':
							case 'tr':
								return parentTag == null
						}
						return true
					}
					var findInvalidAncestorForTag = function (tag, ancestorInfo) {
						switch (tag) {
							case 'address':
							case 'article':
							case 'aside':
							case 'blockquote':
							case 'center':
							case 'details':
							case 'dialog':
							case 'dir':
							case 'div':
							case 'dl':
							case 'fieldset':
							case 'figcaption':
							case 'figure':
							case 'footer':
							case 'header':
							case 'hgroup':
							case 'main':
							case 'menu':
							case 'nav':
							case 'ol':
							case 'p':
							case 'section':
							case 'summary':
							case 'ul':
							case 'pre':
							case 'listing':
							case 'table':
							case 'hr':
							case 'xmp':
							case 'h1':
							case 'h2':
							case 'h3':
							case 'h4':
							case 'h5':
							case 'h6':
								return ancestorInfo.pTagInButtonScope
							case 'form':
								return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope
							case 'li':
								return ancestorInfo.listItemTagAutoclosing
							case 'dd':
							case 'dt':
								return ancestorInfo.dlItemTagAutoclosing
							case 'button':
								return ancestorInfo.buttonTagInScope
							case 'a':
								return ancestorInfo.aTagInScope
							case 'nobr':
								return ancestorInfo.nobrTagInScope
						}
						return null
					}
					var didWarn$1 = {}
					validateDOMNesting = function (childTag, childText, ancestorInfo) {
						ancestorInfo = ancestorInfo || emptyAncestorInfo
						var parentInfo = ancestorInfo.current
						var parentTag = parentInfo && parentInfo.tag
						if (childText != null) {
							if (childTag != null) {
								error('validateDOMNesting: when childText is passed, childTag should be null')
							}
							childTag = '#text'
						}
						var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo
						var invalidAncestor = invalidParent
							? null
							: findInvalidAncestorForTag(childTag, ancestorInfo)
						var invalidParentOrAncestor = invalidParent || invalidAncestor
						if (!invalidParentOrAncestor) {
							return
						}
						var ancestorTag = invalidParentOrAncestor.tag
						var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag
						if (didWarn$1[warnKey]) {
							return
						}
						didWarn$1[warnKey] = true
						var tagDisplayName = childTag
						var whitespaceInfo = ''
						if (childTag === '#text') {
							if (/\S/.test(childText)) {
								tagDisplayName = 'Text nodes'
							} else {
								tagDisplayName = 'Whitespace text nodes'
								whitespaceInfo =
									" Make sure you don't have any extra whitespace between tags on each line of your source code."
							}
						} else {
							tagDisplayName = '<' + childTag + '>'
						}
						if (invalidParent) {
							var info = ''
							if (ancestorTag === 'table' && childTag === 'tr') {
								info +=
									' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.'
							}
							error(
								'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',
								tagDisplayName,
								ancestorTag,
								whitespaceInfo,
								info
							)
						} else {
							error(
								'validateDOMNesting(...): %s cannot appear as a descendant of <%s>.',
								tagDisplayName,
								ancestorTag
							)
						}
					}
				}
				var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning'
				var SUSPENSE_START_DATA = '$'
				var SUSPENSE_END_DATA = '/$'
				var SUSPENSE_PENDING_START_DATA = '$?'
				var SUSPENSE_FALLBACK_START_DATA = '$!'
				var STYLE$1 = 'style'
				var eventsEnabled = null
				var selectionInformation = null
				function getRootHostContext(rootContainerInstance) {
					var type
					var namespace
					var nodeType = rootContainerInstance.nodeType
					switch (nodeType) {
						case DOCUMENT_NODE:
						case DOCUMENT_FRAGMENT_NODE: {
							type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment'
							var root3 = rootContainerInstance.documentElement
							namespace = root3 ? root3.namespaceURI : getChildNamespace(null, '')
							break
						}
						default: {
							var container =
								nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance
							var ownNamespace = container.namespaceURI || null
							type = container.tagName
							namespace = getChildNamespace(ownNamespace, type)
							break
						}
					}
					{
						var validatedTag = type.toLowerCase()
						var ancestorInfo = updatedAncestorInfo(null, validatedTag)
						return {
							namespace,
							ancestorInfo,
						}
					}
				}
				function getChildHostContext(parentHostContext, type, rootContainerInstance) {
					{
						var parentHostContextDev = parentHostContext
						var namespace = getChildNamespace(parentHostContextDev.namespace, type)
						var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type)
						return {
							namespace,
							ancestorInfo,
						}
					}
				}
				function getPublicInstance(instance) {
					return instance
				}
				function prepareForCommit(containerInfo) {
					eventsEnabled = isEnabled()
					selectionInformation = getSelectionInformation()
					var activeInstance = null
					setEnabled(false)
					return activeInstance
				}
				function resetAfterCommit(containerInfo) {
					restoreSelection(selectionInformation)
					setEnabled(eventsEnabled)
					eventsEnabled = null
					selectionInformation = null
				}
				function createInstance(
					type,
					props,
					rootContainerInstance,
					hostContext,
					internalInstanceHandle
				) {
					var parentNamespace
					{
						var hostContextDev = hostContext
						validateDOMNesting(type, null, hostContextDev.ancestorInfo)
						if (typeof props.children === 'string' || typeof props.children === 'number') {
							var string2 = '' + props.children
							var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type)
							validateDOMNesting(null, string2, ownAncestorInfo)
						}
						parentNamespace = hostContextDev.namespace
					}
					var domElement = createElement6(type, props, rootContainerInstance, parentNamespace)
					precacheFiberNode(internalInstanceHandle, domElement)
					updateFiberProps(domElement, props)
					return domElement
				}
				function appendInitialChild(parentInstance, child) {
					parentInstance.appendChild(child)
				}
				function finalizeInitialChildren(
					domElement,
					type,
					props,
					rootContainerInstance,
					hostContext
				) {
					setInitialProperties(domElement, type, props, rootContainerInstance)
					switch (type) {
						case 'button':
						case 'input':
						case 'select':
						case 'textarea':
							return !!props.autoFocus
						case 'img':
							return true
						default:
							return false
					}
				}
				function prepareUpdate(
					domElement,
					type,
					oldProps,
					newProps,
					rootContainerInstance,
					hostContext
				) {
					{
						var hostContextDev = hostContext
						if (
							typeof newProps.children !== typeof oldProps.children &&
							(typeof newProps.children === 'string' || typeof newProps.children === 'number')
						) {
							var string2 = '' + newProps.children
							var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type)
							validateDOMNesting(null, string2, ownAncestorInfo)
						}
					}
					return diffProperties(domElement, type, oldProps, newProps)
				}
				function shouldSetTextContent(type, props) {
					return (
						type === 'textarea' ||
						type === 'noscript' ||
						typeof props.children === 'string' ||
						typeof props.children === 'number' ||
						(typeof props.dangerouslySetInnerHTML === 'object' &&
							props.dangerouslySetInnerHTML !== null &&
							props.dangerouslySetInnerHTML.__html != null)
					)
				}
				function createTextInstance(
					text,
					rootContainerInstance,
					hostContext,
					internalInstanceHandle
				) {
					{
						var hostContextDev = hostContext
						validateDOMNesting(null, text, hostContextDev.ancestorInfo)
					}
					var textNode = createTextNode(text, rootContainerInstance)
					precacheFiberNode(internalInstanceHandle, textNode)
					return textNode
				}
				function getCurrentEventPriority() {
					var currentEvent = window.event
					if (currentEvent === void 0) {
						return DefaultEventPriority
					}
					return getEventPriority(currentEvent.type)
				}
				var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : void 0
				var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : void 0
				var noTimeout = -1
				var localPromise = typeof Promise === 'function' ? Promise : void 0
				var scheduleMicrotask =
					typeof queueMicrotask === 'function'
						? queueMicrotask
						: typeof localPromise !== 'undefined'
						? function (callback) {
								return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick)
						  }
						: scheduleTimeout
				function handleErrorInNextTick(error2) {
					setTimeout(function () {
						throw error2
					})
				}
				function commitMount(domElement, type, newProps, internalInstanceHandle) {
					switch (type) {
						case 'button':
						case 'input':
						case 'select':
						case 'textarea':
							if (newProps.autoFocus) {
								domElement.focus()
							}
							return
						case 'img': {
							if (newProps.src) {
								domElement.src = newProps.src
							}
							return
						}
					}
				}
				function commitUpdate(
					domElement,
					updatePayload,
					type,
					oldProps,
					newProps,
					internalInstanceHandle
				) {
					updateProperties(domElement, updatePayload, type, oldProps, newProps)
					updateFiberProps(domElement, newProps)
				}
				function resetTextContent(domElement) {
					setTextContent(domElement, '')
				}
				function commitTextUpdate(textInstance, oldText, newText) {
					textInstance.nodeValue = newText
				}
				function appendChild(parentInstance, child) {
					parentInstance.appendChild(child)
				}
				function appendChildToContainer(container, child) {
					var parentNode
					if (container.nodeType === COMMENT_NODE) {
						parentNode = container.parentNode
						parentNode.insertBefore(child, container)
					} else {
						parentNode = container
						parentNode.appendChild(child)
					}
					var reactRootContainer = container._reactRootContainer
					if (
						(reactRootContainer === null || reactRootContainer === void 0) &&
						parentNode.onclick === null
					) {
						trapClickOnNonInteractiveElement(parentNode)
					}
				}
				function insertBefore(parentInstance, child, beforeChild) {
					parentInstance.insertBefore(child, beforeChild)
				}
				function insertInContainerBefore(container, child, beforeChild) {
					if (container.nodeType === COMMENT_NODE) {
						container.parentNode.insertBefore(child, beforeChild)
					} else {
						container.insertBefore(child, beforeChild)
					}
				}
				function removeChild(parentInstance, child) {
					parentInstance.removeChild(child)
				}
				function removeChildFromContainer(container, child) {
					if (container.nodeType === COMMENT_NODE) {
						container.parentNode.removeChild(child)
					} else {
						container.removeChild(child)
					}
				}
				function clearSuspenseBoundary(parentInstance, suspenseInstance) {
					var node = suspenseInstance
					var depth = 0
					do {
						var nextNode = node.nextSibling
						parentInstance.removeChild(node)
						if (nextNode && nextNode.nodeType === COMMENT_NODE) {
							var data = nextNode.data
							if (data === SUSPENSE_END_DATA) {
								if (depth === 0) {
									parentInstance.removeChild(nextNode)
									retryIfBlockedOn(suspenseInstance)
									return
								} else {
									depth--
								}
							} else if (
								data === SUSPENSE_START_DATA ||
								data === SUSPENSE_PENDING_START_DATA ||
								data === SUSPENSE_FALLBACK_START_DATA
							) {
								depth++
							}
						}
						node = nextNode
					} while (node)
					retryIfBlockedOn(suspenseInstance)
				}
				function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
					if (container.nodeType === COMMENT_NODE) {
						clearSuspenseBoundary(container.parentNode, suspenseInstance)
					} else if (container.nodeType === ELEMENT_NODE) {
						clearSuspenseBoundary(container, suspenseInstance)
					}
					retryIfBlockedOn(container)
				}
				function hideInstance(instance) {
					instance = instance
					var style2 = instance.style
					if (typeof style2.setProperty === 'function') {
						style2.setProperty('display', 'none', 'important')
					} else {
						style2.display = 'none'
					}
				}
				function hideTextInstance(textInstance) {
					textInstance.nodeValue = ''
				}
				function unhideInstance(instance, props) {
					instance = instance
					var styleProp = props[STYLE$1]
					var display =
						styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty('display')
							? styleProp.display
							: null
					instance.style.display = dangerousStyleValue('display', display)
				}
				function unhideTextInstance(textInstance, text) {
					textInstance.nodeValue = text
				}
				function clearContainer(container) {
					if (container.nodeType === ELEMENT_NODE) {
						container.textContent = ''
					} else if (container.nodeType === DOCUMENT_NODE) {
						if (container.documentElement) {
							container.removeChild(container.documentElement)
						}
					}
				}
				function canHydrateInstance(instance, type, props) {
					if (
						instance.nodeType !== ELEMENT_NODE ||
						type.toLowerCase() !== instance.nodeName.toLowerCase()
					) {
						return null
					}
					return instance
				}
				function canHydrateTextInstance(instance, text) {
					if (text === '' || instance.nodeType !== TEXT_NODE) {
						return null
					}
					return instance
				}
				function canHydrateSuspenseInstance(instance) {
					if (instance.nodeType !== COMMENT_NODE) {
						return null
					}
					return instance
				}
				function isSuspenseInstancePending(instance) {
					return instance.data === SUSPENSE_PENDING_START_DATA
				}
				function isSuspenseInstanceFallback(instance) {
					return instance.data === SUSPENSE_FALLBACK_START_DATA
				}
				function getSuspenseInstanceFallbackErrorDetails(instance) {
					var dataset = instance.nextSibling && instance.nextSibling.dataset
					var digest, message, stack3
					if (dataset) {
						digest = dataset.dgst
						{
							message = dataset.msg
							stack3 = dataset.stck
						}
					}
					{
						return {
							message,
							digest,
							stack: stack3,
						}
					}
				}
				function registerSuspenseInstanceRetry(instance, callback) {
					instance._reactRetry = callback
				}
				function getNextHydratable(node) {
					for (; node != null; node = node.nextSibling) {
						var nodeType = node.nodeType
						if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
							break
						}
						if (nodeType === COMMENT_NODE) {
							var nodeData = node.data
							if (
								nodeData === SUSPENSE_START_DATA ||
								nodeData === SUSPENSE_FALLBACK_START_DATA ||
								nodeData === SUSPENSE_PENDING_START_DATA
							) {
								break
							}
							if (nodeData === SUSPENSE_END_DATA) {
								return null
							}
						}
					}
					return node
				}
				function getNextHydratableSibling(instance) {
					return getNextHydratable(instance.nextSibling)
				}
				function getFirstHydratableChild(parentInstance) {
					return getNextHydratable(parentInstance.firstChild)
				}
				function getFirstHydratableChildWithinContainer(parentContainer) {
					return getNextHydratable(parentContainer.firstChild)
				}
				function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
					return getNextHydratable(parentInstance.nextSibling)
				}
				function hydrateInstance(
					instance,
					type,
					props,
					rootContainerInstance,
					hostContext,
					internalInstanceHandle,
					shouldWarnDev
				) {
					precacheFiberNode(internalInstanceHandle, instance)
					updateFiberProps(instance, props)
					var parentNamespace
					{
						var hostContextDev = hostContext
						parentNamespace = hostContextDev.namespace
					}
					var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode
					return diffHydratedProperties(
						instance,
						type,
						props,
						parentNamespace,
						rootContainerInstance,
						isConcurrentMode,
						shouldWarnDev
					)
				}
				function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
					precacheFiberNode(internalInstanceHandle, textInstance)
					var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode
					return diffHydratedText(textInstance, text)
				}
				function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
					precacheFiberNode(internalInstanceHandle, suspenseInstance)
				}
				function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
					var node = suspenseInstance.nextSibling
					var depth = 0
					while (node) {
						if (node.nodeType === COMMENT_NODE) {
							var data = node.data
							if (data === SUSPENSE_END_DATA) {
								if (depth === 0) {
									return getNextHydratableSibling(node)
								} else {
									depth--
								}
							} else if (
								data === SUSPENSE_START_DATA ||
								data === SUSPENSE_FALLBACK_START_DATA ||
								data === SUSPENSE_PENDING_START_DATA
							) {
								depth++
							}
						}
						node = node.nextSibling
					}
					return null
				}
				function getParentSuspenseInstance(targetInstance) {
					var node = targetInstance.previousSibling
					var depth = 0
					while (node) {
						if (node.nodeType === COMMENT_NODE) {
							var data = node.data
							if (
								data === SUSPENSE_START_DATA ||
								data === SUSPENSE_FALLBACK_START_DATA ||
								data === SUSPENSE_PENDING_START_DATA
							) {
								if (depth === 0) {
									return node
								} else {
									depth--
								}
							} else if (data === SUSPENSE_END_DATA) {
								depth++
							}
						}
						node = node.previousSibling
					}
					return null
				}
				function commitHydratedContainer(container) {
					retryIfBlockedOn(container)
				}
				function commitHydratedSuspenseInstance(suspenseInstance) {
					retryIfBlockedOn(suspenseInstance)
				}
				function shouldDeleteUnhydratedTailInstances(parentType) {
					return parentType !== 'head' && parentType !== 'body'
				}
				function didNotMatchHydratedContainerTextInstance(
					parentContainer,
					textInstance,
					text,
					isConcurrentMode
				) {
					var shouldWarnDev = true
					checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev)
				}
				function didNotMatchHydratedTextInstance(
					parentType,
					parentProps,
					parentInstance,
					textInstance,
					text,
					isConcurrentMode
				) {
					if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
						var shouldWarnDev = true
						checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev)
					}
				}
				function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
					{
						if (instance.nodeType === ELEMENT_NODE) {
							warnForDeletedHydratableElement(parentContainer, instance)
						} else if (instance.nodeType === COMMENT_NODE);
						else {
							warnForDeletedHydratableText(parentContainer, instance)
						}
					}
				}
				function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
					{
						var parentNode = parentInstance.parentNode
						if (parentNode !== null) {
							if (instance.nodeType === ELEMENT_NODE) {
								warnForDeletedHydratableElement(parentNode, instance)
							} else if (instance.nodeType === COMMENT_NODE);
							else {
								warnForDeletedHydratableText(parentNode, instance)
							}
						}
					}
				}
				function didNotHydrateInstance(
					parentType,
					parentProps,
					parentInstance,
					instance,
					isConcurrentMode
				) {
					{
						if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
							if (instance.nodeType === ELEMENT_NODE) {
								warnForDeletedHydratableElement(parentInstance, instance)
							} else if (instance.nodeType === COMMENT_NODE);
							else {
								warnForDeletedHydratableText(parentInstance, instance)
							}
						}
					}
				}
				function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
					{
						warnForInsertedHydratedElement(parentContainer, type)
					}
				}
				function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
					{
						warnForInsertedHydratedText(parentContainer, text)
					}
				}
				function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
					{
						var parentNode = parentInstance.parentNode
						if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type)
					}
				}
				function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
					{
						var parentNode = parentInstance.parentNode
						if (parentNode !== null) warnForInsertedHydratedText(parentNode, text)
					}
				}
				function didNotFindHydratableInstance(
					parentType,
					parentProps,
					parentInstance,
					type,
					props,
					isConcurrentMode
				) {
					{
						if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
							warnForInsertedHydratedElement(parentInstance, type)
						}
					}
				}
				function didNotFindHydratableTextInstance(
					parentType,
					parentProps,
					parentInstance,
					text,
					isConcurrentMode
				) {
					{
						if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
							warnForInsertedHydratedText(parentInstance, text)
						}
					}
				}
				function errorHydratingContainer(parentContainer) {
					{
						error(
							'An error occurred during hydration. The server HTML was replaced with client content in <%s>.',
							parentContainer.nodeName.toLowerCase()
						)
					}
				}
				function preparePortalMount(portalInstance) {
					listenToAllSupportedEvents(portalInstance)
				}
				var randomKey = Math.random().toString(36).slice(2)
				var internalInstanceKey = '__reactFiber$' + randomKey
				var internalPropsKey = '__reactProps$' + randomKey
				var internalContainerInstanceKey = '__reactContainer$' + randomKey
				var internalEventHandlersKey = '__reactEvents$' + randomKey
				var internalEventHandlerListenersKey = '__reactListeners$' + randomKey
				var internalEventHandlesSetKey = '__reactHandles$' + randomKey
				function detachDeletedInstance(node) {
					delete node[internalInstanceKey]
					delete node[internalPropsKey]
					delete node[internalEventHandlersKey]
					delete node[internalEventHandlerListenersKey]
					delete node[internalEventHandlesSetKey]
				}
				function precacheFiberNode(hostInst, node) {
					node[internalInstanceKey] = hostInst
				}
				function markContainerAsRoot(hostRoot, node) {
					node[internalContainerInstanceKey] = hostRoot
				}
				function unmarkContainerAsRoot(node) {
					node[internalContainerInstanceKey] = null
				}
				function isContainerMarkedAsRoot(node) {
					return !!node[internalContainerInstanceKey]
				}
				function getClosestInstanceFromNode(targetNode) {
					var targetInst = targetNode[internalInstanceKey]
					if (targetInst) {
						return targetInst
					}
					var parentNode = targetNode.parentNode
					while (parentNode) {
						targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]
						if (targetInst) {
							var alternate = targetInst.alternate
							if (targetInst.child !== null || (alternate !== null && alternate.child !== null)) {
								var suspenseInstance = getParentSuspenseInstance(targetNode)
								while (suspenseInstance !== null) {
									var targetSuspenseInst = suspenseInstance[internalInstanceKey]
									if (targetSuspenseInst) {
										return targetSuspenseInst
									}
									suspenseInstance = getParentSuspenseInstance(suspenseInstance)
								}
							}
							return targetInst
						}
						targetNode = parentNode
						parentNode = targetNode.parentNode
					}
					return null
				}
				function getInstanceFromNode(node) {
					var inst = node[internalInstanceKey] || node[internalContainerInstanceKey]
					if (inst) {
						if (
							inst.tag === HostComponent ||
							inst.tag === HostText ||
							inst.tag === SuspenseComponent ||
							inst.tag === HostRoot
						) {
							return inst
						} else {
							return null
						}
					}
					return null
				}
				function getNodeFromInstance(inst) {
					if (inst.tag === HostComponent || inst.tag === HostText) {
						return inst.stateNode
					}
					throw new Error('getNodeFromInstance: Invalid argument.')
				}
				function getFiberCurrentPropsFromNode(node) {
					return node[internalPropsKey] || null
				}
				function updateFiberProps(node, props) {
					node[internalPropsKey] = props
				}
				function getEventListenerSet(node) {
					var elementListenerSet = node[internalEventHandlersKey]
					if (elementListenerSet === void 0) {
						elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set()
					}
					return elementListenerSet
				}
				var loggedTypeFailures = {}
				var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame
				function setCurrentlyValidatingElement(element) {
					{
						if (element) {
							var owner = element._owner
							var stack3 = describeUnknownElementTypeFrameInDEV(
								element.type,
								element._source,
								owner ? owner.type : null
							)
							ReactDebugCurrentFrame$1.setExtraStackFrame(stack3)
						} else {
							ReactDebugCurrentFrame$1.setExtraStackFrame(null)
						}
					}
				}
				function checkPropTypes(typeSpecs, values, location, componentName, element) {
					{
						var has2 = Function.call.bind(hasOwnProperty2)
						for (var typeSpecName in typeSpecs) {
							if (has2(typeSpecs, typeSpecName)) {
								var error$1 = void 0
								try {
									if (typeof typeSpecs[typeSpecName] !== 'function') {
										var err = Error(
											(componentName || 'React class') +
												': ' +
												location +
												' type `' +
												typeSpecName +
												'` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
												typeof typeSpecs[typeSpecName] +
												'`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
										)
										err.name = 'Invariant Violation'
										throw err
									}
									error$1 = typeSpecs[typeSpecName](
										values,
										typeSpecName,
										componentName,
										location,
										null,
										'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'
									)
								} catch (ex) {
									error$1 = ex
								}
								if (error$1 && !(error$1 instanceof Error)) {
									setCurrentlyValidatingElement(element)
									error(
										'%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
										componentName || 'React class',
										location,
										typeSpecName,
										typeof error$1
									)
									setCurrentlyValidatingElement(null)
								}
								if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
									loggedTypeFailures[error$1.message] = true
									setCurrentlyValidatingElement(element)
									error('Failed %s type: %s', location, error$1.message)
									setCurrentlyValidatingElement(null)
								}
							}
						}
					}
				}
				var valueStack = []
				var fiberStack
				{
					fiberStack = []
				}
				var index2 = -1
				function createCursor(defaultValue) {
					return {
						current: defaultValue,
					}
				}
				function pop(cursor, fiber) {
					if (index2 < 0) {
						{
							error('Unexpected pop.')
						}
						return
					}
					{
						if (fiber !== fiberStack[index2]) {
							error('Unexpected Fiber popped.')
						}
					}
					cursor.current = valueStack[index2]
					valueStack[index2] = null
					{
						fiberStack[index2] = null
					}
					index2--
				}
				function push(cursor, value, fiber) {
					index2++
					valueStack[index2] = cursor.current
					{
						fiberStack[index2] = fiber
					}
					cursor.current = value
				}
				var warnedAboutMissingGetChildContext
				{
					warnedAboutMissingGetChildContext = {}
				}
				var emptyContextObject = {}
				{
					Object.freeze(emptyContextObject)
				}
				var contextStackCursor = createCursor(emptyContextObject)
				var didPerformWorkStackCursor = createCursor(false)
				var previousContext = emptyContextObject
				function getUnmaskedContext(workInProgress2, Component3, didPushOwnContextIfProvider) {
					{
						if (didPushOwnContextIfProvider && isContextProvider(Component3)) {
							return previousContext
						}
						return contextStackCursor.current
					}
				}
				function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
					{
						var instance = workInProgress2.stateNode
						instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext
						instance.__reactInternalMemoizedMaskedChildContext = maskedContext
					}
				}
				function getMaskedContext(workInProgress2, unmaskedContext) {
					{
						var type = workInProgress2.type
						var contextTypes = type.contextTypes
						if (!contextTypes) {
							return emptyContextObject
						}
						var instance = workInProgress2.stateNode
						if (
							instance &&
							instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext
						) {
							return instance.__reactInternalMemoizedMaskedChildContext
						}
						var context = {}
						for (var key in contextTypes) {
							context[key] = unmaskedContext[key]
						}
						{
							var name = getComponentNameFromFiber(workInProgress2) || 'Unknown'
							checkPropTypes(contextTypes, context, 'context', name)
						}
						if (instance) {
							cacheContext(workInProgress2, unmaskedContext, context)
						}
						return context
					}
				}
				function hasContextChanged() {
					{
						return didPerformWorkStackCursor.current
					}
				}
				function isContextProvider(type) {
					{
						var childContextTypes = type.childContextTypes
						return childContextTypes !== null && childContextTypes !== void 0
					}
				}
				function popContext(fiber) {
					{
						pop(didPerformWorkStackCursor, fiber)
						pop(contextStackCursor, fiber)
					}
				}
				function popTopLevelContextObject(fiber) {
					{
						pop(didPerformWorkStackCursor, fiber)
						pop(contextStackCursor, fiber)
					}
				}
				function pushTopLevelContextObject(fiber, context, didChange) {
					{
						if (contextStackCursor.current !== emptyContextObject) {
							throw new Error(
								'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
						push(contextStackCursor, context, fiber)
						push(didPerformWorkStackCursor, didChange, fiber)
					}
				}
				function processChildContext(fiber, type, parentContext) {
					{
						var instance = fiber.stateNode
						var childContextTypes = type.childContextTypes
						if (typeof instance.getChildContext !== 'function') {
							{
								var componentName = getComponentNameFromFiber(fiber) || 'Unknown'
								if (!warnedAboutMissingGetChildContext[componentName]) {
									warnedAboutMissingGetChildContext[componentName] = true
									error(
										'%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.',
										componentName,
										componentName
									)
								}
							}
							return parentContext
						}
						var childContext = instance.getChildContext()
						for (var contextKey in childContext) {
							if (!(contextKey in childContextTypes)) {
								throw new Error(
									(getComponentNameFromFiber(fiber) || 'Unknown') +
										'.getChildContext(): key "' +
										contextKey +
										'" is not defined in childContextTypes.'
								)
							}
						}
						{
							var name = getComponentNameFromFiber(fiber) || 'Unknown'
							checkPropTypes(childContextTypes, childContext, 'child context', name)
						}
						return assign({}, parentContext, childContext)
					}
				}
				function pushContextProvider(workInProgress2) {
					{
						var instance = workInProgress2.stateNode
						var memoizedMergedChildContext =
							(instance && instance.__reactInternalMemoizedMergedChildContext) || emptyContextObject
						previousContext = contextStackCursor.current
						push(contextStackCursor, memoizedMergedChildContext, workInProgress2)
						push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2)
						return true
					}
				}
				function invalidateContextProvider(workInProgress2, type, didChange) {
					{
						var instance = workInProgress2.stateNode
						if (!instance) {
							throw new Error(
								'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
						if (didChange) {
							var mergedContext = processChildContext(workInProgress2, type, previousContext)
							instance.__reactInternalMemoizedMergedChildContext = mergedContext
							pop(didPerformWorkStackCursor, workInProgress2)
							pop(contextStackCursor, workInProgress2)
							push(contextStackCursor, mergedContext, workInProgress2)
							push(didPerformWorkStackCursor, didChange, workInProgress2)
						} else {
							pop(didPerformWorkStackCursor, workInProgress2)
							push(didPerformWorkStackCursor, didChange, workInProgress2)
						}
					}
				}
				function findCurrentUnmaskedContext(fiber) {
					{
						if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
							throw new Error(
								'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
						var node = fiber
						do {
							switch (node.tag) {
								case HostRoot:
									return node.stateNode.context
								case ClassComponent: {
									var Component3 = node.type
									if (isContextProvider(Component3)) {
										return node.stateNode.__reactInternalMemoizedMergedChildContext
									}
									break
								}
							}
							node = node.return
						} while (node !== null)
						throw new Error(
							'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'
						)
					}
				}
				var LegacyRoot = 0
				var ConcurrentRoot = 1
				var syncQueue = null
				var includesLegacySyncCallbacks = false
				var isFlushingSyncQueue = false
				function scheduleSyncCallback(callback) {
					if (syncQueue === null) {
						syncQueue = [callback]
					} else {
						syncQueue.push(callback)
					}
				}
				function scheduleLegacySyncCallback(callback) {
					includesLegacySyncCallbacks = true
					scheduleSyncCallback(callback)
				}
				function flushSyncCallbacksOnlyInLegacyMode() {
					if (includesLegacySyncCallbacks) {
						flushSyncCallbacks()
					}
				}
				function flushSyncCallbacks() {
					if (!isFlushingSyncQueue && syncQueue !== null) {
						isFlushingSyncQueue = true
						var i3 = 0
						var previousUpdatePriority = getCurrentUpdatePriority()
						try {
							var isSync = true
							var queue = syncQueue
							setCurrentUpdatePriority(DiscreteEventPriority)
							for (; i3 < queue.length; i3++) {
								var callback = queue[i3]
								do {
									callback = callback(isSync)
								} while (callback !== null)
							}
							syncQueue = null
							includesLegacySyncCallbacks = false
						} catch (error2) {
							if (syncQueue !== null) {
								syncQueue = syncQueue.slice(i3 + 1)
							}
							scheduleCallback(ImmediatePriority, flushSyncCallbacks)
							throw error2
						} finally {
							setCurrentUpdatePriority(previousUpdatePriority)
							isFlushingSyncQueue = false
						}
					}
					return null
				}
				var forkStack = []
				var forkStackIndex = 0
				var treeForkProvider = null
				var treeForkCount = 0
				var idStack = []
				var idStackIndex = 0
				var treeContextProvider = null
				var treeContextId = 1
				var treeContextOverflow = ''
				function isForkedChild(workInProgress2) {
					warnIfNotHydrating()
					return (workInProgress2.flags & Forked) !== NoFlags
				}
				function getForksAtLevel(workInProgress2) {
					warnIfNotHydrating()
					return treeForkCount
				}
				function getTreeId() {
					var overflow = treeContextOverflow
					var idWithLeadingBit = treeContextId
					var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit)
					return id.toString(32) + overflow
				}
				function pushTreeFork(workInProgress2, totalChildren) {
					warnIfNotHydrating()
					forkStack[forkStackIndex++] = treeForkCount
					forkStack[forkStackIndex++] = treeForkProvider
					treeForkProvider = workInProgress2
					treeForkCount = totalChildren
				}
				function pushTreeId(workInProgress2, totalChildren, index3) {
					warnIfNotHydrating()
					idStack[idStackIndex++] = treeContextId
					idStack[idStackIndex++] = treeContextOverflow
					idStack[idStackIndex++] = treeContextProvider
					treeContextProvider = workInProgress2
					var baseIdWithLeadingBit = treeContextId
					var baseOverflow = treeContextOverflow
					var baseLength = getBitLength(baseIdWithLeadingBit) - 1
					var baseId = baseIdWithLeadingBit & ~(1 << baseLength)
					var slot = index3 + 1
					var length = getBitLength(totalChildren) + baseLength
					if (length > 30) {
						var numberOfOverflowBits = baseLength - (baseLength % 5)
						var newOverflowBits = (1 << numberOfOverflowBits) - 1
						var newOverflow = (baseId & newOverflowBits).toString(32)
						var restOfBaseId = baseId >> numberOfOverflowBits
						var restOfBaseLength = baseLength - numberOfOverflowBits
						var restOfLength = getBitLength(totalChildren) + restOfBaseLength
						var restOfNewBits = slot << restOfBaseLength
						var id = restOfNewBits | restOfBaseId
						var overflow = newOverflow + baseOverflow
						treeContextId = (1 << restOfLength) | id
						treeContextOverflow = overflow
					} else {
						var newBits = slot << baseLength
						var _id = newBits | baseId
						var _overflow = baseOverflow
						treeContextId = (1 << length) | _id
						treeContextOverflow = _overflow
					}
				}
				function pushMaterializedTreeId(workInProgress2) {
					warnIfNotHydrating()
					var returnFiber = workInProgress2.return
					if (returnFiber !== null) {
						var numberOfForks = 1
						var slotIndex = 0
						pushTreeFork(workInProgress2, numberOfForks)
						pushTreeId(workInProgress2, numberOfForks, slotIndex)
					}
				}
				function getBitLength(number2) {
					return 32 - clz32(number2)
				}
				function getLeadingBit(id) {
					return 1 << (getBitLength(id) - 1)
				}
				function popTreeContext(workInProgress2) {
					while (workInProgress2 === treeForkProvider) {
						treeForkProvider = forkStack[--forkStackIndex]
						forkStack[forkStackIndex] = null
						treeForkCount = forkStack[--forkStackIndex]
						forkStack[forkStackIndex] = null
					}
					while (workInProgress2 === treeContextProvider) {
						treeContextProvider = idStack[--idStackIndex]
						idStack[idStackIndex] = null
						treeContextOverflow = idStack[--idStackIndex]
						idStack[idStackIndex] = null
						treeContextId = idStack[--idStackIndex]
						idStack[idStackIndex] = null
					}
				}
				function getSuspendedTreeContext() {
					warnIfNotHydrating()
					if (treeContextProvider !== null) {
						return {
							id: treeContextId,
							overflow: treeContextOverflow,
						}
					} else {
						return null
					}
				}
				function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
					warnIfNotHydrating()
					idStack[idStackIndex++] = treeContextId
					idStack[idStackIndex++] = treeContextOverflow
					idStack[idStackIndex++] = treeContextProvider
					treeContextId = suspendedContext.id
					treeContextOverflow = suspendedContext.overflow
					treeContextProvider = workInProgress2
				}
				function warnIfNotHydrating() {
					{
						if (!getIsHydrating()) {
							error('Expected to be hydrating. This is a bug in React. Please file an issue.')
						}
					}
				}
				var hydrationParentFiber = null
				var nextHydratableInstance = null
				var isHydrating = false
				var didSuspendOrErrorDEV = false
				var hydrationErrors = null
				function warnIfHydrating() {
					{
						if (isHydrating) {
							error('We should not be hydrating here. This is a bug in React. Please file a bug.')
						}
					}
				}
				function markDidThrowWhileHydratingDEV() {
					{
						didSuspendOrErrorDEV = true
					}
				}
				function didSuspendOrErrorWhileHydratingDEV() {
					{
						return didSuspendOrErrorDEV
					}
				}
				function enterHydrationState(fiber) {
					var parentInstance = fiber.stateNode.containerInfo
					nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance)
					hydrationParentFiber = fiber
					isHydrating = true
					hydrationErrors = null
					didSuspendOrErrorDEV = false
					return true
				}
				function reenterHydrationStateFromDehydratedSuspenseInstance(
					fiber,
					suspenseInstance,
					treeContext
				) {
					nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance)
					hydrationParentFiber = fiber
					isHydrating = true
					hydrationErrors = null
					didSuspendOrErrorDEV = false
					if (treeContext !== null) {
						restoreSuspendedTreeContext(fiber, treeContext)
					}
					return true
				}
				function warnUnhydratedInstance(returnFiber, instance) {
					{
						switch (returnFiber.tag) {
							case HostRoot: {
								didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance)
								break
							}
							case HostComponent: {
								var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode
								didNotHydrateInstance(
									returnFiber.type,
									returnFiber.memoizedProps,
									returnFiber.stateNode,
									instance,
									// TODO: Delete this argument when we remove the legacy root API.
									isConcurrentMode
								)
								break
							}
							case SuspenseComponent: {
								var suspenseState = returnFiber.memoizedState
								if (suspenseState.dehydrated !== null)
									didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance)
								break
							}
						}
					}
				}
				function deleteHydratableInstance(returnFiber, instance) {
					warnUnhydratedInstance(returnFiber, instance)
					var childToDelete = createFiberFromHostInstanceForDeletion()
					childToDelete.stateNode = instance
					childToDelete.return = returnFiber
					var deletions = returnFiber.deletions
					if (deletions === null) {
						returnFiber.deletions = [childToDelete]
						returnFiber.flags |= ChildDeletion
					} else {
						deletions.push(childToDelete)
					}
				}
				function warnNonhydratedInstance(returnFiber, fiber) {
					{
						if (didSuspendOrErrorDEV) {
							return
						}
						switch (returnFiber.tag) {
							case HostRoot: {
								var parentContainer = returnFiber.stateNode.containerInfo
								switch (fiber.tag) {
									case HostComponent:
										var type = fiber.type
										var props = fiber.pendingProps
										didNotFindHydratableInstanceWithinContainer(parentContainer, type)
										break
									case HostText:
										var text = fiber.pendingProps
										didNotFindHydratableTextInstanceWithinContainer(parentContainer, text)
										break
								}
								break
							}
							case HostComponent: {
								var parentType = returnFiber.type
								var parentProps = returnFiber.memoizedProps
								var parentInstance = returnFiber.stateNode
								switch (fiber.tag) {
									case HostComponent: {
										var _type = fiber.type
										var _props = fiber.pendingProps
										var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode
										didNotFindHydratableInstance(
											parentType,
											parentProps,
											parentInstance,
											_type,
											_props,
											// TODO: Delete this argument when we remove the legacy root API.
											isConcurrentMode
										)
										break
									}
									case HostText: {
										var _text = fiber.pendingProps
										var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode
										didNotFindHydratableTextInstance(
											parentType,
											parentProps,
											parentInstance,
											_text,
											// TODO: Delete this argument when we remove the legacy root API.
											_isConcurrentMode
										)
										break
									}
								}
								break
							}
							case SuspenseComponent: {
								var suspenseState = returnFiber.memoizedState
								var _parentInstance = suspenseState.dehydrated
								if (_parentInstance !== null)
									switch (fiber.tag) {
										case HostComponent:
											var _type2 = fiber.type
											var _props2 = fiber.pendingProps
											didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2)
											break
										case HostText:
											var _text2 = fiber.pendingProps
											didNotFindHydratableTextInstanceWithinSuspenseInstance(
												_parentInstance,
												_text2
											)
											break
									}
								break
							}
							default:
								return
						}
					}
				}
				function insertNonHydratedInstance(returnFiber, fiber) {
					fiber.flags = (fiber.flags & ~Hydrating) | Placement
					warnNonhydratedInstance(returnFiber, fiber)
				}
				function tryHydrate(fiber, nextInstance) {
					switch (fiber.tag) {
						case HostComponent: {
							var type = fiber.type
							var props = fiber.pendingProps
							var instance = canHydrateInstance(nextInstance, type)
							if (instance !== null) {
								fiber.stateNode = instance
								hydrationParentFiber = fiber
								nextHydratableInstance = getFirstHydratableChild(instance)
								return true
							}
							return false
						}
						case HostText: {
							var text = fiber.pendingProps
							var textInstance = canHydrateTextInstance(nextInstance, text)
							if (textInstance !== null) {
								fiber.stateNode = textInstance
								hydrationParentFiber = fiber
								nextHydratableInstance = null
								return true
							}
							return false
						}
						case SuspenseComponent: {
							var suspenseInstance = canHydrateSuspenseInstance(nextInstance)
							if (suspenseInstance !== null) {
								var suspenseState = {
									dehydrated: suspenseInstance,
									treeContext: getSuspendedTreeContext(),
									retryLane: OffscreenLane,
								}
								fiber.memoizedState = suspenseState
								var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance)
								dehydratedFragment.return = fiber
								fiber.child = dehydratedFragment
								hydrationParentFiber = fiber
								nextHydratableInstance = null
								return true
							}
							return false
						}
						default:
							return false
					}
				}
				function shouldClientRenderOnMismatch(fiber) {
					return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags
				}
				function throwOnHydrationMismatch(fiber) {
					throw new Error(
						'Hydration failed because the initial UI does not match what was rendered on the server.'
					)
				}
				function tryToClaimNextHydratableInstance(fiber) {
					if (!isHydrating) {
						return
					}
					var nextInstance = nextHydratableInstance
					if (!nextInstance) {
						if (shouldClientRenderOnMismatch(fiber)) {
							warnNonhydratedInstance(hydrationParentFiber, fiber)
							throwOnHydrationMismatch()
						}
						insertNonHydratedInstance(hydrationParentFiber, fiber)
						isHydrating = false
						hydrationParentFiber = fiber
						return
					}
					var firstAttemptedInstance = nextInstance
					if (!tryHydrate(fiber, nextInstance)) {
						if (shouldClientRenderOnMismatch(fiber)) {
							warnNonhydratedInstance(hydrationParentFiber, fiber)
							throwOnHydrationMismatch()
						}
						nextInstance = getNextHydratableSibling(firstAttemptedInstance)
						var prevHydrationParentFiber = hydrationParentFiber
						if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
							insertNonHydratedInstance(hydrationParentFiber, fiber)
							isHydrating = false
							hydrationParentFiber = fiber
							return
						}
						deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance)
					}
				}
				function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
					var instance = fiber.stateNode
					var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV
					var updatePayload = hydrateInstance(
						instance,
						fiber.type,
						fiber.memoizedProps,
						rootContainerInstance,
						hostContext,
						fiber,
						shouldWarnIfMismatchDev
					)
					fiber.updateQueue = updatePayload
					if (updatePayload !== null) {
						return true
					}
					return false
				}
				function prepareToHydrateHostTextInstance(fiber) {
					var textInstance = fiber.stateNode
					var textContent = fiber.memoizedProps
					var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber)
					if (shouldUpdate) {
						var returnFiber = hydrationParentFiber
						if (returnFiber !== null) {
							switch (returnFiber.tag) {
								case HostRoot: {
									var parentContainer = returnFiber.stateNode.containerInfo
									var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode
									didNotMatchHydratedContainerTextInstance(
										parentContainer,
										textInstance,
										textContent,
										// TODO: Delete this argument when we remove the legacy root API.
										isConcurrentMode
									)
									break
								}
								case HostComponent: {
									var parentType = returnFiber.type
									var parentProps = returnFiber.memoizedProps
									var parentInstance = returnFiber.stateNode
									var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode
									didNotMatchHydratedTextInstance(
										parentType,
										parentProps,
										parentInstance,
										textInstance,
										textContent,
										// TODO: Delete this argument when we remove the legacy root API.
										_isConcurrentMode2
									)
									break
								}
							}
						}
					}
					return shouldUpdate
				}
				function prepareToHydrateHostSuspenseInstance(fiber) {
					var suspenseState = fiber.memoizedState
					var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null
					if (!suspenseInstance) {
						throw new Error(
							'Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.'
						)
					}
					hydrateSuspenseInstance(suspenseInstance, fiber)
				}
				function skipPastDehydratedSuspenseInstance(fiber) {
					var suspenseState = fiber.memoizedState
					var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null
					if (!suspenseInstance) {
						throw new Error(
							'Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.'
						)
					}
					return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance)
				}
				function popToNextHostParent(fiber) {
					var parent = fiber.return
					while (
						parent !== null &&
						parent.tag !== HostComponent &&
						parent.tag !== HostRoot &&
						parent.tag !== SuspenseComponent
					) {
						parent = parent.return
					}
					hydrationParentFiber = parent
				}
				function popHydrationState(fiber) {
					if (fiber !== hydrationParentFiber) {
						return false
					}
					if (!isHydrating) {
						popToNextHostParent(fiber)
						isHydrating = true
						return false
					}
					if (
						fiber.tag !== HostRoot &&
						(fiber.tag !== HostComponent ||
							(shouldDeleteUnhydratedTailInstances(fiber.type) &&
								!shouldSetTextContent(fiber.type, fiber.memoizedProps)))
					) {
						var nextInstance = nextHydratableInstance
						if (nextInstance) {
							if (shouldClientRenderOnMismatch(fiber)) {
								warnIfUnhydratedTailNodes(fiber)
								throwOnHydrationMismatch()
							} else {
								while (nextInstance) {
									deleteHydratableInstance(fiber, nextInstance)
									nextInstance = getNextHydratableSibling(nextInstance)
								}
							}
						}
					}
					popToNextHostParent(fiber)
					if (fiber.tag === SuspenseComponent) {
						nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber)
					} else {
						nextHydratableInstance = hydrationParentFiber
							? getNextHydratableSibling(fiber.stateNode)
							: null
					}
					return true
				}
				function hasUnhydratedTailNodes() {
					return isHydrating && nextHydratableInstance !== null
				}
				function warnIfUnhydratedTailNodes(fiber) {
					var nextInstance = nextHydratableInstance
					while (nextInstance) {
						warnUnhydratedInstance(fiber, nextInstance)
						nextInstance = getNextHydratableSibling(nextInstance)
					}
				}
				function resetHydrationState() {
					hydrationParentFiber = null
					nextHydratableInstance = null
					isHydrating = false
					didSuspendOrErrorDEV = false
				}
				function upgradeHydrationErrorsToRecoverable() {
					if (hydrationErrors !== null) {
						queueRecoverableErrors(hydrationErrors)
						hydrationErrors = null
					}
				}
				function getIsHydrating() {
					return isHydrating
				}
				function queueHydrationError(error2) {
					if (hydrationErrors === null) {
						hydrationErrors = [error2]
					} else {
						hydrationErrors.push(error2)
					}
				}
				var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig
				var NoTransition = null
				function requestCurrentTransition() {
					return ReactCurrentBatchConfig$1.transition
				}
				var ReactStrictModeWarnings = {
					recordUnsafeLifecycleWarnings: function (fiber, instance) {},
					flushPendingUnsafeLifecycleWarnings: function () {},
					recordLegacyContextWarning: function (fiber, instance) {},
					flushLegacyContextWarning: function () {},
					discardPendingWarnings: function () {},
				}
				{
					var findStrictRoot = function (fiber) {
						var maybeStrictRoot = null
						var node = fiber
						while (node !== null) {
							if (node.mode & StrictLegacyMode) {
								maybeStrictRoot = node
							}
							node = node.return
						}
						return maybeStrictRoot
					}
					var setToSortedString = function (set2) {
						var array2 = []
						set2.forEach(function (value) {
							array2.push(value)
						})
						return array2.sort().join(', ')
					}
					var pendingComponentWillMountWarnings = []
					var pendingUNSAFE_ComponentWillMountWarnings = []
					var pendingComponentWillReceivePropsWarnings = []
					var pendingUNSAFE_ComponentWillReceivePropsWarnings = []
					var pendingComponentWillUpdateWarnings = []
					var pendingUNSAFE_ComponentWillUpdateWarnings = []
					var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set()
					ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
						if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
							return
						}
						if (
							typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.
							instance.componentWillMount.__suppressDeprecationWarning !== true
						) {
							pendingComponentWillMountWarnings.push(fiber)
						}
						if (
							fiber.mode & StrictLegacyMode &&
							typeof instance.UNSAFE_componentWillMount === 'function'
						) {
							pendingUNSAFE_ComponentWillMountWarnings.push(fiber)
						}
						if (
							typeof instance.componentWillReceiveProps === 'function' &&
							instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
						) {
							pendingComponentWillReceivePropsWarnings.push(fiber)
						}
						if (
							fiber.mode & StrictLegacyMode &&
							typeof instance.UNSAFE_componentWillReceiveProps === 'function'
						) {
							pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber)
						}
						if (
							typeof instance.componentWillUpdate === 'function' &&
							instance.componentWillUpdate.__suppressDeprecationWarning !== true
						) {
							pendingComponentWillUpdateWarnings.push(fiber)
						}
						if (
							fiber.mode & StrictLegacyMode &&
							typeof instance.UNSAFE_componentWillUpdate === 'function'
						) {
							pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber)
						}
					}
					ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
						var componentWillMountUniqueNames = /* @__PURE__ */ new Set()
						if (pendingComponentWillMountWarnings.length > 0) {
							pendingComponentWillMountWarnings.forEach(function (fiber) {
								componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component')
								didWarnAboutUnsafeLifecycles.add(fiber.type)
							})
							pendingComponentWillMountWarnings = []
						}
						var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set()
						if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
							pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
								UNSAFE_componentWillMountUniqueNames.add(
									getComponentNameFromFiber(fiber) || 'Component'
								)
								didWarnAboutUnsafeLifecycles.add(fiber.type)
							})
							pendingUNSAFE_ComponentWillMountWarnings = []
						}
						var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set()
						if (pendingComponentWillReceivePropsWarnings.length > 0) {
							pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
								componentWillReceivePropsUniqueNames.add(
									getComponentNameFromFiber(fiber) || 'Component'
								)
								didWarnAboutUnsafeLifecycles.add(fiber.type)
							})
							pendingComponentWillReceivePropsWarnings = []
						}
						var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set()
						if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
							pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
								UNSAFE_componentWillReceivePropsUniqueNames.add(
									getComponentNameFromFiber(fiber) || 'Component'
								)
								didWarnAboutUnsafeLifecycles.add(fiber.type)
							})
							pendingUNSAFE_ComponentWillReceivePropsWarnings = []
						}
						var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set()
						if (pendingComponentWillUpdateWarnings.length > 0) {
							pendingComponentWillUpdateWarnings.forEach(function (fiber) {
								componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component')
								didWarnAboutUnsafeLifecycles.add(fiber.type)
							})
							pendingComponentWillUpdateWarnings = []
						}
						var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set()
						if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
							pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
								UNSAFE_componentWillUpdateUniqueNames.add(
									getComponentNameFromFiber(fiber) || 'Component'
								)
								didWarnAboutUnsafeLifecycles.add(fiber.type)
							})
							pendingUNSAFE_ComponentWillUpdateWarnings = []
						}
						if (UNSAFE_componentWillMountUniqueNames.size > 0) {
							var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames)
							error(
								'Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s',
								sortedNames
							)
						}
						if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
							var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames)
							error(
								"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s",
								_sortedNames
							)
						}
						if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
							var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames)
							error(
								'Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s',
								_sortedNames2
							)
						}
						if (componentWillMountUniqueNames.size > 0) {
							var _sortedNames3 = setToSortedString(componentWillMountUniqueNames)
							warn(
								'componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s',
								_sortedNames3
							)
						}
						if (componentWillReceivePropsUniqueNames.size > 0) {
							var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames)
							warn(
								"componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
								_sortedNames4
							)
						}
						if (componentWillUpdateUniqueNames.size > 0) {
							var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames)
							warn(
								'componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s',
								_sortedNames5
							)
						}
					}
					var pendingLegacyContextWarning = /* @__PURE__ */ new Map()
					var didWarnAboutLegacyContext = /* @__PURE__ */ new Set()
					ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
						var strictRoot = findStrictRoot(fiber)
						if (strictRoot === null) {
							error(
								'Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.'
							)
							return
						}
						if (didWarnAboutLegacyContext.has(fiber.type)) {
							return
						}
						var warningsForRoot = pendingLegacyContextWarning.get(strictRoot)
						if (
							fiber.type.contextTypes != null ||
							fiber.type.childContextTypes != null ||
							(instance !== null && typeof instance.getChildContext === 'function')
						) {
							if (warningsForRoot === void 0) {
								warningsForRoot = []
								pendingLegacyContextWarning.set(strictRoot, warningsForRoot)
							}
							warningsForRoot.push(fiber)
						}
					}
					ReactStrictModeWarnings.flushLegacyContextWarning = function () {
						pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
							if (fiberArray.length === 0) {
								return
							}
							var firstFiber = fiberArray[0]
							var uniqueNames = /* @__PURE__ */ new Set()
							fiberArray.forEach(function (fiber) {
								uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component')
								didWarnAboutLegacyContext.add(fiber.type)
							})
							var sortedNames = setToSortedString(uniqueNames)
							try {
								setCurrentFiber(firstFiber)
								error(
									'Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context',
									sortedNames
								)
							} finally {
								resetCurrentFiber()
							}
						})
					}
					ReactStrictModeWarnings.discardPendingWarnings = function () {
						pendingComponentWillMountWarnings = []
						pendingUNSAFE_ComponentWillMountWarnings = []
						pendingComponentWillReceivePropsWarnings = []
						pendingUNSAFE_ComponentWillReceivePropsWarnings = []
						pendingComponentWillUpdateWarnings = []
						pendingUNSAFE_ComponentWillUpdateWarnings = []
						pendingLegacyContextWarning = /* @__PURE__ */ new Map()
					}
				}
				function resolveDefaultProps(Component3, baseProps) {
					if (Component3 && Component3.defaultProps) {
						var props = assign({}, baseProps)
						var defaultProps = Component3.defaultProps
						for (var propName in defaultProps) {
							if (props[propName] === void 0) {
								props[propName] = defaultProps[propName]
							}
						}
						return props
					}
					return baseProps
				}
				var valueCursor = createCursor(null)
				var rendererSigil
				{
					rendererSigil = {}
				}
				var currentlyRenderingFiber = null
				var lastContextDependency = null
				var lastFullyObservedContext = null
				var isDisallowedContextReadInDEV = false
				function resetContextDependencies() {
					currentlyRenderingFiber = null
					lastContextDependency = null
					lastFullyObservedContext = null
					{
						isDisallowedContextReadInDEV = false
					}
				}
				function enterDisallowedContextReadInDEV() {
					{
						isDisallowedContextReadInDEV = true
					}
				}
				function exitDisallowedContextReadInDEV() {
					{
						isDisallowedContextReadInDEV = false
					}
				}
				function pushProvider(providerFiber, context, nextValue) {
					{
						push(valueCursor, context._currentValue, providerFiber)
						context._currentValue = nextValue
						{
							if (
								context._currentRenderer !== void 0 &&
								context._currentRenderer !== null &&
								context._currentRenderer !== rendererSigil
							) {
								error(
									'Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.'
								)
							}
							context._currentRenderer = rendererSigil
						}
					}
				}
				function popProvider(context, providerFiber) {
					var currentValue = valueCursor.current
					pop(valueCursor, providerFiber)
					{
						{
							context._currentValue = currentValue
						}
					}
				}
				function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
					var node = parent
					while (node !== null) {
						var alternate = node.alternate
						if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
							node.childLanes = mergeLanes(node.childLanes, renderLanes2)
							if (alternate !== null) {
								alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2)
							}
						} else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
							alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2)
						}
						if (node === propagationRoot) {
							break
						}
						node = node.return
					}
					{
						if (node !== propagationRoot) {
							error(
								'Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
					}
				}
				function propagateContextChange(workInProgress2, context, renderLanes2) {
					{
						propagateContextChange_eager(workInProgress2, context, renderLanes2)
					}
				}
				function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
					var fiber = workInProgress2.child
					if (fiber !== null) {
						fiber.return = workInProgress2
					}
					while (fiber !== null) {
						var nextFiber = void 0
						var list = fiber.dependencies
						if (list !== null) {
							nextFiber = fiber.child
							var dependency = list.firstContext
							while (dependency !== null) {
								if (dependency.context === context) {
									if (fiber.tag === ClassComponent) {
										var lane = pickArbitraryLane(renderLanes2)
										var update = createUpdate(NoTimestamp, lane)
										update.tag = ForceUpdate
										var updateQueue = fiber.updateQueue
										if (updateQueue === null);
										else {
											var sharedQueue = updateQueue.shared
											var pending = sharedQueue.pending
											if (pending === null) {
												update.next = update
											} else {
												update.next = pending.next
												pending.next = update
											}
											sharedQueue.pending = update
										}
									}
									fiber.lanes = mergeLanes(fiber.lanes, renderLanes2)
									var alternate = fiber.alternate
									if (alternate !== null) {
										alternate.lanes = mergeLanes(alternate.lanes, renderLanes2)
									}
									scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2)
									list.lanes = mergeLanes(list.lanes, renderLanes2)
									break
								}
								dependency = dependency.next
							}
						} else if (fiber.tag === ContextProvider) {
							nextFiber = fiber.type === workInProgress2.type ? null : fiber.child
						} else if (fiber.tag === DehydratedFragment) {
							var parentSuspense = fiber.return
							if (parentSuspense === null) {
								throw new Error(
									'We just came from a parent so we must have had a parent. This is a bug in React.'
								)
							}
							parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2)
							var _alternate = parentSuspense.alternate
							if (_alternate !== null) {
								_alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2)
							}
							scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2)
							nextFiber = fiber.sibling
						} else {
							nextFiber = fiber.child
						}
						if (nextFiber !== null) {
							nextFiber.return = fiber
						} else {
							nextFiber = fiber
							while (nextFiber !== null) {
								if (nextFiber === workInProgress2) {
									nextFiber = null
									break
								}
								var sibling = nextFiber.sibling
								if (sibling !== null) {
									sibling.return = nextFiber.return
									nextFiber = sibling
									break
								}
								nextFiber = nextFiber.return
							}
						}
						fiber = nextFiber
					}
				}
				function prepareToReadContext(workInProgress2, renderLanes2) {
					currentlyRenderingFiber = workInProgress2
					lastContextDependency = null
					lastFullyObservedContext = null
					var dependencies = workInProgress2.dependencies
					if (dependencies !== null) {
						{
							var firstContext = dependencies.firstContext
							if (firstContext !== null) {
								if (includesSomeLane(dependencies.lanes, renderLanes2)) {
									markWorkInProgressReceivedUpdate()
								}
								dependencies.firstContext = null
							}
						}
					}
				}
				function readContext(context) {
					{
						if (isDisallowedContextReadInDEV) {
							error(
								'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
							)
						}
					}
					var value = context._currentValue
					if (lastFullyObservedContext === context);
					else {
						var contextItem = {
							context,
							memoizedValue: value,
							next: null,
						}
						if (lastContextDependency === null) {
							if (currentlyRenderingFiber === null) {
								throw new Error(
									'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
								)
							}
							lastContextDependency = contextItem
							currentlyRenderingFiber.dependencies = {
								lanes: NoLanes,
								firstContext: contextItem,
							}
						} else {
							lastContextDependency = lastContextDependency.next = contextItem
						}
					}
					return value
				}
				var concurrentQueues = null
				function pushConcurrentUpdateQueue(queue) {
					if (concurrentQueues === null) {
						concurrentQueues = [queue]
					} else {
						concurrentQueues.push(queue)
					}
				}
				function finishQueueingConcurrentUpdates() {
					if (concurrentQueues !== null) {
						for (var i3 = 0; i3 < concurrentQueues.length; i3++) {
							var queue = concurrentQueues[i3]
							var lastInterleavedUpdate = queue.interleaved
							if (lastInterleavedUpdate !== null) {
								queue.interleaved = null
								var firstInterleavedUpdate = lastInterleavedUpdate.next
								var lastPendingUpdate = queue.pending
								if (lastPendingUpdate !== null) {
									var firstPendingUpdate = lastPendingUpdate.next
									lastPendingUpdate.next = firstInterleavedUpdate
									lastInterleavedUpdate.next = firstPendingUpdate
								}
								queue.pending = lastInterleavedUpdate
							}
						}
						concurrentQueues = null
					}
				}
				function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
					var interleaved = queue.interleaved
					if (interleaved === null) {
						update.next = update
						pushConcurrentUpdateQueue(queue)
					} else {
						update.next = interleaved.next
						interleaved.next = update
					}
					queue.interleaved = update
					return markUpdateLaneFromFiberToRoot(fiber, lane)
				}
				function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
					var interleaved = queue.interleaved
					if (interleaved === null) {
						update.next = update
						pushConcurrentUpdateQueue(queue)
					} else {
						update.next = interleaved.next
						interleaved.next = update
					}
					queue.interleaved = update
				}
				function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
					var interleaved = queue.interleaved
					if (interleaved === null) {
						update.next = update
						pushConcurrentUpdateQueue(queue)
					} else {
						update.next = interleaved.next
						interleaved.next = update
					}
					queue.interleaved = update
					return markUpdateLaneFromFiberToRoot(fiber, lane)
				}
				function enqueueConcurrentRenderForLane(fiber, lane) {
					return markUpdateLaneFromFiberToRoot(fiber, lane)
				}
				var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot
				function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
					sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane)
					var alternate = sourceFiber.alternate
					if (alternate !== null) {
						alternate.lanes = mergeLanes(alternate.lanes, lane)
					}
					{
						if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
							warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber)
						}
					}
					var node = sourceFiber
					var parent = sourceFiber.return
					while (parent !== null) {
						parent.childLanes = mergeLanes(parent.childLanes, lane)
						alternate = parent.alternate
						if (alternate !== null) {
							alternate.childLanes = mergeLanes(alternate.childLanes, lane)
						} else {
							{
								if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
									warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber)
								}
							}
						}
						node = parent
						parent = parent.return
					}
					if (node.tag === HostRoot) {
						var root3 = node.stateNode
						return root3
					} else {
						return null
					}
				}
				var UpdateState = 0
				var ReplaceState = 1
				var ForceUpdate = 2
				var CaptureUpdate = 3
				var hasForceUpdate = false
				var didWarnUpdateInsideUpdate
				var currentlyProcessingQueue
				{
					didWarnUpdateInsideUpdate = false
					currentlyProcessingQueue = null
				}
				function initializeUpdateQueue(fiber) {
					var queue = {
						baseState: fiber.memoizedState,
						firstBaseUpdate: null,
						lastBaseUpdate: null,
						shared: {
							pending: null,
							interleaved: null,
							lanes: NoLanes,
						},
						effects: null,
					}
					fiber.updateQueue = queue
				}
				function cloneUpdateQueue(current2, workInProgress2) {
					var queue = workInProgress2.updateQueue
					var currentQueue = current2.updateQueue
					if (queue === currentQueue) {
						var clone = {
							baseState: currentQueue.baseState,
							firstBaseUpdate: currentQueue.firstBaseUpdate,
							lastBaseUpdate: currentQueue.lastBaseUpdate,
							shared: currentQueue.shared,
							effects: currentQueue.effects,
						}
						workInProgress2.updateQueue = clone
					}
				}
				function createUpdate(eventTime, lane) {
					var update = {
						eventTime,
						lane,
						tag: UpdateState,
						payload: null,
						callback: null,
						next: null,
					}
					return update
				}
				function enqueueUpdate(fiber, update, lane) {
					var updateQueue = fiber.updateQueue
					if (updateQueue === null) {
						return null
					}
					var sharedQueue = updateQueue.shared
					{
						if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
							error(
								'An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.'
							)
							didWarnUpdateInsideUpdate = true
						}
					}
					if (isUnsafeClassRenderPhaseUpdate()) {
						var pending = sharedQueue.pending
						if (pending === null) {
							update.next = update
						} else {
							update.next = pending.next
							pending.next = update
						}
						sharedQueue.pending = update
						return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane)
					} else {
						return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane)
					}
				}
				function entangleTransitions(root3, fiber, lane) {
					var updateQueue = fiber.updateQueue
					if (updateQueue === null) {
						return
					}
					var sharedQueue = updateQueue.shared
					if (isTransitionLane(lane)) {
						var queueLanes = sharedQueue.lanes
						queueLanes = intersectLanes(queueLanes, root3.pendingLanes)
						var newQueueLanes = mergeLanes(queueLanes, lane)
						sharedQueue.lanes = newQueueLanes
						markRootEntangled(root3, newQueueLanes)
					}
				}
				function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
					var queue = workInProgress2.updateQueue
					var current2 = workInProgress2.alternate
					if (current2 !== null) {
						var currentQueue = current2.updateQueue
						if (queue === currentQueue) {
							var newFirst = null
							var newLast = null
							var firstBaseUpdate = queue.firstBaseUpdate
							if (firstBaseUpdate !== null) {
								var update = firstBaseUpdate
								do {
									var clone = {
										eventTime: update.eventTime,
										lane: update.lane,
										tag: update.tag,
										payload: update.payload,
										callback: update.callback,
										next: null,
									}
									if (newLast === null) {
										newFirst = newLast = clone
									} else {
										newLast.next = clone
										newLast = clone
									}
									update = update.next
								} while (update !== null)
								if (newLast === null) {
									newFirst = newLast = capturedUpdate
								} else {
									newLast.next = capturedUpdate
									newLast = capturedUpdate
								}
							} else {
								newFirst = newLast = capturedUpdate
							}
							queue = {
								baseState: currentQueue.baseState,
								firstBaseUpdate: newFirst,
								lastBaseUpdate: newLast,
								shared: currentQueue.shared,
								effects: currentQueue.effects,
							}
							workInProgress2.updateQueue = queue
							return
						}
					}
					var lastBaseUpdate = queue.lastBaseUpdate
					if (lastBaseUpdate === null) {
						queue.firstBaseUpdate = capturedUpdate
					} else {
						lastBaseUpdate.next = capturedUpdate
					}
					queue.lastBaseUpdate = capturedUpdate
				}
				function getStateFromUpdate(
					workInProgress2,
					queue,
					update,
					prevState,
					nextProps,
					instance
				) {
					switch (update.tag) {
						case ReplaceState: {
							var payload = update.payload
							if (typeof payload === 'function') {
								{
									enterDisallowedContextReadInDEV()
								}
								var nextState = payload.call(instance, prevState, nextProps)
								{
									if (workInProgress2.mode & StrictLegacyMode) {
										setIsStrictModeForDevtools(true)
										try {
											payload.call(instance, prevState, nextProps)
										} finally {
											setIsStrictModeForDevtools(false)
										}
									}
									exitDisallowedContextReadInDEV()
								}
								return nextState
							}
							return payload
						}
						case CaptureUpdate: {
							workInProgress2.flags = (workInProgress2.flags & ~ShouldCapture) | DidCapture
						}
						case UpdateState: {
							var _payload = update.payload
							var partialState
							if (typeof _payload === 'function') {
								{
									enterDisallowedContextReadInDEV()
								}
								partialState = _payload.call(instance, prevState, nextProps)
								{
									if (workInProgress2.mode & StrictLegacyMode) {
										setIsStrictModeForDevtools(true)
										try {
											_payload.call(instance, prevState, nextProps)
										} finally {
											setIsStrictModeForDevtools(false)
										}
									}
									exitDisallowedContextReadInDEV()
								}
							} else {
								partialState = _payload
							}
							if (partialState === null || partialState === void 0) {
								return prevState
							}
							return assign({}, prevState, partialState)
						}
						case ForceUpdate: {
							hasForceUpdate = true
							return prevState
						}
					}
					return prevState
				}
				function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
					var queue = workInProgress2.updateQueue
					hasForceUpdate = false
					{
						currentlyProcessingQueue = queue.shared
					}
					var firstBaseUpdate = queue.firstBaseUpdate
					var lastBaseUpdate = queue.lastBaseUpdate
					var pendingQueue = queue.shared.pending
					if (pendingQueue !== null) {
						queue.shared.pending = null
						var lastPendingUpdate = pendingQueue
						var firstPendingUpdate = lastPendingUpdate.next
						lastPendingUpdate.next = null
						if (lastBaseUpdate === null) {
							firstBaseUpdate = firstPendingUpdate
						} else {
							lastBaseUpdate.next = firstPendingUpdate
						}
						lastBaseUpdate = lastPendingUpdate
						var current2 = workInProgress2.alternate
						if (current2 !== null) {
							var currentQueue = current2.updateQueue
							var currentLastBaseUpdate = currentQueue.lastBaseUpdate
							if (currentLastBaseUpdate !== lastBaseUpdate) {
								if (currentLastBaseUpdate === null) {
									currentQueue.firstBaseUpdate = firstPendingUpdate
								} else {
									currentLastBaseUpdate.next = firstPendingUpdate
								}
								currentQueue.lastBaseUpdate = lastPendingUpdate
							}
						}
					}
					if (firstBaseUpdate !== null) {
						var newState = queue.baseState
						var newLanes = NoLanes
						var newBaseState = null
						var newFirstBaseUpdate = null
						var newLastBaseUpdate = null
						var update = firstBaseUpdate
						do {
							var updateLane = update.lane
							var updateEventTime = update.eventTime
							if (!isSubsetOfLanes(renderLanes2, updateLane)) {
								var clone = {
									eventTime: updateEventTime,
									lane: updateLane,
									tag: update.tag,
									payload: update.payload,
									callback: update.callback,
									next: null,
								}
								if (newLastBaseUpdate === null) {
									newFirstBaseUpdate = newLastBaseUpdate = clone
									newBaseState = newState
								} else {
									newLastBaseUpdate = newLastBaseUpdate.next = clone
								}
								newLanes = mergeLanes(newLanes, updateLane)
							} else {
								if (newLastBaseUpdate !== null) {
									var _clone = {
										eventTime: updateEventTime,
										// This update is going to be committed so we never want uncommit
										// it. Using NoLane works because 0 is a subset of all bitmasks, so
										// this will never be skipped by the check above.
										lane: NoLane,
										tag: update.tag,
										payload: update.payload,
										callback: update.callback,
										next: null,
									}
									newLastBaseUpdate = newLastBaseUpdate.next = _clone
								}
								newState = getStateFromUpdate(
									workInProgress2,
									queue,
									update,
									newState,
									props,
									instance
								)
								var callback = update.callback
								if (
									callback !== null && // If the update was already committed, we should not queue its
									// callback again.
									update.lane !== NoLane
								) {
									workInProgress2.flags |= Callback
									var effects = queue.effects
									if (effects === null) {
										queue.effects = [update]
									} else {
										effects.push(update)
									}
								}
							}
							update = update.next
							if (update === null) {
								pendingQueue = queue.shared.pending
								if (pendingQueue === null) {
									break
								} else {
									var _lastPendingUpdate = pendingQueue
									var _firstPendingUpdate = _lastPendingUpdate.next
									_lastPendingUpdate.next = null
									update = _firstPendingUpdate
									queue.lastBaseUpdate = _lastPendingUpdate
									queue.shared.pending = null
								}
							}
						} while (true)
						if (newLastBaseUpdate === null) {
							newBaseState = newState
						}
						queue.baseState = newBaseState
						queue.firstBaseUpdate = newFirstBaseUpdate
						queue.lastBaseUpdate = newLastBaseUpdate
						var lastInterleaved = queue.shared.interleaved
						if (lastInterleaved !== null) {
							var interleaved = lastInterleaved
							do {
								newLanes = mergeLanes(newLanes, interleaved.lane)
								interleaved = interleaved.next
							} while (interleaved !== lastInterleaved)
						} else if (firstBaseUpdate === null) {
							queue.shared.lanes = NoLanes
						}
						markSkippedUpdateLanes(newLanes)
						workInProgress2.lanes = newLanes
						workInProgress2.memoizedState = newState
					}
					{
						currentlyProcessingQueue = null
					}
				}
				function callCallback(callback, context) {
					if (typeof callback !== 'function') {
						throw new Error(
							'Invalid argument passed as callback. Expected a function. Instead ' +
								('received: ' + callback)
						)
					}
					callback.call(context)
				}
				function resetHasForceUpdateBeforeProcessing() {
					hasForceUpdate = false
				}
				function checkHasForceUpdateAfterProcessing() {
					return hasForceUpdate
				}
				function commitUpdateQueue(finishedWork, finishedQueue, instance) {
					var effects = finishedQueue.effects
					finishedQueue.effects = null
					if (effects !== null) {
						for (var i3 = 0; i3 < effects.length; i3++) {
							var effect = effects[i3]
							var callback = effect.callback
							if (callback !== null) {
								effect.callback = null
								callCallback(callback, instance)
							}
						}
					}
				}
				var fakeInternalInstance = {}
				var emptyRefsObject = new React70.Component().refs
				var didWarnAboutStateAssignmentForComponent
				var didWarnAboutUninitializedState
				var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
				var didWarnAboutLegacyLifecyclesAndDerivedState
				var didWarnAboutUndefinedDerivedState
				var warnOnUndefinedDerivedState
				var warnOnInvalidCallback
				var didWarnAboutDirectlyAssigningPropsToState
				var didWarnAboutContextTypeAndContextTypes
				var didWarnAboutInvalidateContextType
				{
					didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set()
					didWarnAboutUninitializedState = /* @__PURE__ */ new Set()
					didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set()
					didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set()
					didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set()
					didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set()
					didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set()
					didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set()
					var didWarnOnInvalidCallback = /* @__PURE__ */ new Set()
					warnOnInvalidCallback = function (callback, callerName) {
						if (callback === null || typeof callback === 'function') {
							return
						}
						var key = callerName + '_' + callback
						if (!didWarnOnInvalidCallback.has(key)) {
							didWarnOnInvalidCallback.add(key)
							error(
								'%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
								callerName,
								callback
							)
						}
					}
					warnOnUndefinedDerivedState = function (type, partialState) {
						if (partialState === void 0) {
							var componentName = getComponentNameFromType(type) || 'Component'
							if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
								didWarnAboutUndefinedDerivedState.add(componentName)
								error(
									'%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.',
									componentName
								)
							}
						}
					}
					Object.defineProperty(fakeInternalInstance, '_processChildContext', {
						enumerable: false,
						value: function () {
							throw new Error(
								"_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)."
							)
						},
					})
					Object.freeze(fakeInternalInstance)
				}
				function applyDerivedStateFromProps(
					workInProgress2,
					ctor,
					getDerivedStateFromProps,
					nextProps
				) {
					var prevState = workInProgress2.memoizedState
					var partialState = getDerivedStateFromProps(nextProps, prevState)
					{
						if (workInProgress2.mode & StrictLegacyMode) {
							setIsStrictModeForDevtools(true)
							try {
								partialState = getDerivedStateFromProps(nextProps, prevState)
							} finally {
								setIsStrictModeForDevtools(false)
							}
						}
						warnOnUndefinedDerivedState(ctor, partialState)
					}
					var memoizedState =
						partialState === null || partialState === void 0
							? prevState
							: assign({}, prevState, partialState)
					workInProgress2.memoizedState = memoizedState
					if (workInProgress2.lanes === NoLanes) {
						var updateQueue = workInProgress2.updateQueue
						updateQueue.baseState = memoizedState
					}
				}
				var classComponentUpdater = {
					isMounted,
					enqueueSetState: function (inst, payload, callback) {
						var fiber = get(inst)
						var eventTime = requestEventTime()
						var lane = requestUpdateLane(fiber)
						var update = createUpdate(eventTime, lane)
						update.payload = payload
						if (callback !== void 0 && callback !== null) {
							{
								warnOnInvalidCallback(callback, 'setState')
							}
							update.callback = callback
						}
						var root3 = enqueueUpdate(fiber, update, lane)
						if (root3 !== null) {
							scheduleUpdateOnFiber(root3, fiber, lane, eventTime)
							entangleTransitions(root3, fiber, lane)
						}
						{
							markStateUpdateScheduled(fiber, lane)
						}
					},
					enqueueReplaceState: function (inst, payload, callback) {
						var fiber = get(inst)
						var eventTime = requestEventTime()
						var lane = requestUpdateLane(fiber)
						var update = createUpdate(eventTime, lane)
						update.tag = ReplaceState
						update.payload = payload
						if (callback !== void 0 && callback !== null) {
							{
								warnOnInvalidCallback(callback, 'replaceState')
							}
							update.callback = callback
						}
						var root3 = enqueueUpdate(fiber, update, lane)
						if (root3 !== null) {
							scheduleUpdateOnFiber(root3, fiber, lane, eventTime)
							entangleTransitions(root3, fiber, lane)
						}
						{
							markStateUpdateScheduled(fiber, lane)
						}
					},
					enqueueForceUpdate: function (inst, callback) {
						var fiber = get(inst)
						var eventTime = requestEventTime()
						var lane = requestUpdateLane(fiber)
						var update = createUpdate(eventTime, lane)
						update.tag = ForceUpdate
						if (callback !== void 0 && callback !== null) {
							{
								warnOnInvalidCallback(callback, 'forceUpdate')
							}
							update.callback = callback
						}
						var root3 = enqueueUpdate(fiber, update, lane)
						if (root3 !== null) {
							scheduleUpdateOnFiber(root3, fiber, lane, eventTime)
							entangleTransitions(root3, fiber, lane)
						}
						{
							markForceUpdateScheduled(fiber, lane)
						}
					},
				}
				function checkShouldComponentUpdate(
					workInProgress2,
					ctor,
					oldProps,
					newProps,
					oldState,
					newState,
					nextContext
				) {
					var instance = workInProgress2.stateNode
					if (typeof instance.shouldComponentUpdate === 'function') {
						var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext)
						{
							if (workInProgress2.mode & StrictLegacyMode) {
								setIsStrictModeForDevtools(true)
								try {
									shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext)
								} finally {
									setIsStrictModeForDevtools(false)
								}
							}
							if (shouldUpdate === void 0) {
								error(
									'%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.',
									getComponentNameFromType(ctor) || 'Component'
								)
							}
						}
						return shouldUpdate
					}
					if (ctor.prototype && ctor.prototype.isPureReactComponent) {
						return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
					}
					return true
				}
				function checkClassInstance(workInProgress2, ctor, newProps) {
					var instance = workInProgress2.stateNode
					{
						var name = getComponentNameFromType(ctor) || 'Component'
						var renderPresent = instance.render
						if (!renderPresent) {
							if (ctor.prototype && typeof ctor.prototype.render === 'function') {
								error(
									'%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?',
									name
								)
							} else {
								error(
									'%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.',
									name
								)
							}
						}
						if (
							instance.getInitialState &&
							!instance.getInitialState.isReactClassApproved &&
							!instance.state
						) {
							error(
								'getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?',
								name
							)
						}
						if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
							error(
								'getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.',
								name
							)
						}
						if (instance.propTypes) {
							error(
								'propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.',
								name
							)
						}
						if (instance.contextType) {
							error(
								'contextType was defined as an instance property on %s. Use a static property to define contextType instead.',
								name
							)
						}
						{
							if (instance.contextTypes) {
								error(
									'contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.',
									name
								)
							}
							if (
								ctor.contextType &&
								ctor.contextTypes &&
								!didWarnAboutContextTypeAndContextTypes.has(ctor)
							) {
								didWarnAboutContextTypeAndContextTypes.add(ctor)
								error(
									'%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.',
									name
								)
							}
						}
						if (typeof instance.componentShouldUpdate === 'function') {
							error(
								'%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.',
								name
							)
						}
						if (
							ctor.prototype &&
							ctor.prototype.isPureReactComponent &&
							typeof instance.shouldComponentUpdate !== 'undefined'
						) {
							error(
								'%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.',
								getComponentNameFromType(ctor) || 'A pure component'
							)
						}
						if (typeof instance.componentDidUnmount === 'function') {
							error(
								'%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?',
								name
							)
						}
						if (typeof instance.componentDidReceiveProps === 'function') {
							error(
								'%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
								name
							)
						}
						if (typeof instance.componentWillRecieveProps === 'function') {
							error(
								'%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
								name
							)
						}
						if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
							error(
								'%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',
								name
							)
						}
						var hasMutatedProps = instance.props !== newProps
						if (instance.props !== void 0 && hasMutatedProps) {
							error(
								"%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
								name,
								name
							)
						}
						if (instance.defaultProps) {
							error(
								'Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.',
								name,
								name
							)
						}
						if (
							typeof instance.getSnapshotBeforeUpdate === 'function' &&
							typeof instance.componentDidUpdate !== 'function' &&
							!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)
						) {
							didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor)
							error(
								'%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.',
								getComponentNameFromType(ctor)
							)
						}
						if (typeof instance.getDerivedStateFromProps === 'function') {
							error(
								'%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
								name
							)
						}
						if (typeof instance.getDerivedStateFromError === 'function') {
							error(
								'%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
								name
							)
						}
						if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
							error(
								'%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.',
								name
							)
						}
						var _state = instance.state
						if (_state && (typeof _state !== 'object' || isArray(_state))) {
							error('%s.state: must be set to an object or null', name)
						}
						if (
							typeof instance.getChildContext === 'function' &&
							typeof ctor.childContextTypes !== 'object'
						) {
							error(
								'%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().',
								name
							)
						}
					}
				}
				function adoptClassInstance(workInProgress2, instance) {
					instance.updater = classComponentUpdater
					workInProgress2.stateNode = instance
					set(instance, workInProgress2)
					{
						instance._reactInternalInstance = fakeInternalInstance
					}
				}
				function constructClassInstance(workInProgress2, ctor, props) {
					var isLegacyContextConsumer = false
					var unmaskedContext = emptyContextObject
					var context = emptyContextObject
					var contextType = ctor.contextType
					{
						if ('contextType' in ctor) {
							var isValid =
								// Allow null for conditional declaration
								contextType === null ||
								(contextType !== void 0 &&
									contextType.$$typeof === REACT_CONTEXT_TYPE &&
									contextType._context === void 0)
							if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
								didWarnAboutInvalidateContextType.add(ctor)
								var addendum = ''
								if (contextType === void 0) {
									addendum =
										' However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.'
								} else if (typeof contextType !== 'object') {
									addendum = ' However, it is set to a ' + typeof contextType + '.'
								} else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
									addendum = ' Did you accidentally pass the Context.Provider instead?'
								} else if (contextType._context !== void 0) {
									addendum = ' Did you accidentally pass the Context.Consumer instead?'
								} else {
									addendum =
										' However, it is set to an object with keys {' +
										Object.keys(contextType).join(', ') +
										'}.'
								}
								error(
									'%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s',
									getComponentNameFromType(ctor) || 'Component',
									addendum
								)
							}
						}
					}
					if (typeof contextType === 'object' && contextType !== null) {
						context = readContext(contextType)
					} else {
						unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true)
						var contextTypes = ctor.contextTypes
						isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0
						context = isLegacyContextConsumer
							? getMaskedContext(workInProgress2, unmaskedContext)
							: emptyContextObject
					}
					var instance = new ctor(props, context)
					{
						if (workInProgress2.mode & StrictLegacyMode) {
							setIsStrictModeForDevtools(true)
							try {
								instance = new ctor(props, context)
							} finally {
								setIsStrictModeForDevtools(false)
							}
						}
					}
					var state = (workInProgress2.memoizedState =
						instance.state !== null && instance.state !== void 0 ? instance.state : null)
					adoptClassInstance(workInProgress2, instance)
					{
						if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
							var componentName = getComponentNameFromType(ctor) || 'Component'
							if (!didWarnAboutUninitializedState.has(componentName)) {
								didWarnAboutUninitializedState.add(componentName)
								error(
									'`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',
									componentName,
									instance.state === null ? 'null' : 'undefined',
									componentName
								)
							}
						}
						if (
							typeof ctor.getDerivedStateFromProps === 'function' ||
							typeof instance.getSnapshotBeforeUpdate === 'function'
						) {
							var foundWillMountName = null
							var foundWillReceivePropsName = null
							var foundWillUpdateName = null
							if (
								typeof instance.componentWillMount === 'function' &&
								instance.componentWillMount.__suppressDeprecationWarning !== true
							) {
								foundWillMountName = 'componentWillMount'
							} else if (typeof instance.UNSAFE_componentWillMount === 'function') {
								foundWillMountName = 'UNSAFE_componentWillMount'
							}
							if (
								typeof instance.componentWillReceiveProps === 'function' &&
								instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
							) {
								foundWillReceivePropsName = 'componentWillReceiveProps'
							} else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
								foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps'
							}
							if (
								typeof instance.componentWillUpdate === 'function' &&
								instance.componentWillUpdate.__suppressDeprecationWarning !== true
							) {
								foundWillUpdateName = 'componentWillUpdate'
							} else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
								foundWillUpdateName = 'UNSAFE_componentWillUpdate'
							}
							if (
								foundWillMountName !== null ||
								foundWillReceivePropsName !== null ||
								foundWillUpdateName !== null
							) {
								var _componentName = getComponentNameFromType(ctor) || 'Component'
								var newApiName =
									typeof ctor.getDerivedStateFromProps === 'function'
										? 'getDerivedStateFromProps()'
										: 'getSnapshotBeforeUpdate()'
								if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
									didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName)
									error(
										'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles',
										_componentName,
										newApiName,
										foundWillMountName !== null ? '\n  ' + foundWillMountName : '',
										foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '',
										foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : ''
									)
								}
							}
						}
					}
					if (isLegacyContextConsumer) {
						cacheContext(workInProgress2, unmaskedContext, context)
					}
					return instance
				}
				function callComponentWillMount(workInProgress2, instance) {
					var oldState = instance.state
					if (typeof instance.componentWillMount === 'function') {
						instance.componentWillMount()
					}
					if (typeof instance.UNSAFE_componentWillMount === 'function') {
						instance.UNSAFE_componentWillMount()
					}
					if (oldState !== instance.state) {
						{
							error(
								"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
								getComponentNameFromFiber(workInProgress2) || 'Component'
							)
						}
						classComponentUpdater.enqueueReplaceState(instance, instance.state, null)
					}
				}
				function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
					var oldState = instance.state
					if (typeof instance.componentWillReceiveProps === 'function') {
						instance.componentWillReceiveProps(newProps, nextContext)
					}
					if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
						instance.UNSAFE_componentWillReceiveProps(newProps, nextContext)
					}
					if (instance.state !== oldState) {
						{
							var componentName = getComponentNameFromFiber(workInProgress2) || 'Component'
							if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
								didWarnAboutStateAssignmentForComponent.add(componentName)
								error(
									"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
									componentName
								)
							}
						}
						classComponentUpdater.enqueueReplaceState(instance, instance.state, null)
					}
				}
				function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
					{
						checkClassInstance(workInProgress2, ctor, newProps)
					}
					var instance = workInProgress2.stateNode
					instance.props = newProps
					instance.state = workInProgress2.memoizedState
					instance.refs = emptyRefsObject
					initializeUpdateQueue(workInProgress2)
					var contextType = ctor.contextType
					if (typeof contextType === 'object' && contextType !== null) {
						instance.context = readContext(contextType)
					} else {
						var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true)
						instance.context = getMaskedContext(workInProgress2, unmaskedContext)
					}
					{
						if (instance.state === newProps) {
							var componentName = getComponentNameFromType(ctor) || 'Component'
							if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
								didWarnAboutDirectlyAssigningPropsToState.add(componentName)
								error(
									"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
									componentName
								)
							}
						}
						if (workInProgress2.mode & StrictLegacyMode) {
							ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance)
						}
						{
							ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance)
						}
					}
					instance.state = workInProgress2.memoizedState
					var getDerivedStateFromProps = ctor.getDerivedStateFromProps
					if (typeof getDerivedStateFromProps === 'function') {
						applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps)
						instance.state = workInProgress2.memoizedState
					}
					if (
						typeof ctor.getDerivedStateFromProps !== 'function' &&
						typeof instance.getSnapshotBeforeUpdate !== 'function' &&
						(typeof instance.UNSAFE_componentWillMount === 'function' ||
							typeof instance.componentWillMount === 'function')
					) {
						callComponentWillMount(workInProgress2, instance)
						processUpdateQueue(workInProgress2, newProps, instance, renderLanes2)
						instance.state = workInProgress2.memoizedState
					}
					if (typeof instance.componentDidMount === 'function') {
						var fiberFlags = Update
						{
							fiberFlags |= LayoutStatic
						}
						if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
							fiberFlags |= MountLayoutDev
						}
						workInProgress2.flags |= fiberFlags
					}
				}
				function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
					var instance = workInProgress2.stateNode
					var oldProps = workInProgress2.memoizedProps
					instance.props = oldProps
					var oldContext = instance.context
					var contextType = ctor.contextType
					var nextContext = emptyContextObject
					if (typeof contextType === 'object' && contextType !== null) {
						nextContext = readContext(contextType)
					} else {
						var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true)
						nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext)
					}
					var getDerivedStateFromProps = ctor.getDerivedStateFromProps
					var hasNewLifecycles =
						typeof getDerivedStateFromProps === 'function' ||
						typeof instance.getSnapshotBeforeUpdate === 'function'
					if (
						!hasNewLifecycles &&
						(typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||
							typeof instance.componentWillReceiveProps === 'function')
					) {
						if (oldProps !== newProps || oldContext !== nextContext) {
							callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext)
						}
					}
					resetHasForceUpdateBeforeProcessing()
					var oldState = workInProgress2.memoizedState
					var newState = (instance.state = oldState)
					processUpdateQueue(workInProgress2, newProps, instance, renderLanes2)
					newState = workInProgress2.memoizedState
					if (
						oldProps === newProps &&
						oldState === newState &&
						!hasContextChanged() &&
						!checkHasForceUpdateAfterProcessing()
					) {
						if (typeof instance.componentDidMount === 'function') {
							var fiberFlags = Update
							{
								fiberFlags |= LayoutStatic
							}
							if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
								fiberFlags |= MountLayoutDev
							}
							workInProgress2.flags |= fiberFlags
						}
						return false
					}
					if (typeof getDerivedStateFromProps === 'function') {
						applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps)
						newState = workInProgress2.memoizedState
					}
					var shouldUpdate =
						checkHasForceUpdateAfterProcessing() ||
						checkShouldComponentUpdate(
							workInProgress2,
							ctor,
							oldProps,
							newProps,
							oldState,
							newState,
							nextContext
						)
					if (shouldUpdate) {
						if (
							!hasNewLifecycles &&
							(typeof instance.UNSAFE_componentWillMount === 'function' ||
								typeof instance.componentWillMount === 'function')
						) {
							if (typeof instance.componentWillMount === 'function') {
								instance.componentWillMount()
							}
							if (typeof instance.UNSAFE_componentWillMount === 'function') {
								instance.UNSAFE_componentWillMount()
							}
						}
						if (typeof instance.componentDidMount === 'function') {
							var _fiberFlags = Update
							{
								_fiberFlags |= LayoutStatic
							}
							if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
								_fiberFlags |= MountLayoutDev
							}
							workInProgress2.flags |= _fiberFlags
						}
					} else {
						if (typeof instance.componentDidMount === 'function') {
							var _fiberFlags2 = Update
							{
								_fiberFlags2 |= LayoutStatic
							}
							if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
								_fiberFlags2 |= MountLayoutDev
							}
							workInProgress2.flags |= _fiberFlags2
						}
						workInProgress2.memoizedProps = newProps
						workInProgress2.memoizedState = newState
					}
					instance.props = newProps
					instance.state = newState
					instance.context = nextContext
					return shouldUpdate
				}
				function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
					var instance = workInProgress2.stateNode
					cloneUpdateQueue(current2, workInProgress2)
					var unresolvedOldProps = workInProgress2.memoizedProps
					var oldProps =
						workInProgress2.type === workInProgress2.elementType
							? unresolvedOldProps
							: resolveDefaultProps(workInProgress2.type, unresolvedOldProps)
					instance.props = oldProps
					var unresolvedNewProps = workInProgress2.pendingProps
					var oldContext = instance.context
					var contextType = ctor.contextType
					var nextContext = emptyContextObject
					if (typeof contextType === 'object' && contextType !== null) {
						nextContext = readContext(contextType)
					} else {
						var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true)
						nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext)
					}
					var getDerivedStateFromProps = ctor.getDerivedStateFromProps
					var hasNewLifecycles =
						typeof getDerivedStateFromProps === 'function' ||
						typeof instance.getSnapshotBeforeUpdate === 'function'
					if (
						!hasNewLifecycles &&
						(typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||
							typeof instance.componentWillReceiveProps === 'function')
					) {
						if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
							callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext)
						}
					}
					resetHasForceUpdateBeforeProcessing()
					var oldState = workInProgress2.memoizedState
					var newState = (instance.state = oldState)
					processUpdateQueue(workInProgress2, newProps, instance, renderLanes2)
					newState = workInProgress2.memoizedState
					if (
						unresolvedOldProps === unresolvedNewProps &&
						oldState === newState &&
						!hasContextChanged() &&
						!checkHasForceUpdateAfterProcessing() &&
						!enableLazyContextPropagation
					) {
						if (typeof instance.componentDidUpdate === 'function') {
							if (
								unresolvedOldProps !== current2.memoizedProps ||
								oldState !== current2.memoizedState
							) {
								workInProgress2.flags |= Update
							}
						}
						if (typeof instance.getSnapshotBeforeUpdate === 'function') {
							if (
								unresolvedOldProps !== current2.memoizedProps ||
								oldState !== current2.memoizedState
							) {
								workInProgress2.flags |= Snapshot
							}
						}
						return false
					}
					if (typeof getDerivedStateFromProps === 'function') {
						applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps)
						newState = workInProgress2.memoizedState
					}
					var shouldUpdate =
						checkHasForceUpdateAfterProcessing() ||
						checkShouldComponentUpdate(
							workInProgress2,
							ctor,
							oldProps,
							newProps,
							oldState,
							newState,
							nextContext
						) || // TODO: In some cases, we'll end up checking if context has changed twice,
						// both before and after `shouldComponentUpdate` has been called. Not ideal,
						// but I'm loath to refactor this function. This only happens for memoized
						// components so it's not that common.
						enableLazyContextPropagation
					if (shouldUpdate) {
						if (
							!hasNewLifecycles &&
							(typeof instance.UNSAFE_componentWillUpdate === 'function' ||
								typeof instance.componentWillUpdate === 'function')
						) {
							if (typeof instance.componentWillUpdate === 'function') {
								instance.componentWillUpdate(newProps, newState, nextContext)
							}
							if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
								instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext)
							}
						}
						if (typeof instance.componentDidUpdate === 'function') {
							workInProgress2.flags |= Update
						}
						if (typeof instance.getSnapshotBeforeUpdate === 'function') {
							workInProgress2.flags |= Snapshot
						}
					} else {
						if (typeof instance.componentDidUpdate === 'function') {
							if (
								unresolvedOldProps !== current2.memoizedProps ||
								oldState !== current2.memoizedState
							) {
								workInProgress2.flags |= Update
							}
						}
						if (typeof instance.getSnapshotBeforeUpdate === 'function') {
							if (
								unresolvedOldProps !== current2.memoizedProps ||
								oldState !== current2.memoizedState
							) {
								workInProgress2.flags |= Snapshot
							}
						}
						workInProgress2.memoizedProps = newProps
						workInProgress2.memoizedState = newState
					}
					instance.props = newProps
					instance.state = newState
					instance.context = nextContext
					return shouldUpdate
				}
				var didWarnAboutMaps
				var didWarnAboutGenerators
				var didWarnAboutStringRefs
				var ownerHasKeyUseWarning
				var ownerHasFunctionTypeWarning
				var warnForMissingKey = function (child, returnFiber) {}
				{
					didWarnAboutMaps = false
					didWarnAboutGenerators = false
					didWarnAboutStringRefs = {}
					ownerHasKeyUseWarning = {}
					ownerHasFunctionTypeWarning = {}
					warnForMissingKey = function (child, returnFiber) {
						if (child === null || typeof child !== 'object') {
							return
						}
						if (!child._store || child._store.validated || child.key != null) {
							return
						}
						if (typeof child._store !== 'object') {
							throw new Error(
								'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
						child._store.validated = true
						var componentName = getComponentNameFromFiber(returnFiber) || 'Component'
						if (ownerHasKeyUseWarning[componentName]) {
							return
						}
						ownerHasKeyUseWarning[componentName] = true
						error(
							'Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'
						)
					}
				}
				function coerceRef(returnFiber, current2, element) {
					var mixedRef = element.ref
					if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
						{
							if (
								(returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
								// because these cannot be automatically converted to an arrow function
								// using a codemod. Therefore, we don't have to warn about string refs again.
								!(element._owner && element._self && element._owner.stateNode !== element._self)
							) {
								var componentName = getComponentNameFromFiber(returnFiber) || 'Component'
								if (!didWarnAboutStringRefs[componentName]) {
									{
										error(
											'A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
											mixedRef
										)
									}
									didWarnAboutStringRefs[componentName] = true
								}
							}
						}
						if (element._owner) {
							var owner = element._owner
							var inst
							if (owner) {
								var ownerFiber = owner
								if (ownerFiber.tag !== ClassComponent) {
									throw new Error(
										'Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref'
									)
								}
								inst = ownerFiber.stateNode
							}
							if (!inst) {
								throw new Error(
									'Missing owner for string ref ' +
										mixedRef +
										'. This error is likely caused by a bug in React. Please file an issue.'
								)
							}
							var resolvedInst = inst
							{
								checkPropStringCoercion(mixedRef, 'ref')
							}
							var stringRef = '' + mixedRef
							if (
								current2 !== null &&
								current2.ref !== null &&
								typeof current2.ref === 'function' &&
								current2.ref._stringRef === stringRef
							) {
								return current2.ref
							}
							var ref = function (value) {
								var refs = resolvedInst.refs
								if (refs === emptyRefsObject) {
									refs = resolvedInst.refs = {}
								}
								if (value === null) {
									delete refs[stringRef]
								} else {
									refs[stringRef] = value
								}
							}
							ref._stringRef = stringRef
							return ref
						} else {
							if (typeof mixedRef !== 'string') {
								throw new Error(
									'Expected ref to be a function, a string, an object returned by React.createRef(), or null.'
								)
							}
							if (!element._owner) {
								throw new Error(
									'Element ref was specified as a string (' +
										mixedRef +
										") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information."
								)
							}
						}
					}
					return mixedRef
				}
				function throwOnInvalidObjectType(returnFiber, newChild) {
					var childString = Object.prototype.toString.call(newChild)
					throw new Error(
						'Objects are not valid as a React child (found: ' +
							(childString === '[object Object]'
								? 'object with keys {' + Object.keys(newChild).join(', ') + '}'
								: childString) +
							'). If you meant to render a collection of children, use an array instead.'
					)
				}
				function warnOnFunctionType(returnFiber) {
					{
						var componentName = getComponentNameFromFiber(returnFiber) || 'Component'
						if (ownerHasFunctionTypeWarning[componentName]) {
							return
						}
						ownerHasFunctionTypeWarning[componentName] = true
						error(
							'Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.'
						)
					}
				}
				function resolveLazy(lazyType) {
					var payload = lazyType._payload
					var init = lazyType._init
					return init(payload)
				}
				function ChildReconciler(shouldTrackSideEffects) {
					function deleteChild(returnFiber, childToDelete) {
						if (!shouldTrackSideEffects) {
							return
						}
						var deletions = returnFiber.deletions
						if (deletions === null) {
							returnFiber.deletions = [childToDelete]
							returnFiber.flags |= ChildDeletion
						} else {
							deletions.push(childToDelete)
						}
					}
					function deleteRemainingChildren(returnFiber, currentFirstChild) {
						if (!shouldTrackSideEffects) {
							return null
						}
						var childToDelete = currentFirstChild
						while (childToDelete !== null) {
							deleteChild(returnFiber, childToDelete)
							childToDelete = childToDelete.sibling
						}
						return null
					}
					function mapRemainingChildren(returnFiber, currentFirstChild) {
						var existingChildren = /* @__PURE__ */ new Map()
						var existingChild = currentFirstChild
						while (existingChild !== null) {
							if (existingChild.key !== null) {
								existingChildren.set(existingChild.key, existingChild)
							} else {
								existingChildren.set(existingChild.index, existingChild)
							}
							existingChild = existingChild.sibling
						}
						return existingChildren
					}
					function useFiber(fiber, pendingProps) {
						var clone = createWorkInProgress(fiber, pendingProps)
						clone.index = 0
						clone.sibling = null
						return clone
					}
					function placeChild(newFiber, lastPlacedIndex, newIndex) {
						newFiber.index = newIndex
						if (!shouldTrackSideEffects) {
							newFiber.flags |= Forked
							return lastPlacedIndex
						}
						var current2 = newFiber.alternate
						if (current2 !== null) {
							var oldIndex = current2.index
							if (oldIndex < lastPlacedIndex) {
								newFiber.flags |= Placement
								return lastPlacedIndex
							} else {
								return oldIndex
							}
						} else {
							newFiber.flags |= Placement
							return lastPlacedIndex
						}
					}
					function placeSingleChild(newFiber) {
						if (shouldTrackSideEffects && newFiber.alternate === null) {
							newFiber.flags |= Placement
						}
						return newFiber
					}
					function updateTextNode(returnFiber, current2, textContent, lanes) {
						if (current2 === null || current2.tag !== HostText) {
							var created = createFiberFromText(textContent, returnFiber.mode, lanes)
							created.return = returnFiber
							return created
						} else {
							var existing = useFiber(current2, textContent)
							existing.return = returnFiber
							return existing
						}
					}
					function updateElement(returnFiber, current2, element, lanes) {
						var elementType = element.type
						if (elementType === REACT_FRAGMENT_TYPE) {
							return updateFragment2(
								returnFiber,
								current2,
								element.props.children,
								lanes,
								element.key
							)
						}
						if (current2 !== null) {
							if (
								current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
								isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
								// We need to do this after the Hot Reloading check above,
								// because hot reloading has different semantics than prod because
								// it doesn't resuspend. So we can't let the call below suspend.
								(typeof elementType === 'object' &&
									elementType !== null &&
									elementType.$$typeof === REACT_LAZY_TYPE &&
									resolveLazy(elementType) === current2.type)
							) {
								var existing = useFiber(current2, element.props)
								existing.ref = coerceRef(returnFiber, current2, element)
								existing.return = returnFiber
								{
									existing._debugSource = element._source
									existing._debugOwner = element._owner
								}
								return existing
							}
						}
						var created = createFiberFromElement(element, returnFiber.mode, lanes)
						created.ref = coerceRef(returnFiber, current2, element)
						created.return = returnFiber
						return created
					}
					function updatePortal(returnFiber, current2, portal, lanes) {
						if (
							current2 === null ||
							current2.tag !== HostPortal ||
							current2.stateNode.containerInfo !== portal.containerInfo ||
							current2.stateNode.implementation !== portal.implementation
						) {
							var created = createFiberFromPortal(portal, returnFiber.mode, lanes)
							created.return = returnFiber
							return created
						} else {
							var existing = useFiber(current2, portal.children || [])
							existing.return = returnFiber
							return existing
						}
					}
					function updateFragment2(returnFiber, current2, fragment, lanes, key) {
						if (current2 === null || current2.tag !== Fragment41) {
							var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key)
							created.return = returnFiber
							return created
						} else {
							var existing = useFiber(current2, fragment)
							existing.return = returnFiber
							return existing
						}
					}
					function createChild(returnFiber, newChild, lanes) {
						if ((typeof newChild === 'string' && newChild !== '') || typeof newChild === 'number') {
							var created = createFiberFromText('' + newChild, returnFiber.mode, lanes)
							created.return = returnFiber
							return created
						}
						if (typeof newChild === 'object' && newChild !== null) {
							switch (newChild.$$typeof) {
								case REACT_ELEMENT_TYPE: {
									var _created = createFiberFromElement(newChild, returnFiber.mode, lanes)
									_created.ref = coerceRef(returnFiber, null, newChild)
									_created.return = returnFiber
									return _created
								}
								case REACT_PORTAL_TYPE: {
									var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes)
									_created2.return = returnFiber
									return _created2
								}
								case REACT_LAZY_TYPE: {
									var payload = newChild._payload
									var init = newChild._init
									return createChild(returnFiber, init(payload), lanes)
								}
							}
							if (isArray(newChild) || getIteratorFn(newChild)) {
								var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null)
								_created3.return = returnFiber
								return _created3
							}
							throwOnInvalidObjectType(returnFiber, newChild)
						}
						{
							if (typeof newChild === 'function') {
								warnOnFunctionType(returnFiber)
							}
						}
						return null
					}
					function updateSlot(returnFiber, oldFiber, newChild, lanes) {
						var key = oldFiber !== null ? oldFiber.key : null
						if ((typeof newChild === 'string' && newChild !== '') || typeof newChild === 'number') {
							if (key !== null) {
								return null
							}
							return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes)
						}
						if (typeof newChild === 'object' && newChild !== null) {
							switch (newChild.$$typeof) {
								case REACT_ELEMENT_TYPE: {
									if (newChild.key === key) {
										return updateElement(returnFiber, oldFiber, newChild, lanes)
									} else {
										return null
									}
								}
								case REACT_PORTAL_TYPE: {
									if (newChild.key === key) {
										return updatePortal(returnFiber, oldFiber, newChild, lanes)
									} else {
										return null
									}
								}
								case REACT_LAZY_TYPE: {
									var payload = newChild._payload
									var init = newChild._init
									return updateSlot(returnFiber, oldFiber, init(payload), lanes)
								}
							}
							if (isArray(newChild) || getIteratorFn(newChild)) {
								if (key !== null) {
									return null
								}
								return updateFragment2(returnFiber, oldFiber, newChild, lanes, null)
							}
							throwOnInvalidObjectType(returnFiber, newChild)
						}
						{
							if (typeof newChild === 'function') {
								warnOnFunctionType(returnFiber)
							}
						}
						return null
					}
					function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
						if ((typeof newChild === 'string' && newChild !== '') || typeof newChild === 'number') {
							var matchedFiber = existingChildren.get(newIdx) || null
							return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes)
						}
						if (typeof newChild === 'object' && newChild !== null) {
							switch (newChild.$$typeof) {
								case REACT_ELEMENT_TYPE: {
									var _matchedFiber =
										existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null
									return updateElement(returnFiber, _matchedFiber, newChild, lanes)
								}
								case REACT_PORTAL_TYPE: {
									var _matchedFiber2 =
										existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null
									return updatePortal(returnFiber, _matchedFiber2, newChild, lanes)
								}
								case REACT_LAZY_TYPE:
									var payload = newChild._payload
									var init = newChild._init
									return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes)
							}
							if (isArray(newChild) || getIteratorFn(newChild)) {
								var _matchedFiber3 = existingChildren.get(newIdx) || null
								return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null)
							}
							throwOnInvalidObjectType(returnFiber, newChild)
						}
						{
							if (typeof newChild === 'function') {
								warnOnFunctionType(returnFiber)
							}
						}
						return null
					}
					function warnOnInvalidKey(child, knownKeys, returnFiber) {
						{
							if (typeof child !== 'object' || child === null) {
								return knownKeys
							}
							switch (child.$$typeof) {
								case REACT_ELEMENT_TYPE:
								case REACT_PORTAL_TYPE:
									warnForMissingKey(child, returnFiber)
									var key = child.key
									if (typeof key !== 'string') {
										break
									}
									if (knownKeys === null) {
										knownKeys = /* @__PURE__ */ new Set()
										knownKeys.add(key)
										break
									}
									if (!knownKeys.has(key)) {
										knownKeys.add(key)
										break
									}
									error(
										'Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.',
										key
									)
									break
								case REACT_LAZY_TYPE:
									var payload = child._payload
									var init = child._init
									warnOnInvalidKey(init(payload), knownKeys, returnFiber)
									break
							}
						}
						return knownKeys
					}
					function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
						{
							var knownKeys = null
							for (var i3 = 0; i3 < newChildren.length; i3++) {
								var child = newChildren[i3]
								knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber)
							}
						}
						var resultingFirstChild = null
						var previousNewFiber = null
						var oldFiber = currentFirstChild
						var lastPlacedIndex = 0
						var newIdx = 0
						var nextOldFiber = null
						for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
							if (oldFiber.index > newIdx) {
								nextOldFiber = oldFiber
								oldFiber = null
							} else {
								nextOldFiber = oldFiber.sibling
							}
							var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes)
							if (newFiber === null) {
								if (oldFiber === null) {
									oldFiber = nextOldFiber
								}
								break
							}
							if (shouldTrackSideEffects) {
								if (oldFiber && newFiber.alternate === null) {
									deleteChild(returnFiber, oldFiber)
								}
							}
							lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx)
							if (previousNewFiber === null) {
								resultingFirstChild = newFiber
							} else {
								previousNewFiber.sibling = newFiber
							}
							previousNewFiber = newFiber
							oldFiber = nextOldFiber
						}
						if (newIdx === newChildren.length) {
							deleteRemainingChildren(returnFiber, oldFiber)
							if (getIsHydrating()) {
								var numberOfForks = newIdx
								pushTreeFork(returnFiber, numberOfForks)
							}
							return resultingFirstChild
						}
						if (oldFiber === null) {
							for (; newIdx < newChildren.length; newIdx++) {
								var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes)
								if (_newFiber === null) {
									continue
								}
								lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx)
								if (previousNewFiber === null) {
									resultingFirstChild = _newFiber
								} else {
									previousNewFiber.sibling = _newFiber
								}
								previousNewFiber = _newFiber
							}
							if (getIsHydrating()) {
								var _numberOfForks = newIdx
								pushTreeFork(returnFiber, _numberOfForks)
							}
							return resultingFirstChild
						}
						var existingChildren = mapRemainingChildren(returnFiber, oldFiber)
						for (; newIdx < newChildren.length; newIdx++) {
							var _newFiber2 = updateFromMap(
								existingChildren,
								returnFiber,
								newIdx,
								newChildren[newIdx],
								lanes
							)
							if (_newFiber2 !== null) {
								if (shouldTrackSideEffects) {
									if (_newFiber2.alternate !== null) {
										existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key)
									}
								}
								lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx)
								if (previousNewFiber === null) {
									resultingFirstChild = _newFiber2
								} else {
									previousNewFiber.sibling = _newFiber2
								}
								previousNewFiber = _newFiber2
							}
						}
						if (shouldTrackSideEffects) {
							existingChildren.forEach(function (child2) {
								return deleteChild(returnFiber, child2)
							})
						}
						if (getIsHydrating()) {
							var _numberOfForks2 = newIdx
							pushTreeFork(returnFiber, _numberOfForks2)
						}
						return resultingFirstChild
					}
					function reconcileChildrenIterator(
						returnFiber,
						currentFirstChild,
						newChildrenIterable,
						lanes
					) {
						var iteratorFn = getIteratorFn(newChildrenIterable)
						if (typeof iteratorFn !== 'function') {
							throw new Error(
								'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
						{
							if (
								typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
								newChildrenIterable[Symbol.toStringTag] === 'Generator'
							) {
								if (!didWarnAboutGenerators) {
									error(
										'Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.'
									)
								}
								didWarnAboutGenerators = true
							}
							if (newChildrenIterable.entries === iteratorFn) {
								if (!didWarnAboutMaps) {
									error(
										'Using Maps as children is not supported. Use an array of keyed ReactElements instead.'
									)
								}
								didWarnAboutMaps = true
							}
							var _newChildren = iteratorFn.call(newChildrenIterable)
							if (_newChildren) {
								var knownKeys = null
								var _step = _newChildren.next()
								for (; !_step.done; _step = _newChildren.next()) {
									var child = _step.value
									knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber)
								}
							}
						}
						var newChildren = iteratorFn.call(newChildrenIterable)
						if (newChildren == null) {
							throw new Error('An iterable object provided no iterator.')
						}
						var resultingFirstChild = null
						var previousNewFiber = null
						var oldFiber = currentFirstChild
						var lastPlacedIndex = 0
						var newIdx = 0
						var nextOldFiber = null
						var step = newChildren.next()
						for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
							if (oldFiber.index > newIdx) {
								nextOldFiber = oldFiber
								oldFiber = null
							} else {
								nextOldFiber = oldFiber.sibling
							}
							var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes)
							if (newFiber === null) {
								if (oldFiber === null) {
									oldFiber = nextOldFiber
								}
								break
							}
							if (shouldTrackSideEffects) {
								if (oldFiber && newFiber.alternate === null) {
									deleteChild(returnFiber, oldFiber)
								}
							}
							lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx)
							if (previousNewFiber === null) {
								resultingFirstChild = newFiber
							} else {
								previousNewFiber.sibling = newFiber
							}
							previousNewFiber = newFiber
							oldFiber = nextOldFiber
						}
						if (step.done) {
							deleteRemainingChildren(returnFiber, oldFiber)
							if (getIsHydrating()) {
								var numberOfForks = newIdx
								pushTreeFork(returnFiber, numberOfForks)
							}
							return resultingFirstChild
						}
						if (oldFiber === null) {
							for (; !step.done; newIdx++, step = newChildren.next()) {
								var _newFiber3 = createChild(returnFiber, step.value, lanes)
								if (_newFiber3 === null) {
									continue
								}
								lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx)
								if (previousNewFiber === null) {
									resultingFirstChild = _newFiber3
								} else {
									previousNewFiber.sibling = _newFiber3
								}
								previousNewFiber = _newFiber3
							}
							if (getIsHydrating()) {
								var _numberOfForks3 = newIdx
								pushTreeFork(returnFiber, _numberOfForks3)
							}
							return resultingFirstChild
						}
						var existingChildren = mapRemainingChildren(returnFiber, oldFiber)
						for (; !step.done; newIdx++, step = newChildren.next()) {
							var _newFiber4 = updateFromMap(
								existingChildren,
								returnFiber,
								newIdx,
								step.value,
								lanes
							)
							if (_newFiber4 !== null) {
								if (shouldTrackSideEffects) {
									if (_newFiber4.alternate !== null) {
										existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key)
									}
								}
								lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx)
								if (previousNewFiber === null) {
									resultingFirstChild = _newFiber4
								} else {
									previousNewFiber.sibling = _newFiber4
								}
								previousNewFiber = _newFiber4
							}
						}
						if (shouldTrackSideEffects) {
							existingChildren.forEach(function (child2) {
								return deleteChild(returnFiber, child2)
							})
						}
						if (getIsHydrating()) {
							var _numberOfForks4 = newIdx
							pushTreeFork(returnFiber, _numberOfForks4)
						}
						return resultingFirstChild
					}
					function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
						if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
							deleteRemainingChildren(returnFiber, currentFirstChild.sibling)
							var existing = useFiber(currentFirstChild, textContent)
							existing.return = returnFiber
							return existing
						}
						deleteRemainingChildren(returnFiber, currentFirstChild)
						var created = createFiberFromText(textContent, returnFiber.mode, lanes)
						created.return = returnFiber
						return created
					}
					function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
						var key = element.key
						var child = currentFirstChild
						while (child !== null) {
							if (child.key === key) {
								var elementType = element.type
								if (elementType === REACT_FRAGMENT_TYPE) {
									if (child.tag === Fragment41) {
										deleteRemainingChildren(returnFiber, child.sibling)
										var existing = useFiber(child, element.props.children)
										existing.return = returnFiber
										{
											existing._debugSource = element._source
											existing._debugOwner = element._owner
										}
										return existing
									}
								} else {
									if (
										child.elementType === elementType || // Keep this check inline so it only runs on the false path:
										isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
										// We need to do this after the Hot Reloading check above,
										// because hot reloading has different semantics than prod because
										// it doesn't resuspend. So we can't let the call below suspend.
										(typeof elementType === 'object' &&
											elementType !== null &&
											elementType.$$typeof === REACT_LAZY_TYPE &&
											resolveLazy(elementType) === child.type)
									) {
										deleteRemainingChildren(returnFiber, child.sibling)
										var _existing = useFiber(child, element.props)
										_existing.ref = coerceRef(returnFiber, child, element)
										_existing.return = returnFiber
										{
											_existing._debugSource = element._source
											_existing._debugOwner = element._owner
										}
										return _existing
									}
								}
								deleteRemainingChildren(returnFiber, child)
								break
							} else {
								deleteChild(returnFiber, child)
							}
							child = child.sibling
						}
						if (element.type === REACT_FRAGMENT_TYPE) {
							var created = createFiberFromFragment(
								element.props.children,
								returnFiber.mode,
								lanes,
								element.key
							)
							created.return = returnFiber
							return created
						} else {
							var _created4 = createFiberFromElement(element, returnFiber.mode, lanes)
							_created4.ref = coerceRef(returnFiber, currentFirstChild, element)
							_created4.return = returnFiber
							return _created4
						}
					}
					function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
						var key = portal.key
						var child = currentFirstChild
						while (child !== null) {
							if (child.key === key) {
								if (
									child.tag === HostPortal &&
									child.stateNode.containerInfo === portal.containerInfo &&
									child.stateNode.implementation === portal.implementation
								) {
									deleteRemainingChildren(returnFiber, child.sibling)
									var existing = useFiber(child, portal.children || [])
									existing.return = returnFiber
									return existing
								} else {
									deleteRemainingChildren(returnFiber, child)
									break
								}
							} else {
								deleteChild(returnFiber, child)
							}
							child = child.sibling
						}
						var created = createFiberFromPortal(portal, returnFiber.mode, lanes)
						created.return = returnFiber
						return created
					}
					function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
						var isUnkeyedTopLevelFragment =
							typeof newChild === 'object' &&
							newChild !== null &&
							newChild.type === REACT_FRAGMENT_TYPE &&
							newChild.key === null
						if (isUnkeyedTopLevelFragment) {
							newChild = newChild.props.children
						}
						if (typeof newChild === 'object' && newChild !== null) {
							switch (newChild.$$typeof) {
								case REACT_ELEMENT_TYPE:
									return placeSingleChild(
										reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes)
									)
								case REACT_PORTAL_TYPE:
									return placeSingleChild(
										reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes)
									)
								case REACT_LAZY_TYPE:
									var payload = newChild._payload
									var init = newChild._init
									return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes)
							}
							if (isArray(newChild)) {
								return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes)
							}
							if (getIteratorFn(newChild)) {
								return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes)
							}
							throwOnInvalidObjectType(returnFiber, newChild)
						}
						if ((typeof newChild === 'string' && newChild !== '') || typeof newChild === 'number') {
							return placeSingleChild(
								reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes)
							)
						}
						{
							if (typeof newChild === 'function') {
								warnOnFunctionType(returnFiber)
							}
						}
						return deleteRemainingChildren(returnFiber, currentFirstChild)
					}
					return reconcileChildFibers2
				}
				var reconcileChildFibers = ChildReconciler(true)
				var mountChildFibers = ChildReconciler(false)
				function cloneChildFibers(current2, workInProgress2) {
					if (current2 !== null && workInProgress2.child !== current2.child) {
						throw new Error('Resuming work not yet implemented.')
					}
					if (workInProgress2.child === null) {
						return
					}
					var currentChild = workInProgress2.child
					var newChild = createWorkInProgress(currentChild, currentChild.pendingProps)
					workInProgress2.child = newChild
					newChild.return = workInProgress2
					while (currentChild.sibling !== null) {
						currentChild = currentChild.sibling
						newChild = newChild.sibling = createWorkInProgress(
							currentChild,
							currentChild.pendingProps
						)
						newChild.return = workInProgress2
					}
					newChild.sibling = null
				}
				function resetChildFibers(workInProgress2, lanes) {
					var child = workInProgress2.child
					while (child !== null) {
						resetWorkInProgress(child, lanes)
						child = child.sibling
					}
				}
				var NO_CONTEXT = {}
				var contextStackCursor$1 = createCursor(NO_CONTEXT)
				var contextFiberStackCursor = createCursor(NO_CONTEXT)
				var rootInstanceStackCursor = createCursor(NO_CONTEXT)
				function requiredContext(c3) {
					if (c3 === NO_CONTEXT) {
						throw new Error(
							'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'
						)
					}
					return c3
				}
				function getRootHostContainer() {
					var rootInstance = requiredContext(rootInstanceStackCursor.current)
					return rootInstance
				}
				function pushHostContainer(fiber, nextRootInstance) {
					push(rootInstanceStackCursor, nextRootInstance, fiber)
					push(contextFiberStackCursor, fiber, fiber)
					push(contextStackCursor$1, NO_CONTEXT, fiber)
					var nextRootContext = getRootHostContext(nextRootInstance)
					pop(contextStackCursor$1, fiber)
					push(contextStackCursor$1, nextRootContext, fiber)
				}
				function popHostContainer(fiber) {
					pop(contextStackCursor$1, fiber)
					pop(contextFiberStackCursor, fiber)
					pop(rootInstanceStackCursor, fiber)
				}
				function getHostContext() {
					var context = requiredContext(contextStackCursor$1.current)
					return context
				}
				function pushHostContext(fiber) {
					var rootInstance = requiredContext(rootInstanceStackCursor.current)
					var context = requiredContext(contextStackCursor$1.current)
					var nextContext = getChildHostContext(context, fiber.type)
					if (context === nextContext) {
						return
					}
					push(contextFiberStackCursor, fiber, fiber)
					push(contextStackCursor$1, nextContext, fiber)
				}
				function popHostContext(fiber) {
					if (contextFiberStackCursor.current !== fiber) {
						return
					}
					pop(contextStackCursor$1, fiber)
					pop(contextFiberStackCursor, fiber)
				}
				var DefaultSuspenseContext = 0
				var SubtreeSuspenseContextMask = 1
				var InvisibleParentSuspenseContext = 1
				var ForceSuspenseFallback = 2
				var suspenseStackCursor = createCursor(DefaultSuspenseContext)
				function hasSuspenseContext(parentContext, flag) {
					return (parentContext & flag) !== 0
				}
				function setDefaultShallowSuspenseContext(parentContext) {
					return parentContext & SubtreeSuspenseContextMask
				}
				function setShallowSuspenseContext(parentContext, shallowContext) {
					return (parentContext & SubtreeSuspenseContextMask) | shallowContext
				}
				function addSubtreeSuspenseContext(parentContext, subtreeContext) {
					return parentContext | subtreeContext
				}
				function pushSuspenseContext(fiber, newContext) {
					push(suspenseStackCursor, newContext, fiber)
				}
				function popSuspenseContext(fiber) {
					pop(suspenseStackCursor, fiber)
				}
				function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
					var nextState = workInProgress2.memoizedState
					if (nextState !== null) {
						if (nextState.dehydrated !== null) {
							return true
						}
						return false
					}
					var props = workInProgress2.memoizedProps
					{
						return true
					}
				}
				function findFirstSuspended(row) {
					var node = row
					while (node !== null) {
						if (node.tag === SuspenseComponent) {
							var state = node.memoizedState
							if (state !== null) {
								var dehydrated = state.dehydrated
								if (
									dehydrated === null ||
									isSuspenseInstancePending(dehydrated) ||
									isSuspenseInstanceFallback(dehydrated)
								) {
									return node
								}
							}
						} else if (
							node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
							// keep track of whether it suspended or not.
							node.memoizedProps.revealOrder !== void 0
						) {
							var didSuspend = (node.flags & DidCapture) !== NoFlags
							if (didSuspend) {
								return node
							}
						} else if (node.child !== null) {
							node.child.return = node
							node = node.child
							continue
						}
						if (node === row) {
							return null
						}
						while (node.sibling === null) {
							if (node.return === null || node.return === row) {
								return null
							}
							node = node.return
						}
						node.sibling.return = node.return
						node = node.sibling
					}
					return null
				}
				var NoFlags$1 =
					/*   */
					0
				var HasEffect =
					/* */
					1
				var Insertion =
					/*  */
					2
				var Layout2 =
					/*    */
					4
				var Passive$1 =
					/*   */
					8
				var workInProgressSources = []
				function resetWorkInProgressVersions() {
					for (var i3 = 0; i3 < workInProgressSources.length; i3++) {
						var mutableSource = workInProgressSources[i3]
						{
							mutableSource._workInProgressVersionPrimary = null
						}
					}
					workInProgressSources.length = 0
				}
				function registerMutableSourceForHydration(root3, mutableSource) {
					var getVersion = mutableSource._getVersion
					var version = getVersion(mutableSource._source)
					if (root3.mutableSourceEagerHydrationData == null) {
						root3.mutableSourceEagerHydrationData = [mutableSource, version]
					} else {
						root3.mutableSourceEagerHydrationData.push(mutableSource, version)
					}
				}
				var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
					ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig
				var didWarnAboutMismatchedHooksForComponent
				var didWarnUncachedGetSnapshot
				{
					didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set()
				}
				var renderLanes = NoLanes
				var currentlyRenderingFiber$1 = null
				var currentHook = null
				var workInProgressHook = null
				var didScheduleRenderPhaseUpdate = false
				var didScheduleRenderPhaseUpdateDuringThisPass = false
				var localIdCounter = 0
				var globalClientIdCounter = 0
				var RE_RENDER_LIMIT = 25
				var currentHookNameInDev = null
				var hookTypesDev = null
				var hookTypesUpdateIndexDev = -1
				var ignorePreviousDependencies = false
				function mountHookTypesDev() {
					{
						var hookName = currentHookNameInDev
						if (hookTypesDev === null) {
							hookTypesDev = [hookName]
						} else {
							hookTypesDev.push(hookName)
						}
					}
				}
				function updateHookTypesDev() {
					{
						var hookName = currentHookNameInDev
						if (hookTypesDev !== null) {
							hookTypesUpdateIndexDev++
							if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
								warnOnHookMismatchInDev(hookName)
							}
						}
					}
				}
				function checkDepsAreArrayDev(deps) {
					{
						if (deps !== void 0 && deps !== null && !isArray(deps)) {
							error(
								'%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.',
								currentHookNameInDev,
								typeof deps
							)
						}
					}
				}
				function warnOnHookMismatchInDev(currentHookName) {
					{
						var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1)
						if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
							didWarnAboutMismatchedHooksForComponent.add(componentName)
							if (hookTypesDev !== null) {
								var table = ''
								var secondColumnStart = 30
								for (var i3 = 0; i3 <= hookTypesUpdateIndexDev; i3++) {
									var oldHookName = hookTypesDev[i3]
									var newHookName = i3 === hookTypesUpdateIndexDev ? currentHookName : oldHookName
									var row = i3 + 1 + '. ' + oldHookName
									while (row.length < secondColumnStart) {
										row += ' '
									}
									row += newHookName + '\n'
									table += row
								}
								error(
									'React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n',
									componentName,
									table
								)
							}
						}
					}
				}
				function throwInvalidHookError() {
					throw new Error(
						'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.'
					)
				}
				function areHookInputsEqual(nextDeps, prevDeps) {
					{
						if (ignorePreviousDependencies) {
							return false
						}
					}
					if (prevDeps === null) {
						{
							error(
								'%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.',
								currentHookNameInDev
							)
						}
						return false
					}
					{
						if (nextDeps.length !== prevDeps.length) {
							error(
								'The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s',
								currentHookNameInDev,
								'[' + prevDeps.join(', ') + ']',
								'[' + nextDeps.join(', ') + ']'
							)
						}
					}
					for (var i3 = 0; i3 < prevDeps.length && i3 < nextDeps.length; i3++) {
						if (objectIs(nextDeps[i3], prevDeps[i3])) {
							continue
						}
						return false
					}
					return true
				}
				function renderWithHooks(
					current2,
					workInProgress2,
					Component3,
					props,
					secondArg,
					nextRenderLanes
				) {
					renderLanes = nextRenderLanes
					currentlyRenderingFiber$1 = workInProgress2
					{
						hookTypesDev = current2 !== null ? current2._debugHookTypes : null
						hookTypesUpdateIndexDev = -1
						ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type
					}
					workInProgress2.memoizedState = null
					workInProgress2.updateQueue = null
					workInProgress2.lanes = NoLanes
					{
						if (current2 !== null && current2.memoizedState !== null) {
							ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV
						} else if (hookTypesDev !== null) {
							ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV
						} else {
							ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV
						}
					}
					var children = Component3(props, secondArg)
					if (didScheduleRenderPhaseUpdateDuringThisPass) {
						var numberOfReRenders = 0
						do {
							didScheduleRenderPhaseUpdateDuringThisPass = false
							localIdCounter = 0
							if (numberOfReRenders >= RE_RENDER_LIMIT) {
								throw new Error(
									'Too many re-renders. React limits the number of renders to prevent an infinite loop.'
								)
							}
							numberOfReRenders += 1
							{
								ignorePreviousDependencies = false
							}
							currentHook = null
							workInProgressHook = null
							workInProgress2.updateQueue = null
							{
								hookTypesUpdateIndexDev = -1
							}
							ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV
							children = Component3(props, secondArg)
						} while (didScheduleRenderPhaseUpdateDuringThisPass)
					}
					ReactCurrentDispatcher$1.current = ContextOnlyDispatcher
					{
						workInProgress2._debugHookTypes = hookTypesDev
					}
					var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null
					renderLanes = NoLanes
					currentlyRenderingFiber$1 = null
					currentHook = null
					workInProgressHook = null
					{
						currentHookNameInDev = null
						hookTypesDev = null
						hookTypesUpdateIndexDev = -1
						if (
							current2 !== null &&
							(current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
							// and creates false positives. To make this work in legacy mode, we'd
							// need to mark fibers that commit in an incomplete state, somehow. For
							// now I'll disable the warning that most of the bugs that would trigger
							// it are either exclusive to concurrent mode or exist in both.
							(current2.mode & ConcurrentMode) !== NoMode
						) {
							error(
								'Internal React error: Expected static flag was missing. Please notify the React team.'
							)
						}
					}
					didScheduleRenderPhaseUpdate = false
					if (didRenderTooFewHooks) {
						throw new Error(
							'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.'
						)
					}
					return children
				}
				function checkDidRenderIdHook() {
					var didRenderIdHook = localIdCounter !== 0
					localIdCounter = 0
					return didRenderIdHook
				}
				function bailoutHooks(current2, workInProgress2, lanes) {
					workInProgress2.updateQueue = current2.updateQueue
					if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
						workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update)
					} else {
						workInProgress2.flags &= ~(Passive | Update)
					}
					current2.lanes = removeLanes(current2.lanes, lanes)
				}
				function resetHooksAfterThrow() {
					ReactCurrentDispatcher$1.current = ContextOnlyDispatcher
					if (didScheduleRenderPhaseUpdate) {
						var hook = currentlyRenderingFiber$1.memoizedState
						while (hook !== null) {
							var queue = hook.queue
							if (queue !== null) {
								queue.pending = null
							}
							hook = hook.next
						}
						didScheduleRenderPhaseUpdate = false
					}
					renderLanes = NoLanes
					currentlyRenderingFiber$1 = null
					currentHook = null
					workInProgressHook = null
					{
						hookTypesDev = null
						hookTypesUpdateIndexDev = -1
						currentHookNameInDev = null
						isUpdatingOpaqueValueInRenderPhase = false
					}
					didScheduleRenderPhaseUpdateDuringThisPass = false
					localIdCounter = 0
				}
				function mountWorkInProgressHook() {
					var hook = {
						memoizedState: null,
						baseState: null,
						baseQueue: null,
						queue: null,
						next: null,
					}
					if (workInProgressHook === null) {
						currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook
					} else {
						workInProgressHook = workInProgressHook.next = hook
					}
					return workInProgressHook
				}
				function updateWorkInProgressHook() {
					var nextCurrentHook
					if (currentHook === null) {
						var current2 = currentlyRenderingFiber$1.alternate
						if (current2 !== null) {
							nextCurrentHook = current2.memoizedState
						} else {
							nextCurrentHook = null
						}
					} else {
						nextCurrentHook = currentHook.next
					}
					var nextWorkInProgressHook
					if (workInProgressHook === null) {
						nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState
					} else {
						nextWorkInProgressHook = workInProgressHook.next
					}
					if (nextWorkInProgressHook !== null) {
						workInProgressHook = nextWorkInProgressHook
						nextWorkInProgressHook = workInProgressHook.next
						currentHook = nextCurrentHook
					} else {
						if (nextCurrentHook === null) {
							throw new Error('Rendered more hooks than during the previous render.')
						}
						currentHook = nextCurrentHook
						var newHook = {
							memoizedState: currentHook.memoizedState,
							baseState: currentHook.baseState,
							baseQueue: currentHook.baseQueue,
							queue: currentHook.queue,
							next: null,
						}
						if (workInProgressHook === null) {
							currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook
						} else {
							workInProgressHook = workInProgressHook.next = newHook
						}
					}
					return workInProgressHook
				}
				function createFunctionComponentUpdateQueue() {
					return {
						lastEffect: null,
						stores: null,
					}
				}
				function basicStateReducer(state, action) {
					return typeof action === 'function' ? action(state) : action
				}
				function mountReducer(reducer, initialArg, init) {
					var hook = mountWorkInProgressHook()
					var initialState2
					if (init !== void 0) {
						initialState2 = init(initialArg)
					} else {
						initialState2 = initialArg
					}
					hook.memoizedState = hook.baseState = initialState2
					var queue = {
						pending: null,
						interleaved: null,
						lanes: NoLanes,
						dispatch: null,
						lastRenderedReducer: reducer,
						lastRenderedState: initialState2,
					}
					hook.queue = queue
					var dispatch2 = (queue.dispatch = dispatchReducerAction.bind(
						null,
						currentlyRenderingFiber$1,
						queue
					))
					return [hook.memoizedState, dispatch2]
				}
				function updateReducer(reducer, initialArg, init) {
					var hook = updateWorkInProgressHook()
					var queue = hook.queue
					if (queue === null) {
						throw new Error(
							'Should have a queue. This is likely a bug in React. Please file an issue.'
						)
					}
					queue.lastRenderedReducer = reducer
					var current2 = currentHook
					var baseQueue = current2.baseQueue
					var pendingQueue = queue.pending
					if (pendingQueue !== null) {
						if (baseQueue !== null) {
							var baseFirst = baseQueue.next
							var pendingFirst = pendingQueue.next
							baseQueue.next = pendingFirst
							pendingQueue.next = baseFirst
						}
						{
							if (current2.baseQueue !== baseQueue) {
								error(
									'Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.'
								)
							}
						}
						current2.baseQueue = baseQueue = pendingQueue
						queue.pending = null
					}
					if (baseQueue !== null) {
						var first = baseQueue.next
						var newState = current2.baseState
						var newBaseState = null
						var newBaseQueueFirst = null
						var newBaseQueueLast = null
						var update = first
						do {
							var updateLane = update.lane
							if (!isSubsetOfLanes(renderLanes, updateLane)) {
								var clone = {
									lane: updateLane,
									action: update.action,
									hasEagerState: update.hasEagerState,
									eagerState: update.eagerState,
									next: null,
								}
								if (newBaseQueueLast === null) {
									newBaseQueueFirst = newBaseQueueLast = clone
									newBaseState = newState
								} else {
									newBaseQueueLast = newBaseQueueLast.next = clone
								}
								currentlyRenderingFiber$1.lanes = mergeLanes(
									currentlyRenderingFiber$1.lanes,
									updateLane
								)
								markSkippedUpdateLanes(updateLane)
							} else {
								if (newBaseQueueLast !== null) {
									var _clone = {
										// This update is going to be committed so we never want uncommit
										// it. Using NoLane works because 0 is a subset of all bitmasks, so
										// this will never be skipped by the check above.
										lane: NoLane,
										action: update.action,
										hasEagerState: update.hasEagerState,
										eagerState: update.eagerState,
										next: null,
									}
									newBaseQueueLast = newBaseQueueLast.next = _clone
								}
								if (update.hasEagerState) {
									newState = update.eagerState
								} else {
									var action = update.action
									newState = reducer(newState, action)
								}
							}
							update = update.next
						} while (update !== null && update !== first)
						if (newBaseQueueLast === null) {
							newBaseState = newState
						} else {
							newBaseQueueLast.next = newBaseQueueFirst
						}
						if (!objectIs(newState, hook.memoizedState)) {
							markWorkInProgressReceivedUpdate()
						}
						hook.memoizedState = newState
						hook.baseState = newBaseState
						hook.baseQueue = newBaseQueueLast
						queue.lastRenderedState = newState
					}
					var lastInterleaved = queue.interleaved
					if (lastInterleaved !== null) {
						var interleaved = lastInterleaved
						do {
							var interleavedLane = interleaved.lane
							currentlyRenderingFiber$1.lanes = mergeLanes(
								currentlyRenderingFiber$1.lanes,
								interleavedLane
							)
							markSkippedUpdateLanes(interleavedLane)
							interleaved = interleaved.next
						} while (interleaved !== lastInterleaved)
					} else if (baseQueue === null) {
						queue.lanes = NoLanes
					}
					var dispatch2 = queue.dispatch
					return [hook.memoizedState, dispatch2]
				}
				function rerenderReducer(reducer, initialArg, init) {
					var hook = updateWorkInProgressHook()
					var queue = hook.queue
					if (queue === null) {
						throw new Error(
							'Should have a queue. This is likely a bug in React. Please file an issue.'
						)
					}
					queue.lastRenderedReducer = reducer
					var dispatch2 = queue.dispatch
					var lastRenderPhaseUpdate = queue.pending
					var newState = hook.memoizedState
					if (lastRenderPhaseUpdate !== null) {
						queue.pending = null
						var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next
						var update = firstRenderPhaseUpdate
						do {
							var action = update.action
							newState = reducer(newState, action)
							update = update.next
						} while (update !== firstRenderPhaseUpdate)
						if (!objectIs(newState, hook.memoizedState)) {
							markWorkInProgressReceivedUpdate()
						}
						hook.memoizedState = newState
						if (hook.baseQueue === null) {
							hook.baseState = newState
						}
						queue.lastRenderedState = newState
					}
					return [newState, dispatch2]
				}
				function mountMutableSource(source, getSnapshot, subscribe) {
					{
						return void 0
					}
				}
				function updateMutableSource(source, getSnapshot, subscribe) {
					{
						return void 0
					}
				}
				function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
					var fiber = currentlyRenderingFiber$1
					var hook = mountWorkInProgressHook()
					var nextSnapshot
					var isHydrating2 = getIsHydrating()
					if (isHydrating2) {
						if (getServerSnapshot === void 0) {
							throw new Error(
								'Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.'
							)
						}
						nextSnapshot = getServerSnapshot()
						{
							if (!didWarnUncachedGetSnapshot) {
								if (nextSnapshot !== getServerSnapshot()) {
									error(
										'The result of getServerSnapshot should be cached to avoid an infinite loop'
									)
									didWarnUncachedGetSnapshot = true
								}
							}
						}
					} else {
						nextSnapshot = getSnapshot()
						{
							if (!didWarnUncachedGetSnapshot) {
								var cachedSnapshot = getSnapshot()
								if (!objectIs(nextSnapshot, cachedSnapshot)) {
									error('The result of getSnapshot should be cached to avoid an infinite loop')
									didWarnUncachedGetSnapshot = true
								}
							}
						}
						var root3 = getWorkInProgressRoot()
						if (root3 === null) {
							throw new Error(
								'Expected a work-in-progress root. This is a bug in React. Please file an issue.'
							)
						}
						if (!includesBlockingLane(root3, renderLanes)) {
							pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot)
						}
					}
					hook.memoizedState = nextSnapshot
					var inst = {
						value: nextSnapshot,
						getSnapshot,
					}
					hook.queue = inst
					mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe])
					fiber.flags |= Passive
					pushEffect(
						HasEffect | Passive$1,
						updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),
						void 0,
						null
					)
					return nextSnapshot
				}
				function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
					var fiber = currentlyRenderingFiber$1
					var hook = updateWorkInProgressHook()
					var nextSnapshot = getSnapshot()
					{
						if (!didWarnUncachedGetSnapshot) {
							var cachedSnapshot = getSnapshot()
							if (!objectIs(nextSnapshot, cachedSnapshot)) {
								error('The result of getSnapshot should be cached to avoid an infinite loop')
								didWarnUncachedGetSnapshot = true
							}
						}
					}
					var prevSnapshot = hook.memoizedState
					var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot)
					if (snapshotChanged) {
						hook.memoizedState = nextSnapshot
						markWorkInProgressReceivedUpdate()
					}
					var inst = hook.queue
					updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe])
					if (
						inst.getSnapshot !== getSnapshot ||
						snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
						// checking whether we scheduled a subscription effect above.
						(workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect)
					) {
						fiber.flags |= Passive
						pushEffect(
							HasEffect | Passive$1,
							updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),
							void 0,
							null
						)
						var root3 = getWorkInProgressRoot()
						if (root3 === null) {
							throw new Error(
								'Expected a work-in-progress root. This is a bug in React. Please file an issue.'
							)
						}
						if (!includesBlockingLane(root3, renderLanes)) {
							pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot)
						}
					}
					return nextSnapshot
				}
				function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
					fiber.flags |= StoreConsistency
					var check = {
						getSnapshot,
						value: renderedSnapshot,
					}
					var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue
					if (componentUpdateQueue === null) {
						componentUpdateQueue = createFunctionComponentUpdateQueue()
						currentlyRenderingFiber$1.updateQueue = componentUpdateQueue
						componentUpdateQueue.stores = [check]
					} else {
						var stores = componentUpdateQueue.stores
						if (stores === null) {
							componentUpdateQueue.stores = [check]
						} else {
							stores.push(check)
						}
					}
				}
				function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
					inst.value = nextSnapshot
					inst.getSnapshot = getSnapshot
					if (checkIfSnapshotChanged(inst)) {
						forceStoreRerender(fiber)
					}
				}
				function subscribeToStore(fiber, inst, subscribe) {
					var handleStoreChange = function () {
						if (checkIfSnapshotChanged(inst)) {
							forceStoreRerender(fiber)
						}
					}
					return subscribe(handleStoreChange)
				}
				function checkIfSnapshotChanged(inst) {
					var latestGetSnapshot = inst.getSnapshot
					var prevValue = inst.value
					try {
						var nextValue = latestGetSnapshot()
						return !objectIs(prevValue, nextValue)
					} catch (error2) {
						return true
					}
				}
				function forceStoreRerender(fiber) {
					var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane)
					if (root3 !== null) {
						scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp)
					}
				}
				function mountState(initialState2) {
					var hook = mountWorkInProgressHook()
					if (typeof initialState2 === 'function') {
						initialState2 = initialState2()
					}
					hook.memoizedState = hook.baseState = initialState2
					var queue = {
						pending: null,
						interleaved: null,
						lanes: NoLanes,
						dispatch: null,
						lastRenderedReducer: basicStateReducer,
						lastRenderedState: initialState2,
					}
					hook.queue = queue
					var dispatch2 = (queue.dispatch = dispatchSetState.bind(
						null,
						currentlyRenderingFiber$1,
						queue
					))
					return [hook.memoizedState, dispatch2]
				}
				function updateState(initialState2) {
					return updateReducer(basicStateReducer)
				}
				function rerenderState(initialState2) {
					return rerenderReducer(basicStateReducer)
				}
				function pushEffect(tag, create, destroy, deps) {
					var effect = {
						tag,
						create,
						destroy,
						deps,
						// Circular
						next: null,
					}
					var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue
					if (componentUpdateQueue === null) {
						componentUpdateQueue = createFunctionComponentUpdateQueue()
						currentlyRenderingFiber$1.updateQueue = componentUpdateQueue
						componentUpdateQueue.lastEffect = effect.next = effect
					} else {
						var lastEffect = componentUpdateQueue.lastEffect
						if (lastEffect === null) {
							componentUpdateQueue.lastEffect = effect.next = effect
						} else {
							var firstEffect = lastEffect.next
							lastEffect.next = effect
							effect.next = firstEffect
							componentUpdateQueue.lastEffect = effect
						}
					}
					return effect
				}
				function mountRef(initialValue) {
					var hook = mountWorkInProgressHook()
					{
						var _ref2 = {
							current: initialValue,
						}
						hook.memoizedState = _ref2
						return _ref2
					}
				}
				function updateRef(initialValue) {
					var hook = updateWorkInProgressHook()
					return hook.memoizedState
				}
				function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
					var hook = mountWorkInProgressHook()
					var nextDeps = deps === void 0 ? null : deps
					currentlyRenderingFiber$1.flags |= fiberFlags
					hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps)
				}
				function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
					var hook = updateWorkInProgressHook()
					var nextDeps = deps === void 0 ? null : deps
					var destroy = void 0
					if (currentHook !== null) {
						var prevEffect = currentHook.memoizedState
						destroy = prevEffect.destroy
						if (nextDeps !== null) {
							var prevDeps = prevEffect.deps
							if (areHookInputsEqual(nextDeps, prevDeps)) {
								hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps)
								return
							}
						}
					}
					currentlyRenderingFiber$1.flags |= fiberFlags
					hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps)
				}
				function mountEffect(create, deps) {
					if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
						return mountEffectImpl(
							MountPassiveDev | Passive | PassiveStatic,
							Passive$1,
							create,
							deps
						)
					} else {
						return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps)
					}
				}
				function updateEffect(create, deps) {
					return updateEffectImpl(Passive, Passive$1, create, deps)
				}
				function mountInsertionEffect(create, deps) {
					return mountEffectImpl(Update, Insertion, create, deps)
				}
				function updateInsertionEffect(create, deps) {
					return updateEffectImpl(Update, Insertion, create, deps)
				}
				function mountLayoutEffect(create, deps) {
					var fiberFlags = Update
					{
						fiberFlags |= LayoutStatic
					}
					if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
						fiberFlags |= MountLayoutDev
					}
					return mountEffectImpl(fiberFlags, Layout2, create, deps)
				}
				function updateLayoutEffect(create, deps) {
					return updateEffectImpl(Update, Layout2, create, deps)
				}
				function imperativeHandleEffect(create, ref) {
					if (typeof ref === 'function') {
						var refCallback = ref
						var _inst = create()
						refCallback(_inst)
						return function () {
							refCallback(null)
						}
					} else if (ref !== null && ref !== void 0) {
						var refObject = ref
						{
							if (!refObject.hasOwnProperty('current')) {
								error(
									'Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.',
									'an object with keys {' + Object.keys(refObject).join(', ') + '}'
								)
							}
						}
						var _inst2 = create()
						refObject.current = _inst2
						return function () {
							refObject.current = null
						}
					}
				}
				function mountImperativeHandle(ref, create, deps) {
					{
						if (typeof create !== 'function') {
							error(
								'Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.',
								create !== null ? typeof create : 'null'
							)
						}
					}
					var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null
					var fiberFlags = Update
					{
						fiberFlags |= LayoutStatic
					}
					if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
						fiberFlags |= MountLayoutDev
					}
					return mountEffectImpl(
						fiberFlags,
						Layout2,
						imperativeHandleEffect.bind(null, create, ref),
						effectDeps
					)
				}
				function updateImperativeHandle(ref, create, deps) {
					{
						if (typeof create !== 'function') {
							error(
								'Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.',
								create !== null ? typeof create : 'null'
							)
						}
					}
					var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null
					return updateEffectImpl(
						Update,
						Layout2,
						imperativeHandleEffect.bind(null, create, ref),
						effectDeps
					)
				}
				function mountDebugValue(value, formatterFn) {}
				var updateDebugValue = mountDebugValue
				function mountCallback(callback, deps) {
					var hook = mountWorkInProgressHook()
					var nextDeps = deps === void 0 ? null : deps
					hook.memoizedState = [callback, nextDeps]
					return callback
				}
				function updateCallback(callback, deps) {
					var hook = updateWorkInProgressHook()
					var nextDeps = deps === void 0 ? null : deps
					var prevState = hook.memoizedState
					if (prevState !== null) {
						if (nextDeps !== null) {
							var prevDeps = prevState[1]
							if (areHookInputsEqual(nextDeps, prevDeps)) {
								return prevState[0]
							}
						}
					}
					hook.memoizedState = [callback, nextDeps]
					return callback
				}
				function mountMemo(nextCreate, deps) {
					var hook = mountWorkInProgressHook()
					var nextDeps = deps === void 0 ? null : deps
					var nextValue = nextCreate()
					hook.memoizedState = [nextValue, nextDeps]
					return nextValue
				}
				function updateMemo(nextCreate, deps) {
					var hook = updateWorkInProgressHook()
					var nextDeps = deps === void 0 ? null : deps
					var prevState = hook.memoizedState
					if (prevState !== null) {
						if (nextDeps !== null) {
							var prevDeps = prevState[1]
							if (areHookInputsEqual(nextDeps, prevDeps)) {
								return prevState[0]
							}
						}
					}
					var nextValue = nextCreate()
					hook.memoizedState = [nextValue, nextDeps]
					return nextValue
				}
				function mountDeferredValue(value) {
					var hook = mountWorkInProgressHook()
					hook.memoizedState = value
					return value
				}
				function updateDeferredValue(value) {
					var hook = updateWorkInProgressHook()
					var resolvedCurrentHook = currentHook
					var prevValue = resolvedCurrentHook.memoizedState
					return updateDeferredValueImpl(hook, prevValue, value)
				}
				function rerenderDeferredValue(value) {
					var hook = updateWorkInProgressHook()
					if (currentHook === null) {
						hook.memoizedState = value
						return value
					} else {
						var prevValue = currentHook.memoizedState
						return updateDeferredValueImpl(hook, prevValue, value)
					}
				}
				function updateDeferredValueImpl(hook, prevValue, value) {
					var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes)
					if (shouldDeferValue) {
						if (!objectIs(value, prevValue)) {
							var deferredLane = claimNextTransitionLane()
							currentlyRenderingFiber$1.lanes = mergeLanes(
								currentlyRenderingFiber$1.lanes,
								deferredLane
							)
							markSkippedUpdateLanes(deferredLane)
							hook.baseState = true
						}
						return prevValue
					} else {
						if (hook.baseState) {
							hook.baseState = false
							markWorkInProgressReceivedUpdate()
						}
						hook.memoizedState = value
						return value
					}
				}
				function startTransition(setPending, callback, options2) {
					var previousPriority = getCurrentUpdatePriority()
					setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority))
					setPending(true)
					var prevTransition = ReactCurrentBatchConfig$2.transition
					ReactCurrentBatchConfig$2.transition = {}
					var currentTransition = ReactCurrentBatchConfig$2.transition
					{
						ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set()
					}
					try {
						setPending(false)
						callback()
					} finally {
						setCurrentUpdatePriority(previousPriority)
						ReactCurrentBatchConfig$2.transition = prevTransition
						{
							if (prevTransition === null && currentTransition._updatedFibers) {
								var updatedFibersCount = currentTransition._updatedFibers.size
								if (updatedFibersCount > 10) {
									warn(
										'Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.'
									)
								}
								currentTransition._updatedFibers.clear()
							}
						}
					}
				}
				function mountTransition() {
					var _mountState = mountState(false),
						isPending = _mountState[0],
						setPending = _mountState[1]
					var start = startTransition.bind(null, setPending)
					var hook = mountWorkInProgressHook()
					hook.memoizedState = start
					return [isPending, start]
				}
				function updateTransition() {
					var _updateState = updateState(),
						isPending = _updateState[0]
					var hook = updateWorkInProgressHook()
					var start = hook.memoizedState
					return [isPending, start]
				}
				function rerenderTransition() {
					var _rerenderState = rerenderState(),
						isPending = _rerenderState[0]
					var hook = updateWorkInProgressHook()
					var start = hook.memoizedState
					return [isPending, start]
				}
				var isUpdatingOpaqueValueInRenderPhase = false
				function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
					{
						return isUpdatingOpaqueValueInRenderPhase
					}
				}
				function mountId() {
					var hook = mountWorkInProgressHook()
					var root3 = getWorkInProgressRoot()
					var identifierPrefix = root3.identifierPrefix
					var id
					if (getIsHydrating()) {
						var treeId = getTreeId()
						id = ':' + identifierPrefix + 'R' + treeId
						var localId = localIdCounter++
						if (localId > 0) {
							id += 'H' + localId.toString(32)
						}
						id += ':'
					} else {
						var globalClientId = globalClientIdCounter++
						id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':'
					}
					hook.memoizedState = id
					return id
				}
				function updateId() {
					var hook = updateWorkInProgressHook()
					var id = hook.memoizedState
					return id
				}
				function dispatchReducerAction(fiber, queue, action) {
					{
						if (typeof arguments[3] === 'function') {
							error(
								"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
							)
						}
					}
					var lane = requestUpdateLane(fiber)
					var update = {
						lane,
						action,
						hasEagerState: false,
						eagerState: null,
						next: null,
					}
					if (isRenderPhaseUpdate(fiber)) {
						enqueueRenderPhaseUpdate(queue, update)
					} else {
						var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane)
						if (root3 !== null) {
							var eventTime = requestEventTime()
							scheduleUpdateOnFiber(root3, fiber, lane, eventTime)
							entangleTransitionUpdate(root3, queue, lane)
						}
					}
					markUpdateInDevTools(fiber, lane)
				}
				function dispatchSetState(fiber, queue, action) {
					{
						if (typeof arguments[3] === 'function') {
							error(
								"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
							)
						}
					}
					var lane = requestUpdateLane(fiber)
					var update = {
						lane,
						action,
						hasEagerState: false,
						eagerState: null,
						next: null,
					}
					if (isRenderPhaseUpdate(fiber)) {
						enqueueRenderPhaseUpdate(queue, update)
					} else {
						var alternate = fiber.alternate
						if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
							var lastRenderedReducer = queue.lastRenderedReducer
							if (lastRenderedReducer !== null) {
								var prevDispatcher
								{
									prevDispatcher = ReactCurrentDispatcher$1.current
									ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
								}
								try {
									var currentState = queue.lastRenderedState
									var eagerState = lastRenderedReducer(currentState, action)
									update.hasEagerState = true
									update.eagerState = eagerState
									if (objectIs(eagerState, currentState)) {
										enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane)
										return
									}
								} catch (error2) {
								} finally {
									{
										ReactCurrentDispatcher$1.current = prevDispatcher
									}
								}
							}
						}
						var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane)
						if (root3 !== null) {
							var eventTime = requestEventTime()
							scheduleUpdateOnFiber(root3, fiber, lane, eventTime)
							entangleTransitionUpdate(root3, queue, lane)
						}
					}
					markUpdateInDevTools(fiber, lane)
				}
				function isRenderPhaseUpdate(fiber) {
					var alternate = fiber.alternate
					return (
						fiber === currentlyRenderingFiber$1 ||
						(alternate !== null && alternate === currentlyRenderingFiber$1)
					)
				}
				function enqueueRenderPhaseUpdate(queue, update) {
					didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true
					var pending = queue.pending
					if (pending === null) {
						update.next = update
					} else {
						update.next = pending.next
						pending.next = update
					}
					queue.pending = update
				}
				function entangleTransitionUpdate(root3, queue, lane) {
					if (isTransitionLane(lane)) {
						var queueLanes = queue.lanes
						queueLanes = intersectLanes(queueLanes, root3.pendingLanes)
						var newQueueLanes = mergeLanes(queueLanes, lane)
						queue.lanes = newQueueLanes
						markRootEntangled(root3, newQueueLanes)
					}
				}
				function markUpdateInDevTools(fiber, lane, action) {
					{
						markStateUpdateScheduled(fiber, lane)
					}
				}
				var ContextOnlyDispatcher = {
					readContext,
					useCallback: throwInvalidHookError,
					useContext: throwInvalidHookError,
					useEffect: throwInvalidHookError,
					useImperativeHandle: throwInvalidHookError,
					useInsertionEffect: throwInvalidHookError,
					useLayoutEffect: throwInvalidHookError,
					useMemo: throwInvalidHookError,
					useReducer: throwInvalidHookError,
					useRef: throwInvalidHookError,
					useState: throwInvalidHookError,
					useDebugValue: throwInvalidHookError,
					useDeferredValue: throwInvalidHookError,
					useTransition: throwInvalidHookError,
					useMutableSource: throwInvalidHookError,
					useSyncExternalStore: throwInvalidHookError,
					useId: throwInvalidHookError,
					unstable_isNewReconciler: enableNewReconciler,
				}
				var HooksDispatcherOnMountInDEV = null
				var HooksDispatcherOnMountWithHookTypesInDEV = null
				var HooksDispatcherOnUpdateInDEV = null
				var HooksDispatcherOnRerenderInDEV = null
				var InvalidNestedHooksDispatcherOnMountInDEV = null
				var InvalidNestedHooksDispatcherOnUpdateInDEV = null
				var InvalidNestedHooksDispatcherOnRerenderInDEV = null
				{
					var warnInvalidContextAccess = function () {
						error(
							'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
						)
					}
					var warnInvalidHookAccess = function () {
						error(
							'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks'
						)
					}
					HooksDispatcherOnMountInDEV = {
						readContext: function (context) {
							return readContext(context)
						},
						useCallback: function (callback, deps) {
							currentHookNameInDev = 'useCallback'
							mountHookTypesDev()
							checkDepsAreArrayDev(deps)
							return mountCallback(callback, deps)
						},
						useContext: function (context) {
							currentHookNameInDev = 'useContext'
							mountHookTypesDev()
							return readContext(context)
						},
						useEffect: function (create, deps) {
							currentHookNameInDev = 'useEffect'
							mountHookTypesDev()
							checkDepsAreArrayDev(deps)
							return mountEffect(create, deps)
						},
						useImperativeHandle: function (ref, create, deps) {
							currentHookNameInDev = 'useImperativeHandle'
							mountHookTypesDev()
							checkDepsAreArrayDev(deps)
							return mountImperativeHandle(ref, create, deps)
						},
						useInsertionEffect: function (create, deps) {
							currentHookNameInDev = 'useInsertionEffect'
							mountHookTypesDev()
							checkDepsAreArrayDev(deps)
							return mountInsertionEffect(create, deps)
						},
						useLayoutEffect: function (create, deps) {
							currentHookNameInDev = 'useLayoutEffect'
							mountHookTypesDev()
							checkDepsAreArrayDev(deps)
							return mountLayoutEffect(create, deps)
						},
						useMemo: function (create, deps) {
							currentHookNameInDev = 'useMemo'
							mountHookTypesDev()
							checkDepsAreArrayDev(deps)
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountMemo(create, deps)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useReducer: function (reducer, initialArg, init) {
							currentHookNameInDev = 'useReducer'
							mountHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountReducer(reducer, initialArg, init)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useRef: function (initialValue) {
							currentHookNameInDev = 'useRef'
							mountHookTypesDev()
							return mountRef(initialValue)
						},
						useState: function (initialState2) {
							currentHookNameInDev = 'useState'
							mountHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountState(initialState2)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useDebugValue: function (value, formatterFn) {
							currentHookNameInDev = 'useDebugValue'
							mountHookTypesDev()
							return mountDebugValue()
						},
						useDeferredValue: function (value) {
							currentHookNameInDev = 'useDeferredValue'
							mountHookTypesDev()
							return mountDeferredValue(value)
						},
						useTransition: function () {
							currentHookNameInDev = 'useTransition'
							mountHookTypesDev()
							return mountTransition()
						},
						useMutableSource: function (source, getSnapshot, subscribe) {
							currentHookNameInDev = 'useMutableSource'
							mountHookTypesDev()
							return mountMutableSource()
						},
						useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
							currentHookNameInDev = 'useSyncExternalStore'
							mountHookTypesDev()
							return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)
						},
						useId: function () {
							currentHookNameInDev = 'useId'
							mountHookTypesDev()
							return mountId()
						},
						unstable_isNewReconciler: enableNewReconciler,
					}
					HooksDispatcherOnMountWithHookTypesInDEV = {
						readContext: function (context) {
							return readContext(context)
						},
						useCallback: function (callback, deps) {
							currentHookNameInDev = 'useCallback'
							updateHookTypesDev()
							return mountCallback(callback, deps)
						},
						useContext: function (context) {
							currentHookNameInDev = 'useContext'
							updateHookTypesDev()
							return readContext(context)
						},
						useEffect: function (create, deps) {
							currentHookNameInDev = 'useEffect'
							updateHookTypesDev()
							return mountEffect(create, deps)
						},
						useImperativeHandle: function (ref, create, deps) {
							currentHookNameInDev = 'useImperativeHandle'
							updateHookTypesDev()
							return mountImperativeHandle(ref, create, deps)
						},
						useInsertionEffect: function (create, deps) {
							currentHookNameInDev = 'useInsertionEffect'
							updateHookTypesDev()
							return mountInsertionEffect(create, deps)
						},
						useLayoutEffect: function (create, deps) {
							currentHookNameInDev = 'useLayoutEffect'
							updateHookTypesDev()
							return mountLayoutEffect(create, deps)
						},
						useMemo: function (create, deps) {
							currentHookNameInDev = 'useMemo'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountMemo(create, deps)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useReducer: function (reducer, initialArg, init) {
							currentHookNameInDev = 'useReducer'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountReducer(reducer, initialArg, init)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useRef: function (initialValue) {
							currentHookNameInDev = 'useRef'
							updateHookTypesDev()
							return mountRef(initialValue)
						},
						useState: function (initialState2) {
							currentHookNameInDev = 'useState'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountState(initialState2)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useDebugValue: function (value, formatterFn) {
							currentHookNameInDev = 'useDebugValue'
							updateHookTypesDev()
							return mountDebugValue()
						},
						useDeferredValue: function (value) {
							currentHookNameInDev = 'useDeferredValue'
							updateHookTypesDev()
							return mountDeferredValue(value)
						},
						useTransition: function () {
							currentHookNameInDev = 'useTransition'
							updateHookTypesDev()
							return mountTransition()
						},
						useMutableSource: function (source, getSnapshot, subscribe) {
							currentHookNameInDev = 'useMutableSource'
							updateHookTypesDev()
							return mountMutableSource()
						},
						useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
							currentHookNameInDev = 'useSyncExternalStore'
							updateHookTypesDev()
							return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)
						},
						useId: function () {
							currentHookNameInDev = 'useId'
							updateHookTypesDev()
							return mountId()
						},
						unstable_isNewReconciler: enableNewReconciler,
					}
					HooksDispatcherOnUpdateInDEV = {
						readContext: function (context) {
							return readContext(context)
						},
						useCallback: function (callback, deps) {
							currentHookNameInDev = 'useCallback'
							updateHookTypesDev()
							return updateCallback(callback, deps)
						},
						useContext: function (context) {
							currentHookNameInDev = 'useContext'
							updateHookTypesDev()
							return readContext(context)
						},
						useEffect: function (create, deps) {
							currentHookNameInDev = 'useEffect'
							updateHookTypesDev()
							return updateEffect(create, deps)
						},
						useImperativeHandle: function (ref, create, deps) {
							currentHookNameInDev = 'useImperativeHandle'
							updateHookTypesDev()
							return updateImperativeHandle(ref, create, deps)
						},
						useInsertionEffect: function (create, deps) {
							currentHookNameInDev = 'useInsertionEffect'
							updateHookTypesDev()
							return updateInsertionEffect(create, deps)
						},
						useLayoutEffect: function (create, deps) {
							currentHookNameInDev = 'useLayoutEffect'
							updateHookTypesDev()
							return updateLayoutEffect(create, deps)
						},
						useMemo: function (create, deps) {
							currentHookNameInDev = 'useMemo'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return updateMemo(create, deps)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useReducer: function (reducer, initialArg, init) {
							currentHookNameInDev = 'useReducer'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return updateReducer(reducer, initialArg, init)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useRef: function (initialValue) {
							currentHookNameInDev = 'useRef'
							updateHookTypesDev()
							return updateRef()
						},
						useState: function (initialState2) {
							currentHookNameInDev = 'useState'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return updateState(initialState2)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useDebugValue: function (value, formatterFn) {
							currentHookNameInDev = 'useDebugValue'
							updateHookTypesDev()
							return updateDebugValue()
						},
						useDeferredValue: function (value) {
							currentHookNameInDev = 'useDeferredValue'
							updateHookTypesDev()
							return updateDeferredValue(value)
						},
						useTransition: function () {
							currentHookNameInDev = 'useTransition'
							updateHookTypesDev()
							return updateTransition()
						},
						useMutableSource: function (source, getSnapshot, subscribe) {
							currentHookNameInDev = 'useMutableSource'
							updateHookTypesDev()
							return updateMutableSource()
						},
						useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
							currentHookNameInDev = 'useSyncExternalStore'
							updateHookTypesDev()
							return updateSyncExternalStore(subscribe, getSnapshot)
						},
						useId: function () {
							currentHookNameInDev = 'useId'
							updateHookTypesDev()
							return updateId()
						},
						unstable_isNewReconciler: enableNewReconciler,
					}
					HooksDispatcherOnRerenderInDEV = {
						readContext: function (context) {
							return readContext(context)
						},
						useCallback: function (callback, deps) {
							currentHookNameInDev = 'useCallback'
							updateHookTypesDev()
							return updateCallback(callback, deps)
						},
						useContext: function (context) {
							currentHookNameInDev = 'useContext'
							updateHookTypesDev()
							return readContext(context)
						},
						useEffect: function (create, deps) {
							currentHookNameInDev = 'useEffect'
							updateHookTypesDev()
							return updateEffect(create, deps)
						},
						useImperativeHandle: function (ref, create, deps) {
							currentHookNameInDev = 'useImperativeHandle'
							updateHookTypesDev()
							return updateImperativeHandle(ref, create, deps)
						},
						useInsertionEffect: function (create, deps) {
							currentHookNameInDev = 'useInsertionEffect'
							updateHookTypesDev()
							return updateInsertionEffect(create, deps)
						},
						useLayoutEffect: function (create, deps) {
							currentHookNameInDev = 'useLayoutEffect'
							updateHookTypesDev()
							return updateLayoutEffect(create, deps)
						},
						useMemo: function (create, deps) {
							currentHookNameInDev = 'useMemo'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV
							try {
								return updateMemo(create, deps)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useReducer: function (reducer, initialArg, init) {
							currentHookNameInDev = 'useReducer'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV
							try {
								return rerenderReducer(reducer, initialArg, init)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useRef: function (initialValue) {
							currentHookNameInDev = 'useRef'
							updateHookTypesDev()
							return updateRef()
						},
						useState: function (initialState2) {
							currentHookNameInDev = 'useState'
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV
							try {
								return rerenderState(initialState2)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useDebugValue: function (value, formatterFn) {
							currentHookNameInDev = 'useDebugValue'
							updateHookTypesDev()
							return updateDebugValue()
						},
						useDeferredValue: function (value) {
							currentHookNameInDev = 'useDeferredValue'
							updateHookTypesDev()
							return rerenderDeferredValue(value)
						},
						useTransition: function () {
							currentHookNameInDev = 'useTransition'
							updateHookTypesDev()
							return rerenderTransition()
						},
						useMutableSource: function (source, getSnapshot, subscribe) {
							currentHookNameInDev = 'useMutableSource'
							updateHookTypesDev()
							return updateMutableSource()
						},
						useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
							currentHookNameInDev = 'useSyncExternalStore'
							updateHookTypesDev()
							return updateSyncExternalStore(subscribe, getSnapshot)
						},
						useId: function () {
							currentHookNameInDev = 'useId'
							updateHookTypesDev()
							return updateId()
						},
						unstable_isNewReconciler: enableNewReconciler,
					}
					InvalidNestedHooksDispatcherOnMountInDEV = {
						readContext: function (context) {
							warnInvalidContextAccess()
							return readContext(context)
						},
						useCallback: function (callback, deps) {
							currentHookNameInDev = 'useCallback'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountCallback(callback, deps)
						},
						useContext: function (context) {
							currentHookNameInDev = 'useContext'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return readContext(context)
						},
						useEffect: function (create, deps) {
							currentHookNameInDev = 'useEffect'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountEffect(create, deps)
						},
						useImperativeHandle: function (ref, create, deps) {
							currentHookNameInDev = 'useImperativeHandle'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountImperativeHandle(ref, create, deps)
						},
						useInsertionEffect: function (create, deps) {
							currentHookNameInDev = 'useInsertionEffect'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountInsertionEffect(create, deps)
						},
						useLayoutEffect: function (create, deps) {
							currentHookNameInDev = 'useLayoutEffect'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountLayoutEffect(create, deps)
						},
						useMemo: function (create, deps) {
							currentHookNameInDev = 'useMemo'
							warnInvalidHookAccess()
							mountHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountMemo(create, deps)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useReducer: function (reducer, initialArg, init) {
							currentHookNameInDev = 'useReducer'
							warnInvalidHookAccess()
							mountHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountReducer(reducer, initialArg, init)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useRef: function (initialValue) {
							currentHookNameInDev = 'useRef'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountRef(initialValue)
						},
						useState: function (initialState2) {
							currentHookNameInDev = 'useState'
							warnInvalidHookAccess()
							mountHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV
							try {
								return mountState(initialState2)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useDebugValue: function (value, formatterFn) {
							currentHookNameInDev = 'useDebugValue'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountDebugValue()
						},
						useDeferredValue: function (value) {
							currentHookNameInDev = 'useDeferredValue'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountDeferredValue(value)
						},
						useTransition: function () {
							currentHookNameInDev = 'useTransition'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountTransition()
						},
						useMutableSource: function (source, getSnapshot, subscribe) {
							currentHookNameInDev = 'useMutableSource'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountMutableSource()
						},
						useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
							currentHookNameInDev = 'useSyncExternalStore'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)
						},
						useId: function () {
							currentHookNameInDev = 'useId'
							warnInvalidHookAccess()
							mountHookTypesDev()
							return mountId()
						},
						unstable_isNewReconciler: enableNewReconciler,
					}
					InvalidNestedHooksDispatcherOnUpdateInDEV = {
						readContext: function (context) {
							warnInvalidContextAccess()
							return readContext(context)
						},
						useCallback: function (callback, deps) {
							currentHookNameInDev = 'useCallback'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateCallback(callback, deps)
						},
						useContext: function (context) {
							currentHookNameInDev = 'useContext'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return readContext(context)
						},
						useEffect: function (create, deps) {
							currentHookNameInDev = 'useEffect'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateEffect(create, deps)
						},
						useImperativeHandle: function (ref, create, deps) {
							currentHookNameInDev = 'useImperativeHandle'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateImperativeHandle(ref, create, deps)
						},
						useInsertionEffect: function (create, deps) {
							currentHookNameInDev = 'useInsertionEffect'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateInsertionEffect(create, deps)
						},
						useLayoutEffect: function (create, deps) {
							currentHookNameInDev = 'useLayoutEffect'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateLayoutEffect(create, deps)
						},
						useMemo: function (create, deps) {
							currentHookNameInDev = 'useMemo'
							warnInvalidHookAccess()
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return updateMemo(create, deps)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useReducer: function (reducer, initialArg, init) {
							currentHookNameInDev = 'useReducer'
							warnInvalidHookAccess()
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return updateReducer(reducer, initialArg, init)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useRef: function (initialValue) {
							currentHookNameInDev = 'useRef'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateRef()
						},
						useState: function (initialState2) {
							currentHookNameInDev = 'useState'
							warnInvalidHookAccess()
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return updateState(initialState2)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useDebugValue: function (value, formatterFn) {
							currentHookNameInDev = 'useDebugValue'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateDebugValue()
						},
						useDeferredValue: function (value) {
							currentHookNameInDev = 'useDeferredValue'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateDeferredValue(value)
						},
						useTransition: function () {
							currentHookNameInDev = 'useTransition'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateTransition()
						},
						useMutableSource: function (source, getSnapshot, subscribe) {
							currentHookNameInDev = 'useMutableSource'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateMutableSource()
						},
						useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
							currentHookNameInDev = 'useSyncExternalStore'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateSyncExternalStore(subscribe, getSnapshot)
						},
						useId: function () {
							currentHookNameInDev = 'useId'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateId()
						},
						unstable_isNewReconciler: enableNewReconciler,
					}
					InvalidNestedHooksDispatcherOnRerenderInDEV = {
						readContext: function (context) {
							warnInvalidContextAccess()
							return readContext(context)
						},
						useCallback: function (callback, deps) {
							currentHookNameInDev = 'useCallback'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateCallback(callback, deps)
						},
						useContext: function (context) {
							currentHookNameInDev = 'useContext'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return readContext(context)
						},
						useEffect: function (create, deps) {
							currentHookNameInDev = 'useEffect'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateEffect(create, deps)
						},
						useImperativeHandle: function (ref, create, deps) {
							currentHookNameInDev = 'useImperativeHandle'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateImperativeHandle(ref, create, deps)
						},
						useInsertionEffect: function (create, deps) {
							currentHookNameInDev = 'useInsertionEffect'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateInsertionEffect(create, deps)
						},
						useLayoutEffect: function (create, deps) {
							currentHookNameInDev = 'useLayoutEffect'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateLayoutEffect(create, deps)
						},
						useMemo: function (create, deps) {
							currentHookNameInDev = 'useMemo'
							warnInvalidHookAccess()
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return updateMemo(create, deps)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useReducer: function (reducer, initialArg, init) {
							currentHookNameInDev = 'useReducer'
							warnInvalidHookAccess()
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return rerenderReducer(reducer, initialArg, init)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useRef: function (initialValue) {
							currentHookNameInDev = 'useRef'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateRef()
						},
						useState: function (initialState2) {
							currentHookNameInDev = 'useState'
							warnInvalidHookAccess()
							updateHookTypesDev()
							var prevDispatcher = ReactCurrentDispatcher$1.current
							ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV
							try {
								return rerenderState(initialState2)
							} finally {
								ReactCurrentDispatcher$1.current = prevDispatcher
							}
						},
						useDebugValue: function (value, formatterFn) {
							currentHookNameInDev = 'useDebugValue'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateDebugValue()
						},
						useDeferredValue: function (value) {
							currentHookNameInDev = 'useDeferredValue'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return rerenderDeferredValue(value)
						},
						useTransition: function () {
							currentHookNameInDev = 'useTransition'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return rerenderTransition()
						},
						useMutableSource: function (source, getSnapshot, subscribe) {
							currentHookNameInDev = 'useMutableSource'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateMutableSource()
						},
						useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
							currentHookNameInDev = 'useSyncExternalStore'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateSyncExternalStore(subscribe, getSnapshot)
						},
						useId: function () {
							currentHookNameInDev = 'useId'
							warnInvalidHookAccess()
							updateHookTypesDev()
							return updateId()
						},
						unstable_isNewReconciler: enableNewReconciler,
					}
				}
				var now$1 = Scheduler.unstable_now
				var commitTime = 0
				var layoutEffectStartTime = -1
				var profilerStartTime = -1
				var passiveEffectStartTime = -1
				var currentUpdateIsNested = false
				var nestedUpdateScheduled = false
				function isCurrentUpdateNested() {
					return currentUpdateIsNested
				}
				function markNestedUpdateScheduled() {
					{
						nestedUpdateScheduled = true
					}
				}
				function resetNestedUpdateFlag() {
					{
						currentUpdateIsNested = false
						nestedUpdateScheduled = false
					}
				}
				function syncNestedUpdateFlag() {
					{
						currentUpdateIsNested = nestedUpdateScheduled
						nestedUpdateScheduled = false
					}
				}
				function getCommitTime() {
					return commitTime
				}
				function recordCommitTime() {
					commitTime = now$1()
				}
				function startProfilerTimer(fiber) {
					profilerStartTime = now$1()
					if (fiber.actualStartTime < 0) {
						fiber.actualStartTime = now$1()
					}
				}
				function stopProfilerTimerIfRunning(fiber) {
					profilerStartTime = -1
				}
				function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
					if (profilerStartTime >= 0) {
						var elapsedTime = now$1() - profilerStartTime
						fiber.actualDuration += elapsedTime
						if (overrideBaseTime) {
							fiber.selfBaseDuration = elapsedTime
						}
						profilerStartTime = -1
					}
				}
				function recordLayoutEffectDuration(fiber) {
					if (layoutEffectStartTime >= 0) {
						var elapsedTime = now$1() - layoutEffectStartTime
						layoutEffectStartTime = -1
						var parentFiber = fiber.return
						while (parentFiber !== null) {
							switch (parentFiber.tag) {
								case HostRoot:
									var root3 = parentFiber.stateNode
									root3.effectDuration += elapsedTime
									return
								case Profiler:
									var parentStateNode = parentFiber.stateNode
									parentStateNode.effectDuration += elapsedTime
									return
							}
							parentFiber = parentFiber.return
						}
					}
				}
				function recordPassiveEffectDuration(fiber) {
					if (passiveEffectStartTime >= 0) {
						var elapsedTime = now$1() - passiveEffectStartTime
						passiveEffectStartTime = -1
						var parentFiber = fiber.return
						while (parentFiber !== null) {
							switch (parentFiber.tag) {
								case HostRoot:
									var root3 = parentFiber.stateNode
									if (root3 !== null) {
										root3.passiveEffectDuration += elapsedTime
									}
									return
								case Profiler:
									var parentStateNode = parentFiber.stateNode
									if (parentStateNode !== null) {
										parentStateNode.passiveEffectDuration += elapsedTime
									}
									return
							}
							parentFiber = parentFiber.return
						}
					}
				}
				function startLayoutEffectTimer() {
					layoutEffectStartTime = now$1()
				}
				function startPassiveEffectTimer() {
					passiveEffectStartTime = now$1()
				}
				function transferActualDuration(fiber) {
					var child = fiber.child
					while (child) {
						fiber.actualDuration += child.actualDuration
						child = child.sibling
					}
				}
				function createCapturedValueAtFiber(value, source) {
					return {
						value,
						source,
						stack: getStackByFiberInDevAndProd(source),
						digest: null,
					}
				}
				function createCapturedValue(value, digest, stack3) {
					return {
						value,
						source: null,
						stack: stack3 != null ? stack3 : null,
						digest: digest != null ? digest : null,
					}
				}
				function showErrorDialog(boundary, errorInfo) {
					return true
				}
				function logCapturedError(boundary, errorInfo) {
					try {
						var logError = showErrorDialog(boundary, errorInfo)
						if (logError === false) {
							return
						}
						var error2 = errorInfo.value
						if (true) {
							var source = errorInfo.source
							var stack3 = errorInfo.stack
							var componentStack = stack3 !== null ? stack3 : ''
							if (error2 != null && error2._suppressLogging) {
								if (boundary.tag === ClassComponent) {
									return
								}
								console['error'](error2)
							}
							var componentName = source ? getComponentNameFromFiber(source) : null
							var componentNameMessage = componentName
								? 'The above error occurred in the <' + componentName + '> component:'
								: 'The above error occurred in one of your React components:'
							var errorBoundaryMessage
							if (boundary.tag === HostRoot) {
								errorBoundaryMessage =
									'Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.'
							} else {
								var errorBoundaryName = getComponentNameFromFiber(boundary) || 'Anonymous'
								errorBoundaryMessage =
									'React will try to recreate this component tree from scratch ' +
									('using the error boundary you provided, ' + errorBoundaryName + '.')
							}
							var combinedMessage =
								componentNameMessage + '\n' + componentStack + '\n\n' + ('' + errorBoundaryMessage)
							console['error'](combinedMessage)
						} else {
							console['error'](error2)
						}
					} catch (e2) {
						setTimeout(function () {
							throw e2
						})
					}
				}
				var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map
				function createRootErrorUpdate(fiber, errorInfo, lane) {
					var update = createUpdate(NoTimestamp, lane)
					update.tag = CaptureUpdate
					update.payload = {
						element: null,
					}
					var error2 = errorInfo.value
					update.callback = function () {
						onUncaughtError(error2)
						logCapturedError(fiber, errorInfo)
					}
					return update
				}
				function createClassErrorUpdate(fiber, errorInfo, lane) {
					var update = createUpdate(NoTimestamp, lane)
					update.tag = CaptureUpdate
					var getDerivedStateFromError = fiber.type.getDerivedStateFromError
					if (typeof getDerivedStateFromError === 'function') {
						var error$1 = errorInfo.value
						update.payload = function () {
							return getDerivedStateFromError(error$1)
						}
						update.callback = function () {
							{
								markFailedErrorBoundaryForHotReloading(fiber)
							}
							logCapturedError(fiber, errorInfo)
						}
					}
					var inst = fiber.stateNode
					if (inst !== null && typeof inst.componentDidCatch === 'function') {
						update.callback = function callback() {
							{
								markFailedErrorBoundaryForHotReloading(fiber)
							}
							logCapturedError(fiber, errorInfo)
							if (typeof getDerivedStateFromError !== 'function') {
								markLegacyErrorBoundaryAsFailed(this)
							}
							var error$12 = errorInfo.value
							var stack3 = errorInfo.stack
							this.componentDidCatch(error$12, {
								componentStack: stack3 !== null ? stack3 : '',
							})
							{
								if (typeof getDerivedStateFromError !== 'function') {
									if (!includesSomeLane(fiber.lanes, SyncLane)) {
										error(
											'%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.',
											getComponentNameFromFiber(fiber) || 'Unknown'
										)
									}
								}
							}
						}
					}
					return update
				}
				function attachPingListener(root3, wakeable, lanes) {
					var pingCache = root3.pingCache
					var threadIDs
					if (pingCache === null) {
						pingCache = root3.pingCache = new PossiblyWeakMap$1()
						threadIDs = /* @__PURE__ */ new Set()
						pingCache.set(wakeable, threadIDs)
					} else {
						threadIDs = pingCache.get(wakeable)
						if (threadIDs === void 0) {
							threadIDs = /* @__PURE__ */ new Set()
							pingCache.set(wakeable, threadIDs)
						}
					}
					if (!threadIDs.has(lanes)) {
						threadIDs.add(lanes)
						var ping = pingSuspendedRoot.bind(null, root3, wakeable, lanes)
						{
							if (isDevToolsPresent) {
								restorePendingUpdaters(root3, lanes)
							}
						}
						wakeable.then(ping, ping)
					}
				}
				function attachRetryListener(suspenseBoundary, root3, wakeable, lanes) {
					var wakeables = suspenseBoundary.updateQueue
					if (wakeables === null) {
						var updateQueue = /* @__PURE__ */ new Set()
						updateQueue.add(wakeable)
						suspenseBoundary.updateQueue = updateQueue
					} else {
						wakeables.add(wakeable)
					}
				}
				function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
					var tag = sourceFiber.tag
					if (
						(sourceFiber.mode & ConcurrentMode) === NoMode &&
						(tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)
					) {
						var currentSource = sourceFiber.alternate
						if (currentSource) {
							sourceFiber.updateQueue = currentSource.updateQueue
							sourceFiber.memoizedState = currentSource.memoizedState
							sourceFiber.lanes = currentSource.lanes
						} else {
							sourceFiber.updateQueue = null
							sourceFiber.memoizedState = null
						}
					}
				}
				function getNearestSuspenseBoundaryToCapture(returnFiber) {
					var node = returnFiber
					do {
						if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
							return node
						}
						node = node.return
					} while (node !== null)
					return null
				}
				function markSuspenseBoundaryShouldCapture(
					suspenseBoundary,
					returnFiber,
					sourceFiber,
					root3,
					rootRenderLanes
				) {
					if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
						if (suspenseBoundary === returnFiber) {
							suspenseBoundary.flags |= ShouldCapture
						} else {
							suspenseBoundary.flags |= DidCapture
							sourceFiber.flags |= ForceUpdateForLegacySuspense
							sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete)
							if (sourceFiber.tag === ClassComponent) {
								var currentSourceFiber = sourceFiber.alternate
								if (currentSourceFiber === null) {
									sourceFiber.tag = IncompleteClassComponent
								} else {
									var update = createUpdate(NoTimestamp, SyncLane)
									update.tag = ForceUpdate
									enqueueUpdate(sourceFiber, update, SyncLane)
								}
							}
							sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane)
						}
						return suspenseBoundary
					}
					suspenseBoundary.flags |= ShouldCapture
					suspenseBoundary.lanes = rootRenderLanes
					return suspenseBoundary
				}
				function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
					sourceFiber.flags |= Incomplete
					{
						if (isDevToolsPresent) {
							restorePendingUpdaters(root3, rootRenderLanes)
						}
					}
					if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
						var wakeable = value
						resetSuspendedComponent(sourceFiber)
						{
							if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
								markDidThrowWhileHydratingDEV()
							}
						}
						var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber)
						if (suspenseBoundary !== null) {
							suspenseBoundary.flags &= ~ForceClientRender
							markSuspenseBoundaryShouldCapture(
								suspenseBoundary,
								returnFiber,
								sourceFiber,
								root3,
								rootRenderLanes
							)
							if (suspenseBoundary.mode & ConcurrentMode) {
								attachPingListener(root3, wakeable, rootRenderLanes)
							}
							attachRetryListener(suspenseBoundary, root3, wakeable)
							return
						} else {
							if (!includesSyncLane(rootRenderLanes)) {
								attachPingListener(root3, wakeable, rootRenderLanes)
								renderDidSuspendDelayIfPossible()
								return
							}
							var uncaughtSuspenseError = new Error(
								'A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.'
							)
							value = uncaughtSuspenseError
						}
					} else {
						if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
							markDidThrowWhileHydratingDEV()
							var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber)
							if (_suspenseBoundary !== null) {
								if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
									_suspenseBoundary.flags |= ForceClientRender
								}
								markSuspenseBoundaryShouldCapture(
									_suspenseBoundary,
									returnFiber,
									sourceFiber,
									root3,
									rootRenderLanes
								)
								queueHydrationError(createCapturedValueAtFiber(value, sourceFiber))
								return
							}
						}
					}
					value = createCapturedValueAtFiber(value, sourceFiber)
					renderDidError(value)
					var workInProgress2 = returnFiber
					do {
						switch (workInProgress2.tag) {
							case HostRoot: {
								var _errorInfo = value
								workInProgress2.flags |= ShouldCapture
								var lane = pickArbitraryLane(rootRenderLanes)
								workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane)
								var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane)
								enqueueCapturedUpdate(workInProgress2, update)
								return
							}
							case ClassComponent:
								var errorInfo = value
								var ctor = workInProgress2.type
								var instance = workInProgress2.stateNode
								if (
									(workInProgress2.flags & DidCapture) === NoFlags &&
									(typeof ctor.getDerivedStateFromError === 'function' ||
										(instance !== null &&
											typeof instance.componentDidCatch === 'function' &&
											!isAlreadyFailedLegacyErrorBoundary(instance)))
								) {
									workInProgress2.flags |= ShouldCapture
									var _lane = pickArbitraryLane(rootRenderLanes)
									workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane)
									var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane)
									enqueueCapturedUpdate(workInProgress2, _update)
									return
								}
								break
						}
						workInProgress2 = workInProgress2.return
					} while (workInProgress2 !== null)
				}
				function getSuspendedCache() {
					{
						return null
					}
				}
				var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner
				var didReceiveUpdate = false
				var didWarnAboutBadClass
				var didWarnAboutModulePatternComponent
				var didWarnAboutContextTypeOnFunctionComponent
				var didWarnAboutGetDerivedStateOnFunctionComponent
				var didWarnAboutFunctionRefs
				var didWarnAboutReassigningProps
				var didWarnAboutRevealOrder
				var didWarnAboutTailOptions
				{
					didWarnAboutBadClass = {}
					didWarnAboutModulePatternComponent = {}
					didWarnAboutContextTypeOnFunctionComponent = {}
					didWarnAboutGetDerivedStateOnFunctionComponent = {}
					didWarnAboutFunctionRefs = {}
					didWarnAboutReassigningProps = false
					didWarnAboutRevealOrder = {}
					didWarnAboutTailOptions = {}
				}
				function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
					if (current2 === null) {
						workInProgress2.child = mountChildFibers(
							workInProgress2,
							null,
							nextChildren,
							renderLanes2
						)
					} else {
						workInProgress2.child = reconcileChildFibers(
							workInProgress2,
							current2.child,
							nextChildren,
							renderLanes2
						)
					}
				}
				function forceUnmountCurrentAndReconcile(
					current2,
					workInProgress2,
					nextChildren,
					renderLanes2
				) {
					workInProgress2.child = reconcileChildFibers(
						workInProgress2,
						current2.child,
						null,
						renderLanes2
					)
					workInProgress2.child = reconcileChildFibers(
						workInProgress2,
						null,
						nextChildren,
						renderLanes2
					)
				}
				function updateForwardRef(current2, workInProgress2, Component3, nextProps, renderLanes2) {
					{
						if (workInProgress2.type !== workInProgress2.elementType) {
							var innerPropTypes = Component3.propTypes
							if (innerPropTypes) {
								checkPropTypes(
									innerPropTypes,
									nextProps,
									// Resolved props
									'prop',
									getComponentNameFromType(Component3)
								)
							}
						}
					}
					var render2 = Component3.render
					var ref = workInProgress2.ref
					var nextChildren
					var hasId
					prepareToReadContext(workInProgress2, renderLanes2)
					{
						markComponentRenderStarted(workInProgress2)
					}
					{
						ReactCurrentOwner$1.current = workInProgress2
						setIsRendering(true)
						nextChildren = renderWithHooks(
							current2,
							workInProgress2,
							render2,
							nextProps,
							ref,
							renderLanes2
						)
						hasId = checkDidRenderIdHook()
						if (workInProgress2.mode & StrictLegacyMode) {
							setIsStrictModeForDevtools(true)
							try {
								nextChildren = renderWithHooks(
									current2,
									workInProgress2,
									render2,
									nextProps,
									ref,
									renderLanes2
								)
								hasId = checkDidRenderIdHook()
							} finally {
								setIsStrictModeForDevtools(false)
							}
						}
						setIsRendering(false)
					}
					{
						markComponentRenderStopped()
					}
					if (current2 !== null && !didReceiveUpdate) {
						bailoutHooks(current2, workInProgress2, renderLanes2)
						return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
					}
					if (getIsHydrating() && hasId) {
						pushMaterializedTreeId(workInProgress2)
					}
					workInProgress2.flags |= PerformedWork
					reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					return workInProgress2.child
				}
				function updateMemoComponent(
					current2,
					workInProgress2,
					Component3,
					nextProps,
					renderLanes2
				) {
					if (current2 === null) {
						var type = Component3.type
						if (
							isSimpleFunctionComponent(type) &&
							Component3.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
							Component3.defaultProps === void 0
						) {
							var resolvedType = type
							{
								resolvedType = resolveFunctionForHotReloading(type)
							}
							workInProgress2.tag = SimpleMemoComponent
							workInProgress2.type = resolvedType
							{
								validateFunctionComponentInDev(workInProgress2, type)
							}
							return updateSimpleMemoComponent(
								current2,
								workInProgress2,
								resolvedType,
								nextProps,
								renderLanes2
							)
						}
						{
							var innerPropTypes = type.propTypes
							if (innerPropTypes) {
								checkPropTypes(
									innerPropTypes,
									nextProps,
									// Resolved props
									'prop',
									getComponentNameFromType(type)
								)
							}
						}
						var child = createFiberFromTypeAndProps(
							Component3.type,
							null,
							nextProps,
							workInProgress2,
							workInProgress2.mode,
							renderLanes2
						)
						child.ref = workInProgress2.ref
						child.return = workInProgress2
						workInProgress2.child = child
						return child
					}
					{
						var _type = Component3.type
						var _innerPropTypes = _type.propTypes
						if (_innerPropTypes) {
							checkPropTypes(
								_innerPropTypes,
								nextProps,
								// Resolved props
								'prop',
								getComponentNameFromType(_type)
							)
						}
					}
					var currentChild = current2.child
					var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2)
					if (!hasScheduledUpdateOrContext) {
						var prevProps = currentChild.memoizedProps
						var compare = Component3.compare
						compare = compare !== null ? compare : shallowEqual
						if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
							return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
						}
					}
					workInProgress2.flags |= PerformedWork
					var newChild = createWorkInProgress(currentChild, nextProps)
					newChild.ref = workInProgress2.ref
					newChild.return = workInProgress2
					workInProgress2.child = newChild
					return newChild
				}
				function updateSimpleMemoComponent(
					current2,
					workInProgress2,
					Component3,
					nextProps,
					renderLanes2
				) {
					{
						if (workInProgress2.type !== workInProgress2.elementType) {
							var outerMemoType = workInProgress2.elementType
							if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
								var lazyComponent = outerMemoType
								var payload = lazyComponent._payload
								var init = lazyComponent._init
								try {
									outerMemoType = init(payload)
								} catch (x3) {
									outerMemoType = null
								}
								var outerPropTypes = outerMemoType && outerMemoType.propTypes
								if (outerPropTypes) {
									checkPropTypes(
										outerPropTypes,
										nextProps,
										// Resolved (SimpleMemoComponent has no defaultProps)
										'prop',
										getComponentNameFromType(outerMemoType)
									)
								}
							}
						}
					}
					if (current2 !== null) {
						var prevProps = current2.memoizedProps
						if (
							shallowEqual(prevProps, nextProps) &&
							current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
							workInProgress2.type === current2.type
						) {
							didReceiveUpdate = false
							workInProgress2.pendingProps = nextProps = prevProps
							if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
								workInProgress2.lanes = current2.lanes
								return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
							} else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
								didReceiveUpdate = true
							}
						}
					}
					return updateFunctionComponent(
						current2,
						workInProgress2,
						Component3,
						nextProps,
						renderLanes2
					)
				}
				function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
					var nextProps = workInProgress2.pendingProps
					var nextChildren = nextProps.children
					var prevState = current2 !== null ? current2.memoizedState : null
					if (nextProps.mode === 'hidden' || enableLegacyHidden) {
						if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
							var nextState = {
								baseLanes: NoLanes,
								cachePool: null,
								transitions: null,
							}
							workInProgress2.memoizedState = nextState
							pushRenderLanes(workInProgress2, renderLanes2)
						} else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
							var spawnedCachePool = null
							var nextBaseLanes
							if (prevState !== null) {
								var prevBaseLanes = prevState.baseLanes
								nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2)
							} else {
								nextBaseLanes = renderLanes2
							}
							workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane)
							var _nextState = {
								baseLanes: nextBaseLanes,
								cachePool: spawnedCachePool,
								transitions: null,
							}
							workInProgress2.memoizedState = _nextState
							workInProgress2.updateQueue = null
							pushRenderLanes(workInProgress2, nextBaseLanes)
							return null
						} else {
							var _nextState2 = {
								baseLanes: NoLanes,
								cachePool: null,
								transitions: null,
							}
							workInProgress2.memoizedState = _nextState2
							var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2
							pushRenderLanes(workInProgress2, subtreeRenderLanes2)
						}
					} else {
						var _subtreeRenderLanes
						if (prevState !== null) {
							_subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2)
							workInProgress2.memoizedState = null
						} else {
							_subtreeRenderLanes = renderLanes2
						}
						pushRenderLanes(workInProgress2, _subtreeRenderLanes)
					}
					reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					return workInProgress2.child
				}
				function updateFragment(current2, workInProgress2, renderLanes2) {
					var nextChildren = workInProgress2.pendingProps
					reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					return workInProgress2.child
				}
				function updateMode(current2, workInProgress2, renderLanes2) {
					var nextChildren = workInProgress2.pendingProps.children
					reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					return workInProgress2.child
				}
				function updateProfiler(current2, workInProgress2, renderLanes2) {
					{
						workInProgress2.flags |= Update
						{
							var stateNode = workInProgress2.stateNode
							stateNode.effectDuration = 0
							stateNode.passiveEffectDuration = 0
						}
					}
					var nextProps = workInProgress2.pendingProps
					var nextChildren = nextProps.children
					reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					return workInProgress2.child
				}
				function markRef(current2, workInProgress2) {
					var ref = workInProgress2.ref
					if ((current2 === null && ref !== null) || (current2 !== null && current2.ref !== ref)) {
						workInProgress2.flags |= Ref
						{
							workInProgress2.flags |= RefStatic
						}
					}
				}
				function updateFunctionComponent(
					current2,
					workInProgress2,
					Component3,
					nextProps,
					renderLanes2
				) {
					{
						if (workInProgress2.type !== workInProgress2.elementType) {
							var innerPropTypes = Component3.propTypes
							if (innerPropTypes) {
								checkPropTypes(
									innerPropTypes,
									nextProps,
									// Resolved props
									'prop',
									getComponentNameFromType(Component3)
								)
							}
						}
					}
					var context
					{
						var unmaskedContext = getUnmaskedContext(workInProgress2, Component3, true)
						context = getMaskedContext(workInProgress2, unmaskedContext)
					}
					var nextChildren
					var hasId
					prepareToReadContext(workInProgress2, renderLanes2)
					{
						markComponentRenderStarted(workInProgress2)
					}
					{
						ReactCurrentOwner$1.current = workInProgress2
						setIsRendering(true)
						nextChildren = renderWithHooks(
							current2,
							workInProgress2,
							Component3,
							nextProps,
							context,
							renderLanes2
						)
						hasId = checkDidRenderIdHook()
						if (workInProgress2.mode & StrictLegacyMode) {
							setIsStrictModeForDevtools(true)
							try {
								nextChildren = renderWithHooks(
									current2,
									workInProgress2,
									Component3,
									nextProps,
									context,
									renderLanes2
								)
								hasId = checkDidRenderIdHook()
							} finally {
								setIsStrictModeForDevtools(false)
							}
						}
						setIsRendering(false)
					}
					{
						markComponentRenderStopped()
					}
					if (current2 !== null && !didReceiveUpdate) {
						bailoutHooks(current2, workInProgress2, renderLanes2)
						return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
					}
					if (getIsHydrating() && hasId) {
						pushMaterializedTreeId(workInProgress2)
					}
					workInProgress2.flags |= PerformedWork
					reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					return workInProgress2.child
				}
				function updateClassComponent(
					current2,
					workInProgress2,
					Component3,
					nextProps,
					renderLanes2
				) {
					{
						switch (shouldError(workInProgress2)) {
							case false: {
								var _instance = workInProgress2.stateNode
								var ctor = workInProgress2.type
								var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context)
								var state = tempInstance.state
								_instance.updater.enqueueSetState(_instance, state, null)
								break
							}
							case true: {
								workInProgress2.flags |= DidCapture
								workInProgress2.flags |= ShouldCapture
								var error$1 = new Error('Simulated error coming from DevTools')
								var lane = pickArbitraryLane(renderLanes2)
								workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane)
								var update = createClassErrorUpdate(
									workInProgress2,
									createCapturedValueAtFiber(error$1, workInProgress2),
									lane
								)
								enqueueCapturedUpdate(workInProgress2, update)
								break
							}
						}
						if (workInProgress2.type !== workInProgress2.elementType) {
							var innerPropTypes = Component3.propTypes
							if (innerPropTypes) {
								checkPropTypes(
									innerPropTypes,
									nextProps,
									// Resolved props
									'prop',
									getComponentNameFromType(Component3)
								)
							}
						}
					}
					var hasContext
					if (isContextProvider(Component3)) {
						hasContext = true
						pushContextProvider(workInProgress2)
					} else {
						hasContext = false
					}
					prepareToReadContext(workInProgress2, renderLanes2)
					var instance = workInProgress2.stateNode
					var shouldUpdate
					if (instance === null) {
						resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2)
						constructClassInstance(workInProgress2, Component3, nextProps)
						mountClassInstance(workInProgress2, Component3, nextProps, renderLanes2)
						shouldUpdate = true
					} else if (current2 === null) {
						shouldUpdate = resumeMountClassInstance(
							workInProgress2,
							Component3,
							nextProps,
							renderLanes2
						)
					} else {
						shouldUpdate = updateClassInstance(
							current2,
							workInProgress2,
							Component3,
							nextProps,
							renderLanes2
						)
					}
					var nextUnitOfWork = finishClassComponent(
						current2,
						workInProgress2,
						Component3,
						shouldUpdate,
						hasContext,
						renderLanes2
					)
					{
						var inst = workInProgress2.stateNode
						if (shouldUpdate && inst.props !== nextProps) {
							if (!didWarnAboutReassigningProps) {
								error(
									'It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.',
									getComponentNameFromFiber(workInProgress2) || 'a component'
								)
							}
							didWarnAboutReassigningProps = true
						}
					}
					return nextUnitOfWork
				}
				function finishClassComponent(
					current2,
					workInProgress2,
					Component3,
					shouldUpdate,
					hasContext,
					renderLanes2
				) {
					markRef(current2, workInProgress2)
					var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags
					if (!shouldUpdate && !didCaptureError) {
						if (hasContext) {
							invalidateContextProvider(workInProgress2, Component3, false)
						}
						return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
					}
					var instance = workInProgress2.stateNode
					ReactCurrentOwner$1.current = workInProgress2
					var nextChildren
					if (didCaptureError && typeof Component3.getDerivedStateFromError !== 'function') {
						nextChildren = null
						{
							stopProfilerTimerIfRunning()
						}
					} else {
						{
							markComponentRenderStarted(workInProgress2)
						}
						{
							setIsRendering(true)
							nextChildren = instance.render()
							if (workInProgress2.mode & StrictLegacyMode) {
								setIsStrictModeForDevtools(true)
								try {
									instance.render()
								} finally {
									setIsStrictModeForDevtools(false)
								}
							}
							setIsRendering(false)
						}
						{
							markComponentRenderStopped()
						}
					}
					workInProgress2.flags |= PerformedWork
					if (current2 !== null && didCaptureError) {
						forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2)
					} else {
						reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					}
					workInProgress2.memoizedState = instance.state
					if (hasContext) {
						invalidateContextProvider(workInProgress2, Component3, true)
					}
					return workInProgress2.child
				}
				function pushHostRootContext(workInProgress2) {
					var root3 = workInProgress2.stateNode
					if (root3.pendingContext) {
						pushTopLevelContextObject(
							workInProgress2,
							root3.pendingContext,
							root3.pendingContext !== root3.context
						)
					} else if (root3.context) {
						pushTopLevelContextObject(workInProgress2, root3.context, false)
					}
					pushHostContainer(workInProgress2, root3.containerInfo)
				}
				function updateHostRoot(current2, workInProgress2, renderLanes2) {
					pushHostRootContext(workInProgress2)
					if (current2 === null) {
						throw new Error('Should have a current fiber. This is a bug in React.')
					}
					var nextProps = workInProgress2.pendingProps
					var prevState = workInProgress2.memoizedState
					var prevChildren = prevState.element
					cloneUpdateQueue(current2, workInProgress2)
					processUpdateQueue(workInProgress2, nextProps, null, renderLanes2)
					var nextState = workInProgress2.memoizedState
					var root3 = workInProgress2.stateNode
					var nextChildren = nextState.element
					if (prevState.isDehydrated) {
						var overrideState = {
							element: nextChildren,
							isDehydrated: false,
							cache: nextState.cache,
							pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
							transitions: nextState.transitions,
						}
						var updateQueue = workInProgress2.updateQueue
						updateQueue.baseState = overrideState
						workInProgress2.memoizedState = overrideState
						if (workInProgress2.flags & ForceClientRender) {
							var recoverableError = createCapturedValueAtFiber(
								new Error(
									'There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.'
								),
								workInProgress2
							)
							return mountHostRootWithoutHydrating(
								current2,
								workInProgress2,
								nextChildren,
								renderLanes2,
								recoverableError
							)
						} else if (nextChildren !== prevChildren) {
							var _recoverableError = createCapturedValueAtFiber(
								new Error(
									'This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.'
								),
								workInProgress2
							)
							return mountHostRootWithoutHydrating(
								current2,
								workInProgress2,
								nextChildren,
								renderLanes2,
								_recoverableError
							)
						} else {
							enterHydrationState(workInProgress2)
							var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2)
							workInProgress2.child = child
							var node = child
							while (node) {
								node.flags = (node.flags & ~Placement) | Hydrating
								node = node.sibling
							}
						}
					} else {
						resetHydrationState()
						if (nextChildren === prevChildren) {
							return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
						}
						reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					}
					return workInProgress2.child
				}
				function mountHostRootWithoutHydrating(
					current2,
					workInProgress2,
					nextChildren,
					renderLanes2,
					recoverableError
				) {
					resetHydrationState()
					queueHydrationError(recoverableError)
					workInProgress2.flags |= ForceClientRender
					reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					return workInProgress2.child
				}
				function updateHostComponent(current2, workInProgress2, renderLanes2) {
					pushHostContext(workInProgress2)
					if (current2 === null) {
						tryToClaimNextHydratableInstance(workInProgress2)
					}
					var type = workInProgress2.type
					var nextProps = workInProgress2.pendingProps
					var prevProps = current2 !== null ? current2.memoizedProps : null
					var nextChildren = nextProps.children
					var isDirectTextChild = shouldSetTextContent(type, nextProps)
					if (isDirectTextChild) {
						nextChildren = null
					} else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
						workInProgress2.flags |= ContentReset
					}
					markRef(current2, workInProgress2)
					reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					return workInProgress2.child
				}
				function updateHostText(current2, workInProgress2) {
					if (current2 === null) {
						tryToClaimNextHydratableInstance(workInProgress2)
					}
					return null
				}
				function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
					resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2)
					var props = workInProgress2.pendingProps
					var lazyComponent = elementType
					var payload = lazyComponent._payload
					var init = lazyComponent._init
					var Component3 = init(payload)
					workInProgress2.type = Component3
					var resolvedTag = (workInProgress2.tag = resolveLazyComponentTag(Component3))
					var resolvedProps = resolveDefaultProps(Component3, props)
					var child
					switch (resolvedTag) {
						case FunctionComponent: {
							{
								validateFunctionComponentInDev(workInProgress2, Component3)
								workInProgress2.type = Component3 = resolveFunctionForHotReloading(Component3)
							}
							child = updateFunctionComponent(
								null,
								workInProgress2,
								Component3,
								resolvedProps,
								renderLanes2
							)
							return child
						}
						case ClassComponent: {
							{
								workInProgress2.type = Component3 = resolveClassForHotReloading(Component3)
							}
							child = updateClassComponent(
								null,
								workInProgress2,
								Component3,
								resolvedProps,
								renderLanes2
							)
							return child
						}
						case ForwardRef: {
							{
								workInProgress2.type = Component3 = resolveForwardRefForHotReloading(Component3)
							}
							child = updateForwardRef(
								null,
								workInProgress2,
								Component3,
								resolvedProps,
								renderLanes2
							)
							return child
						}
						case MemoComponent: {
							{
								if (workInProgress2.type !== workInProgress2.elementType) {
									var outerPropTypes = Component3.propTypes
									if (outerPropTypes) {
										checkPropTypes(
											outerPropTypes,
											resolvedProps,
											// Resolved for outer only
											'prop',
											getComponentNameFromType(Component3)
										)
									}
								}
							}
							child = updateMemoComponent(
								null,
								workInProgress2,
								Component3,
								resolveDefaultProps(Component3.type, resolvedProps),
								// The inner type can have defaults too
								renderLanes2
							)
							return child
						}
					}
					var hint = ''
					{
						if (
							Component3 !== null &&
							typeof Component3 === 'object' &&
							Component3.$$typeof === REACT_LAZY_TYPE
						) {
							hint = ' Did you wrap a component in React.lazy() more than once?'
						}
					}
					throw new Error(
						'Element type is invalid. Received a promise that resolves to: ' +
							Component3 +
							'. ' +
							('Lazy element type must resolve to a class or function.' + hint)
					)
				}
				function mountIncompleteClassComponent(
					_current,
					workInProgress2,
					Component3,
					nextProps,
					renderLanes2
				) {
					resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2)
					workInProgress2.tag = ClassComponent
					var hasContext
					if (isContextProvider(Component3)) {
						hasContext = true
						pushContextProvider(workInProgress2)
					} else {
						hasContext = false
					}
					prepareToReadContext(workInProgress2, renderLanes2)
					constructClassInstance(workInProgress2, Component3, nextProps)
					mountClassInstance(workInProgress2, Component3, nextProps, renderLanes2)
					return finishClassComponent(
						null,
						workInProgress2,
						Component3,
						true,
						hasContext,
						renderLanes2
					)
				}
				function mountIndeterminateComponent(_current, workInProgress2, Component3, renderLanes2) {
					resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2)
					var props = workInProgress2.pendingProps
					var context
					{
						var unmaskedContext = getUnmaskedContext(workInProgress2, Component3, false)
						context = getMaskedContext(workInProgress2, unmaskedContext)
					}
					prepareToReadContext(workInProgress2, renderLanes2)
					var value
					var hasId
					{
						markComponentRenderStarted(workInProgress2)
					}
					{
						if (Component3.prototype && typeof Component3.prototype.render === 'function') {
							var componentName = getComponentNameFromType(Component3) || 'Unknown'
							if (!didWarnAboutBadClass[componentName]) {
								error(
									"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
									componentName,
									componentName
								)
								didWarnAboutBadClass[componentName] = true
							}
						}
						if (workInProgress2.mode & StrictLegacyMode) {
							ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null)
						}
						setIsRendering(true)
						ReactCurrentOwner$1.current = workInProgress2
						value = renderWithHooks(null, workInProgress2, Component3, props, context, renderLanes2)
						hasId = checkDidRenderIdHook()
						setIsRendering(false)
					}
					{
						markComponentRenderStopped()
					}
					workInProgress2.flags |= PerformedWork
					{
						if (
							typeof value === 'object' &&
							value !== null &&
							typeof value.render === 'function' &&
							value.$$typeof === void 0
						) {
							var _componentName = getComponentNameFromType(Component3) || 'Unknown'
							if (!didWarnAboutModulePatternComponent[_componentName]) {
								error(
									"The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
									_componentName,
									_componentName,
									_componentName
								)
								didWarnAboutModulePatternComponent[_componentName] = true
							}
						}
					}
					if (
						// Run these checks in production only if the flag is off.
						// Eventually we'll delete this branch altogether.
						typeof value === 'object' &&
						value !== null &&
						typeof value.render === 'function' &&
						value.$$typeof === void 0
					) {
						{
							var _componentName2 = getComponentNameFromType(Component3) || 'Unknown'
							if (!didWarnAboutModulePatternComponent[_componentName2]) {
								error(
									"The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
									_componentName2,
									_componentName2,
									_componentName2
								)
								didWarnAboutModulePatternComponent[_componentName2] = true
							}
						}
						workInProgress2.tag = ClassComponent
						workInProgress2.memoizedState = null
						workInProgress2.updateQueue = null
						var hasContext = false
						if (isContextProvider(Component3)) {
							hasContext = true
							pushContextProvider(workInProgress2)
						} else {
							hasContext = false
						}
						workInProgress2.memoizedState =
							value.state !== null && value.state !== void 0 ? value.state : null
						initializeUpdateQueue(workInProgress2)
						adoptClassInstance(workInProgress2, value)
						mountClassInstance(workInProgress2, Component3, props, renderLanes2)
						return finishClassComponent(
							null,
							workInProgress2,
							Component3,
							true,
							hasContext,
							renderLanes2
						)
					} else {
						workInProgress2.tag = FunctionComponent
						{
							if (workInProgress2.mode & StrictLegacyMode) {
								setIsStrictModeForDevtools(true)
								try {
									value = renderWithHooks(
										null,
										workInProgress2,
										Component3,
										props,
										context,
										renderLanes2
									)
									hasId = checkDidRenderIdHook()
								} finally {
									setIsStrictModeForDevtools(false)
								}
							}
						}
						if (getIsHydrating() && hasId) {
							pushMaterializedTreeId(workInProgress2)
						}
						reconcileChildren(null, workInProgress2, value, renderLanes2)
						{
							validateFunctionComponentInDev(workInProgress2, Component3)
						}
						return workInProgress2.child
					}
				}
				function validateFunctionComponentInDev(workInProgress2, Component3) {
					{
						if (Component3) {
							if (Component3.childContextTypes) {
								error(
									'%s(...): childContextTypes cannot be defined on a function component.',
									Component3.displayName || Component3.name || 'Component'
								)
							}
						}
						if (workInProgress2.ref !== null) {
							var info = ''
							var ownerName = getCurrentFiberOwnerNameInDevOrNull()
							if (ownerName) {
								info += '\n\nCheck the render method of `' + ownerName + '`.'
							}
							var warningKey = ownerName || ''
							var debugSource = workInProgress2._debugSource
							if (debugSource) {
								warningKey = debugSource.fileName + ':' + debugSource.lineNumber
							}
							if (!didWarnAboutFunctionRefs[warningKey]) {
								didWarnAboutFunctionRefs[warningKey] = true
								error(
									'Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s',
									info
								)
							}
						}
						if (typeof Component3.getDerivedStateFromProps === 'function') {
							var _componentName3 = getComponentNameFromType(Component3) || 'Unknown'
							if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
								error(
									'%s: Function components do not support getDerivedStateFromProps.',
									_componentName3
								)
								didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true
							}
						}
						if (typeof Component3.contextType === 'object' && Component3.contextType !== null) {
							var _componentName4 = getComponentNameFromType(Component3) || 'Unknown'
							if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
								error('%s: Function components do not support contextType.', _componentName4)
								didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true
							}
						}
					}
				}
				var SUSPENDED_MARKER = {
					dehydrated: null,
					treeContext: null,
					retryLane: NoLane,
				}
				function mountSuspenseOffscreenState(renderLanes2) {
					return {
						baseLanes: renderLanes2,
						cachePool: getSuspendedCache(),
						transitions: null,
					}
				}
				function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
					var cachePool = null
					return {
						baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
						cachePool,
						transitions: prevOffscreenState.transitions,
					}
				}
				function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
					if (current2 !== null) {
						var suspenseState = current2.memoizedState
						if (suspenseState === null) {
							return false
						}
					}
					return hasSuspenseContext(suspenseContext, ForceSuspenseFallback)
				}
				function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
					return removeLanes(current2.childLanes, renderLanes2)
				}
				function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
					var nextProps = workInProgress2.pendingProps
					{
						if (shouldSuspend(workInProgress2)) {
							workInProgress2.flags |= DidCapture
						}
					}
					var suspenseContext = suspenseStackCursor.current
					var showFallback = false
					var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags
					if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
						showFallback = true
						workInProgress2.flags &= ~DidCapture
					} else {
						if (current2 === null || current2.memoizedState !== null) {
							{
								suspenseContext = addSubtreeSuspenseContext(
									suspenseContext,
									InvisibleParentSuspenseContext
								)
							}
						}
					}
					suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)
					pushSuspenseContext(workInProgress2, suspenseContext)
					if (current2 === null) {
						tryToClaimNextHydratableInstance(workInProgress2)
						var suspenseState = workInProgress2.memoizedState
						if (suspenseState !== null) {
							var dehydrated = suspenseState.dehydrated
							if (dehydrated !== null) {
								return mountDehydratedSuspenseComponent(workInProgress2, dehydrated)
							}
						}
						var nextPrimaryChildren = nextProps.children
						var nextFallbackChildren = nextProps.fallback
						if (showFallback) {
							var fallbackFragment = mountSuspenseFallbackChildren(
								workInProgress2,
								nextPrimaryChildren,
								nextFallbackChildren,
								renderLanes2
							)
							var primaryChildFragment = workInProgress2.child
							primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2)
							workInProgress2.memoizedState = SUSPENDED_MARKER
							return fallbackFragment
						} else {
							return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren)
						}
					} else {
						var prevState = current2.memoizedState
						if (prevState !== null) {
							var _dehydrated = prevState.dehydrated
							if (_dehydrated !== null) {
								return updateDehydratedSuspenseComponent(
									current2,
									workInProgress2,
									didSuspend,
									nextProps,
									_dehydrated,
									prevState,
									renderLanes2
								)
							}
						}
						if (showFallback) {
							var _nextFallbackChildren = nextProps.fallback
							var _nextPrimaryChildren = nextProps.children
							var fallbackChildFragment = updateSuspenseFallbackChildren(
								current2,
								workInProgress2,
								_nextPrimaryChildren,
								_nextFallbackChildren,
								renderLanes2
							)
							var _primaryChildFragment2 = workInProgress2.child
							var prevOffscreenState = current2.child.memoizedState
							_primaryChildFragment2.memoizedState =
								prevOffscreenState === null
									? mountSuspenseOffscreenState(renderLanes2)
									: updateSuspenseOffscreenState(prevOffscreenState, renderLanes2)
							_primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(
								current2,
								renderLanes2
							)
							workInProgress2.memoizedState = SUSPENDED_MARKER
							return fallbackChildFragment
						} else {
							var _nextPrimaryChildren2 = nextProps.children
							var _primaryChildFragment3 = updateSuspensePrimaryChildren(
								current2,
								workInProgress2,
								_nextPrimaryChildren2,
								renderLanes2
							)
							workInProgress2.memoizedState = null
							return _primaryChildFragment3
						}
					}
				}
				function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
					var mode = workInProgress2.mode
					var primaryChildProps = {
						mode: 'visible',
						children: primaryChildren,
					}
					var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode)
					primaryChildFragment.return = workInProgress2
					workInProgress2.child = primaryChildFragment
					return primaryChildFragment
				}
				function mountSuspenseFallbackChildren(
					workInProgress2,
					primaryChildren,
					fallbackChildren,
					renderLanes2
				) {
					var mode = workInProgress2.mode
					var progressedPrimaryFragment = workInProgress2.child
					var primaryChildProps = {
						mode: 'hidden',
						children: primaryChildren,
					}
					var primaryChildFragment
					var fallbackChildFragment
					if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
						primaryChildFragment = progressedPrimaryFragment
						primaryChildFragment.childLanes = NoLanes
						primaryChildFragment.pendingProps = primaryChildProps
						if (workInProgress2.mode & ProfileMode) {
							primaryChildFragment.actualDuration = 0
							primaryChildFragment.actualStartTime = -1
							primaryChildFragment.selfBaseDuration = 0
							primaryChildFragment.treeBaseDuration = 0
						}
						fallbackChildFragment = createFiberFromFragment(
							fallbackChildren,
							mode,
							renderLanes2,
							null
						)
					} else {
						primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode)
						fallbackChildFragment = createFiberFromFragment(
							fallbackChildren,
							mode,
							renderLanes2,
							null
						)
					}
					primaryChildFragment.return = workInProgress2
					fallbackChildFragment.return = workInProgress2
					primaryChildFragment.sibling = fallbackChildFragment
					workInProgress2.child = primaryChildFragment
					return fallbackChildFragment
				}
				function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
					return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null)
				}
				function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
					return createWorkInProgress(current2, offscreenProps)
				}
				function updateSuspensePrimaryChildren(
					current2,
					workInProgress2,
					primaryChildren,
					renderLanes2
				) {
					var currentPrimaryChildFragment = current2.child
					var currentFallbackChildFragment = currentPrimaryChildFragment.sibling
					var primaryChildFragment = updateWorkInProgressOffscreenFiber(
						currentPrimaryChildFragment,
						{
							mode: 'visible',
							children: primaryChildren,
						}
					)
					if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
						primaryChildFragment.lanes = renderLanes2
					}
					primaryChildFragment.return = workInProgress2
					primaryChildFragment.sibling = null
					if (currentFallbackChildFragment !== null) {
						var deletions = workInProgress2.deletions
						if (deletions === null) {
							workInProgress2.deletions = [currentFallbackChildFragment]
							workInProgress2.flags |= ChildDeletion
						} else {
							deletions.push(currentFallbackChildFragment)
						}
					}
					workInProgress2.child = primaryChildFragment
					return primaryChildFragment
				}
				function updateSuspenseFallbackChildren(
					current2,
					workInProgress2,
					primaryChildren,
					fallbackChildren,
					renderLanes2
				) {
					var mode = workInProgress2.mode
					var currentPrimaryChildFragment = current2.child
					var currentFallbackChildFragment = currentPrimaryChildFragment.sibling
					var primaryChildProps = {
						mode: 'hidden',
						children: primaryChildren,
					}
					var primaryChildFragment
					if (
						// In legacy mode, we commit the primary tree as if it successfully
						// completed, even though it's in an inconsistent state.
						(mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
						// already cloned. In legacy mode, the only case where this isn't true is
						// when DevTools forces us to display a fallback; we skip the first render
						// pass entirely and go straight to rendering the fallback. (In Concurrent
						// Mode, SuspenseList can also trigger this scenario, but this is a legacy-
						// only codepath.)
						workInProgress2.child !== currentPrimaryChildFragment
					) {
						var progressedPrimaryFragment = workInProgress2.child
						primaryChildFragment = progressedPrimaryFragment
						primaryChildFragment.childLanes = NoLanes
						primaryChildFragment.pendingProps = primaryChildProps
						if (workInProgress2.mode & ProfileMode) {
							primaryChildFragment.actualDuration = 0
							primaryChildFragment.actualStartTime = -1
							primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration
							primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration
						}
						workInProgress2.deletions = null
					} else {
						primaryChildFragment = updateWorkInProgressOffscreenFiber(
							currentPrimaryChildFragment,
							primaryChildProps
						)
						primaryChildFragment.subtreeFlags =
							currentPrimaryChildFragment.subtreeFlags & StaticMask
					}
					var fallbackChildFragment
					if (currentFallbackChildFragment !== null) {
						fallbackChildFragment = createWorkInProgress(
							currentFallbackChildFragment,
							fallbackChildren
						)
					} else {
						fallbackChildFragment = createFiberFromFragment(
							fallbackChildren,
							mode,
							renderLanes2,
							null
						)
						fallbackChildFragment.flags |= Placement
					}
					fallbackChildFragment.return = workInProgress2
					primaryChildFragment.return = workInProgress2
					primaryChildFragment.sibling = fallbackChildFragment
					workInProgress2.child = primaryChildFragment
					return fallbackChildFragment
				}
				function retrySuspenseComponentWithoutHydrating(
					current2,
					workInProgress2,
					renderLanes2,
					recoverableError
				) {
					if (recoverableError !== null) {
						queueHydrationError(recoverableError)
					}
					reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2)
					var nextProps = workInProgress2.pendingProps
					var primaryChildren = nextProps.children
					var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren)
					primaryChildFragment.flags |= Placement
					workInProgress2.memoizedState = null
					return primaryChildFragment
				}
				function mountSuspenseFallbackAfterRetryWithoutHydrating(
					current2,
					workInProgress2,
					primaryChildren,
					fallbackChildren,
					renderLanes2
				) {
					var fiberMode = workInProgress2.mode
					var primaryChildProps = {
						mode: 'visible',
						children: primaryChildren,
					}
					var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode)
					var fallbackChildFragment = createFiberFromFragment(
						fallbackChildren,
						fiberMode,
						renderLanes2,
						null
					)
					fallbackChildFragment.flags |= Placement
					primaryChildFragment.return = workInProgress2
					fallbackChildFragment.return = workInProgress2
					primaryChildFragment.sibling = fallbackChildFragment
					workInProgress2.child = primaryChildFragment
					if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
						reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2)
					}
					return fallbackChildFragment
				}
				function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
					if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
						{
							error(
								'Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.'
							)
						}
						workInProgress2.lanes = laneToLanes(SyncLane)
					} else if (isSuspenseInstanceFallback(suspenseInstance)) {
						workInProgress2.lanes = laneToLanes(DefaultHydrationLane)
					} else {
						workInProgress2.lanes = laneToLanes(OffscreenLane)
					}
					return null
				}
				function updateDehydratedSuspenseComponent(
					current2,
					workInProgress2,
					didSuspend,
					nextProps,
					suspenseInstance,
					suspenseState,
					renderLanes2
				) {
					if (!didSuspend) {
						warnIfHydrating()
						if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
							return retrySuspenseComponentWithoutHydrating(
								current2,
								workInProgress2,
								renderLanes2,
								// TODO: When we delete legacy mode, we should make this error argument
								// required — every concurrent mode path that causes hydration to
								// de-opt to client rendering should have an error message.
								null
							)
						}
						if (isSuspenseInstanceFallback(suspenseInstance)) {
							var digest, message, stack3
							{
								var _getSuspenseInstanceF =
									getSuspenseInstanceFallbackErrorDetails(suspenseInstance)
								digest = _getSuspenseInstanceF.digest
								message = _getSuspenseInstanceF.message
								stack3 = _getSuspenseInstanceF.stack
							}
							var error2
							if (message) {
								error2 = new Error(message)
							} else {
								error2 = new Error(
									'The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.'
								)
							}
							var capturedValue = createCapturedValue(error2, digest, stack3)
							return retrySuspenseComponentWithoutHydrating(
								current2,
								workInProgress2,
								renderLanes2,
								capturedValue
							)
						}
						var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes)
						if (didReceiveUpdate || hasContextChanged2) {
							var root3 = getWorkInProgressRoot()
							if (root3 !== null) {
								var attemptHydrationAtLane = getBumpedLaneForHydration(root3, renderLanes2)
								if (
									attemptHydrationAtLane !== NoLane &&
									attemptHydrationAtLane !== suspenseState.retryLane
								) {
									suspenseState.retryLane = attemptHydrationAtLane
									var eventTime = NoTimestamp
									enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane)
									scheduleUpdateOnFiber(root3, current2, attemptHydrationAtLane, eventTime)
								}
							}
							renderDidSuspendDelayIfPossible()
							var _capturedValue = createCapturedValue(
								new Error(
									'This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition.'
								)
							)
							return retrySuspenseComponentWithoutHydrating(
								current2,
								workInProgress2,
								renderLanes2,
								_capturedValue
							)
						} else if (isSuspenseInstancePending(suspenseInstance)) {
							workInProgress2.flags |= DidCapture
							workInProgress2.child = current2.child
							var retry = retryDehydratedSuspenseBoundary.bind(null, current2)
							registerSuspenseInstanceRetry(suspenseInstance, retry)
							return null
						} else {
							reenterHydrationStateFromDehydratedSuspenseInstance(
								workInProgress2,
								suspenseInstance,
								suspenseState.treeContext
							)
							var primaryChildren = nextProps.children
							var primaryChildFragment = mountSuspensePrimaryChildren(
								workInProgress2,
								primaryChildren
							)
							primaryChildFragment.flags |= Hydrating
							return primaryChildFragment
						}
					} else {
						if (workInProgress2.flags & ForceClientRender) {
							workInProgress2.flags &= ~ForceClientRender
							var _capturedValue2 = createCapturedValue(
								new Error(
									'There was an error while hydrating this Suspense boundary. Switched to client rendering.'
								)
							)
							return retrySuspenseComponentWithoutHydrating(
								current2,
								workInProgress2,
								renderLanes2,
								_capturedValue2
							)
						} else if (workInProgress2.memoizedState !== null) {
							workInProgress2.child = current2.child
							workInProgress2.flags |= DidCapture
							return null
						} else {
							var nextPrimaryChildren = nextProps.children
							var nextFallbackChildren = nextProps.fallback
							var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(
								current2,
								workInProgress2,
								nextPrimaryChildren,
								nextFallbackChildren,
								renderLanes2
							)
							var _primaryChildFragment4 = workInProgress2.child
							_primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2)
							workInProgress2.memoizedState = SUSPENDED_MARKER
							return fallbackChildFragment
						}
					}
				}
				function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
					fiber.lanes = mergeLanes(fiber.lanes, renderLanes2)
					var alternate = fiber.alternate
					if (alternate !== null) {
						alternate.lanes = mergeLanes(alternate.lanes, renderLanes2)
					}
					scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot)
				}
				function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
					var node = firstChild
					while (node !== null) {
						if (node.tag === SuspenseComponent) {
							var state = node.memoizedState
							if (state !== null) {
								scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2)
							}
						} else if (node.tag === SuspenseListComponent) {
							scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2)
						} else if (node.child !== null) {
							node.child.return = node
							node = node.child
							continue
						}
						if (node === workInProgress2) {
							return
						}
						while (node.sibling === null) {
							if (node.return === null || node.return === workInProgress2) {
								return
							}
							node = node.return
						}
						node.sibling.return = node.return
						node = node.sibling
					}
				}
				function findLastContentRow(firstChild) {
					var row = firstChild
					var lastContentRow = null
					while (row !== null) {
						var currentRow = row.alternate
						if (currentRow !== null && findFirstSuspended(currentRow) === null) {
							lastContentRow = row
						}
						row = row.sibling
					}
					return lastContentRow
				}
				function validateRevealOrder(revealOrder) {
					{
						if (
							revealOrder !== void 0 &&
							revealOrder !== 'forwards' &&
							revealOrder !== 'backwards' &&
							revealOrder !== 'together' &&
							!didWarnAboutRevealOrder[revealOrder]
						) {
							didWarnAboutRevealOrder[revealOrder] = true
							if (typeof revealOrder === 'string') {
								switch (revealOrder.toLowerCase()) {
									case 'together':
									case 'forwards':
									case 'backwards': {
										error(
											'"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
											revealOrder,
											revealOrder.toLowerCase()
										)
										break
									}
									case 'forward':
									case 'backward': {
										error(
											'"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
											revealOrder,
											revealOrder.toLowerCase()
										)
										break
									}
									default:
										error(
											'"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
											revealOrder
										)
										break
								}
							} else {
								error(
									'%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
									revealOrder
								)
							}
						}
					}
				}
				function validateTailOptions(tailMode, revealOrder) {
					{
						if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
							if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
								didWarnAboutTailOptions[tailMode] = true
								error(
									'"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
									tailMode
								)
							} else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
								didWarnAboutTailOptions[tailMode] = true
								error(
									'<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
									tailMode
								)
							}
						}
					}
				}
				function validateSuspenseListNestedChild(childSlot, index3) {
					{
						var isAnArray = isArray(childSlot)
						var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function'
						if (isAnArray || isIterable) {
							var type = isAnArray ? 'array' : 'iterable'
							error(
								'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>',
								type,
								index3,
								type
							)
							return false
						}
					}
					return true
				}
				function validateSuspenseListChildren(children, revealOrder) {
					{
						if (
							(revealOrder === 'forwards' || revealOrder === 'backwards') &&
							children !== void 0 &&
							children !== null &&
							children !== false
						) {
							if (isArray(children)) {
								for (var i3 = 0; i3 < children.length; i3++) {
									if (!validateSuspenseListNestedChild(children[i3], i3)) {
										return
									}
								}
							} else {
								var iteratorFn = getIteratorFn(children)
								if (typeof iteratorFn === 'function') {
									var childrenIterator = iteratorFn.call(children)
									if (childrenIterator) {
										var step = childrenIterator.next()
										var _i = 0
										for (; !step.done; step = childrenIterator.next()) {
											if (!validateSuspenseListNestedChild(step.value, _i)) {
												return
											}
											_i++
										}
									}
								} else {
									error(
										'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
										revealOrder
									)
								}
							}
						}
					}
				}
				function initSuspenseListRenderState(
					workInProgress2,
					isBackwards,
					tail,
					lastContentRow,
					tailMode
				) {
					var renderState = workInProgress2.memoizedState
					if (renderState === null) {
						workInProgress2.memoizedState = {
							isBackwards,
							rendering: null,
							renderingStartTime: 0,
							last: lastContentRow,
							tail,
							tailMode,
						}
					} else {
						renderState.isBackwards = isBackwards
						renderState.rendering = null
						renderState.renderingStartTime = 0
						renderState.last = lastContentRow
						renderState.tail = tail
						renderState.tailMode = tailMode
					}
				}
				function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
					var nextProps = workInProgress2.pendingProps
					var revealOrder = nextProps.revealOrder
					var tailMode = nextProps.tail
					var newChildren = nextProps.children
					validateRevealOrder(revealOrder)
					validateTailOptions(tailMode, revealOrder)
					validateSuspenseListChildren(newChildren, revealOrder)
					reconcileChildren(current2, workInProgress2, newChildren, renderLanes2)
					var suspenseContext = suspenseStackCursor.current
					var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback)
					if (shouldForceFallback) {
						suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback)
						workInProgress2.flags |= DidCapture
					} else {
						var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags
						if (didSuspendBefore) {
							propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2)
						}
						suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)
					}
					pushSuspenseContext(workInProgress2, suspenseContext)
					if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
						workInProgress2.memoizedState = null
					} else {
						switch (revealOrder) {
							case 'forwards': {
								var lastContentRow = findLastContentRow(workInProgress2.child)
								var tail
								if (lastContentRow === null) {
									tail = workInProgress2.child
									workInProgress2.child = null
								} else {
									tail = lastContentRow.sibling
									lastContentRow.sibling = null
								}
								initSuspenseListRenderState(
									workInProgress2,
									false,
									// isBackwards
									tail,
									lastContentRow,
									tailMode
								)
								break
							}
							case 'backwards': {
								var _tail = null
								var row = workInProgress2.child
								workInProgress2.child = null
								while (row !== null) {
									var currentRow = row.alternate
									if (currentRow !== null && findFirstSuspended(currentRow) === null) {
										workInProgress2.child = row
										break
									}
									var nextRow = row.sibling
									row.sibling = _tail
									_tail = row
									row = nextRow
								}
								initSuspenseListRenderState(
									workInProgress2,
									true,
									// isBackwards
									_tail,
									null,
									// last
									tailMode
								)
								break
							}
							case 'together': {
								initSuspenseListRenderState(
									workInProgress2,
									false,
									// isBackwards
									null,
									// tail
									null,
									// last
									void 0
								)
								break
							}
							default: {
								workInProgress2.memoizedState = null
							}
						}
					}
					return workInProgress2.child
				}
				function updatePortalComponent(current2, workInProgress2, renderLanes2) {
					pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo)
					var nextChildren = workInProgress2.pendingProps
					if (current2 === null) {
						workInProgress2.child = reconcileChildFibers(
							workInProgress2,
							null,
							nextChildren,
							renderLanes2
						)
					} else {
						reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2)
					}
					return workInProgress2.child
				}
				var hasWarnedAboutUsingNoValuePropOnContextProvider = false
				function updateContextProvider(current2, workInProgress2, renderLanes2) {
					var providerType = workInProgress2.type
					var context = providerType._context
					var newProps = workInProgress2.pendingProps
					var oldProps = workInProgress2.memoizedProps
					var newValue = newProps.value
					{
						if (!('value' in newProps)) {
							if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
								hasWarnedAboutUsingNoValuePropOnContextProvider = true
								error(
									'The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?'
								)
							}
						}
						var providerPropTypes = workInProgress2.type.propTypes
						if (providerPropTypes) {
							checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider')
						}
					}
					pushProvider(workInProgress2, context, newValue)
					{
						if (oldProps !== null) {
							var oldValue = oldProps.value
							if (objectIs(oldValue, newValue)) {
								if (oldProps.children === newProps.children && !hasContextChanged()) {
									return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
								}
							} else {
								propagateContextChange(workInProgress2, context, renderLanes2)
							}
						}
					}
					var newChildren = newProps.children
					reconcileChildren(current2, workInProgress2, newChildren, renderLanes2)
					return workInProgress2.child
				}
				var hasWarnedAboutUsingContextAsConsumer = false
				function updateContextConsumer(current2, workInProgress2, renderLanes2) {
					var context = workInProgress2.type
					{
						if (context._context === void 0) {
							if (context !== context.Consumer) {
								if (!hasWarnedAboutUsingContextAsConsumer) {
									hasWarnedAboutUsingContextAsConsumer = true
									error(
										'Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?'
									)
								}
							}
						} else {
							context = context._context
						}
					}
					var newProps = workInProgress2.pendingProps
					var render2 = newProps.children
					{
						if (typeof render2 !== 'function') {
							error(
								"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
							)
						}
					}
					prepareToReadContext(workInProgress2, renderLanes2)
					var newValue = readContext(context)
					{
						markComponentRenderStarted(workInProgress2)
					}
					var newChildren
					{
						ReactCurrentOwner$1.current = workInProgress2
						setIsRendering(true)
						newChildren = render2(newValue)
						setIsRendering(false)
					}
					{
						markComponentRenderStopped()
					}
					workInProgress2.flags |= PerformedWork
					reconcileChildren(current2, workInProgress2, newChildren, renderLanes2)
					return workInProgress2.child
				}
				function markWorkInProgressReceivedUpdate() {
					didReceiveUpdate = true
				}
				function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
					if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
						if (current2 !== null) {
							current2.alternate = null
							workInProgress2.alternate = null
							workInProgress2.flags |= Placement
						}
					}
				}
				function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
					if (current2 !== null) {
						workInProgress2.dependencies = current2.dependencies
					}
					{
						stopProfilerTimerIfRunning()
					}
					markSkippedUpdateLanes(workInProgress2.lanes)
					if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
						{
							return null
						}
					}
					cloneChildFibers(current2, workInProgress2)
					return workInProgress2.child
				}
				function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
					{
						var returnFiber = oldWorkInProgress.return
						if (returnFiber === null) {
							throw new Error('Cannot swap the root fiber.')
						}
						current2.alternate = null
						oldWorkInProgress.alternate = null
						newWorkInProgress.index = oldWorkInProgress.index
						newWorkInProgress.sibling = oldWorkInProgress.sibling
						newWorkInProgress.return = oldWorkInProgress.return
						newWorkInProgress.ref = oldWorkInProgress.ref
						if (oldWorkInProgress === returnFiber.child) {
							returnFiber.child = newWorkInProgress
						} else {
							var prevSibling = returnFiber.child
							if (prevSibling === null) {
								throw new Error('Expected parent to have a child.')
							}
							while (prevSibling.sibling !== oldWorkInProgress) {
								prevSibling = prevSibling.sibling
								if (prevSibling === null) {
									throw new Error('Expected to find the previous sibling.')
								}
							}
							prevSibling.sibling = newWorkInProgress
						}
						var deletions = returnFiber.deletions
						if (deletions === null) {
							returnFiber.deletions = [current2]
							returnFiber.flags |= ChildDeletion
						} else {
							deletions.push(current2)
						}
						newWorkInProgress.flags |= Placement
						return newWorkInProgress
					}
				}
				function checkScheduledUpdateOrContext(current2, renderLanes2) {
					var updateLanes = current2.lanes
					if (includesSomeLane(updateLanes, renderLanes2)) {
						return true
					}
					return false
				}
				function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
					switch (workInProgress2.tag) {
						case HostRoot:
							pushHostRootContext(workInProgress2)
							var root3 = workInProgress2.stateNode
							resetHydrationState()
							break
						case HostComponent:
							pushHostContext(workInProgress2)
							break
						case ClassComponent: {
							var Component3 = workInProgress2.type
							if (isContextProvider(Component3)) {
								pushContextProvider(workInProgress2)
							}
							break
						}
						case HostPortal:
							pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo)
							break
						case ContextProvider: {
							var newValue = workInProgress2.memoizedProps.value
							var context = workInProgress2.type._context
							pushProvider(workInProgress2, context, newValue)
							break
						}
						case Profiler:
							{
								var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes)
								if (hasChildWork) {
									workInProgress2.flags |= Update
								}
								{
									var stateNode = workInProgress2.stateNode
									stateNode.effectDuration = 0
									stateNode.passiveEffectDuration = 0
								}
							}
							break
						case SuspenseComponent: {
							var state = workInProgress2.memoizedState
							if (state !== null) {
								if (state.dehydrated !== null) {
									pushSuspenseContext(
										workInProgress2,
										setDefaultShallowSuspenseContext(suspenseStackCursor.current)
									)
									workInProgress2.flags |= DidCapture
									return null
								}
								var primaryChildFragment = workInProgress2.child
								var primaryChildLanes = primaryChildFragment.childLanes
								if (includesSomeLane(renderLanes2, primaryChildLanes)) {
									return updateSuspenseComponent(current2, workInProgress2, renderLanes2)
								} else {
									pushSuspenseContext(
										workInProgress2,
										setDefaultShallowSuspenseContext(suspenseStackCursor.current)
									)
									var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
									if (child !== null) {
										return child.sibling
									} else {
										return null
									}
								}
							} else {
								pushSuspenseContext(
									workInProgress2,
									setDefaultShallowSuspenseContext(suspenseStackCursor.current)
								)
							}
							break
						}
						case SuspenseListComponent: {
							var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags
							var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes)
							if (didSuspendBefore) {
								if (_hasChildWork) {
									return updateSuspenseListComponent(current2, workInProgress2, renderLanes2)
								}
								workInProgress2.flags |= DidCapture
							}
							var renderState = workInProgress2.memoizedState
							if (renderState !== null) {
								renderState.rendering = null
								renderState.tail = null
								renderState.lastEffect = null
							}
							pushSuspenseContext(workInProgress2, suspenseStackCursor.current)
							if (_hasChildWork) {
								break
							} else {
								return null
							}
						}
						case OffscreenComponent:
						case LegacyHiddenComponent: {
							workInProgress2.lanes = NoLanes
							return updateOffscreenComponent(current2, workInProgress2, renderLanes2)
						}
					}
					return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)
				}
				function beginWork(current2, workInProgress2, renderLanes2) {
					{
						if (workInProgress2._debugNeedsRemount && current2 !== null) {
							return remountFiber(
								current2,
								workInProgress2,
								createFiberFromTypeAndProps(
									workInProgress2.type,
									workInProgress2.key,
									workInProgress2.pendingProps,
									workInProgress2._debugOwner || null,
									workInProgress2.mode,
									workInProgress2.lanes
								)
							)
						}
					}
					if (current2 !== null) {
						var oldProps = current2.memoizedProps
						var newProps = workInProgress2.pendingProps
						if (
							oldProps !== newProps ||
							hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
							workInProgress2.type !== current2.type
						) {
							didReceiveUpdate = true
						} else {
							var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
								current2,
								renderLanes2
							)
							if (
								!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
								// may not be work scheduled on `current`, so we check for this flag.
								(workInProgress2.flags & DidCapture) === NoFlags
							) {
								didReceiveUpdate = false
								return attemptEarlyBailoutIfNoScheduledUpdate(
									current2,
									workInProgress2,
									renderLanes2
								)
							}
							if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
								didReceiveUpdate = true
							} else {
								didReceiveUpdate = false
							}
						}
					} else {
						didReceiveUpdate = false
						if (getIsHydrating() && isForkedChild(workInProgress2)) {
							var slotIndex = workInProgress2.index
							var numberOfForks = getForksAtLevel()
							pushTreeId(workInProgress2, numberOfForks, slotIndex)
						}
					}
					workInProgress2.lanes = NoLanes
					switch (workInProgress2.tag) {
						case IndeterminateComponent: {
							return mountIndeterminateComponent(
								current2,
								workInProgress2,
								workInProgress2.type,
								renderLanes2
							)
						}
						case LazyComponent: {
							var elementType = workInProgress2.elementType
							return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2)
						}
						case FunctionComponent: {
							var Component3 = workInProgress2.type
							var unresolvedProps = workInProgress2.pendingProps
							var resolvedProps =
								workInProgress2.elementType === Component3
									? unresolvedProps
									: resolveDefaultProps(Component3, unresolvedProps)
							return updateFunctionComponent(
								current2,
								workInProgress2,
								Component3,
								resolvedProps,
								renderLanes2
							)
						}
						case ClassComponent: {
							var _Component = workInProgress2.type
							var _unresolvedProps = workInProgress2.pendingProps
							var _resolvedProps =
								workInProgress2.elementType === _Component
									? _unresolvedProps
									: resolveDefaultProps(_Component, _unresolvedProps)
							return updateClassComponent(
								current2,
								workInProgress2,
								_Component,
								_resolvedProps,
								renderLanes2
							)
						}
						case HostRoot:
							return updateHostRoot(current2, workInProgress2, renderLanes2)
						case HostComponent:
							return updateHostComponent(current2, workInProgress2, renderLanes2)
						case HostText:
							return updateHostText(current2, workInProgress2)
						case SuspenseComponent:
							return updateSuspenseComponent(current2, workInProgress2, renderLanes2)
						case HostPortal:
							return updatePortalComponent(current2, workInProgress2, renderLanes2)
						case ForwardRef: {
							var type = workInProgress2.type
							var _unresolvedProps2 = workInProgress2.pendingProps
							var _resolvedProps2 =
								workInProgress2.elementType === type
									? _unresolvedProps2
									: resolveDefaultProps(type, _unresolvedProps2)
							return updateForwardRef(
								current2,
								workInProgress2,
								type,
								_resolvedProps2,
								renderLanes2
							)
						}
						case Fragment41:
							return updateFragment(current2, workInProgress2, renderLanes2)
						case Mode:
							return updateMode(current2, workInProgress2, renderLanes2)
						case Profiler:
							return updateProfiler(current2, workInProgress2, renderLanes2)
						case ContextProvider:
							return updateContextProvider(current2, workInProgress2, renderLanes2)
						case ContextConsumer:
							return updateContextConsumer(current2, workInProgress2, renderLanes2)
						case MemoComponent: {
							var _type2 = workInProgress2.type
							var _unresolvedProps3 = workInProgress2.pendingProps
							var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3)
							{
								if (workInProgress2.type !== workInProgress2.elementType) {
									var outerPropTypes = _type2.propTypes
									if (outerPropTypes) {
										checkPropTypes(
											outerPropTypes,
											_resolvedProps3,
											// Resolved for outer only
											'prop',
											getComponentNameFromType(_type2)
										)
									}
								}
							}
							_resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3)
							return updateMemoComponent(
								current2,
								workInProgress2,
								_type2,
								_resolvedProps3,
								renderLanes2
							)
						}
						case SimpleMemoComponent: {
							return updateSimpleMemoComponent(
								current2,
								workInProgress2,
								workInProgress2.type,
								workInProgress2.pendingProps,
								renderLanes2
							)
						}
						case IncompleteClassComponent: {
							var _Component2 = workInProgress2.type
							var _unresolvedProps4 = workInProgress2.pendingProps
							var _resolvedProps4 =
								workInProgress2.elementType === _Component2
									? _unresolvedProps4
									: resolveDefaultProps(_Component2, _unresolvedProps4)
							return mountIncompleteClassComponent(
								current2,
								workInProgress2,
								_Component2,
								_resolvedProps4,
								renderLanes2
							)
						}
						case SuspenseListComponent: {
							return updateSuspenseListComponent(current2, workInProgress2, renderLanes2)
						}
						case ScopeComponent: {
							break
						}
						case OffscreenComponent: {
							return updateOffscreenComponent(current2, workInProgress2, renderLanes2)
						}
					}
					throw new Error(
						'Unknown unit of work tag (' +
							workInProgress2.tag +
							'). This error is likely caused by a bug in React. Please file an issue.'
					)
				}
				function markUpdate(workInProgress2) {
					workInProgress2.flags |= Update
				}
				function markRef$1(workInProgress2) {
					workInProgress2.flags |= Ref
					{
						workInProgress2.flags |= RefStatic
					}
				}
				var appendAllChildren
				var updateHostContainer
				var updateHostComponent$1
				var updateHostText$1
				{
					appendAllChildren = function (parent, workInProgress2, needsVisibilityToggle, isHidden) {
						var node = workInProgress2.child
						while (node !== null) {
							if (node.tag === HostComponent || node.tag === HostText) {
								appendInitialChild(parent, node.stateNode)
							} else if (node.tag === HostPortal);
							else if (node.child !== null) {
								node.child.return = node
								node = node.child
								continue
							}
							if (node === workInProgress2) {
								return
							}
							while (node.sibling === null) {
								if (node.return === null || node.return === workInProgress2) {
									return
								}
								node = node.return
							}
							node.sibling.return = node.return
							node = node.sibling
						}
					}
					updateHostContainer = function (current2, workInProgress2) {}
					updateHostComponent$1 = function (
						current2,
						workInProgress2,
						type,
						newProps,
						rootContainerInstance
					) {
						var oldProps = current2.memoizedProps
						if (oldProps === newProps) {
							return
						}
						var instance = workInProgress2.stateNode
						var currentHostContext = getHostContext()
						var updatePayload = prepareUpdate(
							instance,
							type,
							oldProps,
							newProps,
							rootContainerInstance,
							currentHostContext
						)
						workInProgress2.updateQueue = updatePayload
						if (updatePayload) {
							markUpdate(workInProgress2)
						}
					}
					updateHostText$1 = function (current2, workInProgress2, oldText, newText) {
						if (oldText !== newText) {
							markUpdate(workInProgress2)
						}
					}
				}
				function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
					if (getIsHydrating()) {
						return
					}
					switch (renderState.tailMode) {
						case 'hidden': {
							var tailNode = renderState.tail
							var lastTailNode = null
							while (tailNode !== null) {
								if (tailNode.alternate !== null) {
									lastTailNode = tailNode
								}
								tailNode = tailNode.sibling
							}
							if (lastTailNode === null) {
								renderState.tail = null
							} else {
								lastTailNode.sibling = null
							}
							break
						}
						case 'collapsed': {
							var _tailNode = renderState.tail
							var _lastTailNode = null
							while (_tailNode !== null) {
								if (_tailNode.alternate !== null) {
									_lastTailNode = _tailNode
								}
								_tailNode = _tailNode.sibling
							}
							if (_lastTailNode === null) {
								if (!hasRenderedATailFallback && renderState.tail !== null) {
									renderState.tail.sibling = null
								} else {
									renderState.tail = null
								}
							} else {
								_lastTailNode.sibling = null
							}
							break
						}
					}
				}
				function bubbleProperties(completedWork) {
					var didBailout =
						completedWork.alternate !== null &&
						completedWork.alternate.child === completedWork.child
					var newChildLanes = NoLanes
					var subtreeFlags = NoFlags
					if (!didBailout) {
						if ((completedWork.mode & ProfileMode) !== NoMode) {
							var actualDuration = completedWork.actualDuration
							var treeBaseDuration = completedWork.selfBaseDuration
							var child = completedWork.child
							while (child !== null) {
								newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes))
								subtreeFlags |= child.subtreeFlags
								subtreeFlags |= child.flags
								actualDuration += child.actualDuration
								treeBaseDuration += child.treeBaseDuration
								child = child.sibling
							}
							completedWork.actualDuration = actualDuration
							completedWork.treeBaseDuration = treeBaseDuration
						} else {
							var _child = completedWork.child
							while (_child !== null) {
								newChildLanes = mergeLanes(
									newChildLanes,
									mergeLanes(_child.lanes, _child.childLanes)
								)
								subtreeFlags |= _child.subtreeFlags
								subtreeFlags |= _child.flags
								_child.return = completedWork
								_child = _child.sibling
							}
						}
						completedWork.subtreeFlags |= subtreeFlags
					} else {
						if ((completedWork.mode & ProfileMode) !== NoMode) {
							var _treeBaseDuration = completedWork.selfBaseDuration
							var _child2 = completedWork.child
							while (_child2 !== null) {
								newChildLanes = mergeLanes(
									newChildLanes,
									mergeLanes(_child2.lanes, _child2.childLanes)
								)
								subtreeFlags |= _child2.subtreeFlags & StaticMask
								subtreeFlags |= _child2.flags & StaticMask
								_treeBaseDuration += _child2.treeBaseDuration
								_child2 = _child2.sibling
							}
							completedWork.treeBaseDuration = _treeBaseDuration
						} else {
							var _child3 = completedWork.child
							while (_child3 !== null) {
								newChildLanes = mergeLanes(
									newChildLanes,
									mergeLanes(_child3.lanes, _child3.childLanes)
								)
								subtreeFlags |= _child3.subtreeFlags & StaticMask
								subtreeFlags |= _child3.flags & StaticMask
								_child3.return = completedWork
								_child3 = _child3.sibling
							}
						}
						completedWork.subtreeFlags |= subtreeFlags
					}
					completedWork.childLanes = newChildLanes
					return didBailout
				}
				function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
					if (
						hasUnhydratedTailNodes() &&
						(workInProgress2.mode & ConcurrentMode) !== NoMode &&
						(workInProgress2.flags & DidCapture) === NoFlags
					) {
						warnIfUnhydratedTailNodes(workInProgress2)
						resetHydrationState()
						workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture
						return false
					}
					var wasHydrated = popHydrationState(workInProgress2)
					if (nextState !== null && nextState.dehydrated !== null) {
						if (current2 === null) {
							if (!wasHydrated) {
								throw new Error(
									'A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.'
								)
							}
							prepareToHydrateHostSuspenseInstance(workInProgress2)
							bubbleProperties(workInProgress2)
							{
								if ((workInProgress2.mode & ProfileMode) !== NoMode) {
									var isTimedOutSuspense = nextState !== null
									if (isTimedOutSuspense) {
										var primaryChildFragment = workInProgress2.child
										if (primaryChildFragment !== null) {
											workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration
										}
									}
								}
							}
							return false
						} else {
							resetHydrationState()
							if ((workInProgress2.flags & DidCapture) === NoFlags) {
								workInProgress2.memoizedState = null
							}
							workInProgress2.flags |= Update
							bubbleProperties(workInProgress2)
							{
								if ((workInProgress2.mode & ProfileMode) !== NoMode) {
									var _isTimedOutSuspense = nextState !== null
									if (_isTimedOutSuspense) {
										var _primaryChildFragment = workInProgress2.child
										if (_primaryChildFragment !== null) {
											workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration
										}
									}
								}
							}
							return false
						}
					} else {
						upgradeHydrationErrorsToRecoverable()
						return true
					}
				}
				function completeWork(current2, workInProgress2, renderLanes2) {
					var newProps = workInProgress2.pendingProps
					popTreeContext(workInProgress2)
					switch (workInProgress2.tag) {
						case IndeterminateComponent:
						case LazyComponent:
						case SimpleMemoComponent:
						case FunctionComponent:
						case ForwardRef:
						case Fragment41:
						case Mode:
						case Profiler:
						case ContextConsumer:
						case MemoComponent:
							bubbleProperties(workInProgress2)
							return null
						case ClassComponent: {
							var Component3 = workInProgress2.type
							if (isContextProvider(Component3)) {
								popContext(workInProgress2)
							}
							bubbleProperties(workInProgress2)
							return null
						}
						case HostRoot: {
							var fiberRoot = workInProgress2.stateNode
							popHostContainer(workInProgress2)
							popTopLevelContextObject(workInProgress2)
							resetWorkInProgressVersions()
							if (fiberRoot.pendingContext) {
								fiberRoot.context = fiberRoot.pendingContext
								fiberRoot.pendingContext = null
							}
							if (current2 === null || current2.child === null) {
								var wasHydrated = popHydrationState(workInProgress2)
								if (wasHydrated) {
									markUpdate(workInProgress2)
								} else {
									if (current2 !== null) {
										var prevState = current2.memoizedState
										if (
											// Check if this is a client root
											!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
											(workInProgress2.flags & ForceClientRender) !== NoFlags
										) {
											workInProgress2.flags |= Snapshot
											upgradeHydrationErrorsToRecoverable()
										}
									}
								}
							}
							updateHostContainer(current2, workInProgress2)
							bubbleProperties(workInProgress2)
							return null
						}
						case HostComponent: {
							popHostContext(workInProgress2)
							var rootContainerInstance = getRootHostContainer()
							var type = workInProgress2.type
							if (current2 !== null && workInProgress2.stateNode != null) {
								updateHostComponent$1(
									current2,
									workInProgress2,
									type,
									newProps,
									rootContainerInstance
								)
								if (current2.ref !== workInProgress2.ref) {
									markRef$1(workInProgress2)
								}
							} else {
								if (!newProps) {
									if (workInProgress2.stateNode === null) {
										throw new Error(
											'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
										)
									}
									bubbleProperties(workInProgress2)
									return null
								}
								var currentHostContext = getHostContext()
								var _wasHydrated = popHydrationState(workInProgress2)
								if (_wasHydrated) {
									if (
										prepareToHydrateHostInstance(
											workInProgress2,
											rootContainerInstance,
											currentHostContext
										)
									) {
										markUpdate(workInProgress2)
									}
								} else {
									var instance = createInstance(
										type,
										newProps,
										rootContainerInstance,
										currentHostContext,
										workInProgress2
									)
									appendAllChildren(instance, workInProgress2, false, false)
									workInProgress2.stateNode = instance
									if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
										markUpdate(workInProgress2)
									}
								}
								if (workInProgress2.ref !== null) {
									markRef$1(workInProgress2)
								}
							}
							bubbleProperties(workInProgress2)
							return null
						}
						case HostText: {
							var newText = newProps
							if (current2 && workInProgress2.stateNode != null) {
								var oldText = current2.memoizedProps
								updateHostText$1(current2, workInProgress2, oldText, newText)
							} else {
								if (typeof newText !== 'string') {
									if (workInProgress2.stateNode === null) {
										throw new Error(
											'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
										)
									}
								}
								var _rootContainerInstance = getRootHostContainer()
								var _currentHostContext = getHostContext()
								var _wasHydrated2 = popHydrationState(workInProgress2)
								if (_wasHydrated2) {
									if (prepareToHydrateHostTextInstance(workInProgress2)) {
										markUpdate(workInProgress2)
									}
								} else {
									workInProgress2.stateNode = createTextInstance(
										newText,
										_rootContainerInstance,
										_currentHostContext,
										workInProgress2
									)
								}
							}
							bubbleProperties(workInProgress2)
							return null
						}
						case SuspenseComponent: {
							popSuspenseContext(workInProgress2)
							var nextState = workInProgress2.memoizedState
							if (
								current2 === null ||
								(current2.memoizedState !== null && current2.memoizedState.dehydrated !== null)
							) {
								var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(
									current2,
									workInProgress2,
									nextState
								)
								if (!fallthroughToNormalSuspensePath) {
									if (workInProgress2.flags & ShouldCapture) {
										return workInProgress2
									} else {
										return null
									}
								}
							}
							if ((workInProgress2.flags & DidCapture) !== NoFlags) {
								workInProgress2.lanes = renderLanes2
								if ((workInProgress2.mode & ProfileMode) !== NoMode) {
									transferActualDuration(workInProgress2)
								}
								return workInProgress2
							}
							var nextDidTimeout = nextState !== null
							var prevDidTimeout = current2 !== null && current2.memoizedState !== null
							if (nextDidTimeout !== prevDidTimeout) {
								if (nextDidTimeout) {
									var _offscreenFiber2 = workInProgress2.child
									_offscreenFiber2.flags |= Visibility
									if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
										var hasInvisibleChildContext =
											current2 === null &&
											(workInProgress2.memoizedProps.unstable_avoidThisFallback !== true ||
												!enableSuspenseAvoidThisFallback)
										if (
											hasInvisibleChildContext ||
											hasSuspenseContext(
												suspenseStackCursor.current,
												InvisibleParentSuspenseContext
											)
										) {
											renderDidSuspend()
										} else {
											renderDidSuspendDelayIfPossible()
										}
									}
								}
							}
							var wakeables = workInProgress2.updateQueue
							if (wakeables !== null) {
								workInProgress2.flags |= Update
							}
							bubbleProperties(workInProgress2)
							{
								if ((workInProgress2.mode & ProfileMode) !== NoMode) {
									if (nextDidTimeout) {
										var primaryChildFragment = workInProgress2.child
										if (primaryChildFragment !== null) {
											workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration
										}
									}
								}
							}
							return null
						}
						case HostPortal:
							popHostContainer(workInProgress2)
							updateHostContainer(current2, workInProgress2)
							if (current2 === null) {
								preparePortalMount(workInProgress2.stateNode.containerInfo)
							}
							bubbleProperties(workInProgress2)
							return null
						case ContextProvider:
							var context = workInProgress2.type._context
							popProvider(context, workInProgress2)
							bubbleProperties(workInProgress2)
							return null
						case IncompleteClassComponent: {
							var _Component = workInProgress2.type
							if (isContextProvider(_Component)) {
								popContext(workInProgress2)
							}
							bubbleProperties(workInProgress2)
							return null
						}
						case SuspenseListComponent: {
							popSuspenseContext(workInProgress2)
							var renderState = workInProgress2.memoizedState
							if (renderState === null) {
								bubbleProperties(workInProgress2)
								return null
							}
							var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags
							var renderedTail = renderState.rendering
							if (renderedTail === null) {
								if (!didSuspendAlready) {
									var cannotBeSuspended =
										renderHasNotSuspendedYet() &&
										(current2 === null || (current2.flags & DidCapture) === NoFlags)
									if (!cannotBeSuspended) {
										var row = workInProgress2.child
										while (row !== null) {
											var suspended = findFirstSuspended(row)
											if (suspended !== null) {
												didSuspendAlready = true
												workInProgress2.flags |= DidCapture
												cutOffTailIfNeeded(renderState, false)
												var newThenables = suspended.updateQueue
												if (newThenables !== null) {
													workInProgress2.updateQueue = newThenables
													workInProgress2.flags |= Update
												}
												workInProgress2.subtreeFlags = NoFlags
												resetChildFibers(workInProgress2, renderLanes2)
												pushSuspenseContext(
													workInProgress2,
													setShallowSuspenseContext(
														suspenseStackCursor.current,
														ForceSuspenseFallback
													)
												)
												return workInProgress2.child
											}
											row = row.sibling
										}
									}
									if (renderState.tail !== null && now() > getRenderTargetTime()) {
										workInProgress2.flags |= DidCapture
										didSuspendAlready = true
										cutOffTailIfNeeded(renderState, false)
										workInProgress2.lanes = SomeRetryLane
									}
								} else {
									cutOffTailIfNeeded(renderState, false)
								}
							} else {
								if (!didSuspendAlready) {
									var _suspended = findFirstSuspended(renderedTail)
									if (_suspended !== null) {
										workInProgress2.flags |= DidCapture
										didSuspendAlready = true
										var _newThenables = _suspended.updateQueue
										if (_newThenables !== null) {
											workInProgress2.updateQueue = _newThenables
											workInProgress2.flags |= Update
										}
										cutOffTailIfNeeded(renderState, true)
										if (
											renderState.tail === null &&
											renderState.tailMode === 'hidden' &&
											!renderedTail.alternate &&
											!getIsHydrating()
										) {
											bubbleProperties(workInProgress2)
											return null
										}
									} else if (
										// The time it took to render last row is greater than the remaining
										// time we have to render. So rendering one more row would likely
										// exceed it.
										now() * 2 - renderState.renderingStartTime > getRenderTargetTime() &&
										renderLanes2 !== OffscreenLane
									) {
										workInProgress2.flags |= DidCapture
										didSuspendAlready = true
										cutOffTailIfNeeded(renderState, false)
										workInProgress2.lanes = SomeRetryLane
									}
								}
								if (renderState.isBackwards) {
									renderedTail.sibling = workInProgress2.child
									workInProgress2.child = renderedTail
								} else {
									var previousSibling = renderState.last
									if (previousSibling !== null) {
										previousSibling.sibling = renderedTail
									} else {
										workInProgress2.child = renderedTail
									}
									renderState.last = renderedTail
								}
							}
							if (renderState.tail !== null) {
								var next = renderState.tail
								renderState.rendering = next
								renderState.tail = next.sibling
								renderState.renderingStartTime = now()
								next.sibling = null
								var suspenseContext = suspenseStackCursor.current
								if (didSuspendAlready) {
									suspenseContext = setShallowSuspenseContext(
										suspenseContext,
										ForceSuspenseFallback
									)
								} else {
									suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)
								}
								pushSuspenseContext(workInProgress2, suspenseContext)
								return next
							}
							bubbleProperties(workInProgress2)
							return null
						}
						case ScopeComponent: {
							break
						}
						case OffscreenComponent:
						case LegacyHiddenComponent: {
							popRenderLanes(workInProgress2)
							var _nextState = workInProgress2.memoizedState
							var nextIsHidden = _nextState !== null
							if (current2 !== null) {
								var _prevState = current2.memoizedState
								var prevIsHidden = _prevState !== null
								if (
									prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding — it only pre-renders.
									!enableLegacyHidden
								) {
									workInProgress2.flags |= Visibility
								}
							}
							if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
								bubbleProperties(workInProgress2)
							} else {
								if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
									bubbleProperties(workInProgress2)
									{
										if (workInProgress2.subtreeFlags & (Placement | Update)) {
											workInProgress2.flags |= Visibility
										}
									}
								}
							}
							return null
						}
						case CacheComponent: {
							return null
						}
						case TracingMarkerComponent: {
							return null
						}
					}
					throw new Error(
						'Unknown unit of work tag (' +
							workInProgress2.tag +
							'). This error is likely caused by a bug in React. Please file an issue.'
					)
				}
				function unwindWork(current2, workInProgress2, renderLanes2) {
					popTreeContext(workInProgress2)
					switch (workInProgress2.tag) {
						case ClassComponent: {
							var Component3 = workInProgress2.type
							if (isContextProvider(Component3)) {
								popContext(workInProgress2)
							}
							var flags = workInProgress2.flags
							if (flags & ShouldCapture) {
								workInProgress2.flags = (flags & ~ShouldCapture) | DidCapture
								if ((workInProgress2.mode & ProfileMode) !== NoMode) {
									transferActualDuration(workInProgress2)
								}
								return workInProgress2
							}
							return null
						}
						case HostRoot: {
							var root3 = workInProgress2.stateNode
							popHostContainer(workInProgress2)
							popTopLevelContextObject(workInProgress2)
							resetWorkInProgressVersions()
							var _flags = workInProgress2.flags
							if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
								workInProgress2.flags = (_flags & ~ShouldCapture) | DidCapture
								return workInProgress2
							}
							return null
						}
						case HostComponent: {
							popHostContext(workInProgress2)
							return null
						}
						case SuspenseComponent: {
							popSuspenseContext(workInProgress2)
							var suspenseState = workInProgress2.memoizedState
							if (suspenseState !== null && suspenseState.dehydrated !== null) {
								if (workInProgress2.alternate === null) {
									throw new Error(
										'Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.'
									)
								}
								resetHydrationState()
							}
							var _flags2 = workInProgress2.flags
							if (_flags2 & ShouldCapture) {
								workInProgress2.flags = (_flags2 & ~ShouldCapture) | DidCapture
								if ((workInProgress2.mode & ProfileMode) !== NoMode) {
									transferActualDuration(workInProgress2)
								}
								return workInProgress2
							}
							return null
						}
						case SuspenseListComponent: {
							popSuspenseContext(workInProgress2)
							return null
						}
						case HostPortal:
							popHostContainer(workInProgress2)
							return null
						case ContextProvider:
							var context = workInProgress2.type._context
							popProvider(context, workInProgress2)
							return null
						case OffscreenComponent:
						case LegacyHiddenComponent:
							popRenderLanes(workInProgress2)
							return null
						case CacheComponent:
							return null
						default:
							return null
					}
				}
				function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
					popTreeContext(interruptedWork)
					switch (interruptedWork.tag) {
						case ClassComponent: {
							var childContextTypes = interruptedWork.type.childContextTypes
							if (childContextTypes !== null && childContextTypes !== void 0) {
								popContext(interruptedWork)
							}
							break
						}
						case HostRoot: {
							var root3 = interruptedWork.stateNode
							popHostContainer(interruptedWork)
							popTopLevelContextObject(interruptedWork)
							resetWorkInProgressVersions()
							break
						}
						case HostComponent: {
							popHostContext(interruptedWork)
							break
						}
						case HostPortal:
							popHostContainer(interruptedWork)
							break
						case SuspenseComponent:
							popSuspenseContext(interruptedWork)
							break
						case SuspenseListComponent:
							popSuspenseContext(interruptedWork)
							break
						case ContextProvider:
							var context = interruptedWork.type._context
							popProvider(context, interruptedWork)
							break
						case OffscreenComponent:
						case LegacyHiddenComponent:
							popRenderLanes(interruptedWork)
							break
					}
				}
				var didWarnAboutUndefinedSnapshotBeforeUpdate = null
				{
					didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set()
				}
				var offscreenSubtreeIsHidden = false
				var offscreenSubtreeWasHidden = false
				var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set
				var nextEffect = null
				var inProgressLanes = null
				var inProgressRoot = null
				function reportUncaughtErrorInDEV(error2) {
					{
						invokeGuardedCallback(null, function () {
							throw error2
						})
						clearCaughtError()
					}
				}
				var callComponentWillUnmountWithTimer = function (current2, instance) {
					instance.props = current2.memoizedProps
					instance.state = current2.memoizedState
					if (current2.mode & ProfileMode) {
						try {
							startLayoutEffectTimer()
							instance.componentWillUnmount()
						} finally {
							recordLayoutEffectDuration(current2)
						}
					} else {
						instance.componentWillUnmount()
					}
				}
				function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
					try {
						commitHookEffectListMount(Layout2, current2)
					} catch (error2) {
						captureCommitPhaseError(current2, nearestMountedAncestor, error2)
					}
				}
				function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
					try {
						callComponentWillUnmountWithTimer(current2, instance)
					} catch (error2) {
						captureCommitPhaseError(current2, nearestMountedAncestor, error2)
					}
				}
				function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
					try {
						instance.componentDidMount()
					} catch (error2) {
						captureCommitPhaseError(current2, nearestMountedAncestor, error2)
					}
				}
				function safelyAttachRef(current2, nearestMountedAncestor) {
					try {
						commitAttachRef(current2)
					} catch (error2) {
						captureCommitPhaseError(current2, nearestMountedAncestor, error2)
					}
				}
				function safelyDetachRef(current2, nearestMountedAncestor) {
					var ref = current2.ref
					if (ref !== null) {
						if (typeof ref === 'function') {
							var retVal
							try {
								if (
									enableProfilerTimer &&
									enableProfilerCommitHooks &&
									current2.mode & ProfileMode
								) {
									try {
										startLayoutEffectTimer()
										retVal = ref(null)
									} finally {
										recordLayoutEffectDuration(current2)
									}
								} else {
									retVal = ref(null)
								}
							} catch (error2) {
								captureCommitPhaseError(current2, nearestMountedAncestor, error2)
							}
							{
								if (typeof retVal === 'function') {
									error(
										'Unexpected return value from a callback ref in %s. A callback ref should not return a function.',
										getComponentNameFromFiber(current2)
									)
								}
							}
						} else {
							ref.current = null
						}
					}
				}
				function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
					try {
						destroy()
					} catch (error2) {
						captureCommitPhaseError(current2, nearestMountedAncestor, error2)
					}
				}
				var focusedInstanceHandle = null
				var shouldFireAfterActiveInstanceBlur = false
				function commitBeforeMutationEffects(root3, firstChild) {
					focusedInstanceHandle = prepareForCommit(root3.containerInfo)
					nextEffect = firstChild
					commitBeforeMutationEffects_begin()
					var shouldFire = shouldFireAfterActiveInstanceBlur
					shouldFireAfterActiveInstanceBlur = false
					focusedInstanceHandle = null
					return shouldFire
				}
				function commitBeforeMutationEffects_begin() {
					while (nextEffect !== null) {
						var fiber = nextEffect
						var child = fiber.child
						if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
							child.return = fiber
							nextEffect = child
						} else {
							commitBeforeMutationEffects_complete()
						}
					}
				}
				function commitBeforeMutationEffects_complete() {
					while (nextEffect !== null) {
						var fiber = nextEffect
						setCurrentFiber(fiber)
						try {
							commitBeforeMutationEffectsOnFiber(fiber)
						} catch (error2) {
							captureCommitPhaseError(fiber, fiber.return, error2)
						}
						resetCurrentFiber()
						var sibling = fiber.sibling
						if (sibling !== null) {
							sibling.return = fiber.return
							nextEffect = sibling
							return
						}
						nextEffect = fiber.return
					}
				}
				function commitBeforeMutationEffectsOnFiber(finishedWork) {
					var current2 = finishedWork.alternate
					var flags = finishedWork.flags
					if ((flags & Snapshot) !== NoFlags) {
						setCurrentFiber(finishedWork)
						switch (finishedWork.tag) {
							case FunctionComponent:
							case ForwardRef:
							case SimpleMemoComponent: {
								break
							}
							case ClassComponent: {
								if (current2 !== null) {
									var prevProps = current2.memoizedProps
									var prevState = current2.memoizedState
									var instance = finishedWork.stateNode
									{
										if (
											finishedWork.type === finishedWork.elementType &&
											!didWarnAboutReassigningProps
										) {
											if (instance.props !== finishedWork.memoizedProps) {
												error(
													'Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
													getComponentNameFromFiber(finishedWork) || 'instance'
												)
											}
											if (instance.state !== finishedWork.memoizedState) {
												error(
													'Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
													getComponentNameFromFiber(finishedWork) || 'instance'
												)
											}
										}
									}
									var snapshot = instance.getSnapshotBeforeUpdate(
										finishedWork.elementType === finishedWork.type
											? prevProps
											: resolveDefaultProps(finishedWork.type, prevProps),
										prevState
									)
									{
										var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate
										if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
											didWarnSet.add(finishedWork.type)
											error(
												'%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.',
												getComponentNameFromFiber(finishedWork)
											)
										}
									}
									instance.__reactInternalSnapshotBeforeUpdate = snapshot
								}
								break
							}
							case HostRoot: {
								{
									var root3 = finishedWork.stateNode
									clearContainer(root3.containerInfo)
								}
								break
							}
							case HostComponent:
							case HostText:
							case HostPortal:
							case IncompleteClassComponent:
								break
							default: {
								throw new Error(
									'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
								)
							}
						}
						resetCurrentFiber()
					}
				}
				function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
					var updateQueue = finishedWork.updateQueue
					var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null
					if (lastEffect !== null) {
						var firstEffect = lastEffect.next
						var effect = firstEffect
						do {
							if ((effect.tag & flags) === flags) {
								var destroy = effect.destroy
								effect.destroy = void 0
								if (destroy !== void 0) {
									{
										if ((flags & Passive$1) !== NoFlags$1) {
											markComponentPassiveEffectUnmountStarted(finishedWork)
										} else if ((flags & Layout2) !== NoFlags$1) {
											markComponentLayoutEffectUnmountStarted(finishedWork)
										}
									}
									{
										if ((flags & Insertion) !== NoFlags$1) {
											setIsRunningInsertionEffect(true)
										}
									}
									safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy)
									{
										if ((flags & Insertion) !== NoFlags$1) {
											setIsRunningInsertionEffect(false)
										}
									}
									{
										if ((flags & Passive$1) !== NoFlags$1) {
											markComponentPassiveEffectUnmountStopped()
										} else if ((flags & Layout2) !== NoFlags$1) {
											markComponentLayoutEffectUnmountStopped()
										}
									}
								}
							}
							effect = effect.next
						} while (effect !== firstEffect)
					}
				}
				function commitHookEffectListMount(flags, finishedWork) {
					var updateQueue = finishedWork.updateQueue
					var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null
					if (lastEffect !== null) {
						var firstEffect = lastEffect.next
						var effect = firstEffect
						do {
							if ((effect.tag & flags) === flags) {
								{
									if ((flags & Passive$1) !== NoFlags$1) {
										markComponentPassiveEffectMountStarted(finishedWork)
									} else if ((flags & Layout2) !== NoFlags$1) {
										markComponentLayoutEffectMountStarted(finishedWork)
									}
								}
								var create = effect.create
								{
									if ((flags & Insertion) !== NoFlags$1) {
										setIsRunningInsertionEffect(true)
									}
								}
								effect.destroy = create()
								{
									if ((flags & Insertion) !== NoFlags$1) {
										setIsRunningInsertionEffect(false)
									}
								}
								{
									if ((flags & Passive$1) !== NoFlags$1) {
										markComponentPassiveEffectMountStopped()
									} else if ((flags & Layout2) !== NoFlags$1) {
										markComponentLayoutEffectMountStopped()
									}
								}
								{
									var destroy = effect.destroy
									if (destroy !== void 0 && typeof destroy !== 'function') {
										var hookName = void 0
										if ((effect.tag & Layout2) !== NoFlags) {
											hookName = 'useLayoutEffect'
										} else if ((effect.tag & Insertion) !== NoFlags) {
											hookName = 'useInsertionEffect'
										} else {
											hookName = 'useEffect'
										}
										var addendum = void 0
										if (destroy === null) {
											addendum =
												' You returned null. If your effect does not require clean up, return undefined (or nothing).'
										} else if (typeof destroy.then === 'function') {
											addendum =
												'\n\nIt looks like you wrote ' +
												hookName +
												'(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n' +
												hookName +
												"(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"
										} else {
											addendum = ' You returned: ' + destroy
										}
										error(
											'%s must not return anything besides a function, which is used for clean-up.%s',
											hookName,
											addendum
										)
									}
								}
							}
							effect = effect.next
						} while (effect !== firstEffect)
					}
				}
				function commitPassiveEffectDurations(finishedRoot, finishedWork) {
					{
						if ((finishedWork.flags & Update) !== NoFlags) {
							switch (finishedWork.tag) {
								case Profiler: {
									var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration
									var _finishedWork$memoize = finishedWork.memoizedProps,
										id = _finishedWork$memoize.id,
										onPostCommit = _finishedWork$memoize.onPostCommit
									var commitTime2 = getCommitTime()
									var phase = finishedWork.alternate === null ? 'mount' : 'update'
									{
										if (isCurrentUpdateNested()) {
											phase = 'nested-update'
										}
									}
									if (typeof onPostCommit === 'function') {
										onPostCommit(id, phase, passiveEffectDuration, commitTime2)
									}
									var parentFiber = finishedWork.return
									outer: while (parentFiber !== null) {
										switch (parentFiber.tag) {
											case HostRoot:
												var root3 = parentFiber.stateNode
												root3.passiveEffectDuration += passiveEffectDuration
												break outer
											case Profiler:
												var parentStateNode = parentFiber.stateNode
												parentStateNode.passiveEffectDuration += passiveEffectDuration
												break outer
										}
										parentFiber = parentFiber.return
									}
									break
								}
							}
						}
					}
				}
				function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
					if ((finishedWork.flags & LayoutMask) !== NoFlags) {
						switch (finishedWork.tag) {
							case FunctionComponent:
							case ForwardRef:
							case SimpleMemoComponent: {
								if (!offscreenSubtreeWasHidden) {
									if (finishedWork.mode & ProfileMode) {
										try {
											startLayoutEffectTimer()
											commitHookEffectListMount(Layout2 | HasEffect, finishedWork)
										} finally {
											recordLayoutEffectDuration(finishedWork)
										}
									} else {
										commitHookEffectListMount(Layout2 | HasEffect, finishedWork)
									}
								}
								break
							}
							case ClassComponent: {
								var instance = finishedWork.stateNode
								if (finishedWork.flags & Update) {
									if (!offscreenSubtreeWasHidden) {
										if (current2 === null) {
											{
												if (
													finishedWork.type === finishedWork.elementType &&
													!didWarnAboutReassigningProps
												) {
													if (instance.props !== finishedWork.memoizedProps) {
														error(
															'Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
															getComponentNameFromFiber(finishedWork) || 'instance'
														)
													}
													if (instance.state !== finishedWork.memoizedState) {
														error(
															'Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
															getComponentNameFromFiber(finishedWork) || 'instance'
														)
													}
												}
											}
											if (finishedWork.mode & ProfileMode) {
												try {
													startLayoutEffectTimer()
													instance.componentDidMount()
												} finally {
													recordLayoutEffectDuration(finishedWork)
												}
											} else {
												instance.componentDidMount()
											}
										} else {
											var prevProps =
												finishedWork.elementType === finishedWork.type
													? current2.memoizedProps
													: resolveDefaultProps(finishedWork.type, current2.memoizedProps)
											var prevState = current2.memoizedState
											{
												if (
													finishedWork.type === finishedWork.elementType &&
													!didWarnAboutReassigningProps
												) {
													if (instance.props !== finishedWork.memoizedProps) {
														error(
															'Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
															getComponentNameFromFiber(finishedWork) || 'instance'
														)
													}
													if (instance.state !== finishedWork.memoizedState) {
														error(
															'Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
															getComponentNameFromFiber(finishedWork) || 'instance'
														)
													}
												}
											}
											if (finishedWork.mode & ProfileMode) {
												try {
													startLayoutEffectTimer()
													instance.componentDidUpdate(
														prevProps,
														prevState,
														instance.__reactInternalSnapshotBeforeUpdate
													)
												} finally {
													recordLayoutEffectDuration(finishedWork)
												}
											} else {
												instance.componentDidUpdate(
													prevProps,
													prevState,
													instance.__reactInternalSnapshotBeforeUpdate
												)
											}
										}
									}
								}
								var updateQueue = finishedWork.updateQueue
								if (updateQueue !== null) {
									{
										if (
											finishedWork.type === finishedWork.elementType &&
											!didWarnAboutReassigningProps
										) {
											if (instance.props !== finishedWork.memoizedProps) {
												error(
													'Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
													getComponentNameFromFiber(finishedWork) || 'instance'
												)
											}
											if (instance.state !== finishedWork.memoizedState) {
												error(
													'Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.',
													getComponentNameFromFiber(finishedWork) || 'instance'
												)
											}
										}
									}
									commitUpdateQueue(finishedWork, updateQueue, instance)
								}
								break
							}
							case HostRoot: {
								var _updateQueue = finishedWork.updateQueue
								if (_updateQueue !== null) {
									var _instance = null
									if (finishedWork.child !== null) {
										switch (finishedWork.child.tag) {
											case HostComponent:
												_instance = getPublicInstance(finishedWork.child.stateNode)
												break
											case ClassComponent:
												_instance = finishedWork.child.stateNode
												break
										}
									}
									commitUpdateQueue(finishedWork, _updateQueue, _instance)
								}
								break
							}
							case HostComponent: {
								var _instance2 = finishedWork.stateNode
								if (current2 === null && finishedWork.flags & Update) {
									var type = finishedWork.type
									var props = finishedWork.memoizedProps
									commitMount(_instance2, type, props)
								}
								break
							}
							case HostText: {
								break
							}
							case HostPortal: {
								break
							}
							case Profiler: {
								{
									var _finishedWork$memoize2 = finishedWork.memoizedProps,
										onCommit = _finishedWork$memoize2.onCommit,
										onRender = _finishedWork$memoize2.onRender
									var effectDuration = finishedWork.stateNode.effectDuration
									var commitTime2 = getCommitTime()
									var phase = current2 === null ? 'mount' : 'update'
									{
										if (isCurrentUpdateNested()) {
											phase = 'nested-update'
										}
									}
									if (typeof onRender === 'function') {
										onRender(
											finishedWork.memoizedProps.id,
											phase,
											finishedWork.actualDuration,
											finishedWork.treeBaseDuration,
											finishedWork.actualStartTime,
											commitTime2
										)
									}
									{
										if (typeof onCommit === 'function') {
											onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2)
										}
										enqueuePendingPassiveProfilerEffect(finishedWork)
										var parentFiber = finishedWork.return
										outer: while (parentFiber !== null) {
											switch (parentFiber.tag) {
												case HostRoot:
													var root3 = parentFiber.stateNode
													root3.effectDuration += effectDuration
													break outer
												case Profiler:
													var parentStateNode = parentFiber.stateNode
													parentStateNode.effectDuration += effectDuration
													break outer
											}
											parentFiber = parentFiber.return
										}
									}
								}
								break
							}
							case SuspenseComponent: {
								commitSuspenseHydrationCallbacks(finishedRoot, finishedWork)
								break
							}
							case SuspenseListComponent:
							case IncompleteClassComponent:
							case ScopeComponent:
							case OffscreenComponent:
							case LegacyHiddenComponent:
							case TracingMarkerComponent: {
								break
							}
							default:
								throw new Error(
									'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
								)
						}
					}
					if (!offscreenSubtreeWasHidden) {
						{
							if (finishedWork.flags & Ref) {
								commitAttachRef(finishedWork)
							}
						}
					}
				}
				function reappearLayoutEffectsOnFiber(node) {
					switch (node.tag) {
						case FunctionComponent:
						case ForwardRef:
						case SimpleMemoComponent: {
							if (node.mode & ProfileMode) {
								try {
									startLayoutEffectTimer()
									safelyCallCommitHookLayoutEffectListMount(node, node.return)
								} finally {
									recordLayoutEffectDuration(node)
								}
							} else {
								safelyCallCommitHookLayoutEffectListMount(node, node.return)
							}
							break
						}
						case ClassComponent: {
							var instance = node.stateNode
							if (typeof instance.componentDidMount === 'function') {
								safelyCallComponentDidMount(node, node.return, instance)
							}
							safelyAttachRef(node, node.return)
							break
						}
						case HostComponent: {
							safelyAttachRef(node, node.return)
							break
						}
					}
				}
				function hideOrUnhideAllChildren(finishedWork, isHidden) {
					var hostSubtreeRoot = null
					{
						var node = finishedWork
						while (true) {
							if (node.tag === HostComponent) {
								if (hostSubtreeRoot === null) {
									hostSubtreeRoot = node
									try {
										var instance = node.stateNode
										if (isHidden) {
											hideInstance(instance)
										} else {
											unhideInstance(node.stateNode, node.memoizedProps)
										}
									} catch (error2) {
										captureCommitPhaseError(finishedWork, finishedWork.return, error2)
									}
								}
							} else if (node.tag === HostText) {
								if (hostSubtreeRoot === null) {
									try {
										var _instance3 = node.stateNode
										if (isHidden) {
											hideTextInstance(_instance3)
										} else {
											unhideTextInstance(_instance3, node.memoizedProps)
										}
									} catch (error2) {
										captureCommitPhaseError(finishedWork, finishedWork.return, error2)
									}
								}
							} else if (
								(node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) &&
								node.memoizedState !== null &&
								node !== finishedWork
							);
							else if (node.child !== null) {
								node.child.return = node
								node = node.child
								continue
							}
							if (node === finishedWork) {
								return
							}
							while (node.sibling === null) {
								if (node.return === null || node.return === finishedWork) {
									return
								}
								if (hostSubtreeRoot === node) {
									hostSubtreeRoot = null
								}
								node = node.return
							}
							if (hostSubtreeRoot === node) {
								hostSubtreeRoot = null
							}
							node.sibling.return = node.return
							node = node.sibling
						}
					}
				}
				function commitAttachRef(finishedWork) {
					var ref = finishedWork.ref
					if (ref !== null) {
						var instance = finishedWork.stateNode
						var instanceToUse
						switch (finishedWork.tag) {
							case HostComponent:
								instanceToUse = getPublicInstance(instance)
								break
							default:
								instanceToUse = instance
						}
						if (typeof ref === 'function') {
							var retVal
							if (finishedWork.mode & ProfileMode) {
								try {
									startLayoutEffectTimer()
									retVal = ref(instanceToUse)
								} finally {
									recordLayoutEffectDuration(finishedWork)
								}
							} else {
								retVal = ref(instanceToUse)
							}
							{
								if (typeof retVal === 'function') {
									error(
										'Unexpected return value from a callback ref in %s. A callback ref should not return a function.',
										getComponentNameFromFiber(finishedWork)
									)
								}
							}
						} else {
							{
								if (!ref.hasOwnProperty('current')) {
									error(
										'Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().',
										getComponentNameFromFiber(finishedWork)
									)
								}
							}
							ref.current = instanceToUse
						}
					}
				}
				function detachFiberMutation(fiber) {
					var alternate = fiber.alternate
					if (alternate !== null) {
						alternate.return = null
					}
					fiber.return = null
				}
				function detachFiberAfterEffects(fiber) {
					var alternate = fiber.alternate
					if (alternate !== null) {
						fiber.alternate = null
						detachFiberAfterEffects(alternate)
					}
					{
						fiber.child = null
						fiber.deletions = null
						fiber.sibling = null
						if (fiber.tag === HostComponent) {
							var hostInstance = fiber.stateNode
							if (hostInstance !== null) {
								detachDeletedInstance(hostInstance)
							}
						}
						fiber.stateNode = null
						{
							fiber._debugOwner = null
						}
						{
							fiber.return = null
							fiber.dependencies = null
							fiber.memoizedProps = null
							fiber.memoizedState = null
							fiber.pendingProps = null
							fiber.stateNode = null
							fiber.updateQueue = null
						}
					}
				}
				function getHostParentFiber(fiber) {
					var parent = fiber.return
					while (parent !== null) {
						if (isHostParent(parent)) {
							return parent
						}
						parent = parent.return
					}
					throw new Error(
						'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
					)
				}
				function isHostParent(fiber) {
					return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal
				}
				function getHostSibling(fiber) {
					var node = fiber
					siblings: while (true) {
						while (node.sibling === null) {
							if (node.return === null || isHostParent(node.return)) {
								return null
							}
							node = node.return
						}
						node.sibling.return = node.return
						node = node.sibling
						while (
							node.tag !== HostComponent &&
							node.tag !== HostText &&
							node.tag !== DehydratedFragment
						) {
							if (node.flags & Placement) {
								continue siblings
							}
							if (node.child === null || node.tag === HostPortal) {
								continue siblings
							} else {
								node.child.return = node
								node = node.child
							}
						}
						if (!(node.flags & Placement)) {
							return node.stateNode
						}
					}
				}
				function commitPlacement(finishedWork) {
					var parentFiber = getHostParentFiber(finishedWork)
					switch (parentFiber.tag) {
						case HostComponent: {
							var parent = parentFiber.stateNode
							if (parentFiber.flags & ContentReset) {
								resetTextContent(parent)
								parentFiber.flags &= ~ContentReset
							}
							var before = getHostSibling(finishedWork)
							insertOrAppendPlacementNode(finishedWork, before, parent)
							break
						}
						case HostRoot:
						case HostPortal: {
							var _parent = parentFiber.stateNode.containerInfo
							var _before = getHostSibling(finishedWork)
							insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent)
							break
						}
						default:
							throw new Error(
								'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.'
							)
					}
				}
				function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
					var tag = node.tag
					var isHost = tag === HostComponent || tag === HostText
					if (isHost) {
						var stateNode = node.stateNode
						if (before) {
							insertInContainerBefore(parent, stateNode, before)
						} else {
							appendChildToContainer(parent, stateNode)
						}
					} else if (tag === HostPortal);
					else {
						var child = node.child
						if (child !== null) {
							insertOrAppendPlacementNodeIntoContainer(child, before, parent)
							var sibling = child.sibling
							while (sibling !== null) {
								insertOrAppendPlacementNodeIntoContainer(sibling, before, parent)
								sibling = sibling.sibling
							}
						}
					}
				}
				function insertOrAppendPlacementNode(node, before, parent) {
					var tag = node.tag
					var isHost = tag === HostComponent || tag === HostText
					if (isHost) {
						var stateNode = node.stateNode
						if (before) {
							insertBefore(parent, stateNode, before)
						} else {
							appendChild(parent, stateNode)
						}
					} else if (tag === HostPortal);
					else {
						var child = node.child
						if (child !== null) {
							insertOrAppendPlacementNode(child, before, parent)
							var sibling = child.sibling
							while (sibling !== null) {
								insertOrAppendPlacementNode(sibling, before, parent)
								sibling = sibling.sibling
							}
						}
					}
				}
				var hostParent = null
				var hostParentIsContainer = false
				function commitDeletionEffects(root3, returnFiber, deletedFiber) {
					{
						var parent = returnFiber
						findParent: while (parent !== null) {
							switch (parent.tag) {
								case HostComponent: {
									hostParent = parent.stateNode
									hostParentIsContainer = false
									break findParent
								}
								case HostRoot: {
									hostParent = parent.stateNode.containerInfo
									hostParentIsContainer = true
									break findParent
								}
								case HostPortal: {
									hostParent = parent.stateNode.containerInfo
									hostParentIsContainer = true
									break findParent
								}
							}
							parent = parent.return
						}
						if (hostParent === null) {
							throw new Error(
								'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
							)
						}
						commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber)
						hostParent = null
						hostParentIsContainer = false
					}
					detachFiberMutation(deletedFiber)
				}
				function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
					var child = parent.child
					while (child !== null) {
						commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child)
						child = child.sibling
					}
				}
				function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
					onCommitUnmount(deletedFiber)
					switch (deletedFiber.tag) {
						case HostComponent: {
							if (!offscreenSubtreeWasHidden) {
								safelyDetachRef(deletedFiber, nearestMountedAncestor)
							}
						}
						case HostText: {
							{
								var prevHostParent = hostParent
								var prevHostParentIsContainer = hostParentIsContainer
								hostParent = null
								recursivelyTraverseDeletionEffects(
									finishedRoot,
									nearestMountedAncestor,
									deletedFiber
								)
								hostParent = prevHostParent
								hostParentIsContainer = prevHostParentIsContainer
								if (hostParent !== null) {
									if (hostParentIsContainer) {
										removeChildFromContainer(hostParent, deletedFiber.stateNode)
									} else {
										removeChild(hostParent, deletedFiber.stateNode)
									}
								}
							}
							return
						}
						case DehydratedFragment: {
							{
								if (hostParent !== null) {
									if (hostParentIsContainer) {
										clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode)
									} else {
										clearSuspenseBoundary(hostParent, deletedFiber.stateNode)
									}
								}
							}
							return
						}
						case HostPortal: {
							{
								var _prevHostParent = hostParent
								var _prevHostParentIsContainer = hostParentIsContainer
								hostParent = deletedFiber.stateNode.containerInfo
								hostParentIsContainer = true
								recursivelyTraverseDeletionEffects(
									finishedRoot,
									nearestMountedAncestor,
									deletedFiber
								)
								hostParent = _prevHostParent
								hostParentIsContainer = _prevHostParentIsContainer
							}
							return
						}
						case FunctionComponent:
						case ForwardRef:
						case MemoComponent:
						case SimpleMemoComponent: {
							if (!offscreenSubtreeWasHidden) {
								var updateQueue = deletedFiber.updateQueue
								if (updateQueue !== null) {
									var lastEffect = updateQueue.lastEffect
									if (lastEffect !== null) {
										var firstEffect = lastEffect.next
										var effect = firstEffect
										do {
											var _effect = effect,
												destroy = _effect.destroy,
												tag = _effect.tag
											if (destroy !== void 0) {
												if ((tag & Insertion) !== NoFlags$1) {
													safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy)
												} else if ((tag & Layout2) !== NoFlags$1) {
													{
														markComponentLayoutEffectUnmountStarted(deletedFiber)
													}
													if (deletedFiber.mode & ProfileMode) {
														startLayoutEffectTimer()
														safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy)
														recordLayoutEffectDuration(deletedFiber)
													} else {
														safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy)
													}
													{
														markComponentLayoutEffectUnmountStopped()
													}
												}
											}
											effect = effect.next
										} while (effect !== firstEffect)
									}
								}
							}
							recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber)
							return
						}
						case ClassComponent: {
							if (!offscreenSubtreeWasHidden) {
								safelyDetachRef(deletedFiber, nearestMountedAncestor)
								var instance = deletedFiber.stateNode
								if (typeof instance.componentWillUnmount === 'function') {
									safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance)
								}
							}
							recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber)
							return
						}
						case ScopeComponent: {
							recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber)
							return
						}
						case OffscreenComponent: {
							if (
								// TODO: Remove this dead flag
								deletedFiber.mode & ConcurrentMode
							) {
								var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden
								offscreenSubtreeWasHidden =
									prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null
								recursivelyTraverseDeletionEffects(
									finishedRoot,
									nearestMountedAncestor,
									deletedFiber
								)
								offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden
							} else {
								recursivelyTraverseDeletionEffects(
									finishedRoot,
									nearestMountedAncestor,
									deletedFiber
								)
							}
							break
						}
						default: {
							recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber)
							return
						}
					}
				}
				function commitSuspenseCallback(finishedWork) {
					var newState = finishedWork.memoizedState
				}
				function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
					var newState = finishedWork.memoizedState
					if (newState === null) {
						var current2 = finishedWork.alternate
						if (current2 !== null) {
							var prevState = current2.memoizedState
							if (prevState !== null) {
								var suspenseInstance = prevState.dehydrated
								if (suspenseInstance !== null) {
									commitHydratedSuspenseInstance(suspenseInstance)
								}
							}
						}
					}
				}
				function attachSuspenseRetryListeners(finishedWork) {
					var wakeables = finishedWork.updateQueue
					if (wakeables !== null) {
						finishedWork.updateQueue = null
						var retryCache = finishedWork.stateNode
						if (retryCache === null) {
							retryCache = finishedWork.stateNode = new PossiblyWeakSet()
						}
						wakeables.forEach(function (wakeable) {
							var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable)
							if (!retryCache.has(wakeable)) {
								retryCache.add(wakeable)
								{
									if (isDevToolsPresent) {
										if (inProgressLanes !== null && inProgressRoot !== null) {
											restorePendingUpdaters(inProgressRoot, inProgressLanes)
										} else {
											throw Error(
												'Expected finished root and lanes to be set. This is a bug in React.'
											)
										}
									}
								}
								wakeable.then(retry, retry)
							}
						})
					}
				}
				function commitMutationEffects(root3, finishedWork, committedLanes) {
					inProgressLanes = committedLanes
					inProgressRoot = root3
					setCurrentFiber(finishedWork)
					commitMutationEffectsOnFiber(finishedWork, root3)
					setCurrentFiber(finishedWork)
					inProgressLanes = null
					inProgressRoot = null
				}
				function recursivelyTraverseMutationEffects(root3, parentFiber, lanes) {
					var deletions = parentFiber.deletions
					if (deletions !== null) {
						for (var i3 = 0; i3 < deletions.length; i3++) {
							var childToDelete = deletions[i3]
							try {
								commitDeletionEffects(root3, parentFiber, childToDelete)
							} catch (error2) {
								captureCommitPhaseError(childToDelete, parentFiber, error2)
							}
						}
					}
					var prevDebugFiber = getCurrentFiber()
					if (parentFiber.subtreeFlags & MutationMask) {
						var child = parentFiber.child
						while (child !== null) {
							setCurrentFiber(child)
							commitMutationEffectsOnFiber(child, root3)
							child = child.sibling
						}
					}
					setCurrentFiber(prevDebugFiber)
				}
				function commitMutationEffectsOnFiber(finishedWork, root3, lanes) {
					var current2 = finishedWork.alternate
					var flags = finishedWork.flags
					switch (finishedWork.tag) {
						case FunctionComponent:
						case ForwardRef:
						case MemoComponent:
						case SimpleMemoComponent: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							if (flags & Update) {
								try {
									commitHookEffectListUnmount(
										Insertion | HasEffect,
										finishedWork,
										finishedWork.return
									)
									commitHookEffectListMount(Insertion | HasEffect, finishedWork)
								} catch (error2) {
									captureCommitPhaseError(finishedWork, finishedWork.return, error2)
								}
								if (finishedWork.mode & ProfileMode) {
									try {
										startLayoutEffectTimer()
										commitHookEffectListUnmount(
											Layout2 | HasEffect,
											finishedWork,
											finishedWork.return
										)
									} catch (error2) {
										captureCommitPhaseError(finishedWork, finishedWork.return, error2)
									}
									recordLayoutEffectDuration(finishedWork)
								} else {
									try {
										commitHookEffectListUnmount(
											Layout2 | HasEffect,
											finishedWork,
											finishedWork.return
										)
									} catch (error2) {
										captureCommitPhaseError(finishedWork, finishedWork.return, error2)
									}
								}
							}
							return
						}
						case ClassComponent: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							if (flags & Ref) {
								if (current2 !== null) {
									safelyDetachRef(current2, current2.return)
								}
							}
							return
						}
						case HostComponent: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							if (flags & Ref) {
								if (current2 !== null) {
									safelyDetachRef(current2, current2.return)
								}
							}
							{
								if (finishedWork.flags & ContentReset) {
									var instance = finishedWork.stateNode
									try {
										resetTextContent(instance)
									} catch (error2) {
										captureCommitPhaseError(finishedWork, finishedWork.return, error2)
									}
								}
								if (flags & Update) {
									var _instance4 = finishedWork.stateNode
									if (_instance4 != null) {
										var newProps = finishedWork.memoizedProps
										var oldProps = current2 !== null ? current2.memoizedProps : newProps
										var type = finishedWork.type
										var updatePayload = finishedWork.updateQueue
										finishedWork.updateQueue = null
										if (updatePayload !== null) {
											try {
												commitUpdate(
													_instance4,
													updatePayload,
													type,
													oldProps,
													newProps,
													finishedWork
												)
											} catch (error2) {
												captureCommitPhaseError(finishedWork, finishedWork.return, error2)
											}
										}
									}
								}
							}
							return
						}
						case HostText: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							if (flags & Update) {
								{
									if (finishedWork.stateNode === null) {
										throw new Error(
											'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'
										)
									}
									var textInstance = finishedWork.stateNode
									var newText = finishedWork.memoizedProps
									var oldText = current2 !== null ? current2.memoizedProps : newText
									try {
										commitTextUpdate(textInstance, oldText, newText)
									} catch (error2) {
										captureCommitPhaseError(finishedWork, finishedWork.return, error2)
									}
								}
							}
							return
						}
						case HostRoot: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							if (flags & Update) {
								{
									if (current2 !== null) {
										var prevRootState = current2.memoizedState
										if (prevRootState.isDehydrated) {
											try {
												commitHydratedContainer(root3.containerInfo)
											} catch (error2) {
												captureCommitPhaseError(finishedWork, finishedWork.return, error2)
											}
										}
									}
								}
							}
							return
						}
						case HostPortal: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							return
						}
						case SuspenseComponent: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							var offscreenFiber = finishedWork.child
							if (offscreenFiber.flags & Visibility) {
								var offscreenInstance = offscreenFiber.stateNode
								var newState = offscreenFiber.memoizedState
								var isHidden = newState !== null
								offscreenInstance.isHidden = isHidden
								if (isHidden) {
									var wasHidden =
										offscreenFiber.alternate !== null &&
										offscreenFiber.alternate.memoizedState !== null
									if (!wasHidden) {
										markCommitTimeOfFallback()
									}
								}
							}
							if (flags & Update) {
								try {
									commitSuspenseCallback(finishedWork)
								} catch (error2) {
									captureCommitPhaseError(finishedWork, finishedWork.return, error2)
								}
								attachSuspenseRetryListeners(finishedWork)
							}
							return
						}
						case OffscreenComponent: {
							var _wasHidden = current2 !== null && current2.memoizedState !== null
							if (
								// TODO: Remove this dead flag
								finishedWork.mode & ConcurrentMode
							) {
								var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden
								offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden
								recursivelyTraverseMutationEffects(root3, finishedWork)
								offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden
							} else {
								recursivelyTraverseMutationEffects(root3, finishedWork)
							}
							commitReconciliationEffects(finishedWork)
							if (flags & Visibility) {
								var _offscreenInstance = finishedWork.stateNode
								var _newState = finishedWork.memoizedState
								var _isHidden = _newState !== null
								var offscreenBoundary = finishedWork
								_offscreenInstance.isHidden = _isHidden
								{
									if (_isHidden) {
										if (!_wasHidden) {
											if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
												nextEffect = offscreenBoundary
												var offscreenChild = offscreenBoundary.child
												while (offscreenChild !== null) {
													nextEffect = offscreenChild
													disappearLayoutEffects_begin(offscreenChild)
													offscreenChild = offscreenChild.sibling
												}
											}
										}
									}
								}
								{
									hideOrUnhideAllChildren(offscreenBoundary, _isHidden)
								}
							}
							return
						}
						case SuspenseListComponent: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							if (flags & Update) {
								attachSuspenseRetryListeners(finishedWork)
							}
							return
						}
						case ScopeComponent: {
							return
						}
						default: {
							recursivelyTraverseMutationEffects(root3, finishedWork)
							commitReconciliationEffects(finishedWork)
							return
						}
					}
				}
				function commitReconciliationEffects(finishedWork) {
					var flags = finishedWork.flags
					if (flags & Placement) {
						try {
							commitPlacement(finishedWork)
						} catch (error2) {
							captureCommitPhaseError(finishedWork, finishedWork.return, error2)
						}
						finishedWork.flags &= ~Placement
					}
					if (flags & Hydrating) {
						finishedWork.flags &= ~Hydrating
					}
				}
				function commitLayoutEffects(finishedWork, root3, committedLanes) {
					inProgressLanes = committedLanes
					inProgressRoot = root3
					nextEffect = finishedWork
					commitLayoutEffects_begin(finishedWork, root3, committedLanes)
					inProgressLanes = null
					inProgressRoot = null
				}
				function commitLayoutEffects_begin(subtreeRoot, root3, committedLanes) {
					var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode
					while (nextEffect !== null) {
						var fiber = nextEffect
						var firstChild = fiber.child
						if (fiber.tag === OffscreenComponent && isModernRoot) {
							var isHidden = fiber.memoizedState !== null
							var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden
							if (newOffscreenSubtreeIsHidden) {
								commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes)
								continue
							} else {
								var current2 = fiber.alternate
								var wasHidden = current2 !== null && current2.memoizedState !== null
								var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden
								var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden
								var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden
								offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden
								offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden
								if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
									nextEffect = fiber
									reappearLayoutEffects_begin(fiber)
								}
								var child = firstChild
								while (child !== null) {
									nextEffect = child
									commitLayoutEffects_begin(
										child,
										// New root; bubble back up to here and stop.
										root3,
										committedLanes
									)
									child = child.sibling
								}
								nextEffect = fiber
								offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden
								offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden
								commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes)
								continue
							}
						}
						if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
							firstChild.return = fiber
							nextEffect = firstChild
						} else {
							commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes)
						}
					}
				}
				function commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						if ((fiber.flags & LayoutMask) !== NoFlags) {
							var current2 = fiber.alternate
							setCurrentFiber(fiber)
							try {
								commitLayoutEffectOnFiber(root3, current2, fiber, committedLanes)
							} catch (error2) {
								captureCommitPhaseError(fiber, fiber.return, error2)
							}
							resetCurrentFiber()
						}
						if (fiber === subtreeRoot) {
							nextEffect = null
							return
						}
						var sibling = fiber.sibling
						if (sibling !== null) {
							sibling.return = fiber.return
							nextEffect = sibling
							return
						}
						nextEffect = fiber.return
					}
				}
				function disappearLayoutEffects_begin(subtreeRoot) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						var firstChild = fiber.child
						switch (fiber.tag) {
							case FunctionComponent:
							case ForwardRef:
							case MemoComponent:
							case SimpleMemoComponent: {
								if (fiber.mode & ProfileMode) {
									try {
										startLayoutEffectTimer()
										commitHookEffectListUnmount(Layout2, fiber, fiber.return)
									} finally {
										recordLayoutEffectDuration(fiber)
									}
								} else {
									commitHookEffectListUnmount(Layout2, fiber, fiber.return)
								}
								break
							}
							case ClassComponent: {
								safelyDetachRef(fiber, fiber.return)
								var instance = fiber.stateNode
								if (typeof instance.componentWillUnmount === 'function') {
									safelyCallComponentWillUnmount(fiber, fiber.return, instance)
								}
								break
							}
							case HostComponent: {
								safelyDetachRef(fiber, fiber.return)
								break
							}
							case OffscreenComponent: {
								var isHidden = fiber.memoizedState !== null
								if (isHidden) {
									disappearLayoutEffects_complete(subtreeRoot)
									continue
								}
								break
							}
						}
						if (firstChild !== null) {
							firstChild.return = fiber
							nextEffect = firstChild
						} else {
							disappearLayoutEffects_complete(subtreeRoot)
						}
					}
				}
				function disappearLayoutEffects_complete(subtreeRoot) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						if (fiber === subtreeRoot) {
							nextEffect = null
							return
						}
						var sibling = fiber.sibling
						if (sibling !== null) {
							sibling.return = fiber.return
							nextEffect = sibling
							return
						}
						nextEffect = fiber.return
					}
				}
				function reappearLayoutEffects_begin(subtreeRoot) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						var firstChild = fiber.child
						if (fiber.tag === OffscreenComponent) {
							var isHidden = fiber.memoizedState !== null
							if (isHidden) {
								reappearLayoutEffects_complete(subtreeRoot)
								continue
							}
						}
						if (firstChild !== null) {
							firstChild.return = fiber
							nextEffect = firstChild
						} else {
							reappearLayoutEffects_complete(subtreeRoot)
						}
					}
				}
				function reappearLayoutEffects_complete(subtreeRoot) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						setCurrentFiber(fiber)
						try {
							reappearLayoutEffectsOnFiber(fiber)
						} catch (error2) {
							captureCommitPhaseError(fiber, fiber.return, error2)
						}
						resetCurrentFiber()
						if (fiber === subtreeRoot) {
							nextEffect = null
							return
						}
						var sibling = fiber.sibling
						if (sibling !== null) {
							sibling.return = fiber.return
							nextEffect = sibling
							return
						}
						nextEffect = fiber.return
					}
				}
				function commitPassiveMountEffects(
					root3,
					finishedWork,
					committedLanes,
					committedTransitions
				) {
					nextEffect = finishedWork
					commitPassiveMountEffects_begin(finishedWork, root3, committedLanes, committedTransitions)
				}
				function commitPassiveMountEffects_begin(
					subtreeRoot,
					root3,
					committedLanes,
					committedTransitions
				) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						var firstChild = fiber.child
						if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
							firstChild.return = fiber
							nextEffect = firstChild
						} else {
							commitPassiveMountEffects_complete(
								subtreeRoot,
								root3,
								committedLanes,
								committedTransitions
							)
						}
					}
				}
				function commitPassiveMountEffects_complete(
					subtreeRoot,
					root3,
					committedLanes,
					committedTransitions
				) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						if ((fiber.flags & Passive) !== NoFlags) {
							setCurrentFiber(fiber)
							try {
								commitPassiveMountOnFiber(root3, fiber, committedLanes, committedTransitions)
							} catch (error2) {
								captureCommitPhaseError(fiber, fiber.return, error2)
							}
							resetCurrentFiber()
						}
						if (fiber === subtreeRoot) {
							nextEffect = null
							return
						}
						var sibling = fiber.sibling
						if (sibling !== null) {
							sibling.return = fiber.return
							nextEffect = sibling
							return
						}
						nextEffect = fiber.return
					}
				}
				function commitPassiveMountOnFiber(
					finishedRoot,
					finishedWork,
					committedLanes,
					committedTransitions
				) {
					switch (finishedWork.tag) {
						case FunctionComponent:
						case ForwardRef:
						case SimpleMemoComponent: {
							if (finishedWork.mode & ProfileMode) {
								startPassiveEffectTimer()
								try {
									commitHookEffectListMount(Passive$1 | HasEffect, finishedWork)
								} finally {
									recordPassiveEffectDuration(finishedWork)
								}
							} else {
								commitHookEffectListMount(Passive$1 | HasEffect, finishedWork)
							}
							break
						}
					}
				}
				function commitPassiveUnmountEffects(firstChild) {
					nextEffect = firstChild
					commitPassiveUnmountEffects_begin()
				}
				function commitPassiveUnmountEffects_begin() {
					while (nextEffect !== null) {
						var fiber = nextEffect
						var child = fiber.child
						if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
							var deletions = fiber.deletions
							if (deletions !== null) {
								for (var i3 = 0; i3 < deletions.length; i3++) {
									var fiberToDelete = deletions[i3]
									nextEffect = fiberToDelete
									commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber)
								}
								{
									var previousFiber = fiber.alternate
									if (previousFiber !== null) {
										var detachedChild = previousFiber.child
										if (detachedChild !== null) {
											previousFiber.child = null
											do {
												var detachedSibling = detachedChild.sibling
												detachedChild.sibling = null
												detachedChild = detachedSibling
											} while (detachedChild !== null)
										}
									}
								}
								nextEffect = fiber
							}
						}
						if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
							child.return = fiber
							nextEffect = child
						} else {
							commitPassiveUnmountEffects_complete()
						}
					}
				}
				function commitPassiveUnmountEffects_complete() {
					while (nextEffect !== null) {
						var fiber = nextEffect
						if ((fiber.flags & Passive) !== NoFlags) {
							setCurrentFiber(fiber)
							commitPassiveUnmountOnFiber(fiber)
							resetCurrentFiber()
						}
						var sibling = fiber.sibling
						if (sibling !== null) {
							sibling.return = fiber.return
							nextEffect = sibling
							return
						}
						nextEffect = fiber.return
					}
				}
				function commitPassiveUnmountOnFiber(finishedWork) {
					switch (finishedWork.tag) {
						case FunctionComponent:
						case ForwardRef:
						case SimpleMemoComponent: {
							if (finishedWork.mode & ProfileMode) {
								startPassiveEffectTimer()
								commitHookEffectListUnmount(
									Passive$1 | HasEffect,
									finishedWork,
									finishedWork.return
								)
								recordPassiveEffectDuration(finishedWork)
							} else {
								commitHookEffectListUnmount(
									Passive$1 | HasEffect,
									finishedWork,
									finishedWork.return
								)
							}
							break
						}
					}
				}
				function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
					deletedSubtreeRoot,
					nearestMountedAncestor
				) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						setCurrentFiber(fiber)
						commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor)
						resetCurrentFiber()
						var child = fiber.child
						if (child !== null) {
							child.return = fiber
							nextEffect = child
						} else {
							commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot)
						}
					}
				}
				function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
					while (nextEffect !== null) {
						var fiber = nextEffect
						var sibling = fiber.sibling
						var returnFiber = fiber.return
						{
							detachFiberAfterEffects(fiber)
							if (fiber === deletedSubtreeRoot) {
								nextEffect = null
								return
							}
						}
						if (sibling !== null) {
							sibling.return = returnFiber
							nextEffect = sibling
							return
						}
						nextEffect = returnFiber
					}
				}
				function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
					switch (current2.tag) {
						case FunctionComponent:
						case ForwardRef:
						case SimpleMemoComponent: {
							if (current2.mode & ProfileMode) {
								startPassiveEffectTimer()
								commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor)
								recordPassiveEffectDuration(current2)
							} else {
								commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor)
							}
							break
						}
					}
				}
				function invokeLayoutEffectMountInDEV(fiber) {
					{
						switch (fiber.tag) {
							case FunctionComponent:
							case ForwardRef:
							case SimpleMemoComponent: {
								try {
									commitHookEffectListMount(Layout2 | HasEffect, fiber)
								} catch (error2) {
									captureCommitPhaseError(fiber, fiber.return, error2)
								}
								break
							}
							case ClassComponent: {
								var instance = fiber.stateNode
								try {
									instance.componentDidMount()
								} catch (error2) {
									captureCommitPhaseError(fiber, fiber.return, error2)
								}
								break
							}
						}
					}
				}
				function invokePassiveEffectMountInDEV(fiber) {
					{
						switch (fiber.tag) {
							case FunctionComponent:
							case ForwardRef:
							case SimpleMemoComponent: {
								try {
									commitHookEffectListMount(Passive$1 | HasEffect, fiber)
								} catch (error2) {
									captureCommitPhaseError(fiber, fiber.return, error2)
								}
								break
							}
						}
					}
				}
				function invokeLayoutEffectUnmountInDEV(fiber) {
					{
						switch (fiber.tag) {
							case FunctionComponent:
							case ForwardRef:
							case SimpleMemoComponent: {
								try {
									commitHookEffectListUnmount(Layout2 | HasEffect, fiber, fiber.return)
								} catch (error2) {
									captureCommitPhaseError(fiber, fiber.return, error2)
								}
								break
							}
							case ClassComponent: {
								var instance = fiber.stateNode
								if (typeof instance.componentWillUnmount === 'function') {
									safelyCallComponentWillUnmount(fiber, fiber.return, instance)
								}
								break
							}
						}
					}
				}
				function invokePassiveEffectUnmountInDEV(fiber) {
					{
						switch (fiber.tag) {
							case FunctionComponent:
							case ForwardRef:
							case SimpleMemoComponent: {
								try {
									commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return)
								} catch (error2) {
									captureCommitPhaseError(fiber, fiber.return, error2)
								}
							}
						}
					}
				}
				var COMPONENT_TYPE = 0
				var HAS_PSEUDO_CLASS_TYPE = 1
				var ROLE_TYPE = 2
				var TEST_NAME_TYPE = 3
				var TEXT_TYPE = 4
				if (typeof Symbol === 'function' && Symbol.for) {
					var symbolFor = Symbol.for
					COMPONENT_TYPE = symbolFor('selector.component')
					HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class')
					ROLE_TYPE = symbolFor('selector.role')
					TEST_NAME_TYPE = symbolFor('selector.test_id')
					TEXT_TYPE = symbolFor('selector.text')
				}
				var commitHooks = []
				function onCommitRoot$1() {
					{
						commitHooks.forEach(function (commitHook) {
							return commitHook()
						})
					}
				}
				var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue
				function isLegacyActEnvironment(fiber) {
					{
						var isReactActEnvironmentGlobal =
							// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
							typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : void 0
						var jestIsDefined = typeof jest !== 'undefined'
						return jestIsDefined && isReactActEnvironmentGlobal !== false
					}
				}
				function isConcurrentActEnvironment() {
					{
						var isReactActEnvironmentGlobal =
							// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
							typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : void 0
						if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
							error('The current testing environment is not configured to support act(...)')
						}
						return isReactActEnvironmentGlobal
					}
				}
				var ceil = Math.ceil
				var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
					ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
					ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig,
					ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue
				var NoContext =
					/*             */
					0
				var BatchedContext =
					/*               */
					1
				var RenderContext =
					/*                */
					2
				var CommitContext =
					/*                */
					4
				var RootInProgress = 0
				var RootFatalErrored = 1
				var RootErrored = 2
				var RootSuspended = 3
				var RootSuspendedWithDelay = 4
				var RootCompleted = 5
				var RootDidNotComplete = 6
				var executionContext = NoContext
				var workInProgressRoot = null
				var workInProgress = null
				var workInProgressRootRenderLanes = NoLanes
				var subtreeRenderLanes = NoLanes
				var subtreeRenderLanesCursor = createCursor(NoLanes)
				var workInProgressRootExitStatus = RootInProgress
				var workInProgressRootFatalError = null
				var workInProgressRootIncludedLanes = NoLanes
				var workInProgressRootSkippedLanes = NoLanes
				var workInProgressRootInterleavedUpdatedLanes = NoLanes
				var workInProgressRootPingedLanes = NoLanes
				var workInProgressRootConcurrentErrors = null
				var workInProgressRootRecoverableErrors = null
				var globalMostRecentFallbackTime = 0
				var FALLBACK_THROTTLE_MS = 500
				var workInProgressRootRenderTargetTime = Infinity
				var RENDER_TIMEOUT_MS = 500
				var workInProgressTransitions = null
				function resetRenderTimer() {
					workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS
				}
				function getRenderTargetTime() {
					return workInProgressRootRenderTargetTime
				}
				var hasUncaughtError = false
				var firstUncaughtError = null
				var legacyErrorBoundariesThatAlreadyFailed = null
				var rootDoesHavePassiveEffects = false
				var rootWithPendingPassiveEffects = null
				var pendingPassiveEffectsLanes = NoLanes
				var pendingPassiveProfilerEffects = []
				var pendingPassiveTransitions = null
				var NESTED_UPDATE_LIMIT = 50
				var nestedUpdateCount = 0
				var rootWithNestedUpdates = null
				var isFlushingPassiveEffects = false
				var didScheduleUpdateDuringPassiveEffects = false
				var NESTED_PASSIVE_UPDATE_LIMIT = 50
				var nestedPassiveUpdateCount = 0
				var rootWithPassiveNestedUpdates = null
				var currentEventTime = NoTimestamp
				var currentEventTransitionLane = NoLanes
				var isRunningInsertionEffect = false
				function getWorkInProgressRoot() {
					return workInProgressRoot
				}
				function requestEventTime() {
					if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
						return now()
					}
					if (currentEventTime !== NoTimestamp) {
						return currentEventTime
					}
					currentEventTime = now()
					return currentEventTime
				}
				function requestUpdateLane(fiber) {
					var mode = fiber.mode
					if ((mode & ConcurrentMode) === NoMode) {
						return SyncLane
					} else if (
						(executionContext & RenderContext) !== NoContext &&
						workInProgressRootRenderLanes !== NoLanes
					) {
						return pickArbitraryLane(workInProgressRootRenderLanes)
					}
					var isTransition = requestCurrentTransition() !== NoTransition
					if (isTransition) {
						if (ReactCurrentBatchConfig$3.transition !== null) {
							var transition = ReactCurrentBatchConfig$3.transition
							if (!transition._updatedFibers) {
								transition._updatedFibers = /* @__PURE__ */ new Set()
							}
							transition._updatedFibers.add(fiber)
						}
						if (currentEventTransitionLane === NoLane) {
							currentEventTransitionLane = claimNextTransitionLane()
						}
						return currentEventTransitionLane
					}
					var updateLane = getCurrentUpdatePriority()
					if (updateLane !== NoLane) {
						return updateLane
					}
					var eventLane = getCurrentEventPriority()
					return eventLane
				}
				function requestRetryLane(fiber) {
					var mode = fiber.mode
					if ((mode & ConcurrentMode) === NoMode) {
						return SyncLane
					}
					return claimNextRetryLane()
				}
				function scheduleUpdateOnFiber(root3, fiber, lane, eventTime) {
					checkForNestedUpdates()
					{
						if (isRunningInsertionEffect) {
							error('useInsertionEffect must not schedule updates.')
						}
					}
					{
						if (isFlushingPassiveEffects) {
							didScheduleUpdateDuringPassiveEffects = true
						}
					}
					markRootUpdated(root3, lane, eventTime)
					if ((executionContext & RenderContext) !== NoLanes && root3 === workInProgressRoot) {
						warnAboutRenderPhaseUpdatesInDEV(fiber)
					} else {
						{
							if (isDevToolsPresent) {
								addFiberToLanesMap(root3, fiber, lane)
							}
						}
						warnIfUpdatesNotWrappedWithActDEV(fiber)
						if (root3 === workInProgressRoot) {
							if ((executionContext & RenderContext) === NoContext) {
								workInProgressRootInterleavedUpdatedLanes = mergeLanes(
									workInProgressRootInterleavedUpdatedLanes,
									lane
								)
							}
							if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
								markRootSuspended$1(root3, workInProgressRootRenderLanes)
							}
						}
						ensureRootIsScheduled(root3, eventTime)
						if (
							lane === SyncLane &&
							executionContext === NoContext &&
							(fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
							!ReactCurrentActQueue$1.isBatchingLegacy
						) {
							resetRenderTimer()
							flushSyncCallbacksOnlyInLegacyMode()
						}
					}
				}
				function scheduleInitialHydrationOnRoot(root3, lane, eventTime) {
					var current2 = root3.current
					current2.lanes = lane
					markRootUpdated(root3, lane, eventTime)
					ensureRootIsScheduled(root3, eventTime)
				}
				function isUnsafeClassRenderPhaseUpdate(fiber) {
					return (
						// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
						// decided not to enable it.
						(executionContext & RenderContext) !== NoContext
					)
				}
				function ensureRootIsScheduled(root3, currentTime) {
					var existingCallbackNode = root3.callbackNode
					markStarvedLanesAsExpired(root3, currentTime)
					var nextLanes = getNextLanes(
						root3,
						root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes
					)
					if (nextLanes === NoLanes) {
						if (existingCallbackNode !== null) {
							cancelCallback$1(existingCallbackNode)
						}
						root3.callbackNode = null
						root3.callbackPriority = NoLane
						return
					}
					var newCallbackPriority = getHighestPriorityLane(nextLanes)
					var existingCallbackPriority = root3.callbackPriority
					if (
						existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
						// Scheduler task, rather than an `act` task, cancel it and re-scheduled
						// on the `act` queue.
						!(
							ReactCurrentActQueue$1.current !== null &&
							existingCallbackNode !== fakeActCallbackNode
						)
					) {
						{
							if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
								error(
									'Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.'
								)
							}
						}
						return
					}
					if (existingCallbackNode != null) {
						cancelCallback$1(existingCallbackNode)
					}
					var newCallbackNode
					if (newCallbackPriority === SyncLane) {
						if (root3.tag === LegacyRoot) {
							if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
								ReactCurrentActQueue$1.didScheduleLegacyUpdate = true
							}
							scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root3))
						} else {
							scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3))
						}
						{
							if (ReactCurrentActQueue$1.current !== null) {
								ReactCurrentActQueue$1.current.push(flushSyncCallbacks)
							} else {
								scheduleMicrotask(function () {
									if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
										flushSyncCallbacks()
									}
								})
							}
						}
						newCallbackNode = null
					} else {
						var schedulerPriorityLevel
						switch (lanesToEventPriority(nextLanes)) {
							case DiscreteEventPriority:
								schedulerPriorityLevel = ImmediatePriority
								break
							case ContinuousEventPriority:
								schedulerPriorityLevel = UserBlockingPriority
								break
							case DefaultEventPriority:
								schedulerPriorityLevel = NormalPriority
								break
							case IdleEventPriority:
								schedulerPriorityLevel = IdlePriority
								break
							default:
								schedulerPriorityLevel = NormalPriority
								break
						}
						newCallbackNode = scheduleCallback$1(
							schedulerPriorityLevel,
							performConcurrentWorkOnRoot.bind(null, root3)
						)
					}
					root3.callbackPriority = newCallbackPriority
					root3.callbackNode = newCallbackNode
				}
				function performConcurrentWorkOnRoot(root3, didTimeout) {
					{
						resetNestedUpdateFlag()
					}
					currentEventTime = NoTimestamp
					currentEventTransitionLane = NoLanes
					if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
						throw new Error('Should not already be working.')
					}
					var originalCallbackNode = root3.callbackNode
					var didFlushPassiveEffects = flushPassiveEffects()
					if (didFlushPassiveEffects) {
						if (root3.callbackNode !== originalCallbackNode) {
							return null
						}
					}
					var lanes = getNextLanes(
						root3,
						root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes
					)
					if (lanes === NoLanes) {
						return null
					}
					var shouldTimeSlice =
						!includesBlockingLane(root3, lanes) && !includesExpiredLane(root3, lanes) && !didTimeout
					var exitStatus = shouldTimeSlice
						? renderRootConcurrent(root3, lanes)
						: renderRootSync(root3, lanes)
					if (exitStatus !== RootInProgress) {
						if (exitStatus === RootErrored) {
							var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3)
							if (errorRetryLanes !== NoLanes) {
								lanes = errorRetryLanes
								exitStatus = recoverFromConcurrentError(root3, errorRetryLanes)
							}
						}
						if (exitStatus === RootFatalErrored) {
							var fatalError = workInProgressRootFatalError
							prepareFreshStack(root3, NoLanes)
							markRootSuspended$1(root3, lanes)
							ensureRootIsScheduled(root3, now())
							throw fatalError
						}
						if (exitStatus === RootDidNotComplete) {
							markRootSuspended$1(root3, lanes)
						} else {
							var renderWasConcurrent = !includesBlockingLane(root3, lanes)
							var finishedWork = root3.current.alternate
							if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
								exitStatus = renderRootSync(root3, lanes)
								if (exitStatus === RootErrored) {
									var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3)
									if (_errorRetryLanes !== NoLanes) {
										lanes = _errorRetryLanes
										exitStatus = recoverFromConcurrentError(root3, _errorRetryLanes)
									}
								}
								if (exitStatus === RootFatalErrored) {
									var _fatalError = workInProgressRootFatalError
									prepareFreshStack(root3, NoLanes)
									markRootSuspended$1(root3, lanes)
									ensureRootIsScheduled(root3, now())
									throw _fatalError
								}
							}
							root3.finishedWork = finishedWork
							root3.finishedLanes = lanes
							finishConcurrentRender(root3, exitStatus, lanes)
						}
					}
					ensureRootIsScheduled(root3, now())
					if (root3.callbackNode === originalCallbackNode) {
						return performConcurrentWorkOnRoot.bind(null, root3)
					}
					return null
				}
				function recoverFromConcurrentError(root3, errorRetryLanes) {
					var errorsFromFirstAttempt = workInProgressRootConcurrentErrors
					if (isRootDehydrated(root3)) {
						var rootWorkInProgress = prepareFreshStack(root3, errorRetryLanes)
						rootWorkInProgress.flags |= ForceClientRender
						{
							errorHydratingContainer(root3.containerInfo)
						}
					}
					var exitStatus = renderRootSync(root3, errorRetryLanes)
					if (exitStatus !== RootErrored) {
						var errorsFromSecondAttempt = workInProgressRootRecoverableErrors
						workInProgressRootRecoverableErrors = errorsFromFirstAttempt
						if (errorsFromSecondAttempt !== null) {
							queueRecoverableErrors(errorsFromSecondAttempt)
						}
					}
					return exitStatus
				}
				function queueRecoverableErrors(errors) {
					if (workInProgressRootRecoverableErrors === null) {
						workInProgressRootRecoverableErrors = errors
					} else {
						workInProgressRootRecoverableErrors.push.apply(
							workInProgressRootRecoverableErrors,
							errors
						)
					}
				}
				function finishConcurrentRender(root3, exitStatus, lanes) {
					switch (exitStatus) {
						case RootInProgress:
						case RootFatalErrored: {
							throw new Error('Root did not complete. This is a bug in React.')
						}
						case RootErrored: {
							commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions)
							break
						}
						case RootSuspended: {
							markRootSuspended$1(root3, lanes)
							if (
								includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
								!shouldForceFlushFallbacksInDEV()
							) {
								var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now()
								if (msUntilTimeout > 10) {
									var nextLanes = getNextLanes(root3, NoLanes)
									if (nextLanes !== NoLanes) {
										break
									}
									var suspendedLanes = root3.suspendedLanes
									if (!isSubsetOfLanes(suspendedLanes, lanes)) {
										var eventTime = requestEventTime()
										markRootPinged(root3, suspendedLanes)
										break
									}
									root3.timeoutHandle = scheduleTimeout(
										commitRoot.bind(
											null,
											root3,
											workInProgressRootRecoverableErrors,
											workInProgressTransitions
										),
										msUntilTimeout
									)
									break
								}
							}
							commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions)
							break
						}
						case RootSuspendedWithDelay: {
							markRootSuspended$1(root3, lanes)
							if (includesOnlyTransitions(lanes)) {
								break
							}
							if (!shouldForceFlushFallbacksInDEV()) {
								var mostRecentEventTime = getMostRecentEventTime(root3, lanes)
								var eventTimeMs = mostRecentEventTime
								var timeElapsedMs = now() - eventTimeMs
								var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs
								if (_msUntilTimeout > 10) {
									root3.timeoutHandle = scheduleTimeout(
										commitRoot.bind(
											null,
											root3,
											workInProgressRootRecoverableErrors,
											workInProgressTransitions
										),
										_msUntilTimeout
									)
									break
								}
							}
							commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions)
							break
						}
						case RootCompleted: {
							commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions)
							break
						}
						default: {
							throw new Error('Unknown root exit status.')
						}
					}
				}
				function isRenderConsistentWithExternalStores(finishedWork) {
					var node = finishedWork
					while (true) {
						if (node.flags & StoreConsistency) {
							var updateQueue = node.updateQueue
							if (updateQueue !== null) {
								var checks = updateQueue.stores
								if (checks !== null) {
									for (var i3 = 0; i3 < checks.length; i3++) {
										var check = checks[i3]
										var getSnapshot = check.getSnapshot
										var renderedValue = check.value
										try {
											if (!objectIs(getSnapshot(), renderedValue)) {
												return false
											}
										} catch (error2) {
											return false
										}
									}
								}
							}
						}
						var child = node.child
						if (node.subtreeFlags & StoreConsistency && child !== null) {
							child.return = node
							node = child
							continue
						}
						if (node === finishedWork) {
							return true
						}
						while (node.sibling === null) {
							if (node.return === null || node.return === finishedWork) {
								return true
							}
							node = node.return
						}
						node.sibling.return = node.return
						node = node.sibling
					}
					return true
				}
				function markRootSuspended$1(root3, suspendedLanes) {
					suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes)
					suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes)
					markRootSuspended(root3, suspendedLanes)
				}
				function performSyncWorkOnRoot(root3) {
					{
						syncNestedUpdateFlag()
					}
					if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
						throw new Error('Should not already be working.')
					}
					flushPassiveEffects()
					var lanes = getNextLanes(root3, NoLanes)
					if (!includesSomeLane(lanes, SyncLane)) {
						ensureRootIsScheduled(root3, now())
						return null
					}
					var exitStatus = renderRootSync(root3, lanes)
					if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
						var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3)
						if (errorRetryLanes !== NoLanes) {
							lanes = errorRetryLanes
							exitStatus = recoverFromConcurrentError(root3, errorRetryLanes)
						}
					}
					if (exitStatus === RootFatalErrored) {
						var fatalError = workInProgressRootFatalError
						prepareFreshStack(root3, NoLanes)
						markRootSuspended$1(root3, lanes)
						ensureRootIsScheduled(root3, now())
						throw fatalError
					}
					if (exitStatus === RootDidNotComplete) {
						throw new Error('Root did not complete. This is a bug in React.')
					}
					var finishedWork = root3.current.alternate
					root3.finishedWork = finishedWork
					root3.finishedLanes = lanes
					commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions)
					ensureRootIsScheduled(root3, now())
					return null
				}
				function flushRoot(root3, lanes) {
					if (lanes !== NoLanes) {
						markRootEntangled(root3, mergeLanes(lanes, SyncLane))
						ensureRootIsScheduled(root3, now())
						if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
							resetRenderTimer()
							flushSyncCallbacks()
						}
					}
				}
				function batchedUpdates$1(fn, a3) {
					var prevExecutionContext = executionContext
					executionContext |= BatchedContext
					try {
						return fn(a3)
					} finally {
						executionContext = prevExecutionContext
						if (
							executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
							!ReactCurrentActQueue$1.isBatchingLegacy
						) {
							resetRenderTimer()
							flushSyncCallbacksOnlyInLegacyMode()
						}
					}
				}
				function discreteUpdates(fn, a3, b3, c3, d3) {
					var previousPriority = getCurrentUpdatePriority()
					var prevTransition = ReactCurrentBatchConfig$3.transition
					try {
						ReactCurrentBatchConfig$3.transition = null
						setCurrentUpdatePriority(DiscreteEventPriority)
						return fn(a3, b3, c3, d3)
					} finally {
						setCurrentUpdatePriority(previousPriority)
						ReactCurrentBatchConfig$3.transition = prevTransition
						if (executionContext === NoContext) {
							resetRenderTimer()
						}
					}
				}
				function flushSync2(fn) {
					if (
						rootWithPendingPassiveEffects !== null &&
						rootWithPendingPassiveEffects.tag === LegacyRoot &&
						(executionContext & (RenderContext | CommitContext)) === NoContext
					) {
						flushPassiveEffects()
					}
					var prevExecutionContext = executionContext
					executionContext |= BatchedContext
					var prevTransition = ReactCurrentBatchConfig$3.transition
					var previousPriority = getCurrentUpdatePriority()
					try {
						ReactCurrentBatchConfig$3.transition = null
						setCurrentUpdatePriority(DiscreteEventPriority)
						if (fn) {
							return fn()
						} else {
							return void 0
						}
					} finally {
						setCurrentUpdatePriority(previousPriority)
						ReactCurrentBatchConfig$3.transition = prevTransition
						executionContext = prevExecutionContext
						if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
							flushSyncCallbacks()
						}
					}
				}
				function isAlreadyRendering() {
					return (executionContext & (RenderContext | CommitContext)) !== NoContext
				}
				function pushRenderLanes(fiber, lanes) {
					push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber)
					subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes)
					workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes)
				}
				function popRenderLanes(fiber) {
					subtreeRenderLanes = subtreeRenderLanesCursor.current
					pop(subtreeRenderLanesCursor, fiber)
				}
				function prepareFreshStack(root3, lanes) {
					root3.finishedWork = null
					root3.finishedLanes = NoLanes
					var timeoutHandle = root3.timeoutHandle
					if (timeoutHandle !== noTimeout) {
						root3.timeoutHandle = noTimeout
						cancelTimeout(timeoutHandle)
					}
					if (workInProgress !== null) {
						var interruptedWork = workInProgress.return
						while (interruptedWork !== null) {
							var current2 = interruptedWork.alternate
							unwindInterruptedWork(current2, interruptedWork)
							interruptedWork = interruptedWork.return
						}
					}
					workInProgressRoot = root3
					var rootWorkInProgress = createWorkInProgress(root3.current, null)
					workInProgress = rootWorkInProgress
					workInProgressRootRenderLanes =
						subtreeRenderLanes =
						workInProgressRootIncludedLanes =
							lanes
					workInProgressRootExitStatus = RootInProgress
					workInProgressRootFatalError = null
					workInProgressRootSkippedLanes = NoLanes
					workInProgressRootInterleavedUpdatedLanes = NoLanes
					workInProgressRootPingedLanes = NoLanes
					workInProgressRootConcurrentErrors = null
					workInProgressRootRecoverableErrors = null
					finishQueueingConcurrentUpdates()
					{
						ReactStrictModeWarnings.discardPendingWarnings()
					}
					return rootWorkInProgress
				}
				function handleError(root3, thrownValue) {
					do {
						var erroredWork = workInProgress
						try {
							resetContextDependencies()
							resetHooksAfterThrow()
							resetCurrentFiber()
							ReactCurrentOwner$2.current = null
							if (erroredWork === null || erroredWork.return === null) {
								workInProgressRootExitStatus = RootFatalErrored
								workInProgressRootFatalError = thrownValue
								workInProgress = null
								return
							}
							if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
								stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true)
							}
							if (enableSchedulingProfiler) {
								markComponentRenderStopped()
								if (
									thrownValue !== null &&
									typeof thrownValue === 'object' &&
									typeof thrownValue.then === 'function'
								) {
									var wakeable = thrownValue
									markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes)
								} else {
									markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes)
								}
							}
							throwException(
								root3,
								erroredWork.return,
								erroredWork,
								thrownValue,
								workInProgressRootRenderLanes
							)
							completeUnitOfWork(erroredWork)
						} catch (yetAnotherThrownValue) {
							thrownValue = yetAnotherThrownValue
							if (workInProgress === erroredWork && erroredWork !== null) {
								erroredWork = erroredWork.return
								workInProgress = erroredWork
							} else {
								erroredWork = workInProgress
							}
							continue
						}
						return
					} while (true)
				}
				function pushDispatcher() {
					var prevDispatcher = ReactCurrentDispatcher$2.current
					ReactCurrentDispatcher$2.current = ContextOnlyDispatcher
					if (prevDispatcher === null) {
						return ContextOnlyDispatcher
					} else {
						return prevDispatcher
					}
				}
				function popDispatcher(prevDispatcher) {
					ReactCurrentDispatcher$2.current = prevDispatcher
				}
				function markCommitTimeOfFallback() {
					globalMostRecentFallbackTime = now()
				}
				function markSkippedUpdateLanes(lane) {
					workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes)
				}
				function renderDidSuspend() {
					if (workInProgressRootExitStatus === RootInProgress) {
						workInProgressRootExitStatus = RootSuspended
					}
				}
				function renderDidSuspendDelayIfPossible() {
					if (
						workInProgressRootExitStatus === RootInProgress ||
						workInProgressRootExitStatus === RootSuspended ||
						workInProgressRootExitStatus === RootErrored
					) {
						workInProgressRootExitStatus = RootSuspendedWithDelay
					}
					if (
						workInProgressRoot !== null &&
						(includesNonIdleWork(workInProgressRootSkippedLanes) ||
							includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))
					) {
						markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes)
					}
				}
				function renderDidError(error2) {
					if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
						workInProgressRootExitStatus = RootErrored
					}
					if (workInProgressRootConcurrentErrors === null) {
						workInProgressRootConcurrentErrors = [error2]
					} else {
						workInProgressRootConcurrentErrors.push(error2)
					}
				}
				function renderHasNotSuspendedYet() {
					return workInProgressRootExitStatus === RootInProgress
				}
				function renderRootSync(root3, lanes) {
					var prevExecutionContext = executionContext
					executionContext |= RenderContext
					var prevDispatcher = pushDispatcher()
					if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
						{
							if (isDevToolsPresent) {
								var memoizedUpdaters = root3.memoizedUpdaters
								if (memoizedUpdaters.size > 0) {
									restorePendingUpdaters(root3, workInProgressRootRenderLanes)
									memoizedUpdaters.clear()
								}
								movePendingFibersToMemoized(root3, lanes)
							}
						}
						workInProgressTransitions = getTransitionsForLanes()
						prepareFreshStack(root3, lanes)
					}
					{
						markRenderStarted(lanes)
					}
					do {
						try {
							workLoopSync()
							break
						} catch (thrownValue) {
							handleError(root3, thrownValue)
						}
					} while (true)
					resetContextDependencies()
					executionContext = prevExecutionContext
					popDispatcher(prevDispatcher)
					if (workInProgress !== null) {
						throw new Error(
							'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.'
						)
					}
					{
						markRenderStopped()
					}
					workInProgressRoot = null
					workInProgressRootRenderLanes = NoLanes
					return workInProgressRootExitStatus
				}
				function workLoopSync() {
					while (workInProgress !== null) {
						performUnitOfWork(workInProgress)
					}
				}
				function renderRootConcurrent(root3, lanes) {
					var prevExecutionContext = executionContext
					executionContext |= RenderContext
					var prevDispatcher = pushDispatcher()
					if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
						{
							if (isDevToolsPresent) {
								var memoizedUpdaters = root3.memoizedUpdaters
								if (memoizedUpdaters.size > 0) {
									restorePendingUpdaters(root3, workInProgressRootRenderLanes)
									memoizedUpdaters.clear()
								}
								movePendingFibersToMemoized(root3, lanes)
							}
						}
						workInProgressTransitions = getTransitionsForLanes()
						resetRenderTimer()
						prepareFreshStack(root3, lanes)
					}
					{
						markRenderStarted(lanes)
					}
					do {
						try {
							workLoopConcurrent()
							break
						} catch (thrownValue) {
							handleError(root3, thrownValue)
						}
					} while (true)
					resetContextDependencies()
					popDispatcher(prevDispatcher)
					executionContext = prevExecutionContext
					if (workInProgress !== null) {
						{
							markRenderYielded()
						}
						return RootInProgress
					} else {
						{
							markRenderStopped()
						}
						workInProgressRoot = null
						workInProgressRootRenderLanes = NoLanes
						return workInProgressRootExitStatus
					}
				}
				function workLoopConcurrent() {
					while (workInProgress !== null && !shouldYield()) {
						performUnitOfWork(workInProgress)
					}
				}
				function performUnitOfWork(unitOfWork) {
					var current2 = unitOfWork.alternate
					setCurrentFiber(unitOfWork)
					var next
					if ((unitOfWork.mode & ProfileMode) !== NoMode) {
						startProfilerTimer(unitOfWork)
						next = beginWork$1(current2, unitOfWork, subtreeRenderLanes)
						stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true)
					} else {
						next = beginWork$1(current2, unitOfWork, subtreeRenderLanes)
					}
					resetCurrentFiber()
					unitOfWork.memoizedProps = unitOfWork.pendingProps
					if (next === null) {
						completeUnitOfWork(unitOfWork)
					} else {
						workInProgress = next
					}
					ReactCurrentOwner$2.current = null
				}
				function completeUnitOfWork(unitOfWork) {
					var completedWork = unitOfWork
					do {
						var current2 = completedWork.alternate
						var returnFiber = completedWork.return
						if ((completedWork.flags & Incomplete) === NoFlags) {
							setCurrentFiber(completedWork)
							var next = void 0
							if ((completedWork.mode & ProfileMode) === NoMode) {
								next = completeWork(current2, completedWork, subtreeRenderLanes)
							} else {
								startProfilerTimer(completedWork)
								next = completeWork(current2, completedWork, subtreeRenderLanes)
								stopProfilerTimerIfRunningAndRecordDelta(completedWork, false)
							}
							resetCurrentFiber()
							if (next !== null) {
								workInProgress = next
								return
							}
						} else {
							var _next = unwindWork(current2, completedWork)
							if (_next !== null) {
								_next.flags &= HostEffectMask
								workInProgress = _next
								return
							}
							if ((completedWork.mode & ProfileMode) !== NoMode) {
								stopProfilerTimerIfRunningAndRecordDelta(completedWork, false)
								var actualDuration = completedWork.actualDuration
								var child = completedWork.child
								while (child !== null) {
									actualDuration += child.actualDuration
									child = child.sibling
								}
								completedWork.actualDuration = actualDuration
							}
							if (returnFiber !== null) {
								returnFiber.flags |= Incomplete
								returnFiber.subtreeFlags = NoFlags
								returnFiber.deletions = null
							} else {
								workInProgressRootExitStatus = RootDidNotComplete
								workInProgress = null
								return
							}
						}
						var siblingFiber = completedWork.sibling
						if (siblingFiber !== null) {
							workInProgress = siblingFiber
							return
						}
						completedWork = returnFiber
						workInProgress = completedWork
					} while (completedWork !== null)
					if (workInProgressRootExitStatus === RootInProgress) {
						workInProgressRootExitStatus = RootCompleted
					}
				}
				function commitRoot(root3, recoverableErrors, transitions) {
					var previousUpdateLanePriority = getCurrentUpdatePriority()
					var prevTransition = ReactCurrentBatchConfig$3.transition
					try {
						ReactCurrentBatchConfig$3.transition = null
						setCurrentUpdatePriority(DiscreteEventPriority)
						commitRootImpl(root3, recoverableErrors, transitions, previousUpdateLanePriority)
					} finally {
						ReactCurrentBatchConfig$3.transition = prevTransition
						setCurrentUpdatePriority(previousUpdateLanePriority)
					}
					return null
				}
				function commitRootImpl(root3, recoverableErrors, transitions, renderPriorityLevel) {
					do {
						flushPassiveEffects()
					} while (rootWithPendingPassiveEffects !== null)
					flushRenderPhaseStrictModeWarningsInDEV()
					if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
						throw new Error('Should not already be working.')
					}
					var finishedWork = root3.finishedWork
					var lanes = root3.finishedLanes
					{
						markCommitStarted(lanes)
					}
					if (finishedWork === null) {
						{
							markCommitStopped()
						}
						return null
					} else {
						{
							if (lanes === NoLanes) {
								error(
									'root.finishedLanes should not be empty during a commit. This is a bug in React.'
								)
							}
						}
					}
					root3.finishedWork = null
					root3.finishedLanes = NoLanes
					if (finishedWork === root3.current) {
						throw new Error(
							'Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.'
						)
					}
					root3.callbackNode = null
					root3.callbackPriority = NoLane
					var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes)
					markRootFinished(root3, remainingLanes)
					if (root3 === workInProgressRoot) {
						workInProgressRoot = null
						workInProgress = null
						workInProgressRootRenderLanes = NoLanes
					}
					if (
						(finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||
						(finishedWork.flags & PassiveMask) !== NoFlags
					) {
						if (!rootDoesHavePassiveEffects) {
							rootDoesHavePassiveEffects = true
							pendingPassiveTransitions = transitions
							scheduleCallback$1(NormalPriority, function () {
								flushPassiveEffects()
								return null
							})
						}
					}
					var subtreeHasEffects =
						(finishedWork.subtreeFlags &
							(BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==
						NoFlags
					var rootHasEffect =
						(finishedWork.flags &
							(BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==
						NoFlags
					if (subtreeHasEffects || rootHasEffect) {
						var prevTransition = ReactCurrentBatchConfig$3.transition
						ReactCurrentBatchConfig$3.transition = null
						var previousPriority = getCurrentUpdatePriority()
						setCurrentUpdatePriority(DiscreteEventPriority)
						var prevExecutionContext = executionContext
						executionContext |= CommitContext
						ReactCurrentOwner$2.current = null
						var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(
							root3,
							finishedWork
						)
						{
							recordCommitTime()
						}
						commitMutationEffects(root3, finishedWork, lanes)
						resetAfterCommit(root3.containerInfo)
						root3.current = finishedWork
						{
							markLayoutEffectsStarted(lanes)
						}
						commitLayoutEffects(finishedWork, root3, lanes)
						{
							markLayoutEffectsStopped()
						}
						requestPaint()
						executionContext = prevExecutionContext
						setCurrentUpdatePriority(previousPriority)
						ReactCurrentBatchConfig$3.transition = prevTransition
					} else {
						root3.current = finishedWork
						{
							recordCommitTime()
						}
					}
					var rootDidHavePassiveEffects = rootDoesHavePassiveEffects
					if (rootDoesHavePassiveEffects) {
						rootDoesHavePassiveEffects = false
						rootWithPendingPassiveEffects = root3
						pendingPassiveEffectsLanes = lanes
					} else {
						{
							nestedPassiveUpdateCount = 0
							rootWithPassiveNestedUpdates = null
						}
					}
					remainingLanes = root3.pendingLanes
					if (remainingLanes === NoLanes) {
						legacyErrorBoundariesThatAlreadyFailed = null
					}
					{
						if (!rootDidHavePassiveEffects) {
							commitDoubleInvokeEffectsInDEV(root3.current, false)
						}
					}
					onCommitRoot(finishedWork.stateNode, renderPriorityLevel)
					{
						if (isDevToolsPresent) {
							root3.memoizedUpdaters.clear()
						}
					}
					{
						onCommitRoot$1()
					}
					ensureRootIsScheduled(root3, now())
					if (recoverableErrors !== null) {
						var onRecoverableError = root3.onRecoverableError
						for (var i3 = 0; i3 < recoverableErrors.length; i3++) {
							var recoverableError = recoverableErrors[i3]
							var componentStack = recoverableError.stack
							var digest = recoverableError.digest
							onRecoverableError(recoverableError.value, {
								componentStack,
								digest,
							})
						}
					}
					if (hasUncaughtError) {
						hasUncaughtError = false
						var error$1 = firstUncaughtError
						firstUncaughtError = null
						throw error$1
					}
					if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root3.tag !== LegacyRoot) {
						flushPassiveEffects()
					}
					remainingLanes = root3.pendingLanes
					if (includesSomeLane(remainingLanes, SyncLane)) {
						{
							markNestedUpdateScheduled()
						}
						if (root3 === rootWithNestedUpdates) {
							nestedUpdateCount++
						} else {
							nestedUpdateCount = 0
							rootWithNestedUpdates = root3
						}
					} else {
						nestedUpdateCount = 0
					}
					flushSyncCallbacks()
					{
						markCommitStopped()
					}
					return null
				}
				function flushPassiveEffects() {
					if (rootWithPendingPassiveEffects !== null) {
						var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes)
						var priority = lowerEventPriority(DefaultEventPriority, renderPriority)
						var prevTransition = ReactCurrentBatchConfig$3.transition
						var previousPriority = getCurrentUpdatePriority()
						try {
							ReactCurrentBatchConfig$3.transition = null
							setCurrentUpdatePriority(priority)
							return flushPassiveEffectsImpl()
						} finally {
							setCurrentUpdatePriority(previousPriority)
							ReactCurrentBatchConfig$3.transition = prevTransition
						}
					}
					return false
				}
				function enqueuePendingPassiveProfilerEffect(fiber) {
					{
						pendingPassiveProfilerEffects.push(fiber)
						if (!rootDoesHavePassiveEffects) {
							rootDoesHavePassiveEffects = true
							scheduleCallback$1(NormalPriority, function () {
								flushPassiveEffects()
								return null
							})
						}
					}
				}
				function flushPassiveEffectsImpl() {
					if (rootWithPendingPassiveEffects === null) {
						return false
					}
					var transitions = pendingPassiveTransitions
					pendingPassiveTransitions = null
					var root3 = rootWithPendingPassiveEffects
					var lanes = pendingPassiveEffectsLanes
					rootWithPendingPassiveEffects = null
					pendingPassiveEffectsLanes = NoLanes
					if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
						throw new Error('Cannot flush passive effects while already rendering.')
					}
					{
						isFlushingPassiveEffects = true
						didScheduleUpdateDuringPassiveEffects = false
					}
					{
						markPassiveEffectsStarted(lanes)
					}
					var prevExecutionContext = executionContext
					executionContext |= CommitContext
					commitPassiveUnmountEffects(root3.current)
					commitPassiveMountEffects(root3, root3.current, lanes, transitions)
					{
						var profilerEffects = pendingPassiveProfilerEffects
						pendingPassiveProfilerEffects = []
						for (var i3 = 0; i3 < profilerEffects.length; i3++) {
							var _fiber = profilerEffects[i3]
							commitPassiveEffectDurations(root3, _fiber)
						}
					}
					{
						markPassiveEffectsStopped()
					}
					{
						commitDoubleInvokeEffectsInDEV(root3.current, true)
					}
					executionContext = prevExecutionContext
					flushSyncCallbacks()
					{
						if (didScheduleUpdateDuringPassiveEffects) {
							if (root3 === rootWithPassiveNestedUpdates) {
								nestedPassiveUpdateCount++
							} else {
								nestedPassiveUpdateCount = 0
								rootWithPassiveNestedUpdates = root3
							}
						} else {
							nestedPassiveUpdateCount = 0
						}
						isFlushingPassiveEffects = false
						didScheduleUpdateDuringPassiveEffects = false
					}
					onPostCommitRoot(root3)
					{
						var stateNode = root3.current.stateNode
						stateNode.effectDuration = 0
						stateNode.passiveEffectDuration = 0
					}
					return true
				}
				function isAlreadyFailedLegacyErrorBoundary(instance) {
					return (
						legacyErrorBoundariesThatAlreadyFailed !== null &&
						legacyErrorBoundariesThatAlreadyFailed.has(instance)
					)
				}
				function markLegacyErrorBoundaryAsFailed(instance) {
					if (legacyErrorBoundariesThatAlreadyFailed === null) {
						legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance])
					} else {
						legacyErrorBoundariesThatAlreadyFailed.add(instance)
					}
				}
				function prepareToThrowUncaughtError(error2) {
					if (!hasUncaughtError) {
						hasUncaughtError = true
						firstUncaughtError = error2
					}
				}
				var onUncaughtError = prepareToThrowUncaughtError
				function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
					var errorInfo = createCapturedValueAtFiber(error2, sourceFiber)
					var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane)
					var root3 = enqueueUpdate(rootFiber, update, SyncLane)
					var eventTime = requestEventTime()
					if (root3 !== null) {
						markRootUpdated(root3, SyncLane, eventTime)
						ensureRootIsScheduled(root3, eventTime)
					}
				}
				function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
					{
						reportUncaughtErrorInDEV(error$1)
						setIsRunningInsertionEffect(false)
					}
					if (sourceFiber.tag === HostRoot) {
						captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1)
						return
					}
					var fiber = null
					{
						fiber = nearestMountedAncestor
					}
					while (fiber !== null) {
						if (fiber.tag === HostRoot) {
							captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1)
							return
						} else if (fiber.tag === ClassComponent) {
							var ctor = fiber.type
							var instance = fiber.stateNode
							if (
								typeof ctor.getDerivedStateFromError === 'function' ||
								(typeof instance.componentDidCatch === 'function' &&
									!isAlreadyFailedLegacyErrorBoundary(instance))
							) {
								var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber)
								var update = createClassErrorUpdate(fiber, errorInfo, SyncLane)
								var root3 = enqueueUpdate(fiber, update, SyncLane)
								var eventTime = requestEventTime()
								if (root3 !== null) {
									markRootUpdated(root3, SyncLane, eventTime)
									ensureRootIsScheduled(root3, eventTime)
								}
								return
							}
						}
						fiber = fiber.return
					}
					{
						error(
							'Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s',
							error$1
						)
					}
				}
				function pingSuspendedRoot(root3, wakeable, pingedLanes) {
					var pingCache = root3.pingCache
					if (pingCache !== null) {
						pingCache.delete(wakeable)
					}
					var eventTime = requestEventTime()
					markRootPinged(root3, pingedLanes)
					warnIfSuspenseResolutionNotWrappedWithActDEV(root3)
					if (
						workInProgressRoot === root3 &&
						isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)
					) {
						if (
							workInProgressRootExitStatus === RootSuspendedWithDelay ||
							(workInProgressRootExitStatus === RootSuspended &&
								includesOnlyRetries(workInProgressRootRenderLanes) &&
								now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
						) {
							prepareFreshStack(root3, NoLanes)
						} else {
							workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes)
						}
					}
					ensureRootIsScheduled(root3, eventTime)
				}
				function retryTimedOutBoundary(boundaryFiber, retryLane) {
					if (retryLane === NoLane) {
						retryLane = requestRetryLane(boundaryFiber)
					}
					var eventTime = requestEventTime()
					var root3 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane)
					if (root3 !== null) {
						markRootUpdated(root3, retryLane, eventTime)
						ensureRootIsScheduled(root3, eventTime)
					}
				}
				function retryDehydratedSuspenseBoundary(boundaryFiber) {
					var suspenseState = boundaryFiber.memoizedState
					var retryLane = NoLane
					if (suspenseState !== null) {
						retryLane = suspenseState.retryLane
					}
					retryTimedOutBoundary(boundaryFiber, retryLane)
				}
				function resolveRetryWakeable(boundaryFiber, wakeable) {
					var retryLane = NoLane
					var retryCache
					switch (boundaryFiber.tag) {
						case SuspenseComponent:
							retryCache = boundaryFiber.stateNode
							var suspenseState = boundaryFiber.memoizedState
							if (suspenseState !== null) {
								retryLane = suspenseState.retryLane
							}
							break
						case SuspenseListComponent:
							retryCache = boundaryFiber.stateNode
							break
						default:
							throw new Error(
								'Pinged unknown suspense boundary type. This is probably a bug in React.'
							)
					}
					if (retryCache !== null) {
						retryCache.delete(wakeable)
					}
					retryTimedOutBoundary(boundaryFiber, retryLane)
				}
				function jnd(timeElapsed) {
					return timeElapsed < 120
						? 120
						: timeElapsed < 480
						? 480
						: timeElapsed < 1080
						? 1080
						: timeElapsed < 1920
						? 1920
						: timeElapsed < 3e3
						? 3e3
						: timeElapsed < 4320
						? 4320
						: ceil(timeElapsed / 1960) * 1960
				}
				function checkForNestedUpdates() {
					if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
						nestedUpdateCount = 0
						rootWithNestedUpdates = null
						throw new Error(
							'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.'
						)
					}
					{
						if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
							nestedPassiveUpdateCount = 0
							rootWithPassiveNestedUpdates = null
							error(
								"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
							)
						}
					}
				}
				function flushRenderPhaseStrictModeWarningsInDEV() {
					{
						ReactStrictModeWarnings.flushLegacyContextWarning()
						{
							ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings()
						}
					}
				}
				function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
					{
						setCurrentFiber(fiber)
						invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV)
						if (hasPassiveEffects) {
							invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV)
						}
						invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV)
						if (hasPassiveEffects) {
							invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV)
						}
						resetCurrentFiber()
					}
				}
				function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
					{
						var current2 = firstChild
						var subtreeRoot = null
						while (current2 !== null) {
							var primarySubtreeFlag = current2.subtreeFlags & fiberFlags
							if (
								current2 !== subtreeRoot &&
								current2.child !== null &&
								primarySubtreeFlag !== NoFlags
							) {
								current2 = current2.child
							} else {
								if ((current2.flags & fiberFlags) !== NoFlags) {
									invokeEffectFn(current2)
								}
								if (current2.sibling !== null) {
									current2 = current2.sibling
								} else {
									current2 = subtreeRoot = current2.return
								}
							}
						}
					}
				}
				var didWarnStateUpdateForNotYetMountedComponent = null
				function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
					{
						if ((executionContext & RenderContext) !== NoContext) {
							return
						}
						if (!(fiber.mode & ConcurrentMode)) {
							return
						}
						var tag = fiber.tag
						if (
							tag !== IndeterminateComponent &&
							tag !== HostRoot &&
							tag !== ClassComponent &&
							tag !== FunctionComponent &&
							tag !== ForwardRef &&
							tag !== MemoComponent &&
							tag !== SimpleMemoComponent
						) {
							return
						}
						var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent'
						if (didWarnStateUpdateForNotYetMountedComponent !== null) {
							if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
								return
							}
							didWarnStateUpdateForNotYetMountedComponent.add(componentName)
						} else {
							didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName])
						}
						var previousFiber = current
						try {
							setCurrentFiber(fiber)
							error(
								"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
							)
						} finally {
							if (previousFiber) {
								setCurrentFiber(fiber)
							} else {
								resetCurrentFiber()
							}
						}
					}
				}
				var beginWork$1
				{
					var dummyFiber = null
					beginWork$1 = function (current2, unitOfWork, lanes) {
						var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork)
						try {
							return beginWork(current2, unitOfWork, lanes)
						} catch (originalError) {
							if (
								didSuspendOrErrorWhileHydratingDEV() ||
								(originalError !== null &&
									typeof originalError === 'object' &&
									typeof originalError.then === 'function')
							) {
								throw originalError
							}
							resetContextDependencies()
							resetHooksAfterThrow()
							unwindInterruptedWork(current2, unitOfWork)
							assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy)
							if (unitOfWork.mode & ProfileMode) {
								startProfilerTimer(unitOfWork)
							}
							invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes)
							if (hasCaughtError()) {
								var replayError = clearCaughtError()
								if (
									typeof replayError === 'object' &&
									replayError !== null &&
									replayError._suppressLogging &&
									typeof originalError === 'object' &&
									originalError !== null &&
									!originalError._suppressLogging
								) {
									originalError._suppressLogging = true
								}
							}
							throw originalError
						}
					}
				}
				var didWarnAboutUpdateInRender = false
				var didWarnAboutUpdateInRenderForAnotherComponent
				{
					didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set()
				}
				function warnAboutRenderPhaseUpdatesInDEV(fiber) {
					{
						if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
							switch (fiber.tag) {
								case FunctionComponent:
								case ForwardRef:
								case SimpleMemoComponent: {
									var renderingComponentName =
										(workInProgress && getComponentNameFromFiber(workInProgress)) || 'Unknown'
									var dedupeKey = renderingComponentName
									if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
										didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey)
										var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown'
										error(
											'Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render',
											setStateComponentName,
											renderingComponentName,
											renderingComponentName
										)
									}
									break
								}
								case ClassComponent: {
									if (!didWarnAboutUpdateInRender) {
										error(
											'Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.'
										)
										didWarnAboutUpdateInRender = true
									}
									break
								}
							}
						}
					}
				}
				function restorePendingUpdaters(root3, lanes) {
					{
						if (isDevToolsPresent) {
							var memoizedUpdaters = root3.memoizedUpdaters
							memoizedUpdaters.forEach(function (schedulingFiber) {
								addFiberToLanesMap(root3, schedulingFiber, lanes)
							})
						}
					}
				}
				var fakeActCallbackNode = {}
				function scheduleCallback$1(priorityLevel, callback) {
					{
						var actQueue = ReactCurrentActQueue$1.current
						if (actQueue !== null) {
							actQueue.push(callback)
							return fakeActCallbackNode
						} else {
							return scheduleCallback(priorityLevel, callback)
						}
					}
				}
				function cancelCallback$1(callbackNode) {
					if (callbackNode === fakeActCallbackNode) {
						return
					}
					return cancelCallback(callbackNode)
				}
				function shouldForceFlushFallbacksInDEV() {
					return ReactCurrentActQueue$1.current !== null
				}
				function warnIfUpdatesNotWrappedWithActDEV(fiber) {
					{
						if (fiber.mode & ConcurrentMode) {
							if (!isConcurrentActEnvironment()) {
								return
							}
						} else {
							if (!isLegacyActEnvironment()) {
								return
							}
							if (executionContext !== NoContext) {
								return
							}
							if (
								fiber.tag !== FunctionComponent &&
								fiber.tag !== ForwardRef &&
								fiber.tag !== SimpleMemoComponent
							) {
								return
							}
						}
						if (ReactCurrentActQueue$1.current === null) {
							var previousFiber = current
							try {
								setCurrentFiber(fiber)
								error(
									"An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act",
									getComponentNameFromFiber(fiber)
								)
							} finally {
								if (previousFiber) {
									setCurrentFiber(fiber)
								} else {
									resetCurrentFiber()
								}
							}
						}
					}
				}
				function warnIfSuspenseResolutionNotWrappedWithActDEV(root3) {
					{
						if (
							root3.tag !== LegacyRoot &&
							isConcurrentActEnvironment() &&
							ReactCurrentActQueue$1.current === null
						) {
							error(
								"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act"
							)
						}
					}
				}
				function setIsRunningInsertionEffect(isRunning) {
					{
						isRunningInsertionEffect = isRunning
					}
				}
				var resolveFamily = null
				var failedBoundaries = null
				var setRefreshHandler = function (handler) {
					{
						resolveFamily = handler
					}
				}
				function resolveFunctionForHotReloading(type) {
					{
						if (resolveFamily === null) {
							return type
						}
						var family = resolveFamily(type)
						if (family === void 0) {
							return type
						}
						return family.current
					}
				}
				function resolveClassForHotReloading(type) {
					return resolveFunctionForHotReloading(type)
				}
				function resolveForwardRefForHotReloading(type) {
					{
						if (resolveFamily === null) {
							return type
						}
						var family = resolveFamily(type)
						if (family === void 0) {
							if (type !== null && type !== void 0 && typeof type.render === 'function') {
								var currentRender = resolveFunctionForHotReloading(type.render)
								if (type.render !== currentRender) {
									var syntheticType = {
										$$typeof: REACT_FORWARD_REF_TYPE,
										render: currentRender,
									}
									if (type.displayName !== void 0) {
										syntheticType.displayName = type.displayName
									}
									return syntheticType
								}
							}
							return type
						}
						return family.current
					}
				}
				function isCompatibleFamilyForHotReloading(fiber, element) {
					{
						if (resolveFamily === null) {
							return false
						}
						var prevType = fiber.elementType
						var nextType = element.type
						var needsCompareFamilies = false
						var $$typeofNextType =
							typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null
						switch (fiber.tag) {
							case ClassComponent: {
								if (typeof nextType === 'function') {
									needsCompareFamilies = true
								}
								break
							}
							case FunctionComponent: {
								if (typeof nextType === 'function') {
									needsCompareFamilies = true
								} else if ($$typeofNextType === REACT_LAZY_TYPE) {
									needsCompareFamilies = true
								}
								break
							}
							case ForwardRef: {
								if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
									needsCompareFamilies = true
								} else if ($$typeofNextType === REACT_LAZY_TYPE) {
									needsCompareFamilies = true
								}
								break
							}
							case MemoComponent:
							case SimpleMemoComponent: {
								if ($$typeofNextType === REACT_MEMO_TYPE) {
									needsCompareFamilies = true
								} else if ($$typeofNextType === REACT_LAZY_TYPE) {
									needsCompareFamilies = true
								}
								break
							}
							default:
								return false
						}
						if (needsCompareFamilies) {
							var prevFamily = resolveFamily(prevType)
							if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
								return true
							}
						}
						return false
					}
				}
				function markFailedErrorBoundaryForHotReloading(fiber) {
					{
						if (resolveFamily === null) {
							return
						}
						if (typeof WeakSet !== 'function') {
							return
						}
						if (failedBoundaries === null) {
							failedBoundaries = /* @__PURE__ */ new WeakSet()
						}
						failedBoundaries.add(fiber)
					}
				}
				var scheduleRefresh = function (root3, update) {
					{
						if (resolveFamily === null) {
							return
						}
						var staleFamilies = update.staleFamilies,
							updatedFamilies = update.updatedFamilies
						flushPassiveEffects()
						flushSync2(function () {
							scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies)
						})
					}
				}
				var scheduleRoot = function (root3, element) {
					{
						if (root3.context !== emptyContextObject) {
							return
						}
						flushPassiveEffects()
						flushSync2(function () {
							updateContainer(element, root3, null, null)
						})
					}
				}
				function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
					{
						var alternate = fiber.alternate,
							child = fiber.child,
							sibling = fiber.sibling,
							tag = fiber.tag,
							type = fiber.type
						var candidateType = null
						switch (tag) {
							case FunctionComponent:
							case SimpleMemoComponent:
							case ClassComponent:
								candidateType = type
								break
							case ForwardRef:
								candidateType = type.render
								break
						}
						if (resolveFamily === null) {
							throw new Error('Expected resolveFamily to be set during hot reload.')
						}
						var needsRender = false
						var needsRemount = false
						if (candidateType !== null) {
							var family = resolveFamily(candidateType)
							if (family !== void 0) {
								if (staleFamilies.has(family)) {
									needsRemount = true
								} else if (updatedFamilies.has(family)) {
									if (tag === ClassComponent) {
										needsRemount = true
									} else {
										needsRender = true
									}
								}
							}
						}
						if (failedBoundaries !== null) {
							if (
								failedBoundaries.has(fiber) ||
								(alternate !== null && failedBoundaries.has(alternate))
							) {
								needsRemount = true
							}
						}
						if (needsRemount) {
							fiber._debugNeedsRemount = true
						}
						if (needsRemount || needsRender) {
							var _root = enqueueConcurrentRenderForLane(fiber, SyncLane)
							if (_root !== null) {
								scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp)
							}
						}
						if (child !== null && !needsRemount) {
							scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies)
						}
						if (sibling !== null) {
							scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies)
						}
					}
				}
				var findHostInstancesForRefresh = function (root3, families) {
					{
						var hostInstances = /* @__PURE__ */ new Set()
						var types = new Set(
							families.map(function (family) {
								return family.current
							})
						)
						findHostInstancesForMatchingFibersRecursively(root3.current, types, hostInstances)
						return hostInstances
					}
				}
				function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
					{
						var child = fiber.child,
							sibling = fiber.sibling,
							tag = fiber.tag,
							type = fiber.type
						var candidateType = null
						switch (tag) {
							case FunctionComponent:
							case SimpleMemoComponent:
							case ClassComponent:
								candidateType = type
								break
							case ForwardRef:
								candidateType = type.render
								break
						}
						var didMatch = false
						if (candidateType !== null) {
							if (types.has(candidateType)) {
								didMatch = true
							}
						}
						if (didMatch) {
							findHostInstancesForFiberShallowly(fiber, hostInstances)
						} else {
							if (child !== null) {
								findHostInstancesForMatchingFibersRecursively(child, types, hostInstances)
							}
						}
						if (sibling !== null) {
							findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances)
						}
					}
				}
				function findHostInstancesForFiberShallowly(fiber, hostInstances) {
					{
						var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances)
						if (foundHostInstances) {
							return
						}
						var node = fiber
						while (true) {
							switch (node.tag) {
								case HostComponent:
									hostInstances.add(node.stateNode)
									return
								case HostPortal:
									hostInstances.add(node.stateNode.containerInfo)
									return
								case HostRoot:
									hostInstances.add(node.stateNode.containerInfo)
									return
							}
							if (node.return === null) {
								throw new Error('Expected to reach root first.')
							}
							node = node.return
						}
					}
				}
				function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
					{
						var node = fiber
						var foundHostInstances = false
						while (true) {
							if (node.tag === HostComponent) {
								foundHostInstances = true
								hostInstances.add(node.stateNode)
							} else if (node.child !== null) {
								node.child.return = node
								node = node.child
								continue
							}
							if (node === fiber) {
								return foundHostInstances
							}
							while (node.sibling === null) {
								if (node.return === null || node.return === fiber) {
									return foundHostInstances
								}
								node = node.return
							}
							node.sibling.return = node.return
							node = node.sibling
						}
					}
					return false
				}
				var hasBadMapPolyfill
				{
					hasBadMapPolyfill = false
					try {
						var nonExtensibleObject = Object.preventExtensions({})
						/* @__PURE__ */ new Map([[nonExtensibleObject, null]])
						/* @__PURE__ */ new Set([nonExtensibleObject])
					} catch (e2) {
						hasBadMapPolyfill = true
					}
				}
				function FiberNode(tag, pendingProps, key, mode) {
					this.tag = tag
					this.key = key
					this.elementType = null
					this.type = null
					this.stateNode = null
					this.return = null
					this.child = null
					this.sibling = null
					this.index = 0
					this.ref = null
					this.pendingProps = pendingProps
					this.memoizedProps = null
					this.updateQueue = null
					this.memoizedState = null
					this.dependencies = null
					this.mode = mode
					this.flags = NoFlags
					this.subtreeFlags = NoFlags
					this.deletions = null
					this.lanes = NoLanes
					this.childLanes = NoLanes
					this.alternate = null
					{
						this.actualDuration = Number.NaN
						this.actualStartTime = Number.NaN
						this.selfBaseDuration = Number.NaN
						this.treeBaseDuration = Number.NaN
						this.actualDuration = 0
						this.actualStartTime = -1
						this.selfBaseDuration = 0
						this.treeBaseDuration = 0
					}
					{
						this._debugSource = null
						this._debugOwner = null
						this._debugNeedsRemount = false
						this._debugHookTypes = null
						if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
							Object.preventExtensions(this)
						}
					}
				}
				var createFiber = function (tag, pendingProps, key, mode) {
					return new FiberNode(tag, pendingProps, key, mode)
				}
				function shouldConstruct$1(Component3) {
					var prototype = Component3.prototype
					return !!(prototype && prototype.isReactComponent)
				}
				function isSimpleFunctionComponent(type) {
					return (
						typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === void 0
					)
				}
				function resolveLazyComponentTag(Component3) {
					if (typeof Component3 === 'function') {
						return shouldConstruct$1(Component3) ? ClassComponent : FunctionComponent
					} else if (Component3 !== void 0 && Component3 !== null) {
						var $$typeof = Component3.$$typeof
						if ($$typeof === REACT_FORWARD_REF_TYPE) {
							return ForwardRef
						}
						if ($$typeof === REACT_MEMO_TYPE) {
							return MemoComponent
						}
					}
					return IndeterminateComponent
				}
				function createWorkInProgress(current2, pendingProps) {
					var workInProgress2 = current2.alternate
					if (workInProgress2 === null) {
						workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode)
						workInProgress2.elementType = current2.elementType
						workInProgress2.type = current2.type
						workInProgress2.stateNode = current2.stateNode
						{
							workInProgress2._debugSource = current2._debugSource
							workInProgress2._debugOwner = current2._debugOwner
							workInProgress2._debugHookTypes = current2._debugHookTypes
						}
						workInProgress2.alternate = current2
						current2.alternate = workInProgress2
					} else {
						workInProgress2.pendingProps = pendingProps
						workInProgress2.type = current2.type
						workInProgress2.flags = NoFlags
						workInProgress2.subtreeFlags = NoFlags
						workInProgress2.deletions = null
						{
							workInProgress2.actualDuration = 0
							workInProgress2.actualStartTime = -1
						}
					}
					workInProgress2.flags = current2.flags & StaticMask
					workInProgress2.childLanes = current2.childLanes
					workInProgress2.lanes = current2.lanes
					workInProgress2.child = current2.child
					workInProgress2.memoizedProps = current2.memoizedProps
					workInProgress2.memoizedState = current2.memoizedState
					workInProgress2.updateQueue = current2.updateQueue
					var currentDependencies = current2.dependencies
					workInProgress2.dependencies =
						currentDependencies === null
							? null
							: {
									lanes: currentDependencies.lanes,
									firstContext: currentDependencies.firstContext,
							  }
					workInProgress2.sibling = current2.sibling
					workInProgress2.index = current2.index
					workInProgress2.ref = current2.ref
					{
						workInProgress2.selfBaseDuration = current2.selfBaseDuration
						workInProgress2.treeBaseDuration = current2.treeBaseDuration
					}
					{
						workInProgress2._debugNeedsRemount = current2._debugNeedsRemount
						switch (workInProgress2.tag) {
							case IndeterminateComponent:
							case FunctionComponent:
							case SimpleMemoComponent:
								workInProgress2.type = resolveFunctionForHotReloading(current2.type)
								break
							case ClassComponent:
								workInProgress2.type = resolveClassForHotReloading(current2.type)
								break
							case ForwardRef:
								workInProgress2.type = resolveForwardRefForHotReloading(current2.type)
								break
						}
					}
					return workInProgress2
				}
				function resetWorkInProgress(workInProgress2, renderLanes2) {
					workInProgress2.flags &= StaticMask | Placement
					var current2 = workInProgress2.alternate
					if (current2 === null) {
						workInProgress2.childLanes = NoLanes
						workInProgress2.lanes = renderLanes2
						workInProgress2.child = null
						workInProgress2.subtreeFlags = NoFlags
						workInProgress2.memoizedProps = null
						workInProgress2.memoizedState = null
						workInProgress2.updateQueue = null
						workInProgress2.dependencies = null
						workInProgress2.stateNode = null
						{
							workInProgress2.selfBaseDuration = 0
							workInProgress2.treeBaseDuration = 0
						}
					} else {
						workInProgress2.childLanes = current2.childLanes
						workInProgress2.lanes = current2.lanes
						workInProgress2.child = current2.child
						workInProgress2.subtreeFlags = NoFlags
						workInProgress2.deletions = null
						workInProgress2.memoizedProps = current2.memoizedProps
						workInProgress2.memoizedState = current2.memoizedState
						workInProgress2.updateQueue = current2.updateQueue
						workInProgress2.type = current2.type
						var currentDependencies = current2.dependencies
						workInProgress2.dependencies =
							currentDependencies === null
								? null
								: {
										lanes: currentDependencies.lanes,
										firstContext: currentDependencies.firstContext,
								  }
						{
							workInProgress2.selfBaseDuration = current2.selfBaseDuration
							workInProgress2.treeBaseDuration = current2.treeBaseDuration
						}
					}
					return workInProgress2
				}
				function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
					var mode
					if (tag === ConcurrentRoot) {
						mode = ConcurrentMode
						if (isStrictMode === true) {
							mode |= StrictLegacyMode
							{
								mode |= StrictEffectsMode
							}
						}
					} else {
						mode = NoMode
					}
					if (isDevToolsPresent) {
						mode |= ProfileMode
					}
					return createFiber(HostRoot, null, null, mode)
				}
				function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
					var fiberTag = IndeterminateComponent
					var resolvedType = type
					if (typeof type === 'function') {
						if (shouldConstruct$1(type)) {
							fiberTag = ClassComponent
							{
								resolvedType = resolveClassForHotReloading(resolvedType)
							}
						} else {
							{
								resolvedType = resolveFunctionForHotReloading(resolvedType)
							}
						}
					} else if (typeof type === 'string') {
						fiberTag = HostComponent
					} else {
						getTag: switch (type) {
							case REACT_FRAGMENT_TYPE:
								return createFiberFromFragment(pendingProps.children, mode, lanes, key)
							case REACT_STRICT_MODE_TYPE:
								fiberTag = Mode
								mode |= StrictLegacyMode
								if ((mode & ConcurrentMode) !== NoMode) {
									mode |= StrictEffectsMode
								}
								break
							case REACT_PROFILER_TYPE:
								return createFiberFromProfiler(pendingProps, mode, lanes, key)
							case REACT_SUSPENSE_TYPE:
								return createFiberFromSuspense(pendingProps, mode, lanes, key)
							case REACT_SUSPENSE_LIST_TYPE:
								return createFiberFromSuspenseList(pendingProps, mode, lanes, key)
							case REACT_OFFSCREEN_TYPE:
								return createFiberFromOffscreen(pendingProps, mode, lanes, key)
							case REACT_LEGACY_HIDDEN_TYPE:
							case REACT_SCOPE_TYPE:
							case REACT_CACHE_TYPE:
							case REACT_TRACING_MARKER_TYPE:
							case REACT_DEBUG_TRACING_MODE_TYPE:
							default: {
								if (typeof type === 'object' && type !== null) {
									switch (type.$$typeof) {
										case REACT_PROVIDER_TYPE:
											fiberTag = ContextProvider
											break getTag
										case REACT_CONTEXT_TYPE:
											fiberTag = ContextConsumer
											break getTag
										case REACT_FORWARD_REF_TYPE:
											fiberTag = ForwardRef
											{
												resolvedType = resolveForwardRefForHotReloading(resolvedType)
											}
											break getTag
										case REACT_MEMO_TYPE:
											fiberTag = MemoComponent
											break getTag
										case REACT_LAZY_TYPE:
											fiberTag = LazyComponent
											resolvedType = null
											break getTag
									}
								}
								var info = ''
								{
									if (
										type === void 0 ||
										(typeof type === 'object' && type !== null && Object.keys(type).length === 0)
									) {
										info +=
											" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."
									}
									var ownerName = owner ? getComponentNameFromFiber(owner) : null
									if (ownerName) {
										info += '\n\nCheck the render method of `' + ownerName + '`.'
									}
								}
								throw new Error(
									'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) ' +
										('but got: ' + (type == null ? type : typeof type) + '.' + info)
								)
							}
						}
					}
					var fiber = createFiber(fiberTag, pendingProps, key, mode)
					fiber.elementType = type
					fiber.type = resolvedType
					fiber.lanes = lanes
					{
						fiber._debugOwner = owner
					}
					return fiber
				}
				function createFiberFromElement(element, mode, lanes) {
					var owner = null
					{
						owner = element._owner
					}
					var type = element.type
					var key = element.key
					var pendingProps = element.props
					var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes)
					{
						fiber._debugSource = element._source
						fiber._debugOwner = element._owner
					}
					return fiber
				}
				function createFiberFromFragment(elements, mode, lanes, key) {
					var fiber = createFiber(Fragment41, elements, key, mode)
					fiber.lanes = lanes
					return fiber
				}
				function createFiberFromProfiler(pendingProps, mode, lanes, key) {
					{
						if (typeof pendingProps.id !== 'string') {
							error(
								'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
								typeof pendingProps.id
							)
						}
					}
					var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode)
					fiber.elementType = REACT_PROFILER_TYPE
					fiber.lanes = lanes
					{
						fiber.stateNode = {
							effectDuration: 0,
							passiveEffectDuration: 0,
						}
					}
					return fiber
				}
				function createFiberFromSuspense(pendingProps, mode, lanes, key) {
					var fiber = createFiber(SuspenseComponent, pendingProps, key, mode)
					fiber.elementType = REACT_SUSPENSE_TYPE
					fiber.lanes = lanes
					return fiber
				}
				function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
					var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode)
					fiber.elementType = REACT_SUSPENSE_LIST_TYPE
					fiber.lanes = lanes
					return fiber
				}
				function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
					var fiber = createFiber(OffscreenComponent, pendingProps, key, mode)
					fiber.elementType = REACT_OFFSCREEN_TYPE
					fiber.lanes = lanes
					var primaryChildInstance = {
						isHidden: false,
					}
					fiber.stateNode = primaryChildInstance
					return fiber
				}
				function createFiberFromText(content, mode, lanes) {
					var fiber = createFiber(HostText, content, null, mode)
					fiber.lanes = lanes
					return fiber
				}
				function createFiberFromHostInstanceForDeletion() {
					var fiber = createFiber(HostComponent, null, null, NoMode)
					fiber.elementType = 'DELETED'
					return fiber
				}
				function createFiberFromDehydratedFragment(dehydratedNode) {
					var fiber = createFiber(DehydratedFragment, null, null, NoMode)
					fiber.stateNode = dehydratedNode
					return fiber
				}
				function createFiberFromPortal(portal, mode, lanes) {
					var pendingProps = portal.children !== null ? portal.children : []
					var fiber = createFiber(HostPortal, pendingProps, portal.key, mode)
					fiber.lanes = lanes
					fiber.stateNode = {
						containerInfo: portal.containerInfo,
						pendingChildren: null,
						// Used by persistent updates
						implementation: portal.implementation,
					}
					return fiber
				}
				function assignFiberPropertiesInDEV(target, source) {
					if (target === null) {
						target = createFiber(IndeterminateComponent, null, null, NoMode)
					}
					target.tag = source.tag
					target.key = source.key
					target.elementType = source.elementType
					target.type = source.type
					target.stateNode = source.stateNode
					target.return = source.return
					target.child = source.child
					target.sibling = source.sibling
					target.index = source.index
					target.ref = source.ref
					target.pendingProps = source.pendingProps
					target.memoizedProps = source.memoizedProps
					target.updateQueue = source.updateQueue
					target.memoizedState = source.memoizedState
					target.dependencies = source.dependencies
					target.mode = source.mode
					target.flags = source.flags
					target.subtreeFlags = source.subtreeFlags
					target.deletions = source.deletions
					target.lanes = source.lanes
					target.childLanes = source.childLanes
					target.alternate = source.alternate
					{
						target.actualDuration = source.actualDuration
						target.actualStartTime = source.actualStartTime
						target.selfBaseDuration = source.selfBaseDuration
						target.treeBaseDuration = source.treeBaseDuration
					}
					target._debugSource = source._debugSource
					target._debugOwner = source._debugOwner
					target._debugNeedsRemount = source._debugNeedsRemount
					target._debugHookTypes = source._debugHookTypes
					return target
				}
				function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
					this.tag = tag
					this.containerInfo = containerInfo
					this.pendingChildren = null
					this.current = null
					this.pingCache = null
					this.finishedWork = null
					this.timeoutHandle = noTimeout
					this.context = null
					this.pendingContext = null
					this.callbackNode = null
					this.callbackPriority = NoLane
					this.eventTimes = createLaneMap(NoLanes)
					this.expirationTimes = createLaneMap(NoTimestamp)
					this.pendingLanes = NoLanes
					this.suspendedLanes = NoLanes
					this.pingedLanes = NoLanes
					this.expiredLanes = NoLanes
					this.mutableReadLanes = NoLanes
					this.finishedLanes = NoLanes
					this.entangledLanes = NoLanes
					this.entanglements = createLaneMap(NoLanes)
					this.identifierPrefix = identifierPrefix
					this.onRecoverableError = onRecoverableError
					{
						this.mutableSourceEagerHydrationData = null
					}
					{
						this.effectDuration = 0
						this.passiveEffectDuration = 0
					}
					{
						this.memoizedUpdaters = /* @__PURE__ */ new Set()
						var pendingUpdatersLaneMap = (this.pendingUpdatersLaneMap = [])
						for (var _i = 0; _i < TotalLanes; _i++) {
							pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set())
						}
					}
					{
						switch (tag) {
							case ConcurrentRoot:
								this._debugRootType = hydrate2 ? 'hydrateRoot()' : 'createRoot()'
								break
							case LegacyRoot:
								this._debugRootType = hydrate2 ? 'hydrate()' : 'render()'
								break
						}
					}
				}
				function createFiberRoot(
					containerInfo,
					tag,
					hydrate2,
					initialChildren,
					hydrationCallbacks,
					isStrictMode,
					concurrentUpdatesByDefaultOverride,
					identifierPrefix,
					onRecoverableError,
					transitionCallbacks
				) {
					var root3 = new FiberRootNode(
						containerInfo,
						tag,
						hydrate2,
						identifierPrefix,
						onRecoverableError
					)
					var uninitializedFiber = createHostRootFiber(tag, isStrictMode)
					root3.current = uninitializedFiber
					uninitializedFiber.stateNode = root3
					{
						var _initialState = {
							element: initialChildren,
							isDehydrated: hydrate2,
							cache: null,
							// not enabled yet
							transitions: null,
							pendingSuspenseBoundaries: null,
						}
						uninitializedFiber.memoizedState = _initialState
					}
					initializeUpdateQueue(uninitializedFiber)
					return root3
				}
				var ReactVersion = '18.2.0'
				function createPortal(children, containerInfo, implementation) {
					var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null
					{
						checkKeyStringCoercion(key)
					}
					return {
						// This tag allow us to uniquely identify this as a React Portal
						$$typeof: REACT_PORTAL_TYPE,
						key: key == null ? null : '' + key,
						children,
						containerInfo,
						implementation,
					}
				}
				var didWarnAboutNestedUpdates
				var didWarnAboutFindNodeInStrictMode
				{
					didWarnAboutNestedUpdates = false
					didWarnAboutFindNodeInStrictMode = {}
				}
				function getContextForSubtree(parentComponent) {
					if (!parentComponent) {
						return emptyContextObject
					}
					var fiber = get(parentComponent)
					var parentContext = findCurrentUnmaskedContext(fiber)
					if (fiber.tag === ClassComponent) {
						var Component3 = fiber.type
						if (isContextProvider(Component3)) {
							return processChildContext(fiber, Component3, parentContext)
						}
					}
					return parentContext
				}
				function findHostInstanceWithWarning(component, methodName) {
					{
						var fiber = get(component)
						if (fiber === void 0) {
							if (typeof component.render === 'function') {
								throw new Error('Unable to find node on an unmounted component.')
							} else {
								var keys = Object.keys(component).join(',')
								throw new Error('Argument appears to not be a ReactComponent. Keys: ' + keys)
							}
						}
						var hostFiber = findCurrentHostFiber(fiber)
						if (hostFiber === null) {
							return null
						}
						if (hostFiber.mode & StrictLegacyMode) {
							var componentName = getComponentNameFromFiber(fiber) || 'Component'
							if (!didWarnAboutFindNodeInStrictMode[componentName]) {
								didWarnAboutFindNodeInStrictMode[componentName] = true
								var previousFiber = current
								try {
									setCurrentFiber(hostFiber)
									if (fiber.mode & StrictLegacyMode) {
										error(
											'%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node',
											methodName,
											methodName,
											componentName
										)
									} else {
										error(
											'%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node',
											methodName,
											methodName,
											componentName
										)
									}
								} finally {
									if (previousFiber) {
										setCurrentFiber(previousFiber)
									} else {
										resetCurrentFiber()
									}
								}
							}
						}
						return hostFiber.stateNode
					}
				}
				function createContainer(
					containerInfo,
					tag,
					hydrationCallbacks,
					isStrictMode,
					concurrentUpdatesByDefaultOverride,
					identifierPrefix,
					onRecoverableError,
					transitionCallbacks
				) {
					var hydrate2 = false
					var initialChildren = null
					return createFiberRoot(
						containerInfo,
						tag,
						hydrate2,
						initialChildren,
						hydrationCallbacks,
						isStrictMode,
						concurrentUpdatesByDefaultOverride,
						identifierPrefix,
						onRecoverableError
					)
				}
				function createHydrationContainer(
					initialChildren,
					callback,
					containerInfo,
					tag,
					hydrationCallbacks,
					isStrictMode,
					concurrentUpdatesByDefaultOverride,
					identifierPrefix,
					onRecoverableError,
					transitionCallbacks
				) {
					var hydrate2 = true
					var root3 = createFiberRoot(
						containerInfo,
						tag,
						hydrate2,
						initialChildren,
						hydrationCallbacks,
						isStrictMode,
						concurrentUpdatesByDefaultOverride,
						identifierPrefix,
						onRecoverableError
					)
					root3.context = getContextForSubtree(null)
					var current2 = root3.current
					var eventTime = requestEventTime()
					var lane = requestUpdateLane(current2)
					var update = createUpdate(eventTime, lane)
					update.callback = callback !== void 0 && callback !== null ? callback : null
					enqueueUpdate(current2, update, lane)
					scheduleInitialHydrationOnRoot(root3, lane, eventTime)
					return root3
				}
				function updateContainer(element, container, parentComponent, callback) {
					{
						onScheduleRoot(container, element)
					}
					var current$1 = container.current
					var eventTime = requestEventTime()
					var lane = requestUpdateLane(current$1)
					{
						markRenderScheduled(lane)
					}
					var context = getContextForSubtree(parentComponent)
					if (container.context === null) {
						container.context = context
					} else {
						container.pendingContext = context
					}
					{
						if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
							didWarnAboutNestedUpdates = true
							error(
								'Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.',
								getComponentNameFromFiber(current) || 'Unknown'
							)
						}
					}
					var update = createUpdate(eventTime, lane)
					update.payload = {
						element,
					}
					callback = callback === void 0 ? null : callback
					if (callback !== null) {
						{
							if (typeof callback !== 'function') {
								error(
									'render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
									callback
								)
							}
						}
						update.callback = callback
					}
					var root3 = enqueueUpdate(current$1, update, lane)
					if (root3 !== null) {
						scheduleUpdateOnFiber(root3, current$1, lane, eventTime)
						entangleTransitions(root3, current$1, lane)
					}
					return lane
				}
				function getPublicRootInstance(container) {
					var containerFiber = container.current
					if (!containerFiber.child) {
						return null
					}
					switch (containerFiber.child.tag) {
						case HostComponent:
							return getPublicInstance(containerFiber.child.stateNode)
						default:
							return containerFiber.child.stateNode
					}
				}
				function attemptSynchronousHydration$1(fiber) {
					switch (fiber.tag) {
						case HostRoot: {
							var root3 = fiber.stateNode
							if (isRootDehydrated(root3)) {
								var lanes = getHighestPriorityPendingLanes(root3)
								flushRoot(root3, lanes)
							}
							break
						}
						case SuspenseComponent: {
							flushSync2(function () {
								var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane)
								if (root4 !== null) {
									var eventTime = requestEventTime()
									scheduleUpdateOnFiber(root4, fiber, SyncLane, eventTime)
								}
							})
							var retryLane = SyncLane
							markRetryLaneIfNotHydrated(fiber, retryLane)
							break
						}
					}
				}
				function markRetryLaneImpl(fiber, retryLane) {
					var suspenseState = fiber.memoizedState
					if (suspenseState !== null && suspenseState.dehydrated !== null) {
						suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane)
					}
				}
				function markRetryLaneIfNotHydrated(fiber, retryLane) {
					markRetryLaneImpl(fiber, retryLane)
					var alternate = fiber.alternate
					if (alternate) {
						markRetryLaneImpl(alternate, retryLane)
					}
				}
				function attemptContinuousHydration$1(fiber) {
					if (fiber.tag !== SuspenseComponent) {
						return
					}
					var lane = SelectiveHydrationLane
					var root3 = enqueueConcurrentRenderForLane(fiber, lane)
					if (root3 !== null) {
						var eventTime = requestEventTime()
						scheduleUpdateOnFiber(root3, fiber, lane, eventTime)
					}
					markRetryLaneIfNotHydrated(fiber, lane)
				}
				function attemptHydrationAtCurrentPriority$1(fiber) {
					if (fiber.tag !== SuspenseComponent) {
						return
					}
					var lane = requestUpdateLane(fiber)
					var root3 = enqueueConcurrentRenderForLane(fiber, lane)
					if (root3 !== null) {
						var eventTime = requestEventTime()
						scheduleUpdateOnFiber(root3, fiber, lane, eventTime)
					}
					markRetryLaneIfNotHydrated(fiber, lane)
				}
				function findHostInstanceWithNoPortals(fiber) {
					var hostFiber = findCurrentHostFiberWithNoPortals(fiber)
					if (hostFiber === null) {
						return null
					}
					return hostFiber.stateNode
				}
				var shouldErrorImpl = function (fiber) {
					return null
				}
				function shouldError(fiber) {
					return shouldErrorImpl(fiber)
				}
				var shouldSuspendImpl = function (fiber) {
					return false
				}
				function shouldSuspend(fiber) {
					return shouldSuspendImpl(fiber)
				}
				var overrideHookState = null
				var overrideHookStateDeletePath = null
				var overrideHookStateRenamePath = null
				var overrideProps = null
				var overridePropsDeletePath = null
				var overridePropsRenamePath = null
				var scheduleUpdate = null
				var setErrorHandler = null
				var setSuspenseHandler = null
				{
					var copyWithDeleteImpl = function (obj, path, index3) {
						var key = path[index3]
						var updated = isArray(obj) ? obj.slice() : assign({}, obj)
						if (index3 + 1 === path.length) {
							if (isArray(updated)) {
								updated.splice(key, 1)
							} else {
								delete updated[key]
							}
							return updated
						}
						updated[key] = copyWithDeleteImpl(obj[key], path, index3 + 1)
						return updated
					}
					var copyWithDelete = function (obj, path) {
						return copyWithDeleteImpl(obj, path, 0)
					}
					var copyWithRenameImpl = function (obj, oldPath, newPath, index3) {
						var oldKey = oldPath[index3]
						var updated = isArray(obj) ? obj.slice() : assign({}, obj)
						if (index3 + 1 === oldPath.length) {
							var newKey = newPath[index3]
							updated[newKey] = updated[oldKey]
							if (isArray(updated)) {
								updated.splice(oldKey, 1)
							} else {
								delete updated[oldKey]
							}
						} else {
							updated[oldKey] = copyWithRenameImpl(
								// $FlowFixMe number or string is fine here
								obj[oldKey],
								oldPath,
								newPath,
								index3 + 1
							)
						}
						return updated
					}
					var copyWithRename = function (obj, oldPath, newPath) {
						if (oldPath.length !== newPath.length) {
							warn('copyWithRename() expects paths of the same length')
							return
						} else {
							for (var i3 = 0; i3 < newPath.length - 1; i3++) {
								if (oldPath[i3] !== newPath[i3]) {
									warn('copyWithRename() expects paths to be the same except for the deepest key')
									return
								}
							}
						}
						return copyWithRenameImpl(obj, oldPath, newPath, 0)
					}
					var copyWithSetImpl = function (obj, path, index3, value) {
						if (index3 >= path.length) {
							return value
						}
						var key = path[index3]
						var updated = isArray(obj) ? obj.slice() : assign({}, obj)
						updated[key] = copyWithSetImpl(obj[key], path, index3 + 1, value)
						return updated
					}
					var copyWithSet = function (obj, path, value) {
						return copyWithSetImpl(obj, path, 0, value)
					}
					var findHook = function (fiber, id) {
						var currentHook2 = fiber.memoizedState
						while (currentHook2 !== null && id > 0) {
							currentHook2 = currentHook2.next
							id--
						}
						return currentHook2
					}
					overrideHookState = function (fiber, id, path, value) {
						var hook = findHook(fiber, id)
						if (hook !== null) {
							var newState = copyWithSet(hook.memoizedState, path, value)
							hook.memoizedState = newState
							hook.baseState = newState
							fiber.memoizedProps = assign({}, fiber.memoizedProps)
							var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane)
							if (root3 !== null) {
								scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp)
							}
						}
					}
					overrideHookStateDeletePath = function (fiber, id, path) {
						var hook = findHook(fiber, id)
						if (hook !== null) {
							var newState = copyWithDelete(hook.memoizedState, path)
							hook.memoizedState = newState
							hook.baseState = newState
							fiber.memoizedProps = assign({}, fiber.memoizedProps)
							var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane)
							if (root3 !== null) {
								scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp)
							}
						}
					}
					overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
						var hook = findHook(fiber, id)
						if (hook !== null) {
							var newState = copyWithRename(hook.memoizedState, oldPath, newPath)
							hook.memoizedState = newState
							hook.baseState = newState
							fiber.memoizedProps = assign({}, fiber.memoizedProps)
							var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane)
							if (root3 !== null) {
								scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp)
							}
						}
					}
					overrideProps = function (fiber, path, value) {
						fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value)
						if (fiber.alternate) {
							fiber.alternate.pendingProps = fiber.pendingProps
						}
						var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane)
						if (root3 !== null) {
							scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp)
						}
					}
					overridePropsDeletePath = function (fiber, path) {
						fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path)
						if (fiber.alternate) {
							fiber.alternate.pendingProps = fiber.pendingProps
						}
						var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane)
						if (root3 !== null) {
							scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp)
						}
					}
					overridePropsRenamePath = function (fiber, oldPath, newPath) {
						fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath)
						if (fiber.alternate) {
							fiber.alternate.pendingProps = fiber.pendingProps
						}
						var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane)
						if (root3 !== null) {
							scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp)
						}
					}
					scheduleUpdate = function (fiber) {
						var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane)
						if (root3 !== null) {
							scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp)
						}
					}
					setErrorHandler = function (newShouldErrorImpl) {
						shouldErrorImpl = newShouldErrorImpl
					}
					setSuspenseHandler = function (newShouldSuspendImpl) {
						shouldSuspendImpl = newShouldSuspendImpl
					}
				}
				function findHostInstanceByFiber(fiber) {
					var hostFiber = findCurrentHostFiber(fiber)
					if (hostFiber === null) {
						return null
					}
					return hostFiber.stateNode
				}
				function emptyFindFiberByHostInstance(instance) {
					return null
				}
				function getCurrentFiberForDevTools() {
					return current
				}
				function injectIntoDevTools(devToolsConfig) {
					var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance
					var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher
					return injectInternals({
						bundleType: devToolsConfig.bundleType,
						version: devToolsConfig.version,
						rendererPackageName: devToolsConfig.rendererPackageName,
						rendererConfig: devToolsConfig.rendererConfig,
						overrideHookState,
						overrideHookStateDeletePath,
						overrideHookStateRenamePath,
						overrideProps,
						overridePropsDeletePath,
						overridePropsRenamePath,
						setErrorHandler,
						setSuspenseHandler,
						scheduleUpdate,
						currentDispatcherRef: ReactCurrentDispatcher2,
						findHostInstanceByFiber,
						findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
						// React Refresh
						findHostInstancesForRefresh,
						scheduleRefresh,
						scheduleRoot,
						setRefreshHandler,
						// Enables DevTools to append owner stacks to error messages in DEV mode.
						getCurrentFiber: getCurrentFiberForDevTools,
						// Enables DevTools to detect reconciler version rather than renderer version
						// which may not match for third party renderers.
						reconcilerVersion: ReactVersion,
					})
				}
				var defaultOnRecoverableError =
					typeof reportError === 'function'
						? // In modern browsers, reportError will dispatch an error event,
						  // emulating an uncaught JavaScript error.
						  reportError
						: function (error2) {
								console['error'](error2)
						  }
				function ReactDOMRoot(internalRoot) {
					this._internalRoot = internalRoot
				}
				ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (
					children
				) {
					var root3 = this._internalRoot
					if (root3 === null) {
						throw new Error('Cannot update an unmounted root.')
					}
					{
						if (typeof arguments[1] === 'function') {
							error(
								'render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().'
							)
						} else if (isValidContainer(arguments[1])) {
							error(
								"You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
							)
						} else if (typeof arguments[1] !== 'undefined') {
							error(
								'You passed a second argument to root.render(...) but it only accepts one argument.'
							)
						}
						var container = root3.containerInfo
						if (container.nodeType !== COMMENT_NODE) {
							var hostInstance = findHostInstanceWithNoPortals(root3.current)
							if (hostInstance) {
								if (hostInstance.parentNode !== container) {
									error(
										"render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container."
									)
								}
							}
						}
					}
					updateContainer(children, root3, null, null)
				}
				ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function () {
					{
						if (typeof arguments[0] === 'function') {
							error(
								'unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().'
							)
						}
					}
					var root3 = this._internalRoot
					if (root3 !== null) {
						this._internalRoot = null
						var container = root3.containerInfo
						{
							if (isAlreadyRendering()) {
								error(
									'Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.'
								)
							}
						}
						flushSync2(function () {
							updateContainer(null, root3, null, null)
						})
						unmarkContainerAsRoot(container)
					}
				}
				function createRoot2(container, options2) {
					if (!isValidContainer(container)) {
						throw new Error('createRoot(...): Target container is not a DOM element.')
					}
					warnIfReactDOMContainerInDEV(container)
					var isStrictMode = false
					var concurrentUpdatesByDefaultOverride = false
					var identifierPrefix = ''
					var onRecoverableError = defaultOnRecoverableError
					var transitionCallbacks = null
					if (options2 !== null && options2 !== void 0) {
						{
							if (options2.hydrate) {
								warn(
									'hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.'
								)
							} else {
								if (
									typeof options2 === 'object' &&
									options2 !== null &&
									options2.$$typeof === REACT_ELEMENT_TYPE
								) {
									error(
										'You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);'
									)
								}
							}
						}
						if (options2.unstable_strictMode === true) {
							isStrictMode = true
						}
						if (options2.identifierPrefix !== void 0) {
							identifierPrefix = options2.identifierPrefix
						}
						if (options2.onRecoverableError !== void 0) {
							onRecoverableError = options2.onRecoverableError
						}
						if (options2.transitionCallbacks !== void 0) {
							transitionCallbacks = options2.transitionCallbacks
						}
					}
					var root3 = createContainer(
						container,
						ConcurrentRoot,
						null,
						isStrictMode,
						concurrentUpdatesByDefaultOverride,
						identifierPrefix,
						onRecoverableError
					)
					markContainerAsRoot(root3.current, container)
					var rootContainerElement =
						container.nodeType === COMMENT_NODE ? container.parentNode : container
					listenToAllSupportedEvents(rootContainerElement)
					return new ReactDOMRoot(root3)
				}
				function ReactDOMHydrationRoot(internalRoot) {
					this._internalRoot = internalRoot
				}
				function scheduleHydration(target) {
					if (target) {
						queueExplicitHydrationTarget(target)
					}
				}
				ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration
				function hydrateRoot(container, initialChildren, options2) {
					if (!isValidContainer(container)) {
						throw new Error('hydrateRoot(...): Target container is not a DOM element.')
					}
					warnIfReactDOMContainerInDEV(container)
					{
						if (initialChildren === void 0) {
							error(
								'Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)'
							)
						}
					}
					var hydrationCallbacks = options2 != null ? options2 : null
					var mutableSources = (options2 != null && options2.hydratedSources) || null
					var isStrictMode = false
					var concurrentUpdatesByDefaultOverride = false
					var identifierPrefix = ''
					var onRecoverableError = defaultOnRecoverableError
					if (options2 !== null && options2 !== void 0) {
						if (options2.unstable_strictMode === true) {
							isStrictMode = true
						}
						if (options2.identifierPrefix !== void 0) {
							identifierPrefix = options2.identifierPrefix
						}
						if (options2.onRecoverableError !== void 0) {
							onRecoverableError = options2.onRecoverableError
						}
					}
					var root3 = createHydrationContainer(
						initialChildren,
						null,
						container,
						ConcurrentRoot,
						hydrationCallbacks,
						isStrictMode,
						concurrentUpdatesByDefaultOverride,
						identifierPrefix,
						onRecoverableError
					)
					markContainerAsRoot(root3.current, container)
					listenToAllSupportedEvents(container)
					if (mutableSources) {
						for (var i3 = 0; i3 < mutableSources.length; i3++) {
							var mutableSource = mutableSources[i3]
							registerMutableSourceForHydration(root3, mutableSource)
						}
					}
					return new ReactDOMHydrationRoot(root3)
				}
				function isValidContainer(node) {
					return !!(
						node &&
						(node.nodeType === ELEMENT_NODE ||
							node.nodeType === DOCUMENT_NODE ||
							node.nodeType === DOCUMENT_FRAGMENT_NODE ||
							!disableCommentsAsDOMContainers)
					)
				}
				function isValidContainerLegacy(node) {
					return !!(
						node &&
						(node.nodeType === ELEMENT_NODE ||
							node.nodeType === DOCUMENT_NODE ||
							node.nodeType === DOCUMENT_FRAGMENT_NODE ||
							(node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '))
					)
				}
				function warnIfReactDOMContainerInDEV(container) {
					{
						if (
							container.nodeType === ELEMENT_NODE &&
							container.tagName &&
							container.tagName.toUpperCase() === 'BODY'
						) {
							error(
								'createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.'
							)
						}
						if (isContainerMarkedAsRoot(container)) {
							if (container._reactRootContainer) {
								error(
									'You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.'
								)
							} else {
								error(
									'You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.'
								)
							}
						}
					}
				}
				var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner
				var topLevelUpdateWarnings
				{
					topLevelUpdateWarnings = function (container) {
						if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
							var hostInstance = findHostInstanceWithNoPortals(
								container._reactRootContainer.current
							)
							if (hostInstance) {
								if (hostInstance.parentNode !== container) {
									error(
										'render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.'
									)
								}
							}
						}
						var isRootRenderedBySomeReact = !!container._reactRootContainer
						var rootEl = getReactRootElementInContainer(container)
						var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl))
						if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
							error(
								'render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.'
							)
						}
						if (
							container.nodeType === ELEMENT_NODE &&
							container.tagName &&
							container.tagName.toUpperCase() === 'BODY'
						) {
							error(
								'render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.'
							)
						}
					}
				}
				function getReactRootElementInContainer(container) {
					if (!container) {
						return null
					}
					if (container.nodeType === DOCUMENT_NODE) {
						return container.documentElement
					} else {
						return container.firstChild
					}
				}
				function noopOnRecoverableError() {}
				function legacyCreateRootFromDOMContainer(
					container,
					initialChildren,
					parentComponent,
					callback,
					isHydrationContainer
				) {
					if (isHydrationContainer) {
						if (typeof callback === 'function') {
							var originalCallback = callback
							callback = function () {
								var instance = getPublicRootInstance(root3)
								originalCallback.call(instance)
							}
						}
						var root3 = createHydrationContainer(
							initialChildren,
							callback,
							container,
							LegacyRoot,
							null,
							// hydrationCallbacks
							false,
							// isStrictMode
							false,
							// concurrentUpdatesByDefaultOverride,
							'',
							// identifierPrefix
							noopOnRecoverableError
						)
						container._reactRootContainer = root3
						markContainerAsRoot(root3.current, container)
						var rootContainerElement =
							container.nodeType === COMMENT_NODE ? container.parentNode : container
						listenToAllSupportedEvents(rootContainerElement)
						flushSync2()
						return root3
					} else {
						var rootSibling
						while ((rootSibling = container.lastChild)) {
							container.removeChild(rootSibling)
						}
						if (typeof callback === 'function') {
							var _originalCallback = callback
							callback = function () {
								var instance = getPublicRootInstance(_root)
								_originalCallback.call(instance)
							}
						}
						var _root = createContainer(
							container,
							LegacyRoot,
							null,
							// hydrationCallbacks
							false,
							// isStrictMode
							false,
							// concurrentUpdatesByDefaultOverride,
							'',
							// identifierPrefix
							noopOnRecoverableError
						)
						container._reactRootContainer = _root
						markContainerAsRoot(_root.current, container)
						var _rootContainerElement =
							container.nodeType === COMMENT_NODE ? container.parentNode : container
						listenToAllSupportedEvents(_rootContainerElement)
						flushSync2(function () {
							updateContainer(initialChildren, _root, parentComponent, callback)
						})
						return _root
					}
				}
				function warnOnInvalidCallback$1(callback, callerName) {
					{
						if (callback !== null && typeof callback !== 'function') {
							error(
								'%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
								callerName,
								callback
							)
						}
					}
				}
				function legacyRenderSubtreeIntoContainer(
					parentComponent,
					children,
					container,
					forceHydrate,
					callback
				) {
					{
						topLevelUpdateWarnings(container)
						warnOnInvalidCallback$1(callback === void 0 ? null : callback, 'render')
					}
					var maybeRoot = container._reactRootContainer
					var root3
					if (!maybeRoot) {
						root3 = legacyCreateRootFromDOMContainer(
							container,
							children,
							parentComponent,
							callback,
							forceHydrate
						)
					} else {
						root3 = maybeRoot
						if (typeof callback === 'function') {
							var originalCallback = callback
							callback = function () {
								var instance = getPublicRootInstance(root3)
								originalCallback.call(instance)
							}
						}
						updateContainer(children, root3, parentComponent, callback)
					}
					return getPublicRootInstance(root3)
				}
				function findDOMNode(componentOrElement) {
					{
						var owner = ReactCurrentOwner$3.current
						if (owner !== null && owner.stateNode !== null) {
							var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender
							if (!warnedAboutRefsInRender) {
								error(
									'%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.',
									getComponentNameFromType(owner.type) || 'A component'
								)
							}
							owner.stateNode._warnedAboutRefsInRender = true
						}
					}
					if (componentOrElement == null) {
						return null
					}
					if (componentOrElement.nodeType === ELEMENT_NODE) {
						return componentOrElement
					}
					{
						return findHostInstanceWithWarning(componentOrElement, 'findDOMNode')
					}
				}
				function hydrate(element, container, callback) {
					{
						error(
							"ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
						)
					}
					if (!isValidContainerLegacy(container)) {
						throw new Error('Target container is not a DOM element.')
					}
					{
						var isModernRoot =
							isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0
						if (isModernRoot) {
							error(
								'You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?'
							)
						}
					}
					return legacyRenderSubtreeIntoContainer(null, element, container, true, callback)
				}
				function render(element, container, callback) {
					{
						error(
							"ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
						)
					}
					if (!isValidContainerLegacy(container)) {
						throw new Error('Target container is not a DOM element.')
					}
					{
						var isModernRoot =
							isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0
						if (isModernRoot) {
							error(
								'You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?'
							)
						}
					}
					return legacyRenderSubtreeIntoContainer(null, element, container, false, callback)
				}
				function unstable_renderSubtreeIntoContainer(
					parentComponent,
					element,
					containerNode,
					callback
				) {
					{
						error(
							"ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"
						)
					}
					if (!isValidContainerLegacy(containerNode)) {
						throw new Error('Target container is not a DOM element.')
					}
					if (parentComponent == null || !has(parentComponent)) {
						throw new Error('parentComponent must be a valid React Component')
					}
					return legacyRenderSubtreeIntoContainer(
						parentComponent,
						element,
						containerNode,
						false,
						callback
					)
				}
				function unmountComponentAtNode(container) {
					if (!isValidContainerLegacy(container)) {
						throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.')
					}
					{
						var isModernRoot =
							isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0
						if (isModernRoot) {
							error(
								'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?'
							)
						}
					}
					if (container._reactRootContainer) {
						{
							var rootEl = getReactRootElementInContainer(container)
							var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl)
							if (renderedByDifferentReact) {
								error(
									"unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React."
								)
							}
						}
						flushSync2(function () {
							legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
								container._reactRootContainer = null
								unmarkContainerAsRoot(container)
							})
						})
						return true
					} else {
						{
							var _rootEl = getReactRootElementInContainer(container)
							var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl))
							var isContainerReactRoot =
								container.nodeType === ELEMENT_NODE &&
								isValidContainerLegacy(container.parentNode) &&
								!!container.parentNode._reactRootContainer
							if (hasNonRootReactChild) {
								error(
									"unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s",
									isContainerReactRoot
										? 'You may have accidentally passed in a React root node instead of its container.'
										: 'Instead, have the parent component update its state and rerender in order to remove this component.'
								)
							}
						}
						return false
					}
				}
				setAttemptSynchronousHydration(attemptSynchronousHydration$1)
				setAttemptContinuousHydration(attemptContinuousHydration$1)
				setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1)
				setGetCurrentUpdatePriority(getCurrentUpdatePriority)
				setAttemptHydrationAtPriority(runWithPriority)
				{
					if (
						typeof Map !== 'function' || // $FlowIssue Flow incorrectly thinks Map has no prototype
						Map.prototype == null ||
						typeof Map.prototype.forEach !== 'function' ||
						typeof Set !== 'function' || // $FlowIssue Flow incorrectly thinks Set has no prototype
						Set.prototype == null ||
						typeof Set.prototype.clear !== 'function' ||
						typeof Set.prototype.forEach !== 'function'
					) {
						error(
							'React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills'
						)
					}
				}
				setRestoreImplementation(restoreControlledState$3)
				setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync2)
				function createPortal$1(children, container) {
					var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null
					if (!isValidContainer(container)) {
						throw new Error('Target container is not a DOM element.')
					}
					return createPortal(children, container, null, key)
				}
				function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
					return unstable_renderSubtreeIntoContainer(
						parentComponent,
						element,
						containerNode,
						callback
					)
				}
				var Internals = {
					usingClientEntryPoint: false,
					// Keep in sync with ReactTestUtils.js.
					// This is an array for better minification.
					Events: [
						getInstanceFromNode,
						getNodeFromInstance,
						getFiberCurrentPropsFromNode,
						enqueueStateRestore,
						restoreStateIfNeeded,
						batchedUpdates$1,
					],
				}
				function createRoot$1(container, options2) {
					{
						if (!Internals.usingClientEntryPoint && true) {
							error(
								'You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'
							)
						}
					}
					return createRoot2(container, options2)
				}
				function hydrateRoot$1(container, initialChildren, options2) {
					{
						if (!Internals.usingClientEntryPoint && true) {
							error(
								'You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'
							)
						}
					}
					return hydrateRoot(container, initialChildren, options2)
				}
				function flushSync$1(fn) {
					{
						if (isAlreadyRendering()) {
							error(
								'flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.'
							)
						}
					}
					return flushSync2(fn)
				}
				var foundDevTools = injectIntoDevTools({
					findFiberByHostInstance: getClosestInstanceFromNode,
					bundleType: 1,
					version: ReactVersion,
					rendererPackageName: 'react-dom',
				})
				{
					if (!foundDevTools && canUseDOM && window.top === window.self) {
						if (
							(navigator.userAgent.indexOf('Chrome') > -1 &&
								navigator.userAgent.indexOf('Edge') === -1) ||
							navigator.userAgent.indexOf('Firefox') > -1
						) {
							var protocol = window.location.protocol
							if (/^(https?|file):$/.test(protocol)) {
								console.info(
									'%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools' +
										(protocol === 'file:'
											? '\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq'
											: ''),
									'font-weight:bold'
								)
							}
						}
					}
				}
				exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals
				exports.createPortal = createPortal$1
				exports.createRoot = createRoot$1
				exports.findDOMNode = findDOMNode
				exports.flushSync = flushSync$1
				exports.hydrate = hydrate
				exports.hydrateRoot = hydrateRoot$1
				exports.render = render
				exports.unmountComponentAtNode = unmountComponentAtNode
				exports.unstable_batchedUpdates = batchedUpdates$1
				exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer
				exports.version = ReactVersion
				if (
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
					typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function'
				) {
					__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
				}
			})()
		}
	},
})

// ../node_modules/react-dom/index.js
var require_react_dom = __commonJS({
	'../node_modules/react-dom/index.js'(exports, module2) {
		'use strict'
		init_define_process()
		function checkDCE() {
			if (
				typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
				typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
			) {
				return
			}
			if (define_process_default.env.NODE_ENV !== 'production') {
				throw new Error('^_^')
			}
			try {
				__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
			} catch (err) {
				console.error(err)
			}
		}
		if (define_process_default.env.NODE_ENV === 'production') {
			checkDCE()
			module2.exports = require_react_dom_production_min()
		} else {
			module2.exports = require_react_dom_development()
		}
	},
})

// ../node_modules/lz-string/libs/lz-string.js
var require_lz_string = __commonJS({
	'../node_modules/lz-string/libs/lz-string.js'(exports, module2) {
		init_define_process()
		var LZString = (function () {
			var f3 = String.fromCharCode
			var keyStrBase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
			var keyStrUriSafe = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$'
			var baseReverseDic = {}
			function getBaseValue(alphabet, character) {
				if (!baseReverseDic[alphabet]) {
					baseReverseDic[alphabet] = {}
					for (var i3 = 0; i3 < alphabet.length; i3++) {
						baseReverseDic[alphabet][alphabet.charAt(i3)] = i3
					}
				}
				return baseReverseDic[alphabet][character]
			}
			var LZString2 = {
				compressToBase64: function (input) {
					if (input == null) return ''
					var res = LZString2._compress(input, 6, function (a3) {
						return keyStrBase64.charAt(a3)
					})
					switch (res.length % 4) {
						default:
						case 0:
							return res
						case 1:
							return res + '==='
						case 2:
							return res + '=='
						case 3:
							return res + '='
					}
				},
				decompressFromBase64: function (input) {
					if (input == null) return ''
					if (input == '') return null
					return LZString2._decompress(input.length, 32, function (index2) {
						return getBaseValue(keyStrBase64, input.charAt(index2))
					})
				},
				compressToUTF16: function (input) {
					if (input == null) return ''
					return (
						LZString2._compress(input, 15, function (a3) {
							return f3(a3 + 32)
						}) + ' '
					)
				},
				decompressFromUTF16: function (compressed) {
					if (compressed == null) return ''
					if (compressed == '') return null
					return LZString2._decompress(compressed.length, 16384, function (index2) {
						return compressed.charCodeAt(index2) - 32
					})
				},
				//compress into uint8array (UCS-2 big endian format)
				compressToUint8Array: function (uncompressed) {
					var compressed = LZString2.compress(uncompressed)
					var buf = new Uint8Array(compressed.length * 2)
					for (var i3 = 0, TotalLen = compressed.length; i3 < TotalLen; i3++) {
						var current_value = compressed.charCodeAt(i3)
						buf[i3 * 2] = current_value >>> 8
						buf[i3 * 2 + 1] = current_value % 256
					}
					return buf
				},
				//decompress from uint8array (UCS-2 big endian format)
				decompressFromUint8Array: function (compressed) {
					if (compressed === null || compressed === void 0) {
						return LZString2.decompress(compressed)
					} else {
						var buf = new Array(compressed.length / 2)
						for (var i3 = 0, TotalLen = buf.length; i3 < TotalLen; i3++) {
							buf[i3] = compressed[i3 * 2] * 256 + compressed[i3 * 2 + 1]
						}
						var result = []
						buf.forEach(function (c3) {
							result.push(f3(c3))
						})
						return LZString2.decompress(result.join(''))
					}
				},
				//compress into a string that is already URI encoded
				compressToEncodedURIComponent: function (input) {
					if (input == null) return ''
					return LZString2._compress(input, 6, function (a3) {
						return keyStrUriSafe.charAt(a3)
					})
				},
				//decompress from an output of compressToEncodedURIComponent
				decompressFromEncodedURIComponent: function (input) {
					if (input == null) return ''
					if (input == '') return null
					input = input.replace(/ /g, '+')
					return LZString2._decompress(input.length, 32, function (index2) {
						return getBaseValue(keyStrUriSafe, input.charAt(index2))
					})
				},
				compress: function (uncompressed) {
					return LZString2._compress(uncompressed, 16, function (a3) {
						return f3(a3)
					})
				},
				_compress: function (uncompressed, bitsPerChar, getCharFromInt) {
					if (uncompressed == null) return ''
					var i3,
						value,
						context_dictionary = {},
						context_dictionaryToCreate = {},
						context_c = '',
						context_wc = '',
						context_w = '',
						context_enlargeIn = 2,
						context_dictSize = 3,
						context_numBits = 2,
						context_data = [],
						context_data_val = 0,
						context_data_position = 0,
						ii
					for (ii = 0; ii < uncompressed.length; ii += 1) {
						context_c = uncompressed.charAt(ii)
						if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
							context_dictionary[context_c] = context_dictSize++
							context_dictionaryToCreate[context_c] = true
						}
						context_wc = context_w + context_c
						if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
							context_w = context_wc
						} else {
							if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
								if (context_w.charCodeAt(0) < 256) {
									for (i3 = 0; i3 < context_numBits; i3++) {
										context_data_val = context_data_val << 1
										if (context_data_position == bitsPerChar - 1) {
											context_data_position = 0
											context_data.push(getCharFromInt(context_data_val))
											context_data_val = 0
										} else {
											context_data_position++
										}
									}
									value = context_w.charCodeAt(0)
									for (i3 = 0; i3 < 8; i3++) {
										context_data_val = (context_data_val << 1) | (value & 1)
										if (context_data_position == bitsPerChar - 1) {
											context_data_position = 0
											context_data.push(getCharFromInt(context_data_val))
											context_data_val = 0
										} else {
											context_data_position++
										}
										value = value >> 1
									}
								} else {
									value = 1
									for (i3 = 0; i3 < context_numBits; i3++) {
										context_data_val = (context_data_val << 1) | value
										if (context_data_position == bitsPerChar - 1) {
											context_data_position = 0
											context_data.push(getCharFromInt(context_data_val))
											context_data_val = 0
										} else {
											context_data_position++
										}
										value = 0
									}
									value = context_w.charCodeAt(0)
									for (i3 = 0; i3 < 16; i3++) {
										context_data_val = (context_data_val << 1) | (value & 1)
										if (context_data_position == bitsPerChar - 1) {
											context_data_position = 0
											context_data.push(getCharFromInt(context_data_val))
											context_data_val = 0
										} else {
											context_data_position++
										}
										value = value >> 1
									}
								}
								context_enlargeIn--
								if (context_enlargeIn == 0) {
									context_enlargeIn = Math.pow(2, context_numBits)
									context_numBits++
								}
								delete context_dictionaryToCreate[context_w]
							} else {
								value = context_dictionary[context_w]
								for (i3 = 0; i3 < context_numBits; i3++) {
									context_data_val = (context_data_val << 1) | (value & 1)
									if (context_data_position == bitsPerChar - 1) {
										context_data_position = 0
										context_data.push(getCharFromInt(context_data_val))
										context_data_val = 0
									} else {
										context_data_position++
									}
									value = value >> 1
								}
							}
							context_enlargeIn--
							if (context_enlargeIn == 0) {
								context_enlargeIn = Math.pow(2, context_numBits)
								context_numBits++
							}
							context_dictionary[context_wc] = context_dictSize++
							context_w = String(context_c)
						}
					}
					if (context_w !== '') {
						if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
							if (context_w.charCodeAt(0) < 256) {
								for (i3 = 0; i3 < context_numBits; i3++) {
									context_data_val = context_data_val << 1
									if (context_data_position == bitsPerChar - 1) {
										context_data_position = 0
										context_data.push(getCharFromInt(context_data_val))
										context_data_val = 0
									} else {
										context_data_position++
									}
								}
								value = context_w.charCodeAt(0)
								for (i3 = 0; i3 < 8; i3++) {
									context_data_val = (context_data_val << 1) | (value & 1)
									if (context_data_position == bitsPerChar - 1) {
										context_data_position = 0
										context_data.push(getCharFromInt(context_data_val))
										context_data_val = 0
									} else {
										context_data_position++
									}
									value = value >> 1
								}
							} else {
								value = 1
								for (i3 = 0; i3 < context_numBits; i3++) {
									context_data_val = (context_data_val << 1) | value
									if (context_data_position == bitsPerChar - 1) {
										context_data_position = 0
										context_data.push(getCharFromInt(context_data_val))
										context_data_val = 0
									} else {
										context_data_position++
									}
									value = 0
								}
								value = context_w.charCodeAt(0)
								for (i3 = 0; i3 < 16; i3++) {
									context_data_val = (context_data_val << 1) | (value & 1)
									if (context_data_position == bitsPerChar - 1) {
										context_data_position = 0
										context_data.push(getCharFromInt(context_data_val))
										context_data_val = 0
									} else {
										context_data_position++
									}
									value = value >> 1
								}
							}
							context_enlargeIn--
							if (context_enlargeIn == 0) {
								context_enlargeIn = Math.pow(2, context_numBits)
								context_numBits++
							}
							delete context_dictionaryToCreate[context_w]
						} else {
							value = context_dictionary[context_w]
							for (i3 = 0; i3 < context_numBits; i3++) {
								context_data_val = (context_data_val << 1) | (value & 1)
								if (context_data_position == bitsPerChar - 1) {
									context_data_position = 0
									context_data.push(getCharFromInt(context_data_val))
									context_data_val = 0
								} else {
									context_data_position++
								}
								value = value >> 1
							}
						}
						context_enlargeIn--
						if (context_enlargeIn == 0) {
							context_enlargeIn = Math.pow(2, context_numBits)
							context_numBits++
						}
					}
					value = 2
					for (i3 = 0; i3 < context_numBits; i3++) {
						context_data_val = (context_data_val << 1) | (value & 1)
						if (context_data_position == bitsPerChar - 1) {
							context_data_position = 0
							context_data.push(getCharFromInt(context_data_val))
							context_data_val = 0
						} else {
							context_data_position++
						}
						value = value >> 1
					}
					while (true) {
						context_data_val = context_data_val << 1
						if (context_data_position == bitsPerChar - 1) {
							context_data.push(getCharFromInt(context_data_val))
							break
						} else context_data_position++
					}
					return context_data.join('')
				},
				decompress: function (compressed) {
					if (compressed == null) return ''
					if (compressed == '') return null
					return LZString2._decompress(compressed.length, 32768, function (index2) {
						return compressed.charCodeAt(index2)
					})
				},
				_decompress: function (length, resetValue, getNextValue) {
					var dictionary = [],
						next,
						enlargeIn = 4,
						dictSize = 4,
						numBits = 3,
						entry = '',
						result = [],
						i3,
						w3,
						bits,
						resb,
						maxpower,
						power,
						c3,
						data = { val: getNextValue(0), position: resetValue, index: 1 }
					for (i3 = 0; i3 < 3; i3 += 1) {
						dictionary[i3] = i3
					}
					bits = 0
					maxpower = Math.pow(2, 2)
					power = 1
					while (power != maxpower) {
						resb = data.val & data.position
						data.position >>= 1
						if (data.position == 0) {
							data.position = resetValue
							data.val = getNextValue(data.index++)
						}
						bits |= (resb > 0 ? 1 : 0) * power
						power <<= 1
					}
					switch ((next = bits)) {
						case 0:
							bits = 0
							maxpower = Math.pow(2, 8)
							power = 1
							while (power != maxpower) {
								resb = data.val & data.position
								data.position >>= 1
								if (data.position == 0) {
									data.position = resetValue
									data.val = getNextValue(data.index++)
								}
								bits |= (resb > 0 ? 1 : 0) * power
								power <<= 1
							}
							c3 = f3(bits)
							break
						case 1:
							bits = 0
							maxpower = Math.pow(2, 16)
							power = 1
							while (power != maxpower) {
								resb = data.val & data.position
								data.position >>= 1
								if (data.position == 0) {
									data.position = resetValue
									data.val = getNextValue(data.index++)
								}
								bits |= (resb > 0 ? 1 : 0) * power
								power <<= 1
							}
							c3 = f3(bits)
							break
						case 2:
							return ''
					}
					dictionary[3] = c3
					w3 = c3
					result.push(c3)
					while (true) {
						if (data.index > length) {
							return ''
						}
						bits = 0
						maxpower = Math.pow(2, numBits)
						power = 1
						while (power != maxpower) {
							resb = data.val & data.position
							data.position >>= 1
							if (data.position == 0) {
								data.position = resetValue
								data.val = getNextValue(data.index++)
							}
							bits |= (resb > 0 ? 1 : 0) * power
							power <<= 1
						}
						switch ((c3 = bits)) {
							case 0:
								bits = 0
								maxpower = Math.pow(2, 8)
								power = 1
								while (power != maxpower) {
									resb = data.val & data.position
									data.position >>= 1
									if (data.position == 0) {
										data.position = resetValue
										data.val = getNextValue(data.index++)
									}
									bits |= (resb > 0 ? 1 : 0) * power
									power <<= 1
								}
								dictionary[dictSize++] = f3(bits)
								c3 = dictSize - 1
								enlargeIn--
								break
							case 1:
								bits = 0
								maxpower = Math.pow(2, 16)
								power = 1
								while (power != maxpower) {
									resb = data.val & data.position
									data.position >>= 1
									if (data.position == 0) {
										data.position = resetValue
										data.val = getNextValue(data.index++)
									}
									bits |= (resb > 0 ? 1 : 0) * power
									power <<= 1
								}
								dictionary[dictSize++] = f3(bits)
								c3 = dictSize - 1
								enlargeIn--
								break
							case 2:
								return result.join('')
						}
						if (enlargeIn == 0) {
							enlargeIn = Math.pow(2, numBits)
							numBits++
						}
						if (dictionary[c3]) {
							entry = dictionary[c3]
						} else {
							if (c3 === dictSize) {
								entry = w3 + w3.charAt(0)
							} else {
								return null
							}
						}
						result.push(entry)
						dictionary[dictSize++] = w3 + entry.charAt(0)
						enlargeIn--
						w3 = entry
						if (enlargeIn == 0) {
							enlargeIn = Math.pow(2, numBits)
							numBits++
						}
					}
				},
			}
			return LZString2
		})()
		if (typeof define === 'function' && define.amd) {
			define(function () {
				return LZString
			})
		} else if (typeof module2 !== 'undefined' && module2 != null) {
			module2.exports = LZString
		} else if (typeof angular !== 'undefined' && angular != null) {
			angular.module('LZString', []).factory('LZString', function () {
				return LZString
			})
		}
	},
})

// ../node_modules/react-dom/client.js
var require_client = __commonJS({
	'../node_modules/react-dom/client.js'(exports) {
		'use strict'
		init_define_process()
		var m3 = require_react_dom()
		if (define_process_default.env.NODE_ENV === 'production') {
			exports.createRoot = m3.createRoot
			exports.hydrateRoot = m3.hydrateRoot
		} else {
			i3 = m3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
			exports.createRoot = function (c3, o3) {
				i3.usingClientEntryPoint = true
				try {
					return m3.createRoot(c3, o3)
				} finally {
					i3.usingClientEntryPoint = false
				}
			}
			exports.hydrateRoot = function (c3, h3, o3) {
				i3.usingClientEntryPoint = true
				try {
					return m3.hydrateRoot(c3, h3, o3)
				} finally {
					i3.usingClientEntryPoint = false
				}
			}
		}
		var i3
	},
})

// src/index.tsx
init_define_process()

// ../packages/tldraw/src/index.ts
init_define_process()

// ../packages/polyfills/src/index.ts
init_define_process()

// ../packages/polyfills/src/lib/polyfills.ts
init_define_process()
var import_at = __toESM(require_at2())
var import_flat = __toESM(require_flat2())
var import_flat_map = __toESM(require_flat_map2())
var import_at2 = __toESM(require_at4())
var import_replace_all = __toESM(require_replace_all2())

// ../packages/editor/src/index.ts
init_define_process()

// ../packages/indices/src/index.ts
init_define_process()

// ../packages/indices/src/lib/reordering.ts
init_define_process()

// ../packages/indices/src/lib/dgreensp/index.ts
init_define_process()

// ../packages/indices/src/lib/dgreensp/dgreensp.ts
init_define_process()
var DIGITS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
var INTEGER_ZERO = 'a0'
var SMALLEST_INTEGER = 'A00000000000000000000000000'
function getIntegerLength(head) {
	if (head >= 'a' && head <= 'z') {
		return head.charCodeAt(0) - 'a'.charCodeAt(0) + 2
	} else if (head >= 'A' && head <= 'Z') {
		return 'Z'.charCodeAt(0) - head.charCodeAt(0) + 2
	} else {
		throw new Error('Invalid index key head: ' + head)
	}
}
function validateInteger(int) {
	if (int.length !== getIntegerLength(int.charAt(0))) {
		throw new Error('invalid integer part of index key: ' + int)
	}
}
function isNotUndefined(n3) {
	if (n3 === void 0) throw Error('n is undefined')
}
function incrementInteger(x3) {
	validateInteger(x3)
	const [head, ...digs] = x3.split('')
	let carry = true
	for (let i3 = digs.length - 1; carry && i3 >= 0; i3--) {
		const d3 = DIGITS.indexOf(digs[i3]) + 1
		if (d3 === DIGITS.length) {
			digs[i3] = '0'
		} else {
			digs[i3] = DIGITS.charAt(d3)
			carry = false
		}
	}
	if (carry) {
		if (head === 'Z') return 'a0'
		if (head === 'z') return void 0
		const h3 = String.fromCharCode(head.charCodeAt(0) + 1)
		if (h3 > 'a') {
			digs.push('0')
		} else {
			digs.pop()
		}
		return h3 + digs.join('')
	} else {
		return head + digs.join('')
	}
}
function decrementInteger(x3) {
	validateInteger(x3)
	const [head, ...digs] = x3.split('')
	let borrow = true
	for (let i3 = digs.length - 1; borrow && i3 >= 0; i3--) {
		const d3 = DIGITS.indexOf(digs[i3]) - 1
		if (d3 === -1) {
			digs[i3] = DIGITS.slice(-1)
		} else {
			digs[i3] = DIGITS.charAt(d3)
			borrow = false
		}
	}
	if (borrow) {
		if (head === 'a') return 'Z' + DIGITS.slice(-1)
		if (head === 'A') return void 0
		const h3 = String.fromCharCode(head.charCodeAt(0) - 1)
		if (h3 < 'Z') {
			digs.push(DIGITS.slice(-1))
		} else {
			digs.pop()
		}
		return h3 + digs.join('')
	} else {
		return head + digs.join('')
	}
}
function midpoint(a3, b3) {
	if (b3 !== void 0 && a3 >= b3) {
		throw new Error(a3 + ' >= ' + b3)
	}
	if (a3.slice(-1) === '0' || (b3 && b3.slice(-1) === '0')) {
		throw new Error('trailing zero')
	}
	if (b3) {
		let n3 = 0
		while ((a3.charAt(n3) || '0') === b3.charAt(n3)) {
			n3++
		}
		if (n3 > 0) {
			return b3.slice(0, n3) + midpoint(a3.slice(n3), b3.slice(n3))
		}
	}
	const digitA = a3 ? DIGITS.indexOf(a3.charAt(0)) : 0
	const digitB = b3 !== void 0 ? DIGITS.indexOf(b3.charAt(0)) : DIGITS.length
	if (digitB - digitA > 1) {
		const midDigit = Math.round(0.5 * (digitA + digitB))
		return DIGITS.charAt(midDigit)
	} else {
		if (b3 && b3.length > 1) {
			return b3.slice(0, 1)
		} else {
			return DIGITS.charAt(digitA) + midpoint(a3.slice(1), void 0)
		}
	}
}
function getIntegerPart(index2) {
	const integerPartLength = getIntegerLength(index2.charAt(0))
	if (integerPartLength > index2.length) {
		throw new Error('invalid index: ' + index2)
	}
	return index2.slice(0, integerPartLength)
}
function validateOrder(index2) {
	if (index2 === SMALLEST_INTEGER) {
		throw new Error('invalid index: ' + index2)
	}
	const i3 = getIntegerPart(index2)
	const f3 = index2.slice(i3.length)
	if (f3.slice(-1) === '0') {
		throw new Error('invalid index: ' + index2)
	}
}
function generateKeyBetween(a3, b3) {
	if (a3 !== void 0) validateOrder(a3)
	if (b3 !== void 0) validateOrder(b3)
	if (a3 !== void 0 && b3 !== void 0 && a3 >= b3) {
		throw new Error(a3 + ' >= ' + b3)
	}
	if (a3 === void 0 && b3 === void 0) {
		return INTEGER_ZERO
	}
	if (a3 === void 0) {
		if (b3 === void 0) throw Error('b is undefined')
		const ib2 = getIntegerPart(b3)
		const fb2 = b3.slice(ib2.length)
		if (ib2 === SMALLEST_INTEGER) {
			return ib2 + midpoint('', fb2)
		}
		if (ib2 < b3) {
			return ib2
		}
		const ibl = decrementInteger(ib2)
		isNotUndefined(ibl)
		return ibl
	}
	if (b3 === void 0) {
		const ia2 = getIntegerPart(a3)
		const fa2 = a3.slice(ia2.length)
		const i4 = incrementInteger(ia2)
		return i4 === void 0 ? ia2 + midpoint(fa2, void 0) : i4
	}
	const ia = getIntegerPart(a3)
	const fa = a3.slice(ia.length)
	const ib = getIntegerPart(b3)
	const fb = b3.slice(ib.length)
	if (ia === ib) {
		return ia + midpoint(fa, fb)
	}
	const i3 = incrementInteger(ia)
	isNotUndefined(i3)
	return i3 < b3 ? i3 : ia + midpoint(fa, void 0)
}
function generateNKeysBetween(a3, b3, n3) {
	if (n3 === 0) return []
	if (n3 === 1) return [generateKeyBetween(a3, b3)]
	if (b3 === void 0) {
		let c4 = generateKeyBetween(a3, b3)
		const result = [c4]
		for (let i3 = 0; i3 < n3 - 1; i3++) {
			c4 = generateKeyBetween(c4, b3)
			result.push(c4)
		}
		return result
	}
	if (a3 === void 0) {
		let c4 = generateKeyBetween(a3, b3)
		const result = [c4]
		for (let i3 = 0; i3 < n3 - 1; i3++) {
			c4 = generateKeyBetween(a3, c4)
			result.push(c4)
		}
		result.reverse()
		return result
	}
	const mid = Math.floor(n3 / 2)
	const c3 = generateKeyBetween(a3, b3)
	return [...generateNKeysBetween(a3, c3, mid), c3, ...generateNKeysBetween(c3, b3, n3 - mid - 1)]
}

// ../packages/indices/src/lib/reordering.ts
function getIndicesBetween(below, above, n3) {
	return generateNKeysBetween(below, above, n3)
}
function getIndicesAbove(below, n3) {
	return generateNKeysBetween(below, void 0, n3)
}
function getIndexBetween(below, above) {
	return generateNKeysBetween(below, above, 1)[0]
}
function getIndexAbove(below) {
	return generateNKeysBetween(below, void 0, 1)[0]
}
function getIndexBelow(above) {
	return generateNKeysBetween(void 0, above, 1)[0]
}
function getIndices(n3, start = 'a1') {
	return [start, ...generateNKeysBetween(start, void 0, n3)]
}
function sortByIndex(a3, b3) {
	if (a3.index < b3.index) {
		return -1
	} else if (a3.index > b3.index) {
		return 1
	}
	return 0
}

// ../packages/tlschema/src/index.ts
init_define_process()

// ../packages/tlschema/src/TLRecord.ts
init_define_process()

// ../packages/tlschema/src/TLStore.ts
init_define_process()

// ../packages/utils/src/index.ts
init_define_process()

// ../packages/utils/src/lib/array.ts
init_define_process()
function dedupe(input, equals2) {
	const result = []
	mainLoop: for (const item of input) {
		for (const existing of result) {
			if (equals2 ? equals2(item, existing) : item === existing) {
				continue mainLoop
			}
		}
		result.push(item)
	}
	return result
}
function compact(arr) {
	return arr.filter((i3) => i3 !== void 0 && i3 !== null)
}
function last(arr) {
	return arr[arr.length - 1]
}
function minBy(arr, fn) {
	let min2
	let minVal = Infinity
	for (const item of arr) {
		const val = fn(item)
		if (val < minVal) {
			min2 = item
			minVal = val
		}
	}
	return min2
}
function partition(arr, predicate) {
	const satisfies = []
	const doesNotSatisfy = []
	for (const item of arr) {
		if (predicate(item)) {
			satisfies.push(item)
		} else {
			doesNotSatisfy.push(item)
		}
	}
	return [satisfies, doesNotSatisfy]
}

// ../packages/utils/src/lib/control.ts
init_define_process()

// ../packages/utils/src/lib/function.ts
init_define_process()
function omitFromStackTrace(fn) {
	const wrappedFn = (...args) => {
		try {
			return fn(...args)
		} catch (error) {
			if (error instanceof Error && Error.captureStackTrace) {
				Error.captureStackTrace(error, wrappedFn)
			}
			throw error
		}
	}
	return wrappedFn
}

// ../packages/utils/src/lib/control.ts
function exhaustiveSwitchError(value, property) {
	const debugValue =
		property && value && typeof value === 'object' && property in value ? value[property] : value
	throw new Error(`Unknown switch case ${debugValue}`)
}
var assert = omitFromStackTrace((value, message) => {
	if (!value) {
		throw new Error(message || 'Assertion Error')
	}
})
var assertExists = omitFromStackTrace((value, message) => {
	if (value == null) {
		throw new Error(message ?? 'value must be defined')
	}
	return value
})

// ../packages/utils/src/lib/debounce.ts
init_define_process()
function debounce(callback, wait) {
	let state = void 0
	const fn = (...args) => {
		if (!state) {
			state = {}
			state.promise = new Promise((resolve, reject) => {
				state.resolve = resolve
				state.reject = reject
			})
		}
		clearTimeout(state.timeout)
		state.latestArgs = args
		state.timeout = setTimeout(() => {
			const s3 = state
			state = void 0
			try {
				s3.resolve(callback(...s3.latestArgs))
			} catch (e2) {
				s3.reject(e2)
			}
		}, wait)
		return state.promise
	}
	fn.cancel = () => {
		if (!state) return
		clearTimeout(state.timeout)
	}
	return fn
}

// ../packages/utils/src/lib/error.ts
init_define_process()
var annotationsByError = /* @__PURE__ */ new WeakMap()
function annotateError(error, annotations) {
	if (typeof error !== 'object' || error === null) return
	let currentAnnotations = annotationsByError.get(error)
	if (!currentAnnotations) {
		currentAnnotations = { tags: {}, extras: {} }
		annotationsByError.set(error, currentAnnotations)
	}
	if (annotations.tags) {
		currentAnnotations.tags = {
			...currentAnnotations.tags,
			...annotations.tags,
		}
	}
	if (annotations.extras) {
		currentAnnotations.extras = {
			...currentAnnotations.extras,
			...annotations.extras,
		}
	}
}

// ../packages/utils/src/lib/hash.ts
init_define_process()
function getHashForString(string2) {
	let hash = 0
	for (let i3 = 0; i3 < string2.length; i3++) {
		hash = (hash << 5) - hash + string2.charCodeAt(i3)
		hash |= 0
	}
	return hash + ''
}

// ../packages/utils/src/lib/iterable.ts
init_define_process()

// ../packages/utils/src/lib/number.ts
init_define_process()
function rng(seed = '') {
	let x3 = 0
	let y3 = 0
	let z2 = 0
	let w3 = 0
	function next() {
		const t4 = x3 ^ (x3 << 11)
		x3 = y3
		y3 = z2
		z2 = w3
		w3 ^= ((w3 >>> 19) ^ t4 ^ (t4 >>> 8)) >>> 0
		return (w3 / 4294967296) * 2
	}
	for (let k2 = 0; k2 < seed.length + 64; k2++) {
		x3 ^= seed.charCodeAt(k2) | 0
		next()
	}
	return next
}
function modulate(value, rangeA, rangeB, clamp3 = false) {
	const [fromLow, fromHigh] = rangeA
	const [v0, v1] = rangeB
	const result = v0 + ((value - fromLow) / (fromHigh - fromLow)) * (v1 - v0)
	return clamp3
		? v0 < v1
			? Math.max(Math.min(result, v1), v0)
			: Math.max(Math.min(result, v0), v1)
		: result
}

// ../packages/utils/src/lib/object.ts
init_define_process()
function hasOwnProperty(obj, key) {
	return Object.prototype.hasOwnProperty.call(obj, key)
}
function getOwnProperty(obj, key) {
	if (!hasOwnProperty(obj, key)) {
		return void 0
	}
	return obj[key]
}
function deepCopy(obj) {
	if (!obj) return obj
	if (Array.isArray(obj)) {
		const arr = []
		const length = obj.length
		for (let i3 = 0; i3 < length; i3++) arr.push(deepCopy(obj[i3]))
		return arr
	} else if (typeof obj === 'object') {
		const keys = Object.keys(obj)
		const length = keys.length
		const newObject = {}
		for (let i3 = 0; i3 < length; i3++) {
			const key = keys[i3]
			newObject[key] = deepCopy(obj[key])
		}
		return newObject
	}
	return obj
}
function objectMapKeys(object2) {
	return Object.keys(object2)
}
function objectMapValues(object2) {
	return Object.values(object2)
}
function objectMapEntries(object2) {
	return Object.entries(object2)
}
function objectMapFromEntries(entries) {
	return Object.fromEntries(entries)
}

// ../packages/utils/src/lib/raf.ts
init_define_process()
var isTest = () =>
	typeof define_process_default !== 'undefined' &&
	define_process_default.env.NODE_ENV === 'test' && // @ts-expect-error
	!globalThis.__FORCE_RAF_IN_TESTS__
var rafQueue = []
var tick = () => {
	const queue = rafQueue.splice(0, rafQueue.length)
	for (const fn of queue) {
		fn()
	}
}
var frame
function raf() {
	if (frame) {
		return
	}
	frame = requestAnimationFrame(() => {
		frame = void 0
		tick()
	})
}
function throttledRaf(fn) {
	if (isTest()) {
		return fn()
	}
	if (rafQueue.includes(fn)) {
		return
	}
	rafQueue.push(fn)
	raf()
}

// ../packages/utils/src/lib/sort.ts
init_define_process()
function sortById(a3, b3) {
	return a3.id > b3.id ? 1 : -1
}

// ../packages/utils/src/lib/value.ts
init_define_process()
function isNonNull(value) {
	return value !== null
}
var structuredClone =
	typeof window !== 'undefined' && window.structuredClone
		? window.structuredClone
		: (i3) => (i3 ? JSON.parse(JSON.stringify(i3)) : i3)

// ../packages/tlschema/src/records/TLCamera.ts
init_define_process()

// ../packages/tlstore/src/index.ts
init_define_process()

// ../packages/tlstore/src/lib/IncrementalSetConstructor.ts
init_define_process()
var IncrementalSetConstructor = class {
	constructor(previousValue) {
		this.previousValue = previousValue
	}
	/**
	 * The next value of the set.
	 *
	 * @internal
	 */
	nextValue
	/**
	 * The diff of the set.
	 *
	 * @internal
	 */
	diff
	/**
	 * Get the next value of the set.
	 *
	 * @public
	 */
	get() {
		const numRemoved = this.diff?.removed?.size ?? 0
		const numAdded = this.diff?.added?.size ?? 0
		if (numRemoved === 0 && numAdded === 0) {
			return void 0
		}
		return { value: this.nextValue, diff: this.diff }
	}
	/**
	 * Add an item to the set.
	 *
	 * @param item - The item to add.
	 * @param wasAlreadyPresent - Whether the item was already present in the set.
	 * @internal
	 */
	_add(item, wasAlreadyPresent) {
		this.nextValue ??= new Set(this.previousValue)
		this.nextValue.add(item)
		this.diff ??= {}
		if (wasAlreadyPresent) {
			this.diff.removed?.delete(item)
		} else {
			this.diff.added ??= /* @__PURE__ */ new Set()
			this.diff.added.add(item)
		}
	}
	/**
	 * Add an item to the set.
	 *
	 * @param item - The item to add.
	 * @public
	 */
	add(item) {
		const wasAlreadyPresent = this.previousValue.has(item)
		if (wasAlreadyPresent) {
			const wasRemoved = this.diff?.removed?.has(item)
			if (!wasRemoved) return
			return this._add(item, wasAlreadyPresent)
		}
		const isCurrentlyPresent = this.nextValue?.has(item)
		if (isCurrentlyPresent) return
		this._add(item, wasAlreadyPresent)
	}
	/**
	 * Remove an item from the set.
	 *
	 * @param item - The item to remove.
	 * @param wasAlreadyPresent - Whether the item was already present in the set.
	 * @internal
	 */
	_remove(item, wasAlreadyPresent) {
		this.nextValue ??= new Set(this.previousValue)
		this.nextValue.delete(item)
		this.diff ??= {}
		if (wasAlreadyPresent) {
			this.diff.removed ??= /* @__PURE__ */ new Set()
			this.diff.removed.add(item)
		} else {
			this.diff.added?.delete(item)
		}
	}
	/**
	 * Remove an item from the set.
	 *
	 * @param item - The item to remove.
	 * @public
	 */
	remove(item) {
		const wasAlreadyPresent = this.previousValue.has(item)
		if (!wasAlreadyPresent) {
			const wasAdded = this.diff?.added?.has(item)
			if (!wasAdded) return
			return this._remove(item, wasAlreadyPresent)
		}
		const hasAlreadyBeenRemoved = this.diff?.removed?.has(item)
		if (hasAlreadyBeenRemoved) return
		this._remove(item, wasAlreadyPresent)
	}
}

// ../packages/tlstore/src/lib/RecordType.ts
init_define_process()

// ../node_modules/nanoid/index.browser.js
init_define_process()
var nanoid = (size = 21) =>
	crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
		byte &= 63
		if (byte < 36) {
			id += byte.toString(36)
		} else if (byte < 62) {
			id += (byte - 26).toString(36).toUpperCase()
		} else if (byte > 62) {
			id += '-'
		} else {
			id += '_'
		}
		return id
	}, '')

// ../packages/tlstore/src/lib/RecordType.ts
var RecordType = class {
	constructor(typeName, config) {
		this.typeName = typeName
		this.createDefaultProperties = config.createDefaultProperties
		this.migrations = config.migrations
		this.validator = config.validator ?? { validate: (r3) => r3 }
		this.scope = config.scope ?? 'document'
	}
	createDefaultProperties
	migrations
	validator
	scope
	/**
	 * Create a new record of this type.
	 *
	 * @param properties - The properties of the record.
	 * @returns The new record.
	 */
	create(properties) {
		const result = { ...this.createDefaultProperties(), id: this.createId() }
		for (const [k2, v3] of Object.entries(properties)) {
			if (v3 !== void 0) {
				result[k2] = v3
			}
		}
		result.typeName = this.typeName
		return result
	}
	/**
	 * Clone a record of this type.
	 *
	 * @param record - The record to clone.
	 * @returns The cloned record.
	 * @public
	 */
	clone(record) {
		return { ...structuredClone(record), id: this.createId() }
	}
	/**
	 * Create a new ID for this record type.
	 *
	 * @example
	 *
	 * ```ts
	 * const id = recordType.createId()
	 * ```
	 *
	 * @returns The new ID.
	 * @public
	 */
	createId() {
		return this.typeName + ':' + nanoid()
	}
	/**
	 * Create a new ID for this record type based on the given ID.
	 *
	 * @example
	 *
	 * ```ts
	 * const id = recordType.createCustomId('myId')
	 * ```
	 *
	 * @param id - The ID to base the new ID on.
	 * @returns The new ID.
	 */
	createCustomId(id) {
		return this.typeName + ':' + id
	}
	/**
	 * Takes an id like `user:123` and returns the part after the colon `123`
	 *
	 * @param id - The id
	 * @returns
	 */
	parseId(id) {
		if (!this.isId(id)) {
			throw new Error(`ID "${id}" is not a valid ID for type "${this.typeName}"`)
		}
		return id.slice(this.typeName.length + 1)
	}
	/**
	 * Check whether a record is an instance of this record type.
	 *
	 * @example
	 *
	 * ```ts
	 * const result = recordType.isInstance(someRecord)
	 * ```
	 *
	 * @param record - The record to check.
	 * @returns Whether the record is an instance of this record type.
	 */
	isInstance = (record) => {
		return record?.typeName === this.typeName
	}
	/**
	 * Check whether an id is an id of this type.
	 *
	 * @example
	 *
	 * ```ts
	 * const result = recordType.isIn('someId')
	 * ```
	 *
	 * @param id - The id to check.
	 * @returns Whether the id is an id of this type.
	 */
	isId(id) {
		if (!id) return false
		for (let i3 = 0; i3 < this.typeName.length; i3++) {
			if (id[i3] !== this.typeName[i3]) return false
		}
		return id[this.typeName.length] === ':'
	}
	/**
	 * Create a new RecordType that has the same type name as this RecordType and includes the given
	 * default properties.
	 *
	 * @example
	 *
	 * ```ts
	 * const authorType = createRecordType('author', () => ({ living: true }))
	 * const deadAuthorType = authorType.withDefaultProperties({ living: false })
	 * ```
	 *
	 * @param fn - A function that returns the default properties of the new RecordType.
	 * @returns The new RecordType.
	 */
	withDefaultProperties(createDefaultProperties) {
		return new RecordType(this.typeName, {
			createDefaultProperties,
			migrations: this.migrations,
			validator: this.validator,
			scope: this.scope,
		})
	}
	/**
	 * Check that the passed in record passes the validations for this type. Returns its input
	 * correctly typed if it does, but throws an error otherwise.
	 */
	validate(record) {
		return this.validator.validate(record)
	}
}
function createRecordType(typeName, config) {
	return new RecordType(typeName, {
		createDefaultProperties: () => ({}),
		migrations: config.migrations ?? { currentVersion: 0, firstVersion: 0, migrators: {} },
		validator: config.validator,
		scope: config.scope,
	})
}

// ../packages/tlstore/src/lib/Store.ts
init_define_process()

// ../node_modules/signia/dist/esm/index.mjs
init_define_process()

// ../node_modules/signia/dist/esm/api.mjs
init_define_process()

// ../node_modules/signia/dist/esm/Atom.mjs
init_define_process()

// ../node_modules/signia/dist/esm/ArraySet.mjs
init_define_process()
var ARRAY_SIZE_THRESHOLD = 8
var ArraySet = class {
	arraySize = 0
	array = Array(ARRAY_SIZE_THRESHOLD)
	set = null
	/**
	 * Get whether this ArraySet has any elements.
	 *
	 * @returns True if this ArraySet has any elements, false otherwise.
	 */
	get isEmpty() {
		if (this.array) {
			return this.arraySize === 0
		}
		if (this.set) {
			return this.set.size === 0
		}
		throw new Error('no set or array')
	}
	/**
	 * Add an item to the ArraySet if it is not already present.
	 *
	 * @param elem - The element to add.
	 */
	add(elem) {
		if (this.array) {
			const idx = this.array.indexOf(elem)
			if (idx !== -1) {
				return false
			}
			if (this.arraySize < ARRAY_SIZE_THRESHOLD) {
				this.array[this.arraySize] = elem
				this.arraySize++
				return true
			} else {
				this.set = new Set(this.array)
				this.array = null
				this.set.add(elem)
				return true
			}
		}
		if (this.set) {
			if (this.set.has(elem)) {
				return false
			}
			this.set.add(elem)
			return true
		}
		throw new Error('no set or array')
	}
	/**
	 * Remove an item from the ArraySet if it is present.
	 *
	 * @param elem - The element to remove
	 */
	remove(elem) {
		if (this.array) {
			const idx = this.array.indexOf(elem)
			if (idx === -1) {
				return false
			}
			this.array[idx] = void 0
			this.arraySize--
			if (idx !== this.arraySize) {
				this.array[idx] = this.array[this.arraySize]
				this.array[this.arraySize] = void 0
			}
			return true
		}
		if (this.set) {
			if (!this.set.has(elem)) {
				return false
			}
			this.set.delete(elem)
			return true
		}
		throw new Error('no set or array')
	}
	/**
	 * Run a callback for each element in the ArraySet.
	 *
	 * @param visitor The callback to run for each element.
	 */
	visit(visitor) {
		if (this.array) {
			for (let i3 = 0; i3 < this.arraySize; i3++) {
				const elem = this.array[i3]
				if (typeof elem !== 'undefined') {
					visitor(elem)
				}
			}
			return
		}
		if (this.set) {
			this.set.forEach(visitor)
			return
		}
		throw new Error('no set or array')
	}
}

// ../node_modules/signia/dist/esm/capture.mjs
init_define_process()

// ../node_modules/signia/dist/esm/helpers.mjs
init_define_process()
function isChild(x3) {
	return x3 && typeof x3 === 'object' && 'parents' in x3
}
function haveParentsChanged(child) {
	for (let i3 = 0, n3 = child.parents.length; i3 < n3; i3++) {
		child.parents[i3].__unsafe__getWithoutCapture()
		if (child.parents[i3].lastChangedEpoch !== child.parentEpochs[i3]) {
			return true
		}
	}
	return false
}
var detach = (parent, child) => {
	if (!parent.children.remove(child)) {
		return
	}
	if (parent.children.isEmpty && isChild(parent)) {
		for (let i3 = 0, n3 = parent.parents.length; i3 < n3; i3++) {
			detach(parent.parents[i3], parent)
		}
	}
}
var attach = (parent, child) => {
	if (!parent.children.add(child)) {
		return
	}
	if (isChild(parent)) {
		for (let i3 = 0, n3 = parent.parents.length; i3 < n3; i3++) {
			attach(parent.parents[i3], parent)
		}
	}
}
function equals(a3, b3) {
	const shallowEquals =
		a3 === b3 ||
		Object.is(a3, b3) ||
		Boolean(a3 && b3 && typeof a3.equals === 'function' && a3.equals(b3))
	return shallowEquals
}
var EMPTY_ARRAY = Object.freeze([])

// ../node_modules/signia/dist/esm/capture.mjs
var signiaKey = Symbol.for('__signia__')
var global2 = globalThis
if (global2[signiaKey]) {
	console.error(
		'Multiple versions of signia detected. This will cause unexpected behavior. Please add "resolutions" (yarn/pnpm) or "overrides" (npm) in your package.json to ensure only one version of signia is loaded.'
	)
} else {
	global2[signiaKey] = true
}
var CaptureStackFrame = class {
	constructor(below, child) {
		this.below = below
		this.child = child
	}
	offset = 0
	numNewParents = 0
	maybeRemoved
}
var stack = null
function startCapturingParents(child) {
	stack = new CaptureStackFrame(stack, child)
}
function stopCapturingParents() {
	const frame2 = stack
	stack = frame2.below
	const didParentsChange = frame2.numNewParents > 0 || frame2.offset !== frame2.child.parents.length
	if (!didParentsChange) {
		return
	}
	for (let i3 = frame2.offset; i3 < frame2.child.parents.length; i3++) {
		const p3 = frame2.child.parents[i3]
		const parentWasRemoved = frame2.child.parents.indexOf(p3) >= frame2.offset
		if (parentWasRemoved) {
			detach(p3, frame2.child)
		}
	}
	frame2.child.parents.length = frame2.offset
	frame2.child.parentEpochs.length = frame2.offset
	if (stack?.maybeRemoved) {
		for (let i3 = 0; i3 < stack.maybeRemoved.length; i3++) {
			const maybeRemovedParent = stack.maybeRemoved[i3]
			if (frame2.child.parents.indexOf(maybeRemovedParent) === -1) {
				detach(maybeRemovedParent, frame2.child)
			}
		}
	}
}
function maybeCaptureParent(p3) {
	if (stack) {
		const idx = stack.child.parents.indexOf(p3)
		if (idx < 0) {
			stack.numNewParents++
			if (stack.child.isActivelyListening) {
				attach(p3, stack.child)
			}
		}
		if (idx < 0 || idx >= stack.offset) {
			if (idx !== stack.offset && idx > 0) {
				const maybeRemovedParent = stack.child.parents[stack.offset]
				if (!stack.maybeRemoved) {
					stack.maybeRemoved = [maybeRemovedParent]
				} else if (stack.maybeRemoved.indexOf(maybeRemovedParent) === -1) {
					stack.maybeRemoved.push(maybeRemovedParent)
				}
			}
			stack.child.parents[stack.offset] = p3
			stack.child.parentEpochs[stack.offset] = p3.lastChangedEpoch
			stack.offset++
		}
	}
}

// ../node_modules/signia/dist/esm/HistoryBuffer.mjs
init_define_process()

// ../node_modules/signia/dist/esm/types.mjs
init_define_process()
var RESET_VALUE = Symbol('RESET_VALUE')

// ../node_modules/signia/dist/esm/HistoryBuffer.mjs
var HistoryBuffer = class {
	constructor(capacity) {
		this.capacity = capacity
		this.buffer = new Array(capacity)
	}
	index = 0
	// use a wrap around buffer to store the last N values
	buffer
	/**
	 * Add a diff to the history buffer.
	 *
	 * @param lastComputedEpoch The epoch when the diff was computed.
	 * @param currentEpoch The current epoch.
	 * @param diff (optional) The diff to add, or else a reset value.
	 */
	pushEntry(lastComputedEpoch, currentEpoch, diff) {
		if (diff === void 0) {
			return
		}
		if (diff === RESET_VALUE) {
			this.clear()
			return
		}
		this.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff]
		this.index = (this.index + 1) % this.capacity
	}
	/**
	 * Clear the history buffer.
	 */
	clear() {
		this.index = 0
		this.buffer.fill(void 0)
	}
	/**
	 * Get the diffs since the given epoch.
	 *
	 * @param epoch The epoch to get diffs since.
	 * @returns An array of diffs or a flag to reset the history buffer.
	 */
	getChangesSince(sinceEpoch) {
		const { index: index2, capacity, buffer } = this
		for (let i3 = 0; i3 < capacity; i3++) {
			const offset = (index2 - 1 + capacity - i3) % capacity
			const elem = buffer[offset]
			if (!elem) {
				return RESET_VALUE
			}
			const [fromEpoch, toEpoch] = elem
			if (i3 === 0 && sinceEpoch >= toEpoch) {
				return []
			}
			if (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {
				const len = i3 + 1
				const result = new Array(len)
				for (let j = 0; j < len; j++) {
					result[j] = buffer[(offset + j) % capacity][2]
				}
				return result
			}
		}
		return RESET_VALUE
	}
}

// ../node_modules/signia/dist/esm/transactions.mjs
init_define_process()

// ../node_modules/signia/dist/esm/constants.mjs
init_define_process()
var GLOBAL_START_EPOCH = -1

// ../node_modules/signia/dist/esm/transactions.mjs
var globalEpoch = GLOBAL_START_EPOCH + 1
var globalIsReacting = false
function advanceGlobalEpoch() {
	globalEpoch++
}
var Transaction = class {
	constructor(parent) {
		this.parent = parent
	}
	initialAtomValues = /* @__PURE__ */ new Map()
	/**
	 * Get whether this transaction is a root (no parents).
	 *
	 * @public
	 */
	get isRoot() {
		return this.parent === null
	}
	/**
	 * Commit the transaction's changes.
	 *
	 * @public
	 */
	commit() {
		if (this.isRoot) {
			const atoms = this.initialAtomValues
			this.initialAtomValues = /* @__PURE__ */ new Map()
			flushChanges(atoms.keys())
		} else {
			this.initialAtomValues.forEach((value, atom2) => {
				if (!this.parent.initialAtomValues.has(atom2)) {
					this.parent.initialAtomValues.set(atom2, value)
				}
			})
		}
	}
	/**
	 * Abort the transaction.
	 *
	 * @public
	 */
	abort() {
		globalEpoch++
		this.initialAtomValues.forEach((value, atom2) => {
			atom2.set(value)
			atom2.historyBuffer?.clear()
		})
		this.commit()
	}
}
function flushChanges(atoms) {
	if (globalIsReacting) {
		throw new Error('cannot change atoms during reaction cycle')
	}
	try {
		globalIsReacting = true
		const reactors = /* @__PURE__ */ new Set()
		const traverse = (node) => {
			if (node.lastTraversedEpoch === globalEpoch) {
				return
			}
			node.lastTraversedEpoch = globalEpoch
			if ('maybeScheduleEffect' in node) {
				reactors.add(node)
			} else {
				node.children.visit(traverse)
			}
		}
		for (const atom2 of atoms) {
			atom2.children.visit(traverse)
		}
		for (const r3 of reactors) {
			r3.maybeScheduleEffect()
		}
	} finally {
		globalIsReacting = false
	}
}
function atomDidChange(atom2, previousValue) {
	if (!currentTransaction) {
		flushChanges([atom2])
	} else if (!currentTransaction.initialAtomValues.has(atom2)) {
		currentTransaction.initialAtomValues.set(atom2, previousValue)
	}
}
var currentTransaction = null
function transaction(fn) {
	const txn = new Transaction(currentTransaction)
	currentTransaction = txn
	try {
		let rollback = false
		const result = fn(() => (rollback = true))
		if (rollback) {
			txn.abort()
		} else {
			txn.commit()
		}
		return result
	} catch (e2) {
		txn.abort()
		throw e2
	} finally {
		currentTransaction = currentTransaction.parent
	}
}
function transact(fn) {
	if (currentTransaction) {
		return fn()
	}
	return transaction(fn)
}

// ../node_modules/signia/dist/esm/Atom.mjs
var _Atom = class {
	constructor(name, current, options) {
		this.name = name
		this.current = current
		this.isEqual = options?.isEqual ?? null
		if (!options) return
		if (options.historyLength) {
			this.historyBuffer = new HistoryBuffer(options.historyLength)
		}
		this.computeDiff = options.computeDiff
	}
	isEqual
	computeDiff
	lastChangedEpoch = globalEpoch
	children = new ArraySet()
	historyBuffer
	__unsafe__getWithoutCapture() {
		return this.current
	}
	get value() {
		maybeCaptureParent(this)
		return this.current
	}
	set(value, diff) {
		if (this.isEqual?.(this.current, value) ?? equals(this.current, value)) {
			return this.current
		}
		advanceGlobalEpoch()
		if (this.historyBuffer) {
			this.historyBuffer.pushEntry(
				this.lastChangedEpoch,
				globalEpoch,
				diff ??
					this.computeDiff?.(this.current, value, this.lastChangedEpoch, globalEpoch) ??
					RESET_VALUE
			)
		}
		this.lastChangedEpoch = globalEpoch
		const oldValue = this.current
		this.current = value
		atomDidChange(this, oldValue)
		return value
	}
	update(updater) {
		return this.set(updater(this.current))
	}
	getDiffSince(epoch) {
		maybeCaptureParent(this)
		if (epoch >= this.lastChangedEpoch) {
			return EMPTY_ARRAY
		}
		return this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE
	}
}
function atom(name, initialValue, options) {
	return new _Atom(name, initialValue, options)
}

// ../node_modules/signia/dist/esm/Computed.mjs
init_define_process()
var UNINITIALIZED = Symbol('UNINITIALIZED')
var isUninitialized = (value) => {
	return value === UNINITIALIZED
}
var WithDiff = class {
	constructor(value, diff) {
		this.value = value
		this.diff = diff
	}
}
function withDiff(value, diff) {
	return new WithDiff(value, diff)
}
var _Computed = class {
	constructor(name, derive, options) {
		this.name = name
		this.derive = derive
		if (options?.historyLength) {
			this.historyBuffer = new HistoryBuffer(options.historyLength)
		}
		this.computeDiff = options?.computeDiff
		this.isEqual = options?.isEqual ?? equals
	}
	lastChangedEpoch = GLOBAL_START_EPOCH
	lastTraversedEpoch = GLOBAL_START_EPOCH
	/**
	 * The epoch when the reactor was last checked.
	 */
	lastCheckedEpoch = GLOBAL_START_EPOCH
	parents = []
	parentEpochs = []
	children = new ArraySet()
	get isActivelyListening() {
		return !this.children.isEmpty
	}
	historyBuffer
	// The last-computed value of this signal.
	state = UNINITIALIZED
	computeDiff
	isEqual
	__unsafe__getWithoutCapture() {
		const isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH
		if (!isNew && (this.lastCheckedEpoch === globalEpoch || !haveParentsChanged(this))) {
			this.lastCheckedEpoch = globalEpoch
			return this.state
		}
		try {
			startCapturingParents(this)
			const result = this.derive(this.state, this.lastCheckedEpoch)
			const newState = result instanceof WithDiff ? result.value : result
			if (this.state === UNINITIALIZED || !this.isEqual(newState, this.state)) {
				if (this.historyBuffer && !isNew) {
					const diff = result instanceof WithDiff ? result.diff : void 0
					this.historyBuffer.pushEntry(
						this.lastChangedEpoch,
						globalEpoch,
						diff ??
							this.computeDiff?.(this.state, newState, this.lastCheckedEpoch, globalEpoch) ??
							RESET_VALUE
					)
				}
				this.lastChangedEpoch = globalEpoch
				this.state = newState
			}
			this.lastCheckedEpoch = globalEpoch
			return this.state
		} finally {
			stopCapturingParents()
		}
	}
	get value() {
		const value = this.__unsafe__getWithoutCapture()
		maybeCaptureParent(this)
		return value
	}
	getDiffSince(epoch) {
		this.value
		if (epoch >= this.lastChangedEpoch) {
			return EMPTY_ARRAY
		}
		return this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE
	}
}
function computedAnnotation(options = {}, _target, key, descriptor) {
	const originalMethod = descriptor.get
	const derivationKey = Symbol.for('__signia__computed__' + key)
	descriptor.get = function () {
		let d3 = this[derivationKey]
		if (!d3) {
			d3 = new _Computed(key, originalMethod.bind(this), options)
			Object.defineProperty(this, derivationKey, {
				enumerable: false,
				configurable: false,
				writable: false,
				value: d3,
			})
		}
		return d3.value
	}
	return descriptor
}
function computed() {
	if (arguments.length === 1) {
		const options = arguments[0]
		return (target, key, descriptor) => computedAnnotation(options, target, key, descriptor)
	} else if (typeof arguments[0] === 'string') {
		return new _Computed(arguments[0], arguments[1], arguments[2])
	} else {
		return computedAnnotation(void 0, arguments[0], arguments[1], arguments[2])
	}
}

// ../node_modules/signia/dist/esm/EffectScheduler.mjs
init_define_process()
var EffectScheduler = class {
	constructor(name, runEffect, options) {
		this.name = name
		this.runEffect = runEffect
		this._scheduleEffect = options?.scheduleEffect
	}
	_isActivelyListening = false
	/**
	 * Whether this scheduler is attached and actively listening to its parents.
	 * @public
	 */
	get isActivelyListening() {
		return this._isActivelyListening
	}
	/** @internal */
	lastTraversedEpoch = GLOBAL_START_EPOCH
	lastReactedEpoch = GLOBAL_START_EPOCH
	_scheduleCount = 0
	/**
	 * The number of times this effect has been scheduled.
	 * @public
	 */
	get scheduleCount() {
		return this._scheduleCount
	}
	/** @internal */
	parentEpochs = []
	/** @internal */
	parents = []
	_scheduleEffect
	/** @internal */
	maybeScheduleEffect() {
		if (!this._isActivelyListening) return
		if (this.lastReactedEpoch === globalEpoch) return
		if (this.parents.length && !haveParentsChanged(this)) {
			this.lastReactedEpoch = globalEpoch
			return
		}
		this.scheduleEffect()
	}
	/** @internal */
	scheduleEffect() {
		this._scheduleCount++
		if (this._scheduleEffect) {
			this._scheduleEffect(this.maybeExecute)
		} else {
			this.execute()
		}
	}
	maybeExecute = () => {
		if (!this._isActivelyListening) return
		this.execute()
	}
	/**
	 * Makes this scheduler become 'actively listening' to its parents.
	 * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
	 * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].
	 * @public
	 */
	attach() {
		this._isActivelyListening = true
		for (let i3 = 0, n3 = this.parents.length; i3 < n3; i3++) {
			attach(this.parents[i3], this)
		}
	}
	/**
	 * Makes this scheduler stop 'actively listening' to its parents.
	 * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.
	 */
	detach() {
		this._isActivelyListening = false
		for (let i3 = 0, n3 = this.parents.length; i3 < n3; i3++) {
			detach(this.parents[i3], this)
		}
	}
	/**
	 * Executes the effect immediately and returns the result.
	 * @returns The result of the effect.
	 */
	execute() {
		try {
			startCapturingParents(this)
			const result = this.runEffect(this.lastReactedEpoch)
			this.lastReactedEpoch = globalEpoch
			return result
		} finally {
			stopCapturingParents()
		}
	}
}
function react(name, fn, options) {
	const scheduler = new EffectScheduler(name, fn, options)
	scheduler.attach()
	scheduler.scheduleEffect()
	return () => {
		scheduler.detach()
	}
}
function reactor(name, fn, options) {
	const scheduler = new EffectScheduler(name, fn, options)
	return {
		scheduler,
		start: (options2) => {
			const force = options2?.force ?? false
			scheduler.attach()
			if (force) {
				scheduler.scheduleEffect()
			} else {
				scheduler.maybeScheduleEffect()
			}
		},
		stop: () => {
			scheduler.detach()
		},
	}
}

// ../node_modules/signia/dist/esm/isSignal.mjs
init_define_process()

// ../packages/tlstore/src/lib/Cache.ts
init_define_process()
var Cache = class {
	/** The map of items to their cached values. */
	items = /* @__PURE__ */ new WeakMap()
	/**
	 * Get the cached value for a given record. If the record is not present in the map, the callback
	 * will be used to create the value (with the result being stored in the cache for next time).
	 *
	 * @param item - The item to get.
	 * @param cb - The callback to use to create the value when a cached value is not found.
	 */
	get(item, cb) {
		if (!this.items.has(item)) {
			this.items.set(item, cb(item))
		}
		return this.items.get(item)
	}
}

// ../packages/tlstore/src/lib/StoreQueries.ts
init_define_process()
var import_lodash = __toESM(require_lodash())

// ../packages/tlstore/src/lib/executeQuery.ts
init_define_process()

// ../packages/tlstore/src/lib/setUtils.ts
init_define_process()
function intersectSets(sets) {
	if (sets.length === 0) return /* @__PURE__ */ new Set()
	const first = sets[0]
	const rest = sets.slice(1)
	const result = /* @__PURE__ */ new Set()
	for (const val of first) {
		if (rest.every((set) => set.has(val))) {
			result.add(val)
		}
	}
	return result
}
function diffSets(prev, next) {
	const result = {}
	for (const val of next) {
		if (!prev.has(val)) {
			result.added ??= /* @__PURE__ */ new Set()
			result.added.add(val)
		}
	}
	for (const val of prev) {
		if (!next.has(val)) {
			result.removed ??= /* @__PURE__ */ new Set()
			result.removed.add(val)
		}
	}
	return result.added || result.removed ? result : void 0
}

// ../packages/tlstore/src/lib/executeQuery.ts
function objectMatchesQuery(query, object2) {
	for (const [key, _matcher] of Object.entries(query)) {
		const matcher = _matcher
		const value = object2[key]
		if ('eq' in matcher && value !== matcher.eq) return false
		if ('neq' in matcher && value === matcher.neq) return false
		if ('gt' in matcher && (typeof value !== 'number' || value <= matcher.gt)) return false
	}
	return true
}
function executeQuery(store, typeName, query) {
	const matchIds = Object.fromEntries(
		Object.keys(query).map((key) => [key, /* @__PURE__ */ new Set()])
	)
	for (const [k2, matcher] of Object.entries(query)) {
		if ('eq' in matcher) {
			const index2 = store.index(typeName, k2)
			const ids = index2.value.get(matcher.eq)
			if (ids) {
				for (const id of ids) {
					matchIds[k2].add(id)
				}
			}
		} else if ('neq' in matcher) {
			const index2 = store.index(typeName, k2)
			for (const [value, ids] of index2.value) {
				if (value !== matcher.neq) {
					for (const id of ids) {
						matchIds[k2].add(id)
					}
				}
			}
		} else if ('gt' in matcher) {
			const index2 = store.index(typeName, k2)
			for (const [value, ids] of index2.value) {
				if (value > matcher.gt) {
					for (const id of ids) {
						matchIds[k2].add(id)
					}
				}
			}
		}
	}
	return intersectSets(Object.values(matchIds))
}

// ../packages/tlstore/src/lib/StoreQueries.ts
var StoreQueries = class {
	constructor(atoms, history) {
		this.atoms = atoms
		this.history = history
	}
	/**
	 * A cache of derivations (indexes).
	 *
	 * @internal
	 */
	indexCache = /* @__PURE__ */ new Map()
	/**
	 * A cache of derivations (filtered histories).
	 *
	 * @internal
	 */
	historyCache = /* @__PURE__ */ new Map()
	/**
	 * Create a derivation that contains the hisotry for a given type
	 *
	 * @param typeName - The name of the type to filter by.
	 * @returns A derivation that returns the ids of all records of the given type.
	 * @public
	 */
	filterHistory(typeName) {
		if (this.historyCache.has(typeName)) {
			return this.historyCache.get(typeName)
		}
		const filtered = computed(
			'filterHistory:' + typeName,
			(lastValue, lastComputedEpoch) => {
				if (isUninitialized(lastValue)) {
					return this.history.value
				}
				const diff = this.history.getDiffSince(lastComputedEpoch)
				if (diff === RESET_VALUE) return this.history.value
				const res = { added: {}, removed: {}, updated: {} }
				let numAdded = 0
				let numRemoved = 0
				let numUpdated = 0
				for (const changes of diff) {
					for (const added of objectMapValues(changes.added)) {
						if (added.typeName === typeName) {
							if (res.removed[added.id]) {
								const original = res.removed[added.id]
								delete res.removed[added.id]
								numRemoved--
								if (original !== added) {
									res.updated[added.id] = [original, added]
									numUpdated++
								}
							} else {
								res.added[added.id] = added
								numAdded++
							}
						}
					}
					for (const [from, to] of objectMapValues(changes.updated)) {
						if (to.typeName === typeName) {
							if (res.added[to.id]) {
								res.added[to.id] = to
							} else if (res.updated[to.id]) {
								res.updated[to.id] = [res.updated[to.id][0], to]
							} else {
								res.updated[to.id] = [from, to]
								numUpdated++
							}
						}
					}
					for (const removed of objectMapValues(changes.removed)) {
						if (removed.typeName === typeName) {
							if (res.added[removed.id]) {
								delete res.added[removed.id]
								numAdded--
							} else if (res.updated[removed.id]) {
								res.removed[removed.id] = res.updated[removed.id][0]
								delete res.updated[removed.id]
								numUpdated--
								numRemoved++
							} else {
								res.removed[removed.id] = removed
								numRemoved++
							}
						}
					}
				}
				if (numAdded || numRemoved || numUpdated) {
					return withDiff(this.history.value, res)
				} else {
					return lastValue
				}
			},
			{ historyLength: 100 }
		)
		this.historyCache.set(typeName, filtered)
		return filtered
	}
	/**
	 * Create a derivation that returns an index on a property for the given type.
	 *
	 * @param typeName - The name of the type.
	 * @param property - The name of the property.
	 * @public
	 */
	index(typeName, property) {
		const cacheKey = typeName + ':' + property
		if (this.indexCache.has(cacheKey)) {
			return this.indexCache.get(cacheKey)
		}
		const index2 = this.__uncached_createIndex(typeName, property)
		this.indexCache.set(cacheKey, index2)
		return index2
	}
	/**
	 * Create a derivation that returns an index on a property for the given type.
	 *
	 * @param typeName - The name of the type?.
	 * @param property - The name of the property?.
	 * @internal
	 */
	__uncached_createIndex(typeName, property) {
		const typeHistory = this.filterHistory(typeName)
		const fromScratch = () => {
			typeHistory.value
			const res = /* @__PURE__ */ new Map()
			for (const atom2 of objectMapValues(this.atoms.value)) {
				const record = atom2.value
				if (record.typeName === typeName) {
					const value = record[property]
					if (!res.has(value)) {
						res.set(value, /* @__PURE__ */ new Set())
					}
					res.get(value).add(record.id)
				}
			}
			return res
		}
		return computed(
			'index:' + typeName + ':' + property,
			(prevValue, lastComputedEpoch) => {
				if (isUninitialized(prevValue)) return fromScratch()
				const history = typeHistory.getDiffSince(lastComputedEpoch)
				if (history === RESET_VALUE) {
					return fromScratch()
				}
				const setConstructors = /* @__PURE__ */ new Map()
				const add = (value, id) => {
					let setConstructor = setConstructors.get(value)
					if (!setConstructor)
						setConstructor = new IncrementalSetConstructor(
							prevValue.get(value) ?? /* @__PURE__ */ new Set()
						)
					setConstructor.add(id)
					setConstructors.set(value, setConstructor)
				}
				const remove = (value, id) => {
					let set = setConstructors.get(value)
					if (!set)
						set = new IncrementalSetConstructor(prevValue.get(value) ?? /* @__PURE__ */ new Set())
					set.remove(id)
					setConstructors.set(value, set)
				}
				for (const changes of history) {
					for (const record of objectMapValues(changes.added)) {
						if (record.typeName === typeName) {
							const value = record[property]
							add(value, record.id)
						}
					}
					for (const [from, to] of objectMapValues(changes.updated)) {
						if (to.typeName === typeName) {
							const prev = from[property]
							const next = to[property]
							if (prev !== next) {
								remove(prev, to.id)
								add(next, to.id)
							}
						}
					}
					for (const record of objectMapValues(changes.removed)) {
						if (record.typeName === typeName) {
							const value = record[property]
							remove(value, record.id)
						}
					}
				}
				let nextValue = void 0
				let nextDiff = void 0
				for (const [value, setConstructor] of setConstructors) {
					const result = setConstructor.get()
					if (!result) continue
					if (!nextValue) nextValue = new Map(prevValue)
					if (!nextDiff) nextDiff = /* @__PURE__ */ new Map()
					if (result.value.size === 0) {
						nextValue.delete(value)
					} else {
						nextValue.set(value, result.value)
					}
					nextDiff.set(value, result.diff)
				}
				if (nextValue && nextDiff) {
					return withDiff(nextValue, nextDiff)
				}
				return prevValue
			},
			{ historyLength: 100 }
		)
	}
	/**
	 * Create a derivation that will return a signle record matching the given query.
	 *
	 * It will return undefined if there is no matching record
	 *
	 * @param typeName - The name of the type?
	 * @param queryCreator - A function that returns the query expression.
	 * @param name - (optinal) The name of the query.
	 */
	record(
		typeName,
		queryCreator = () => ({}),
		name = 'record:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')
	) {
		const ids = this.ids(typeName, queryCreator, name)
		return computed(name, () => {
			for (const id of ids.value) {
				return this.atoms.value[id]?.value
			}
			return void 0
		})
	}
	/**
	 * Create a derivation that will return an array of records matching the given query
	 *
	 * @param typeName - The name of the type?
	 * @param queryCreator - A function that returns the query expression.
	 * @param name - (optinal) The name of the query.
	 */
	records(
		typeName,
		queryCreator = () => ({}),
		name = 'records:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')
	) {
		const ids = this.ids(typeName, queryCreator, 'ids:' + name)
		return computed(name, () => {
			return [...ids.value].map((id) => {
				const atom2 = this.atoms.value[id]
				if (!atom2) {
					throw new Error('no atom found for record id: ' + id)
				}
				return atom2.value
			})
		})
	}
	/**
	 * Create a derivation that will return the ids of all records of the given type.
	 *
	 * @param typeName - The name of the type.
	 * @param queryCreator - A function that returns the query expression.
	 * @param name - (optinal) The name of the query.
	 */
	ids(
		typeName,
		queryCreator = () => ({}),
		name = 'ids:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')
	) {
		const typeHistory = this.filterHistory(typeName)
		const fromScratch = () => {
			typeHistory.value
			const query = queryCreator()
			if (Object.keys(query).length === 0) {
				return new Set(
					objectMapValues(this.atoms.value).flatMap((v3) => {
						const r3 = v3.value
						if (r3.typeName === typeName) {
							return r3.id
						} else {
							return []
						}
					})
				)
			}
			return executeQuery(this, typeName, query)
		}
		const fromScratchWithDiff = (prevValue) => {
			const nextValue = fromScratch()
			const diff = diffSets(prevValue, nextValue)
			if (diff) {
				return withDiff(nextValue, diff)
			} else {
				return prevValue
			}
		}
		const cachedQuery = computed('ids_query:' + name, queryCreator, {
			isEqual: import_lodash.default,
		})
		return computed(
			'query:' + name,
			(prevValue, lastComputedEpoch) => {
				const query = cachedQuery.value
				if (isUninitialized(prevValue)) {
					return fromScratch()
				}
				if (lastComputedEpoch < cachedQuery.lastChangedEpoch) {
					return fromScratchWithDiff(prevValue)
				}
				const history = typeHistory.getDiffSince(lastComputedEpoch)
				if (history === RESET_VALUE) {
					return fromScratchWithDiff(prevValue)
				}
				const setConstructor = new IncrementalSetConstructor(prevValue)
				for (const changes of history) {
					for (const added of objectMapValues(changes.added)) {
						if (added.typeName === typeName && objectMatchesQuery(query, added)) {
							setConstructor.add(added.id)
						}
					}
					for (const [_, updated] of objectMapValues(changes.updated)) {
						if (updated.typeName === typeName) {
							if (objectMatchesQuery(query, updated)) {
								setConstructor.add(updated.id)
							} else {
								setConstructor.remove(updated.id)
							}
						}
					}
					for (const removed of objectMapValues(changes.removed)) {
						if (removed.typeName === typeName) {
							setConstructor.remove(removed.id)
						}
					}
				}
				const result = setConstructor.get()
				if (!result) {
					return prevValue
				}
				return withDiff(result.value, result.diff)
			},
			{ historyLength: 50 }
		)
	}
	exec(typeName, query) {
		const ids = executeQuery(this, typeName, query)
		if (ids.size === 0) {
			return EMPTY_ARRAY
		}
		const atoms = this.atoms.value
		return [...ids].map((id) => atoms[id].value)
	}
}

// ../packages/tlstore/src/lib/devFreeze.ts
init_define_process()
function devFreeze(object2) {
	if (define_process_default.env.NODE_ENV === 'production') {
		return object2
	}
	const proto = Object.getPrototypeOf(object2)
	if (proto && !(proto === Array.prototype || proto === Object.prototype)) {
		console.error('cannot include non-js data in a record', object2)
		throw new Error('cannot include non-js data in a record')
	}
	const propNames = Object.getOwnPropertyNames(object2)
	for (const name of propNames) {
		const value = object2[name]
		if (value && typeof value === 'object') {
			devFreeze(value)
		}
	}
	return Object.freeze(object2)
}

// ../packages/tlstore/src/lib/Store.ts
var Store = class {
	/**
	 * An atom containing the store's atoms.
	 *
	 * @internal
	 * @readonly
	 */
	atoms = atom('store_atoms', {})
	/**
	 * An atom containing the store's history.
	 *
	 * @public
	 * @readonly
	 */
	history = atom('history', 0, {
		historyLength: 1e3,
	})
	/**
	 * A StoreQueries instance for this store.
	 *
	 * @public
	 * @readonly
	 */
	query = new StoreQueries(this.atoms, this.history)
	/**
	 * A set containing listeners that have been added to this store.
	 *
	 * @internal
	 */
	listeners = /* @__PURE__ */ new Set()
	/**
	 * An array of history entries that have not yet been flushed.
	 *
	 * @internal
	 */
	historyAccumulator = new HistoryAccumulator()
	/**
	 * A reactor that responds to changes to the history by squashing the accumulated history and
	 * notifying listeners of the changes.
	 *
	 * @internal
	 */
	historyReactor
	schema
	props
	constructor(config) {
		const { initialData, schema } = config
		this.schema = schema
		this.props = config.props
		if (initialData) {
			this.atoms.set(
				objectMapFromEntries(
					objectMapEntries(initialData).map(([id, record]) => [
						id,
						atom('atom:' + id, this.schema.validateRecord(this, record, 'initialize', null)),
					])
				)
			)
		}
		this.historyReactor = reactor(
			'Store.historyReactor',
			() => {
				this.history.value
				this._flushHistory()
			},
			{ scheduleEffect: (cb) => throttledRaf(cb) }
		)
	}
	_flushHistory() {
		if (this.historyAccumulator.hasChanges()) {
			const entries = this.historyAccumulator.flush()
			for (const { changes, source } of entries) {
				this.listeners.forEach((l3) => l3({ changes, source }))
			}
		}
	}
	/**
	 * Update the history with a diff of changes.
	 *
	 * @param changes - The changes to add to the history.
	 */
	updateHistory(changes) {
		this.historyAccumulator.add({
			changes,
			source: this.isMergingRemoteChanges ? 'remote' : 'user',
		})
		if (this.listeners.size === 0) {
			this.historyAccumulator.clear()
		}
		this.history.set(this.history.value + 1, changes)
	}
	validate(phase) {
		this.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null))
	}
	/**
	 * A callback fired after a record is created. Use this to perform related updates to other
	 * records in the store.
	 *
	 * @param record - The record to be created
	 */
	onAfterCreate
	/**
	 * A callback fired after each record's change.
	 *
	 * @param prev - The previous value, if any.
	 * @param next - The next value.
	 */
	onAfterChange
	/**
	 * A callback fired before a record is deleted.
	 *
	 * @param prev - The record that will be deleted.
	 */
	onBeforeDelete
	/**
	 * A callback fired after a record is deleted.
	 *
	 * @param prev - The record that will be deleted.
	 */
	onAfterDelete
	// used to avoid running callbacks when rolling back changes in sync client
	_runCallbacks = true
	/**
	 * Add some records to the store. It's an error if they already exist.
	 *
	 * @param records - The records to add.
	 * @public
	 */
	put = (records, phaseOverride) => {
		transact(() => {
			const updates = {}
			const additions = {}
			const currentMap = this.atoms.__unsafe__getWithoutCapture()
			let map = null
			let record
			let didChange = false
			for (let i3 = 0, n3 = records.length; i3 < n3; i3++) {
				record = records[i3]
				const recordAtom = (map ?? currentMap)[record.id]
				if (recordAtom) {
					const initialValue = recordAtom.__unsafe__getWithoutCapture()
					record = this.schema.validateRecord(
						this,
						record,
						phaseOverride ?? 'updateRecord',
						initialValue
					)
					recordAtom.set(devFreeze(record))
					const finalValue = recordAtom.__unsafe__getWithoutCapture()
					if (initialValue !== finalValue) {
						didChange = true
						updates[record.id] = [initialValue, finalValue]
					}
				} else {
					didChange = true
					record = this.schema.validateRecord(this, record, phaseOverride ?? 'createRecord', null)
					additions[record.id] = record
					if (!map) {
						map = { ...currentMap }
					}
					map[record.id] = atom('atom:' + record.id, record)
				}
			}
			if (map) {
				this.atoms.set(map)
			}
			if (!didChange) return
			this.updateHistory({
				added: additions,
				updated: updates,
				removed: {},
			})
			const { onAfterCreate, onAfterChange } = this
			if (onAfterCreate && this._runCallbacks) {
				Object.values(additions).forEach((record2) => {
					onAfterCreate(record2)
				})
			}
			if (onAfterChange && this._runCallbacks) {
				Object.values(updates).forEach(([from, to]) => {
					onAfterChange(from, to)
				})
			}
		})
	}
	/**
	 * Remove some records from the store via their ids.
	 *
	 * @param ids - The ids of the records to remove.
	 * @public
	 */
	remove = (ids) => {
		transact(() => {
			if (this.onBeforeDelete && this._runCallbacks) {
				for (const id of ids) {
					const atom2 = this.atoms.__unsafe__getWithoutCapture()[id]
					if (!atom2) continue
					this.onBeforeDelete(atom2.value)
				}
			}
			let removed = void 0
			this.atoms.update((atoms) => {
				let result = void 0
				for (const id of ids) {
					if (!(id in atoms)) continue
					if (!result) result = { ...atoms }
					if (!removed) removed = {}
					delete result[id]
					removed[id] = atoms[id].value
				}
				return result ?? atoms
			})
			if (!removed) return
			this.updateHistory({ added: {}, updated: {}, removed })
			if (this.onAfterDelete && this._runCallbacks) {
				for (let i3 = 0, n3 = ids.length; i3 < n3; i3++) {
					this.onAfterDelete(removed[ids[i3]])
				}
			}
		})
	}
	/**
	 * Get the value of a store record by its id.
	 *
	 * @param id - The id of the record to get.
	 * @public
	 */
	get = (id) => {
		return this.atoms.value[id]?.value
	}
	/**
	 * Get the value of a store record by its id without updating its epoch.
	 *
	 * @param id - The id of the record to get.
	 * @public
	 */
	unsafeGetWithoutCapture = (id) => {
		return this.atoms.value[id]?.__unsafe__getWithoutCapture()
	}
	/**
	 * Opposite of `deserialize`. Creates a JSON payload from the record store.
	 *
	 * @param filter - A function to filter structs that do not satisfy the predicate.
	 * @returns The record store snapshot as a JSON payload.
	 */
	serialize = (filter2) => {
		const result = {}
		for (const [id, atom2] of objectMapEntries(this.atoms.value)) {
			const record = atom2.value
			if (typeof filter2 === 'function' && !filter2(record)) continue
			result[id] = record
		}
		return result
	}
	/**
	 * The same as `serialize`, but only serializes records with a scope of `document`.
	 * @returns The record store snapshot as a JSON payload.
	 */
	serializeDocumentState = () => {
		return this.serialize((r3) => {
			const type = this.schema.types[r3.typeName]
			return type.scope === 'document'
		})
	}
	/**
	 * Opposite of `serialize`. Replace the store's current records with records as defined by a
	 * simple JSON structure into the stores.
	 *
	 * @param snapshot - The JSON snapshot to deserialize.
	 * @public
	 */
	deserialize = (snapshot) => {
		transact(() => {
			this.clear()
			this.put(Object.values(snapshot))
		})
	}
	/**
	 * Get an array of all values in the store.
	 *
	 * @returns An array of all values in the store.
	 * @public
	 */
	allRecords = () => {
		return objectMapValues(this.atoms.value).map((atom2) => atom2.value)
	}
	/**
	 * Removes all records from the store.
	 *
	 * @public
	 */
	clear = () => {
		this.remove(objectMapKeys(this.atoms.value))
	}
	/**
	 * Update a record. To update multiple records at once, use the `update` method of the
	 * `TypedStore` class.
	 *
	 * @param id - The id of the record to update.
	 * @param updater - A function that updates the record.
	 */
	update = (id, updater) => {
		const atom2 = this.atoms.value[id]
		if (!atom2) {
			console.error(`Record ${id} not found. This is probably an error`)
			return
		}
		this.put([updater(atom2.__unsafe__getWithoutCapture())])
	}
	/**
	 * Get whether the record store has a id.
	 *
	 * @param id - The id of the record to check.
	 * @public
	 */
	has = (id) => {
		return !!this.atoms.value[id]
	}
	/**
	 * Add a new listener to the store.
	 *
	 * @param listener - The listener to call when the store updates.
	 * @returns A function to remove the listener.
	 */
	listen = (listener) => {
		this._flushHistory()
		this.listeners.add(listener)
		if (!this.historyReactor.scheduler.isActivelyListening) {
			this.historyReactor.start()
		}
		return () => {
			this.listeners.delete(listener)
			if (this.listeners.size === 0) {
				this.historyReactor.stop()
			}
		}
	}
	isMergingRemoteChanges = false
	/**
	 * Merge changes from a remote source without triggering listeners.
	 *
	 * @param fn - A function that merges the external changes.
	 * @public
	 */
	mergeRemoteChanges = (fn) => {
		if (this.isMergingRemoteChanges) {
			return fn()
		}
		try {
			this.isMergingRemoteChanges = true
			transact(fn)
		} finally {
			this.isMergingRemoteChanges = false
		}
	}
	extractingChanges(fn) {
		const changes = []
		const dispose = this.historyAccumulator.intercepting((entry) => changes.push(entry.changes))
		try {
			transact(fn)
			return squashRecordDiffs(changes)
		} finally {
			dispose()
		}
	}
	applyDiff(diff, runCallbacks = true) {
		const prevRunCallbacks = this._runCallbacks
		try {
			this._runCallbacks = runCallbacks
			transact(() => {
				const toPut = objectMapValues(diff.added).concat(
					objectMapValues(diff.updated).map(([_from, to]) => to)
				)
				const toRemove = objectMapKeys(diff.removed)
				if (toPut.length) {
					this.put(toPut)
				}
				if (toRemove.length) {
					this.remove(toRemove)
				}
			})
		} finally {
			this._runCallbacks = prevRunCallbacks
		}
	}
	/**
	 * Create a computed cache.
	 *
	 * @param name - The name of the derivation cache.
	 * @param derive - A function used to derive the value of the cache.
	 * @public
	 */
	createComputedCache = (name, derive) => {
		const cache = new Cache()
		return {
			get: (id) => {
				const atom2 = this.atoms.value[id]
				if (!atom2) {
					return void 0
				}
				return cache.get(atom2, () => computed(name + ':' + id, () => derive(atom2.value))).value
			},
		}
	}
	/**
	 * Create a computed cache from a selector
	 *
	 * @param name - The name of the derivation cache.
	 * @param selector - A function that returns a subset of the original shape
	 * @param derive - A function used to derive the value of the cache.
	 * @public
	 */
	createSelectedComputedCache = (name, selector, derive) => {
		const cache = new Cache()
		return {
			get: (id) => {
				const atom2 = this.atoms.value[id]
				if (!atom2) {
					return void 0
				}
				const d3 = computed(name + ':' + id + ':selector', () => selector(atom2.value))
				return cache.get(atom2, () => computed(name + ':' + id, () => derive(d3.value))).value
			},
		}
	}
	_integrityChecker
	/** @internal */
	ensureStoreIsUsable() {
		this._integrityChecker ??= this.schema.createIntegrityChecker(this)
		this._integrityChecker?.()
	}
	_isPossiblyCorrupted = false
	/** @internal */
	markAsPossiblyCorrupted() {
		this._isPossiblyCorrupted = true
	}
	/** @internal */
	isPossiblyCorrupted() {
		return this._isPossiblyCorrupted
	}
}
function squashRecordDiffs(diffs) {
	const result = { added: {}, removed: {}, updated: {} }
	for (const diff of diffs) {
		for (const [id, value] of objectMapEntries(diff.added)) {
			if (result.removed[id]) {
				const original = result.removed[id]
				delete result.removed[id]
				if (original !== value) {
					result.updated[id] = [original, value]
				}
			} else {
				result.added[id] = value
			}
		}
		for (const [id, [_from, to]] of objectMapEntries(diff.updated)) {
			if (result.added[id]) {
				result.added[id] = to
				delete result.updated[id]
				delete result.removed[id]
				continue
			}
			if (result.updated[id]) {
				result.updated[id][1] = to
				delete result.removed[id]
				continue
			}
			result.updated[id] = diff.updated[id]
			delete result.removed[id]
		}
		for (const [id, value] of objectMapEntries(diff.removed)) {
			if (result.added[id]) {
				delete result.added[id]
			} else if (result.updated[id]) {
				result.removed[id] = result.updated[id][0]
				delete result.updated[id]
			} else {
				result.removed[id] = value
			}
		}
	}
	return result
}
function squashHistoryEntries(entries) {
	const result = []
	let current = entries[0]
	let entry
	for (let i3 = 1, n3 = entries.length; i3 < n3; i3++) {
		entry = entries[i3]
		if (current.source !== entry.source) {
			result.push(current)
			current = entry
		} else {
			current = {
				source: current.source,
				changes: squashRecordDiffs([current.changes, entry.changes]),
			}
		}
	}
	result.push(current)
	return result
}
var HistoryAccumulator = class {
	_history = []
	_inteceptors = /* @__PURE__ */ new Set()
	intercepting(fn) {
		this._inteceptors.add(fn)
		return () => {
			this._inteceptors.delete(fn)
		}
	}
	add(entry) {
		this._history.push(entry)
		for (const interceptor of this._inteceptors) {
			interceptor(entry)
		}
	}
	flush() {
		const history = squashHistoryEntries(this._history)
		this._history = []
		return history
	}
	clear() {
		this._history = []
	}
	hasChanges() {
		return this._history.length > 0
	}
}

// ../packages/tlstore/src/lib/StoreSchema.ts
init_define_process()

// ../packages/tlstore/src/lib/migrate.ts
init_define_process()

// ../packages/tlstore/src/lib/BaseRecord.ts
init_define_process()
function isRecord(record) {
	return typeof record === 'object' && record !== null && 'id' in record && 'typeName' in record
}

// ../packages/tlstore/src/lib/migrate.ts
function defineMigrations(opts) {
	const { currentVersion, firstVersion, migrators = {}, subTypeKey, subTypeMigrations } = opts
	if (typeof currentVersion === 'number' && typeof firstVersion === 'number') {
		if (currentVersion === firstVersion) {
			throw Error(`Current version is equal to initial version.`)
		} else if (currentVersion < firstVersion) {
			throw Error(`Current version is lower than initial version.`)
		}
	}
	return {
		firstVersion: firstVersion ?? 0,
		// defaults
		currentVersion: currentVersion ?? 0,
		// defaults
		migrators,
		subTypeKey,
		subTypeMigrations,
	}
}
function migrateRecord({ record, migrations, fromVersion, toVersion }) {
	let currentVersion = fromVersion
	if (!isRecord(record)) throw new Error('[migrateRecord] object is not a record')
	const { typeName, id, ...others } = record
	let recordWithoutMeta = others
	while (currentVersion < toVersion) {
		const nextVersion = currentVersion + 1
		const migrator = migrations.migrators[nextVersion]
		if (!migrator) {
			return {
				type: 'error',
				reason: 'target-version-too-new' /* TargetVersionTooNew */,
			}
		}
		recordWithoutMeta = migrator.up(recordWithoutMeta)
		currentVersion = nextVersion
	}
	while (currentVersion > toVersion) {
		const nextVersion = currentVersion - 1
		const migrator = migrations.migrators[currentVersion]
		if (!migrator) {
			return {
				type: 'error',
				reason: 'target-version-too-old' /* TargetVersionTooOld */,
			}
		}
		recordWithoutMeta = migrator.down(recordWithoutMeta)
		currentVersion = nextVersion
	}
	return {
		type: 'success',
		value: { ...recordWithoutMeta, id, typeName },
	}
}
function migrate({ value, migrations, fromVersion, toVersion }) {
	let currentVersion = fromVersion
	while (currentVersion < toVersion) {
		const nextVersion = currentVersion + 1
		const migrator = migrations.migrators[nextVersion]
		if (!migrator) {
			return {
				type: 'error',
				reason: 'target-version-too-new' /* TargetVersionTooNew */,
			}
		}
		value = migrator.up(value)
		currentVersion = nextVersion
	}
	while (currentVersion > toVersion) {
		const nextVersion = currentVersion - 1
		const migrator = migrations.migrators[currentVersion]
		if (!migrator) {
			return {
				type: 'error',
				reason: 'target-version-too-old' /* TargetVersionTooOld */,
			}
		}
		value = migrator.down(value)
		currentVersion = nextVersion
	}
	return {
		type: 'success',
		value,
	}
}

// ../packages/tlstore/src/lib/StoreSchema.ts
var StoreSchema = class {
	constructor(types, options) {
		this.types = types
		this.options = options
	}
	static create(types, options) {
		return new StoreSchema(types, options ?? {})
	}
	get currentStoreVersion() {
		return this.options.snapshotMigrations?.currentVersion ?? 0
	}
	validateRecord(store, record, phase, recordBefore) {
		try {
			const recordType = getOwnProperty(this.types, record.typeName)
			if (!recordType) {
				throw new Error(`Missing definition for record type ${record.typeName}`)
			}
			return recordType.validate(record)
		} catch (error) {
			if (this.options.onValidationFailure) {
				return this.options.onValidationFailure({
					store,
					record,
					phase,
					recordBefore,
					error,
				})
			} else {
				throw error
			}
		}
	}
	migratePersistedRecord(record, persistedSchema, direction = 'up') {
		const ourType = getOwnProperty(this.types, record.typeName)
		const persistedType = persistedSchema.recordVersions[record.typeName]
		if (!persistedType || !ourType) {
			return { type: 'error', reason: 'unknown-type' /* UnknownType */ }
		}
		const ourVersion = ourType.migrations.currentVersion
		const persistedVersion = persistedType.version
		if (ourVersion !== persistedVersion) {
			const result2 =
				direction === 'up'
					? migrateRecord({
							record,
							migrations: ourType.migrations,
							fromVersion: persistedVersion,
							toVersion: ourVersion,
					  })
					: migrateRecord({
							record,
							migrations: ourType.migrations,
							fromVersion: ourVersion,
							toVersion: persistedVersion,
					  })
			if (result2.type === 'error') {
				return result2
			}
			record = result2.value
		}
		if (!ourType.migrations.subTypeKey) {
			return { type: 'success', value: record }
		}
		const ourSubTypeMigrations =
			ourType.migrations.subTypeMigrations?.[record[ourType.migrations.subTypeKey]]
		const persistedSubTypeVersion =
			'subTypeVersions' in persistedType
				? persistedType.subTypeVersions[record[ourType.migrations.subTypeKey]]
				: void 0
		if (ourSubTypeMigrations === void 0) {
			return { type: 'error', reason: 'unrecognized-subtype' /* UnrecognizedSubtype */ }
		}
		if (persistedSubTypeVersion === void 0) {
			return { type: 'error', reason: 'incompatible-subtype' /* IncompatibleSubtype */ }
		}
		const result =
			direction === 'up'
				? migrateRecord({
						record,
						migrations: ourSubTypeMigrations,
						fromVersion: persistedSubTypeVersion,
						toVersion: ourSubTypeMigrations.currentVersion,
				  })
				: migrateRecord({
						record,
						migrations: ourSubTypeMigrations,
						fromVersion: ourSubTypeMigrations.currentVersion,
						toVersion: persistedSubTypeVersion,
				  })
		if (result.type === 'error') {
			return result
		}
		return { type: 'success', value: result.value }
	}
	migrateStoreSnapshot(storeSnapshot, persistedSchema) {
		const migrations = this.options.snapshotMigrations
		if (!migrations) {
			return { type: 'success', value: storeSnapshot }
		}
		const ourStoreVersion = migrations.currentVersion
		const persistedStoreVersion = persistedSchema.storeVersion ?? 0
		if (ourStoreVersion < persistedStoreVersion) {
			return { type: 'error', reason: 'target-version-too-old' /* TargetVersionTooOld */ }
		}
		if (ourStoreVersion > persistedStoreVersion) {
			const result = migrate({
				value: storeSnapshot,
				migrations,
				fromVersion: persistedStoreVersion,
				toVersion: ourStoreVersion,
			})
			if (result.type === 'error') {
				return result
			}
			storeSnapshot = result.value
		}
		const updated = []
		for (const r3 of objectMapValues(storeSnapshot)) {
			const result = this.migratePersistedRecord(r3, persistedSchema)
			if (result.type === 'error') {
				return result
			} else if (result.value && result.value !== r3) {
				updated.push(result.value)
			}
		}
		if (updated.length) {
			storeSnapshot = { ...storeSnapshot }
			for (const r3 of updated) {
				storeSnapshot[r3.id] = r3
			}
		}
		return { type: 'success', value: storeSnapshot }
	}
	/** @internal */
	createIntegrityChecker(store) {
		return this.options.createIntegrityChecker?.(store) ?? void 0
	}
	serialize() {
		return {
			schemaVersion: 1,
			storeVersion: this.options.snapshotMigrations?.currentVersion ?? 0,
			recordVersions: Object.fromEntries(
				objectMapValues(this.types).map((type) => [
					type.typeName,
					type.migrations.subTypeKey && type.migrations.subTypeMigrations
						? {
								version: type.migrations.currentVersion,
								subTypeKey: type.migrations.subTypeKey,
								subTypeVersions: type.migrations.subTypeMigrations
									? Object.fromEntries(
											Object.entries(type.migrations.subTypeMigrations).map(([k2, v3]) => [
												k2,
												v3.currentVersion,
											])
									  )
									: void 0,
						  }
						: {
								version: type.migrations.currentVersion,
						  },
				])
			),
		}
	}
	serializeEarliestVersion() {
		return {
			schemaVersion: 1,
			storeVersion: this.options.snapshotMigrations?.firstVersion ?? 0,
			recordVersions: Object.fromEntries(
				objectMapValues(this.types).map((type) => [
					type.typeName,
					type.migrations.subTypeKey && type.migrations.subTypeMigrations
						? {
								version: type.migrations.firstVersion,
								subTypeKey: type.migrations.subTypeKey,
								subTypeVersions: type.migrations.subTypeMigrations
									? Object.fromEntries(
											Object.entries(type.migrations.subTypeMigrations).map(([k2, v3]) => [
												k2,
												v3.firstVersion,
											])
									  )
									: void 0,
						  }
						: {
								version: type.migrations.firstVersion,
						  },
				])
			),
		}
	}
}

// ../packages/tlstore/src/lib/compareSchemas.ts
init_define_process()
var compareSchemas = (a3, b3) => {
	if (a3.schemaVersion > b3.schemaVersion) {
		return 1
	}
	if (a3.schemaVersion < b3.schemaVersion) {
		return -1
	}
	if (a3.storeVersion > b3.storeVersion) {
		return 1
	}
	if (a3.storeVersion < b3.storeVersion) {
		return -1
	}
	for (const key of Object.keys(a3.recordVersions)) {
		const aRecordVersion = a3.recordVersions[key]
		const bRecordVersion = b3.recordVersions[key]
		if (aRecordVersion.version > bRecordVersion.version) {
			return 1
		}
		if (aRecordVersion.version < bRecordVersion.version) {
			return -1
		}
		if ('subTypeVersions' in aRecordVersion && !('subTypeVersions' in bRecordVersion)) {
			return 1
		}
		if (!('subTypeVersions' in aRecordVersion) && 'subTypeVersions' in bRecordVersion) {
			return -1
		}
		if (!('subTypeVersions' in aRecordVersion) || !('subTypeVersions' in bRecordVersion)) {
			continue
		}
		for (const subType of Object.keys(aRecordVersion.subTypeVersions)) {
			const aSubTypeVersion = aRecordVersion.subTypeVersions[subType]
			const bSubTypeVersion = bRecordVersion.subTypeVersions[subType]
			if (aSubTypeVersion > bSubTypeVersion) {
				return 1
			}
			if (aSubTypeVersion < bSubTypeVersion) {
				return -1
			}
		}
	}
	return 0
}

// ../packages/tlvalidate/src/index.ts
init_define_process()

// ../packages/tlvalidate/src/lib/validation.ts
var validation_exports = {}
__export(validation_exports, {
	ArrayOfValidator: () => ArrayOfValidator,
	DictValidator: () => DictValidator,
	ObjectValidator: () => ObjectValidator,
	UnionValidator: () => UnionValidator,
	ValidationError: () => ValidationError,
	Validator: () => Validator,
	any: () => any,
	array: () => array,
	arrayOf: () => arrayOf,
	bigint: () => bigint,
	boolean: () => boolean,
	boxModel: () => boxModel,
	dict: () => dict,
	integer: () => integer,
	literal: () => literal,
	model: () => model,
	nonZeroInteger: () => nonZeroInteger,
	nonZeroNumber: () => nonZeroNumber,
	number: () => number,
	object: () => object,
	point: () => point,
	positiveInteger: () => positiveInteger,
	positiveNumber: () => positiveNumber,
	setEnum: () => setEnum,
	string: () => string,
	union: () => union,
	unknown: () => unknown,
	unknownObject: () => unknownObject,
})
init_define_process()
function formatPath(path) {
	if (!path.length) {
		return null
	}
	let formattedPath = ''
	for (const item of path) {
		if (typeof item === 'number') {
			formattedPath += `.${item}`
		} else if (item.startsWith('(')) {
			if (formattedPath.endsWith(')')) {
				formattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`
			} else {
				formattedPath += item
			}
		} else {
			formattedPath += `.${item}`
		}
	}
	if (formattedPath.startsWith('.')) {
		return formattedPath.slice(1)
	}
	return formattedPath
}
var ValidationError = class extends Error {
	constructor(rawMessage, path = []) {
		const formattedPath = formatPath(path)
		const indentedMessage = rawMessage
			.split('\n')
			.map((line, i3) => (i3 === 0 ? line : `  ${line}`))
			.join('\n')
		super(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage)
		this.rawMessage = rawMessage
		this.path = path
	}
	name = 'ValidationError'
}
function prefixError(path, fn) {
	try {
		return fn()
	} catch (err) {
		if (err instanceof ValidationError) {
			throw new ValidationError(err.rawMessage, [path, ...err.path])
		}
		throw new ValidationError(err.toString(), [path])
	}
}
function typeToString(value) {
	if (value === null) return 'null'
	if (Array.isArray(value)) return 'an array'
	const type = typeof value
	switch (type) {
		case 'bigint':
		case 'boolean':
		case 'function':
		case 'number':
		case 'string':
		case 'symbol':
			return `a ${type}`
		case 'object':
			return `an ${type}`
		case 'undefined':
			return 'undefined'
		default:
			exhaustiveSwitchError(type)
	}
}
var Validator = class {
	constructor(validationFn) {
		this.validationFn = validationFn
	}
	/**
	 * Asserts that the passed value is of the correct type and returns it. The returned value is
	 * guaranteed to be referentially equal to the passed value.
	 */
	validate(value) {
		const validated = this.validationFn(value)
		if (define_process_default.env.NODE_ENV !== 'production' && !Object.is(value, validated)) {
			throw new ValidationError('Validator functions must return the same value they were passed')
		}
		return validated
	}
	/**
	 * Returns a new validator that also accepts null or undefined. The resulting value will always be
	 * null.
	 */
	nullable() {
		return new Validator((value) => {
			if (value === null) return null
			return this.validate(value)
		})
	}
	/**
	 * Returns a new validator that also accepts null or undefined. The resulting value will always be
	 * null.
	 */
	optional() {
		return new Validator((value) => {
			if (value === void 0) return void 0
			return this.validate(value)
		})
	}
	/**
	 * Refine this validation to a new type. The passed-in validation function should throw an error
	 * if the value can't be converted to the new type, or return the new type otherwise.
	 */
	refine(otherValidationFn) {
		return new Validator((value) => {
			return otherValidationFn(this.validate(value))
		})
	}
	check(nameOrCheckFn, checkFn) {
		if (typeof nameOrCheckFn === 'string') {
			return this.refine((value) => {
				prefixError(`(check ${nameOrCheckFn})`, () => checkFn(value))
				return value
			})
		} else {
			return this.refine((value) => {
				nameOrCheckFn(value)
				return value
			})
		}
	}
}
var ArrayOfValidator = class extends Validator {
	constructor(itemValidator) {
		super((value) => {
			const arr = array.validate(value)
			for (let i3 = 0; i3 < arr.length; i3++) {
				prefixError(i3, () => itemValidator.validate(arr[i3]))
			}
			return arr
		})
		this.itemValidator = itemValidator
	}
	nonEmpty() {
		return this.check((value) => {
			if (value.length === 0) {
				throw new ValidationError('Expected a non-empty array')
			}
		})
	}
	lengthGreaterThan1() {
		return this.check((value) => {
			if (value.length <= 1) {
				throw new ValidationError('Expected an array with length greater than 1')
			}
		})
	}
}
var ObjectValidator = class extends Validator {
	constructor(config, shouldAllowUnknownProperties = false) {
		super((object2) => {
			if (typeof object2 !== 'object' || object2 === null) {
				throw new ValidationError(`Expected object, got ${typeToString(object2)}`)
			}
			for (const [key, validator] of Object.entries(config)) {
				prefixError(key, () => {
					validator.validate(getOwnProperty(object2, key))
				})
			}
			if (!shouldAllowUnknownProperties) {
				for (const key of Object.keys(object2)) {
					if (!hasOwnProperty(config, key)) {
						throw new ValidationError(`Unexpected property`, [key])
					}
				}
			}
			return object2
		})
		this.config = config
		this.shouldAllowUnknownProperties = shouldAllowUnknownProperties
	}
	allowUnknownProperties() {
		return new ObjectValidator(this.config, true)
	}
	/**
	 * Extend an object validator by adding additional properties.
	 *
	 * @example
	 *
	 * ```ts
	 * const animalValidator = T.object({
	 * 	name: T.string,
	 * })
	 * const catValidator = animalValidator.extend({
	 * 	meowVolume: T.number,
	 * })
	 * ```
	 */
	extend(extension) {
		return new ObjectValidator({ ...this.config, ...extension })
	}
}
var UnionValidator = class extends Validator {
	constructor(key, config, unknownValueValidation) {
		super((input) => {
			if (typeof input !== 'object' || input === null) {
				throw new ValidationError(`Expected an object, got ${typeToString(input)}`, [])
			}
			const variant = getOwnProperty(input, key)
			if (typeof variant !== 'string') {
				throw new ValidationError(
					`Expected a string for key "${key}", got ${typeToString(variant)}`
				)
			}
			const matchingSchema = hasOwnProperty(config, variant) ? config[variant] : void 0
			if (matchingSchema === void 0) {
				return this.unknownValueValidation(input, variant)
			}
			return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input))
		})
		this.key = key
		this.config = config
		this.unknownValueValidation = unknownValueValidation
	}
	validateUnknownVariants(unknownValueValidation) {
		return new UnionValidator(this.key, this.config, unknownValueValidation)
	}
}
var DictValidator = class extends Validator {
	constructor(keyValidator, valueValidator) {
		super((object2) => {
			if (typeof object2 !== 'object' || object2 === null) {
				throw new ValidationError(`Expected object, got ${typeToString(object2)}`)
			}
			for (const [key, value] of Object.entries(object2)) {
				prefixError(key, () => {
					keyValidator.validate(key)
					valueValidator.validate(value)
				})
			}
			return object2
		})
		this.keyValidator = keyValidator
		this.valueValidator = valueValidator
	}
}
function typeofValidator(type) {
	return new Validator((value) => {
		if (typeof value !== type) {
			throw new ValidationError(`Expected ${type}, got ${typeToString(value)}`)
		}
		return value
	})
}
var unknown = new Validator((value) => value)
var any = new Validator((value) => value)
var string = typeofValidator('string')
var number = typeofValidator('number').check((number2) => {
	if (Number.isNaN(number2)) {
		throw new ValidationError('Expected a number, got NaN')
	}
	if (!Number.isFinite(number2)) {
		throw new ValidationError(`Expected a finite number, got ${number2}`)
	}
})
var positiveNumber = number.check((value) => {
	if (value < 0) throw new ValidationError(`Expected a positive number, got ${value}`)
})
var nonZeroNumber = number.check((value) => {
	if (value <= 0) throw new ValidationError(`Expected a non-zero positive number, got ${value}`)
})
var integer = number.check((value) => {
	if (!Number.isInteger(value)) throw new ValidationError(`Expected an integer, got ${value}`)
})
var positiveInteger = integer.check((value) => {
	if (value < 0) throw new ValidationError(`Expected a positive integer, got ${value}`)
})
var nonZeroInteger = integer.check((value) => {
	if (value <= 0) throw new ValidationError(`Expected a non-zero positive integer, got ${value}`)
})
var boolean = typeofValidator('boolean')
var bigint = typeofValidator('bigint')
function literal(expectedValue) {
	return new Validator((actualValue) => {
		if (actualValue !== expectedValue) {
			throw new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`)
		}
		return expectedValue
	})
}
var array = new Validator((value) => {
	if (!Array.isArray(value)) {
		throw new ValidationError(`Expected an array, got ${typeToString(value)}`)
	}
	return value
})
function arrayOf(itemValidator) {
	return new ArrayOfValidator(itemValidator)
}
var unknownObject = new Validator((value) => {
	if (typeof value !== 'object' || value === null) {
		throw new ValidationError(`Expected object, got ${typeToString(value)}`)
	}
	return value
})
function object(config) {
	return new ObjectValidator(config)
}
function dict(keyValidator, valueValidator) {
	return new DictValidator(keyValidator, valueValidator)
}
function union(key, config) {
	return new UnionValidator(key, config, (unknownValue, unknownVariant) => {
		throw new ValidationError(
			`Expected one of ${Object.keys(config)
				.map((key2) => JSON.stringify(key2))
				.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,
			[key]
		)
	})
}
function model(name, validator) {
	return new Validator((value) => {
		const prefix =
			value && typeof value === 'object' && 'id' in value && typeof value.id === 'string'
				? `${name}(id = ${value.id})`
				: name
		return prefixError(prefix, () => validator.validate(value))
	})
}
function setEnum(values) {
	return new Validator((value) => {
		if (!values.has(value)) {
			const valuesString = Array.from(values, (value2) => JSON.stringify(value2)).join(' or ')
			throw new ValidationError(`Expected ${valuesString}, got ${value}`)
		}
		return value
	})
}
var point = object({
	x: number,
	y: number,
	z: number.optional(),
})
var boxModel = object({
	x: number,
	y: number,
	w: number,
	h: number,
})

// ../packages/tlschema/src/validation.ts
init_define_process()

// ../packages/tlschema/src/style-types.ts
init_define_process()
var TL_STYLE_TYPES = /* @__PURE__ */ new Set([
	'color',
	'labelColor',
	'dash',
	'fill',
	'size',
	'opacity',
	'font',
	'align',
	'verticalAlign',
	'icon',
	'geo',
	'arrowheadStart',
	'arrowheadEnd',
	'spline',
])
var TL_COLOR_TYPES = /* @__PURE__ */ new Set([
	'black',
	'grey',
	'light-violet',
	'violet',
	'blue',
	'light-blue',
	'yellow',
	'orange',
	'green',
	'light-green',
	'light-red',
	'red',
])
var TL_DASH_TYPES = /* @__PURE__ */ new Set(['draw', 'solid', 'dashed', 'dotted'])
var TL_FILL_TYPES = /* @__PURE__ */ new Set(['none', 'semi', 'solid', 'pattern'])
var TL_SIZE_TYPES = /* @__PURE__ */ new Set(['s', 'm', 'l', 'xl'])
var TL_OPACITY_TYPES = /* @__PURE__ */ new Set(['0.1', '0.25', '0.5', '0.75', '1'])
var TL_FONT_TYPES = /* @__PURE__ */ new Set(['draw', 'sans', 'serif', 'mono'])
var TL_ALIGN_TYPES = /* @__PURE__ */ new Set(['start', 'middle', 'end'])
var TL_ALIGN_TYPES_WITH_LEGACY_STUFF = /* @__PURE__ */ new Set([
	...TL_ALIGN_TYPES,
	'start-legacy',
	'end-legacy',
	'middle-legacy',
])
var TL_VERTICAL_ALIGN_TYPES = /* @__PURE__ */ new Set(['start', 'middle', 'end'])
var TL_GEO_TYPES = /* @__PURE__ */ new Set([
	'rectangle',
	'ellipse',
	'triangle',
	'diamond',
	'pentagon',
	'hexagon',
	'octagon',
	'star',
	'rhombus',
	'rhombus-2',
	'oval',
	'trapezoid',
	'arrow-right',
	'arrow-left',
	'arrow-up',
	'arrow-down',
	'x-box',
	'check-box',
])
var TL_ARROWHEAD_TYPES = /* @__PURE__ */ new Set([
	'arrow',
	'triangle',
	'square',
	'dot',
	'pipe',
	'diamond',
	'inverted',
	'bar',
	'none',
])
var TL_SPLINE_TYPES = /* @__PURE__ */ new Set(['cubic', 'line'])
var TL_ICON_TYPES = /* @__PURE__ */ new Set([
	'activity',
	'airplay',
	'alert-circle',
	'alert-octagon',
	'alert-triangle',
	'align-center',
	'align-justify',
	'align-left',
	'align-right',
	'anchor',
	'aperture',
	'archive',
	'arrow-down-circle',
	'arrow-down-left',
	'arrow-down-right',
	'arrow-down',
	'arrow-left-circle',
	'arrow-left',
	'arrow-right-circle',
	'arrow-right',
	'arrow-up-circle',
	'arrow-up-left',
	'arrow-up-right',
	'arrow-up',
	'at-sign',
	'award',
	'bar-chart-2',
	'bar-chart',
	'battery-charging',
	'battery',
	'bell-off',
	'bell',
	'bluetooth',
	'bold',
	'book-open',
	'book',
	'bookmark',
	'geo',
	'briefcase',
	'calendar',
	'camera-off',
	'camera',
	'cast',
	'check-circle',
	'check-square',
	'check',
	'chevron-down',
	'chevron-left',
	'chevron-right',
	'chevron-up',
	'chevrons-down',
	'chevrons-left',
	'chevrons-right',
	'chevrons-up',
	'chrome',
	'circle',
	'clipboard',
	'clock',
	'cloud-drizzle',
	'cloud-lightning',
	'cloud-off',
	'cloud-rain',
	'cloud-snow',
	'cloud',
	'codepen',
	'codesandbox',
	'coffee',
	'columns',
	'command',
	'compass',
	'copy',
	'corner-down-left',
	'corner-down-right',
	'corner-left-down',
	'corner-left-up',
	'corner-right-down',
	'corner-right-up',
	'corner-up-left',
	'corner-up-right',
	'cpu',
	'credit-card',
	'crop',
	'crosshair',
	'database',
	'delete',
	'disc',
	'divide-circle',
	'divide-square',
	'divide',
	'dollar-sign',
	'download-cloud',
	'download',
	'dribbble',
	'droplet',
	'edit-2',
	'edit-3',
	'edit',
	'external-link',
	'eye-off',
	'eye',
	'facebook',
	'fast-forward',
	'feather',
	'figma',
	'file-minus',
	'file-plus',
	'file-text',
	'file',
	'film',
	'filter',
	'flag',
	'folder-minus',
	'folder-plus',
	'folder',
	'framer',
	'frown',
	'gift',
	'git-branch',
	'git-commit',
	'git-merge',
	'git-pull-request',
	'github',
	'gitlab',
	'globe',
	'grid',
	'hard-drive',
	'hash',
	'headphones',
	'heart',
	'help-circle',
	'hexagon',
	'home',
	'image',
	'inbox',
	'info',
	'instagram',
	'italic',
	'key',
	'layers',
	'layout',
	'life-buoy',
	'link-2',
	'link',
	'linkedin',
	'list',
	'loader',
	'lock',
	'log-in',
	'log-out',
	'mail',
	'map-pin',
	'map',
	'maximize-2',
	'maximize',
	'meh',
	'menu',
	'message-circle',
	'message-square',
	'mic-off',
	'mic',
	'minimize-2',
	'minimize',
	'minus-circle',
	'minus-square',
	'minus',
	'monitor',
	'moon',
	'more-horizontal',
	'more-vertical',
	'mouse-pointer',
	'move',
	'music',
	'navigation-2',
	'navigation',
	'octagon',
	'package',
	'paperclip',
	'pause-circle',
	'pause',
	'pen-tool',
	'percent',
	'phone-call',
	'phone-forwarded',
	'phone-incoming',
	'phone-missed',
	'phone-off',
	'phone-outgoing',
	'phone',
	'pie-chart',
	'play-circle',
	'play',
	'plus-circle',
	'plus-square',
	'plus',
	'pocket',
	'power',
	'printer',
	'radio',
	'refresh-ccw',
	'refresh-cw',
	'repeat',
	'rewind',
	'rotate-ccw',
	'rotate-cw',
	'rss',
	'save',
	'scissors',
	'search',
	'send',
	'server',
	'settings',
	'share-2',
	'share',
	'shield-off',
	'shield',
	'shopping-bag',
	'shopping-cart',
	'shuffle',
	'sidebar',
	'skip-back',
	'skip-forward',
	'slack',
	'slash',
	'sliders',
	'smartphone',
	'smile',
	'speaker',
	'square',
	'star',
	'stop-circle',
	'sun',
	'sunrise',
	'sunset',
	'table',
	'tablet',
	'tag',
	'target',
	'terminal',
	'thermometer',
	'thumbs-down',
	'thumbs-up',
	'toggle-left',
	'toggle-right',
	'tool',
	'trash-2',
	'trash',
	'trello',
	'trending-down',
	'trending-up',
	'triangle',
	'truck',
	'tv',
	'twitch',
	'twitter',
	'type',
	'umbrella',
	'underline',
	'unlock',
	'upload-cloud',
	'upload',
	'user-check',
	'user-minus',
	'user-plus',
	'user-x',
	'user',
	'users',
	'video-off',
	'video',
	'voicemail',
	'volume-1',
	'volume-2',
	'volume-x',
	'volume',
	'watch',
	'wifi-off',
	'wifi',
	'wind',
	'x-circle',
	'x-octagon',
	'x-square',
	'x',
	'youtube',
	'zap-off',
	'zap',
	'zoom-in',
	'zoom-out',
])

// ../packages/tlschema/src/validation.ts
function idValidator(prefix) {
	return validation_exports.string.refine((id) => {
		if (!id.startsWith(`${prefix}:`)) {
			throw new Error(`${prefix} ID must start with "${prefix}:"`)
		}
		return id
	})
}
var assetIdValidator = idValidator('asset')
var pageIdValidator = idValidator('page')
var shapeIdValidator = idValidator('shape')
var instanceIdValidator = idValidator('instance')
var parentIdValidator = validation_exports.string.refine((id) => {
	if (!id.startsWith('page:') && !id.startsWith('shape:')) {
		throw new Error('Parent ID must start with "page:" or "shape:"')
	}
	return id
})
var colorValidator = validation_exports.setEnum(TL_COLOR_TYPES)
var dashValidator = validation_exports.setEnum(TL_DASH_TYPES)
var fillValidator = validation_exports.setEnum(TL_FILL_TYPES)
var geoValidator = validation_exports.setEnum(TL_GEO_TYPES)
var sizeValidator = validation_exports.setEnum(TL_SIZE_TYPES)
var fontValidator = validation_exports.setEnum(TL_FONT_TYPES)
var alignValidator = validation_exports.setEnum(TL_ALIGN_TYPES_WITH_LEGACY_STUFF)
var verticalAlignValidator = validation_exports.setEnum(TL_VERTICAL_ALIGN_TYPES)
var arrowheadValidator = validation_exports.setEnum(TL_ARROWHEAD_TYPES)
var opacityValidator = validation_exports.setEnum(TL_OPACITY_TYPES)
var iconValidator = validation_exports.setEnum(TL_ICON_TYPES)
var splineValidator = validation_exports.setEnum(TL_SPLINE_TYPES)

// ../packages/tlschema/src/records/TLCamera.ts
var cameraTypeValidator = validation_exports.model(
	'camera',
	validation_exports.object({
		typeName: validation_exports.literal('camera'),
		id: idValidator('camera'),
		x: validation_exports.number,
		y: validation_exports.number,
		z: validation_exports.number,
	})
)
var CameraRecordType = createRecordType('camera', {
	validator: cameraTypeValidator,
	scope: 'instance',
}).withDefaultProperties(() => ({
	x: 0,
	y: 0,
	z: 1,
}))
var cameraTypeMigrations = defineMigrations({})

// ../packages/tlschema/src/records/TLDocument.ts
init_define_process()
var documentTypeValidator = validation_exports.model(
	'document',
	validation_exports.object({
		typeName: validation_exports.literal('document'),
		id: validation_exports.literal('document:document'),
		gridSize: validation_exports.number,
	})
)
var DocumentRecordType = createRecordType('document', {
	validator: documentTypeValidator,
	scope: 'document',
}).withDefaultProperties(() => ({
	gridSize: 10,
}))
var TLDOCUMENT_ID = DocumentRecordType.createCustomId('document')
var documentTypeMigrations = defineMigrations({})

// ../packages/tlschema/src/records/TLInstance.ts
init_define_process()

// ../packages/tlschema/src/ui-types.ts
init_define_process()
var TL_UI_COLOR_TYPES = /* @__PURE__ */ new Set([
	'accent',
	'white',
	'black',
	'selection-stroke',
	'selection-fill',
	'laser',
	'muted-1',
])
var uiColorTypeValidator = validation_exports.setEnum(TL_UI_COLOR_TYPES)
var TL_CURSOR_TYPES = /* @__PURE__ */ new Set([
	'none',
	'default',
	'pointer',
	'cross',
	'grab',
	'rotate',
	'grabbing',
	'resize-edge',
	'resize-corner',
	'text',
	'move',
	'ew-resize',
	'ns-resize',
	'nesw-resize',
	'nwse-resize',
	'nesw-rotate',
	'nwse-rotate',
	'swne-rotate',
	'senw-rotate',
	'zoom-in',
	'zoom-out',
])
var cursorTypeValidator = validation_exports.setEnum(TL_CURSOR_TYPES)
var cursorValidator = validation_exports.object({
	color: uiColorTypeValidator,
	type: cursorTypeValidator,
	rotation: validation_exports.number,
})
var TL_SCRIBBLE_STATES = /* @__PURE__ */ new Set(['starting', 'paused', 'active', 'stopping'])
var scribbleTypeValidator = validation_exports.object({
	points: validation_exports.arrayOf(validation_exports.point),
	size: validation_exports.positiveNumber,
	color: uiColorTypeValidator,
	opacity: validation_exports.number,
	state: validation_exports.setEnum(TL_SCRIBBLE_STATES),
	delay: validation_exports.number,
})
var TL_HANDLE_TYPES = /* @__PURE__ */ new Set(['vertex', 'virtual', 'create'])
var handleTypeValidator = validation_exports.object({
	id: validation_exports.string,
	type: validation_exports.setEnum(TL_HANDLE_TYPES),
	canBind: validation_exports.boolean.optional(),
	index: validation_exports.string,
	x: validation_exports.number,
	y: validation_exports.number,
})

// ../packages/tlschema/src/records/TLInstance.ts
var instanceTypeValidator = validation_exports.model(
	'instance',
	validation_exports.object({
		typeName: validation_exports.literal('instance'),
		id: idValidator('instance'),
		currentPageId: pageIdValidator,
		followingUserId: validation_exports.string.nullable(),
		brush: validation_exports.boxModel.nullable(),
		propsForNextShape: validation_exports.object({
			color: colorValidator,
			labelColor: colorValidator,
			dash: dashValidator,
			fill: fillValidator,
			size: sizeValidator,
			opacity: opacityValidator,
			font: fontValidator,
			align: alignValidator,
			verticalAlign: verticalAlignValidator,
			icon: iconValidator,
			geo: geoValidator,
			arrowheadStart: arrowheadValidator,
			arrowheadEnd: arrowheadValidator,
			spline: splineValidator,
		}),
		cursor: cursorValidator,
		scribble: scribbleTypeValidator.nullable(),
		isFocusMode: validation_exports.boolean,
		isDebugMode: validation_exports.boolean,
		isToolLocked: validation_exports.boolean,
		exportBackground: validation_exports.boolean,
		screenBounds: validation_exports.boxModel,
		zoomBrush: validation_exports.boxModel.nullable(),
	})
)
var Versions = {
	AddTransparentExportBgs: 1,
	RemoveDialog: 2,
	AddToolLockMode: 3,
	RemoveExtraPropsForNextShape: 4,
	AddLabelColor: 5,
	AddFollowingUserId: 6,
	RemoveAlignJustify: 7,
	AddZoom: 8,
	AddVerticalAlign: 9,
	AddScribbleDelay: 10,
	RemoveUserId: 11,
}
var instanceTypeMigrations = defineMigrations({
	currentVersion: Versions.RemoveUserId,
	migrators: {
		[Versions.AddTransparentExportBgs]: {
			up: (instance) => {
				return { ...instance, exportBackground: true }
			},
			down: ({ exportBackground: _, ...instance }) => {
				return instance
			},
		},
		[Versions.RemoveDialog]: {
			up: ({ dialog: _, ...instance }) => {
				return instance
			},
			down: (instance) => {
				return { ...instance, dialog: null }
			},
		},
		[Versions.AddToolLockMode]: {
			up: (instance) => {
				return { ...instance, isToolLocked: false }
			},
			down: ({ isToolLocked: _, ...instance }) => {
				return instance
			},
		},
		[Versions.RemoveExtraPropsForNextShape]: {
			up: ({ propsForNextShape, ...instance }) => {
				return {
					...instance,
					propsForNextShape: Object.fromEntries(
						Object.entries(propsForNextShape).filter(([key]) => TL_STYLE_TYPES.has(key))
					),
				}
			},
			down: (instance) => {
				return instance
			},
		},
		[Versions.AddLabelColor]: {
			up: ({ propsForNextShape, ...instance }) => {
				return {
					...instance,
					propsForNextShape: {
						...propsForNextShape,
						labelColor: 'black',
					},
				}
			},
			down: (instance) => {
				const { labelColor: _, ...rest } = instance.propsForNextShape
				return {
					...instance,
					propsForNextShape: {
						...rest,
					},
				}
			},
		},
		[Versions.AddFollowingUserId]: {
			up: (instance) => {
				return { ...instance, followingUserId: null }
			},
			down: ({ followingUserId: _, ...instance }) => {
				return instance
			},
		},
		[Versions.RemoveAlignJustify]: {
			up: (instance) => {
				let newAlign = instance.propsForNextShape.align
				if (newAlign === 'justify') {
					newAlign = 'start'
				}
				return {
					...instance,
					propsForNextShape: {
						...instance.propsForNextShape,
						align: newAlign,
					},
				}
			},
			down: (instance) => {
				return { ...instance }
			},
		},
		[Versions.AddZoom]: {
			up: (instance) => {
				return { ...instance, zoomBrush: null }
			},
			down: ({ zoomBrush: _, ...instance }) => {
				return instance
			},
		},
		[Versions.AddVerticalAlign]: {
			up: (instance) => {
				return {
					...instance,
					propsForNextShape: {
						...instance.propsForNextShape,
						verticalAlign: 'middle',
					},
				}
			},
			down: (instance) => {
				const { verticalAlign: _, ...propsForNextShape } = instance.propsForNextShape
				return {
					...instance,
					propsForNextShape,
				}
			},
		},
		[Versions.AddScribbleDelay]: {
			up: (instance) => {
				if (instance.scribble !== null) {
					return { ...instance, scribble: { ...instance.scribble, delay: 0 } }
				}
				return { ...instance }
			},
			down: (instance) => {
				if (instance.scribble !== null) {
					const { delay: _delay, ...rest } = instance.scribble
					return { ...instance, scribble: rest }
				}
				return { ...instance }
			},
		},
		[Versions.RemoveUserId]: {
			up: ({ userId: _, ...instance }) => {
				return instance
			},
			down: (instance) => {
				return { ...instance, userId: 'user:none' }
			},
		},
	},
})
var InstanceRecordType = createRecordType('instance', {
	migrations: instanceTypeMigrations,
	validator: instanceTypeValidator,
	scope: 'instance',
}).withDefaultProperties(() => ({
	followingUserId: null,
	propsForNextShape: {
		opacity: '1',
		color: 'black',
		labelColor: 'black',
		dash: 'draw',
		fill: 'none',
		size: 'm',
		icon: 'file',
		font: 'draw',
		align: 'middle',
		verticalAlign: 'middle',
		geo: 'rectangle',
		arrowheadStart: 'none',
		arrowheadEnd: 'arrow',
		spline: 'line',
	},
	brush: null,
	scribble: null,
	cursor: {
		type: 'default',
		color: 'black',
		rotation: 0,
	},
	isFocusMode: false,
	exportBackground: false,
	isDebugMode: define_process_default.env.NODE_ENV === 'development',
	isToolLocked: false,
	screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
	zoomBrush: null,
}))

// ../packages/tlschema/src/records/TLInstancePageState.ts
init_define_process()
var instancePageStateTypeValidator = validation_exports.model(
	'instance_page_state',
	validation_exports.object({
		typeName: validation_exports.literal('instance_page_state'),
		id: idValidator('instance_page_state'),
		instanceId: instanceIdValidator,
		pageId: pageIdValidator,
		cameraId: idValidator('camera'),
		selectedIds: validation_exports.arrayOf(shapeIdValidator),
		hintingIds: validation_exports.arrayOf(shapeIdValidator),
		erasingIds: validation_exports.arrayOf(shapeIdValidator),
		hoveredId: shapeIdValidator.nullable(),
		editingId: shapeIdValidator.nullable(),
		croppingId: shapeIdValidator.nullable(),
		focusLayerId: shapeIdValidator.nullable(),
	})
)
var Versions2 = {
	AddCroppingId: 1,
}
var instancePageStateMigrations = defineMigrations({
	currentVersion: Versions2.AddCroppingId,
	migrators: {
		[Versions2.AddCroppingId]: {
			up(instance) {
				return { ...instance, croppingId: null }
			},
			down({ croppingId: _croppingId, ...instance }) {
				return instance
			},
		},
	},
})
var InstancePageStateRecordType = createRecordType('instance_page_state', {
	migrations: instancePageStateMigrations,
	validator: instancePageStateTypeValidator,
	scope: 'instance',
}).withDefaultProperties(() => ({
	editingId: null,
	croppingId: null,
	selectedIds: [],
	hoveredId: null,
	erasingIds: [],
	hintingIds: [],
	focusLayerId: null,
}))

// ../packages/tlschema/src/records/TLPage.ts
init_define_process()
var pageTypeValidator = validation_exports.model(
	'page',
	validation_exports.object({
		typeName: validation_exports.literal('page'),
		id: pageIdValidator,
		name: validation_exports.string,
		index: validation_exports.string,
	})
)
var PageRecordType = createRecordType('page', {
	validator: pageTypeValidator,
	scope: 'document',
})
var pageTypeMigrations = defineMigrations({})

// ../packages/tlschema/src/records/TLPointer.ts
init_define_process()
var pointerTypeValidator = validation_exports.model(
	'pointer',
	validation_exports.object({
		typeName: validation_exports.literal('pointer'),
		id: idValidator('pointer'),
		x: validation_exports.number,
		y: validation_exports.number,
		lastActivityTimestamp: validation_exports.number,
	})
)
var PointerRecordType = createRecordType('pointer', {
	validator: pointerTypeValidator,
	scope: 'instance',
}).withDefaultProperties(() => ({
	x: 0,
	y: 0,
	lastActivityTimestamp: 0,
}))
var TLPOINTER_ID = PointerRecordType.createCustomId('pointer')
var pointerTypeMigrations = defineMigrations({})

// ../packages/tlschema/src/records/TLUserDocument.ts
init_define_process()
var userDocumentTypeValidator = validation_exports.model(
	'user_document',
	validation_exports.object({
		typeName: validation_exports.literal('user_document'),
		id: idValidator('user_document'),
		isPenMode: validation_exports.boolean,
		isGridMode: validation_exports.boolean,
		isMobileMode: validation_exports.boolean,
		isSnapMode: validation_exports.boolean,
		lastUpdatedPageId: pageIdValidator.nullable(),
		lastUsedTabId: instanceIdValidator.nullable(),
	})
)
var Versions3 = {
	AddSnapMode: 1,
	AddMissingIsMobileMode: 2,
	RemoveIsReadOnly: 3,
	RemoveUserIdAndIsDarkMode: 4,
}
var userDocumentTypeMigrations = defineMigrations({
	currentVersion: Versions3.RemoveUserIdAndIsDarkMode,
	migrators: {
		[Versions3.AddSnapMode]: {
			up: (userDocument) => {
				return { ...userDocument, isSnapMode: false }
			},
			down: ({ isSnapMode: _, ...userDocument }) => {
				return userDocument
			},
		},
		[Versions3.AddMissingIsMobileMode]: {
			up: (userDocument) => {
				return { ...userDocument, isMobileMode: userDocument.isMobileMode ?? false }
			},
			down: ({ isMobileMode: _, ...userDocument }) => {
				return userDocument
			},
		},
		[Versions3.RemoveIsReadOnly]: {
			up: ({ isReadOnly: _, ...userDocument }) => {
				return userDocument
			},
			down: (userDocument) => {
				return { ...userDocument, isReadOnly: false }
			},
		},
		[Versions3.RemoveUserIdAndIsDarkMode]: {
			up: ({ userId: _, isDarkMode: __, ...userDocument }) => {
				return userDocument
			},
			down: (userDocument) => {
				return { ...userDocument, userId: 'user:none', isDarkMode: false }
			},
		},
	},
})
var UserDocumentRecordType = createRecordType('user_document', {
	migrations: userDocumentTypeMigrations,
	validator: userDocumentTypeValidator,
	scope: 'instance',
}).withDefaultProperties(() => ({
	/* STEP 6: Add any new default values for properties here */
	isPenMode: false,
	isGridMode: false,
	isMobileMode: false,
	isSnapMode: false,
	lastUpdatedPageId: null,
	lastUsedTabId: null,
}))

// ../packages/tlschema/src/TLStore.ts
function sortByIndex2(a3, b3) {
	if (a3.index < b3.index) {
		return -1
	} else if (a3.index > b3.index) {
		return 1
	}
	return 0
}
function redactRecordForErrorReporting(record) {
	if (record.typeName === 'asset') {
		if ('src' in record) {
			record.src = '<redacted>'
		}
		if ('src' in record.props) {
			record.props.src = '<redacted>'
		}
	}
}
var onValidationFailure = ({ error, phase, record, recordBefore }) => {
	const isExistingValidationIssue =
		// if we're initializing the store for the first time, we should
		// allow invalid records so people can load old buggy data:
		phase === 'initialize'
	annotateError(error, {
		tags: {
			origin: 'store.validateRecord',
			storePhase: phase,
			isExistingValidationIssue,
		},
		extras: {
			recordBefore: recordBefore
				? redactRecordForErrorReporting(structuredClone(recordBefore))
				: void 0,
			recordAfter: redactRecordForErrorReporting(structuredClone(record)),
		},
	})
	throw error
}
function getDefaultPages() {
	return [PageRecordType.create({ name: 'Page 1', index: 'a1' })]
}
function createIntegrityChecker(store) {
	const $pages = store.query.records('page')
	const $userDocumentSettings = store.query.record('user_document')
	const $instanceState = store.query.record('instance', () => ({
		id: { eq: store.props.instanceId },
	}))
	const $instancePageStates = store.query.records('instance_page_state')
	const ensureStoreIsUsable = () => {
		const { instanceId: tabId } = store.props
		if (!store.has(TLDOCUMENT_ID)) {
			store.put([DocumentRecordType.create({ id: TLDOCUMENT_ID })])
			return ensureStoreIsUsable()
		}
		if (!store.has(TLPOINTER_ID)) {
			store.put([PointerRecordType.create({ id: TLPOINTER_ID })])
			return ensureStoreIsUsable()
		}
		const userDocumentSettings = $userDocumentSettings.value
		if (!userDocumentSettings) {
			store.put([UserDocumentRecordType.create({})])
			return ensureStoreIsUsable()
		}
		const pages = $pages.value.sort(sortByIndex2)
		if (pages.length === 0) {
			store.put(getDefaultPages())
			return ensureStoreIsUsable()
		}
		const instanceState = $instanceState.value
		if (!instanceState) {
			const propsForNextShape = userDocumentSettings.lastUsedTabId
				? store.get(userDocumentSettings.lastUsedTabId)?.propsForNextShape
				: void 0
			const currentPageId2 = userDocumentSettings?.lastUpdatedPageId ?? pages[0].id
			store.put([
				InstanceRecordType.create({
					id: tabId,
					currentPageId: currentPageId2,
					propsForNextShape,
					exportBackground: true,
				}),
			])
			return ensureStoreIsUsable()
		}
		let currentPageId = instanceState.currentPageId
		if (!pages.find((p3) => p3.id === currentPageId)) {
			currentPageId = pages[0].id
			store.put([{ ...instanceState, currentPageId }])
			return ensureStoreIsUsable()
		}
		for (const page of pages) {
			const instancePageStates = $instancePageStates.value.filter(
				(tps) => tps.pageId === page.id && tps.instanceId === tabId
			)
			if (instancePageStates.length > 1) {
				store.remove(instancePageStates.slice(1).map((ips) => ips.id))
			} else if (instancePageStates.length === 0) {
				const camera2 = CameraRecordType.create({})
				store.put([
					camera2,
					InstancePageStateRecordType.create({
						pageId: page.id,
						instanceId: tabId,
						cameraId: camera2.id,
					}),
				])
				return ensureStoreIsUsable()
			}
			const camera = store.get(instancePageStates[0].cameraId)
			if (!camera) {
				store.put([CameraRecordType.create({ id: instancePageStates[0].cameraId })])
				return ensureStoreIsUsable()
			}
		}
	}
	return ensureStoreIsUsable
}

// ../packages/tlschema/src/assets/TLBookmarkAsset.ts
init_define_process()

// ../packages/tlschema/src/assets/asset-validation.ts
init_define_process()
function createAssetValidator(type, props) {
	return validation_exports.object({
		id: assetIdValidator,
		typeName: validation_exports.literal('asset'),
		type: validation_exports.literal(type),
		props,
	})
}

// ../packages/tlschema/src/assets/TLBookmarkAsset.ts
var bookmarkAssetTypeValidator = createAssetValidator(
	'bookmark',
	validation_exports.object({
		title: validation_exports.string,
		description: validation_exports.string,
		image: validation_exports.string,
		src: validation_exports.string.nullable(),
	})
)
var bookmarkAssetMigrations = defineMigrations({})

// ../packages/tlschema/src/assets/TLImageAsset.ts
init_define_process()
var imageAssetTypeValidator = createAssetValidator(
	'image',
	validation_exports.object({
		w: validation_exports.number,
		h: validation_exports.number,
		name: validation_exports.string,
		isAnimated: validation_exports.boolean,
		mimeType: validation_exports.string.nullable(),
		src: validation_exports.string.nullable(),
	})
)
var Versions4 = {
	AddIsAnimated: 1,
	RenameWidthHeight: 2,
}
var imageAssetMigrations = defineMigrations({
	currentVersion: Versions4.RenameWidthHeight,
	migrators: {
		[Versions4.AddIsAnimated]: {
			up: (asset) => {
				return {
					...asset,
					props: {
						...asset.props,
						isAnimated: false,
					},
				}
			},
			down: (asset) => {
				const { isAnimated: isAnimated2, ...rest } = asset.props
				return {
					...asset,
					props: rest,
				}
			},
		},
		[Versions4.RenameWidthHeight]: {
			up: (asset) => {
				const { width, height, ...others } = asset.props
				return { ...asset, props: { w: width, h: height, ...others } }
			},
			down: (asset) => {
				const { w: w3, h: h3, ...others } = asset.props
				return { ...asset, props: { width: w3, height: h3, ...others } }
			},
		},
	},
})

// ../packages/tlschema/src/assets/TLVideoAsset.ts
init_define_process()
var videoAssetTypeValidator = createAssetValidator(
	'video',
	validation_exports.object({
		w: validation_exports.number,
		h: validation_exports.number,
		name: validation_exports.string,
		isAnimated: validation_exports.boolean,
		mimeType: validation_exports.string.nullable(),
		src: validation_exports.string.nullable(),
	})
)
var Versions5 = {
	AddIsAnimated: 1,
	RenameWidthHeight: 2,
}
var videoAssetMigrations = defineMigrations({
	currentVersion: Versions5.RenameWidthHeight,
	migrators: {
		[Versions5.AddIsAnimated]: {
			up: (asset) => {
				return {
					...asset,
					props: {
						...asset.props,
						isAnimated: false,
					},
				}
			},
			down: (asset) => {
				const { isAnimated: isAnimated2, ...rest } = asset.props
				return {
					...asset,
					props: rest,
				}
			},
		},
		[Versions5.RenameWidthHeight]: {
			up: (asset) => {
				const { width, height, ...others } = asset.props
				return { ...asset, props: { w: width, h: height, ...others } }
			},
			down: (asset) => {
				const { w: w3, h: h3, ...others } = asset.props
				return { ...asset, props: { width: w3, height: h3, ...others } }
			},
		},
	},
})

// ../packages/tlschema/src/createPresenceStateDerivation.ts
init_define_process()

// ../packages/tlschema/src/records/TLInstancePresence.ts
init_define_process()
var instancePresenceTypeValidator = validation_exports.model(
	'instance_presence',
	validation_exports.object({
		instanceId: idValidator('instance'),
		typeName: validation_exports.literal('instance_presence'),
		id: idValidator('instance_presence'),
		userId: validation_exports.string,
		userName: validation_exports.string,
		lastActivityTimestamp: validation_exports.number,
		followingUserId: validation_exports.string.nullable(),
		cursor: validation_exports.object({
			x: validation_exports.number,
			y: validation_exports.number,
			type: cursorTypeValidator,
			rotation: validation_exports.number,
		}),
		color: validation_exports.string,
		camera: validation_exports.object({
			x: validation_exports.number,
			y: validation_exports.number,
			z: validation_exports.number,
		}),
		screenBounds: validation_exports.boxModel,
		selectedIds: validation_exports.arrayOf(idValidator('shape')),
		currentPageId: idValidator('page'),
		brush: validation_exports.boxModel.nullable(),
		scribble: scribbleTypeValidator.nullable(),
	})
)
var Versions6 = {
	AddScribbleDelay: 1,
}
var instancePresenceTypeMigrations = defineMigrations({
	currentVersion: Versions6.AddScribbleDelay,
	migrators: {
		[Versions6.AddScribbleDelay]: {
			up: (instance) => {
				if (instance.scribble !== null) {
					return { ...instance, scribble: { ...instance.scribble, delay: 0 } }
				}
				return { ...instance }
			},
			down: (instance) => {
				if (instance.scribble !== null) {
					const { delay: _delay, ...rest } = instance.scribble
					return { ...instance, scribble: rest }
				}
				return { ...instance }
			},
		},
	},
})
var InstancePresenceRecordType = createRecordType('instance_presence', {
	migrations: instancePresenceTypeMigrations,
	validator: instancePresenceTypeValidator,
	scope: 'presence',
}).withDefaultProperties(() => ({
	lastActivityTimestamp: 0,
	followingUserId: null,
	color: '#FF0000',
	camera: {
		x: 0,
		y: 0,
		z: 1,
	},
	cursor: {
		x: 0,
		y: 0,
		type: 'default',
		rotation: 0,
	},
	screenBounds: {
		x: 0,
		y: 0,
		w: 1,
		h: 1,
	},
	selectedIds: [],
	brush: null,
	scribble: null,
}))

// ../packages/tlschema/src/createTLSchema.ts
init_define_process()

// ../packages/tlschema/src/records/TLAsset.ts
init_define_process()
var assetTypeValidator = validation_exports.model(
	'asset',
	validation_exports.union('type', {
		image: imageAssetTypeValidator,
		video: videoAssetTypeValidator,
		bookmark: bookmarkAssetTypeValidator,
	})
)
var assetTypeMigrations = defineMigrations({
	subTypeKey: 'type',
	subTypeMigrations: {
		image: imageAssetMigrations,
		video: videoAssetMigrations,
		bookmark: bookmarkAssetMigrations,
	},
})
var AssetRecordType = createRecordType('asset', {
	migrations: assetTypeMigrations,
	validator: assetTypeValidator,
	scope: 'document',
})

// ../packages/tlschema/src/records/TLShape.ts
init_define_process()
var Versions7 = {
	AddIsLocked: 1,
}
var rootShapeTypeMigrations = defineMigrations({
	currentVersion: Versions7.AddIsLocked,
	migrators: {
		[Versions7.AddIsLocked]: {
			up: (record) => {
				return {
					...record,
					isLocked: false,
				}
			},
			down: (record) => {
				const { isLocked: _, ...rest } = record
				return {
					...rest,
				}
			},
		},
	},
})
function isShape(record) {
	if (!record) return false
	return record.typeName === 'shape'
}
function isShapeId(id) {
	if (!id) return false
	return id.startsWith('shape:')
}
function createShapeId() {
	return `shape:${nanoid()}`
}
function createCustomShapeId(id) {
	return `shape:${id}`
}

// ../packages/tlschema/src/schema.ts
init_define_process()
var Versions8 = {
	RemoveCodeAndIconShapeTypes: 1,
	AddInstancePresenceType: 2,
	RemoveTLUserAndPresenceAndAddPointer: 3,
}
var storeMigrations = defineMigrations({
	currentVersion: Versions8.RemoveTLUserAndPresenceAndAddPointer,
	migrators: {
		[Versions8.RemoveCodeAndIconShapeTypes]: {
			up: (store) => {
				return Object.fromEntries(
					Object.entries(store).filter(
						([_, v3]) => v3.typeName !== 'shape' || (v3.type !== 'icon' && v3.type !== 'code')
					)
				)
			},
			down: (store) => {
				return store
			},
		},
		[Versions8.AddInstancePresenceType]: {
			up: (store) => {
				return store
			},
			down: (store) => {
				return Object.fromEntries(
					Object.entries(store).filter(([_, v3]) => v3.typeName !== 'instance_presence')
				)
			},
		},
		[Versions8.RemoveTLUserAndPresenceAndAddPointer]: {
			up: (store) => {
				return Object.fromEntries(
					Object.entries(store).filter(([_, v3]) => !v3.typeName.match(/^(user|user_presence)$/))
				)
			},
			down: (store) => {
				return Object.fromEntries(
					Object.entries(store).filter(([_, v3]) => v3.typeName !== 'pointer')
				)
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLArrowShape.ts
init_define_process()

// ../packages/tlschema/src/shapes/shape-validation.ts
init_define_process()
function createShapeValidator(type, props) {
	return validation_exports.object({
		id: shapeIdValidator,
		typeName: validation_exports.literal('shape'),
		x: validation_exports.number,
		y: validation_exports.number,
		rotation: validation_exports.number,
		index: validation_exports.string,
		parentId: parentIdValidator,
		type: validation_exports.literal(type),
		isLocked: validation_exports.boolean,
		props,
	})
}

// ../packages/tlschema/src/shapes/TLArrowShape.ts
var arrowTerminalTypeValidator = validation_exports.union('type', {
	binding: validation_exports.object({
		type: validation_exports.literal('binding'),
		boundShapeId: shapeIdValidator,
		normalizedAnchor: validation_exports.point,
		isExact: validation_exports.boolean,
	}),
	point: validation_exports.object({
		type: validation_exports.literal('point'),
		x: validation_exports.number,
		y: validation_exports.number,
	}),
})
var arrowShapeTypeValidator = createShapeValidator(
	'arrow',
	validation_exports.object({
		labelColor: colorValidator,
		color: colorValidator,
		fill: fillValidator,
		dash: dashValidator,
		size: sizeValidator,
		opacity: opacityValidator,
		arrowheadStart: arrowheadValidator,
		arrowheadEnd: arrowheadValidator,
		font: fontValidator,
		start: arrowTerminalTypeValidator,
		end: arrowTerminalTypeValidator,
		bend: validation_exports.number,
		text: validation_exports.string,
	})
)
var Versions9 = {
	AddLabelColor: 1,
}
var arrowShapeTypeMigrations = defineMigrations({
	currentVersion: Versions9.AddLabelColor,
	migrators: {
		[Versions9.AddLabelColor]: {
			up: (record) => {
				return {
					...record,
					props: {
						...record.props,
						labelColor: 'black',
					},
				}
			},
			down: (record) => {
				const { labelColor: _, ...props } = record.props
				return {
					...record,
					props,
				}
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLBookmarkShape.ts
init_define_process()
var bookmarkShapeTypeValidator = createShapeValidator(
	'bookmark',
	validation_exports.object({
		opacity: opacityValidator,
		w: validation_exports.nonZeroNumber,
		h: validation_exports.nonZeroNumber,
		assetId: assetIdValidator.nullable(),
		url: validation_exports.string,
	})
)
var Versions10 = {
	NullAssetId: 1,
}
var bookmarkShapeTypeMigrations = defineMigrations({
	currentVersion: Versions10.NullAssetId,
	migrators: {
		[Versions10.NullAssetId]: {
			up: (shape) => {
				if (shape.props.assetId === void 0) {
					return { ...shape, props: { ...shape.props, assetId: null } }
				}
				return shape
			},
			down: (shape) => {
				if (shape.props.assetId === null) {
					const { assetId: _, ...props } = shape.props
					return { ...shape, props }
				}
				return shape
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLDrawShape.ts
init_define_process()
var TL_DRAW_SHAPE_SEGMENT_TYPE = /* @__PURE__ */ new Set(['free', 'straight'])
var drawShapeTypeValidator = createShapeValidator(
	'draw',
	validation_exports.object({
		color: colorValidator,
		fill: fillValidator,
		dash: dashValidator,
		size: sizeValidator,
		opacity: opacityValidator,
		segments: validation_exports.arrayOf(
			validation_exports.object({
				type: validation_exports.setEnum(TL_DRAW_SHAPE_SEGMENT_TYPE),
				points: validation_exports.arrayOf(validation_exports.point),
			})
		),
		isComplete: validation_exports.boolean,
		isClosed: validation_exports.boolean,
		isPen: validation_exports.boolean,
	})
)
var Versions11 = {
	AddInPen: 1,
}
var drawShapeTypeMigrations = defineMigrations({
	currentVersion: Versions11.AddInPen,
	migrators: {
		[Versions11.AddInPen]: {
			up: (shape) => {
				const { points: points2 } = shape.props.segments[0]
				if (points2.length === 0) {
					return {
						...shape,
						props: {
							...shape.props,
							isPen: false,
						},
					}
				}
				let isPen = !(points2[0].z === 0 || points2[0].z === 0.5)
				if (points2[1]) {
					isPen = isPen && !(points2[1].z === 0 || points2[1].z === 0.5)
				}
				return {
					...shape,
					props: {
						...shape.props,
						isPen,
					},
				}
			},
			down: (shape) => {
				const { isPen: _isPen, ...propsWithOutIsPen } = shape.props
				return {
					...shape,
					props: {
						...propsWithOutIsPen,
					},
				}
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLEmbedShape.ts
init_define_process()
var tlEmbedShapePermissionDefaults = {
	// ========================================================================================
	// Disabled permissions
	// ========================================================================================
	// [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
	// [REASON] Disabled because otherwise the <iframe/> trick the user on behalf of us to performing an action
	'allow-downloads-without-user-activation': false,
	// [MDN] Allows for downloads to occur with a gesture from the user.
	// [REASON] Disabled because otherwise the <iframe/> trick the user on behalf of us to performing an action
	'allow-downloads': false,
	// [MDN] Lets the resource open modal windows.
	// [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'
	'allow-modals': false,
	// [MDN] Lets the resource lock the screen orientation.
	// [REASON] Would interfer with tldraw interface
	'allow-orientation-lock': false,
	// [MDN] Lets the resource use the Pointer Lock API.
	// [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox)
	'allow-pointer-lock': false,
	// [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
	// [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within out app
	'allow-popups': true,
	// [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
	// [REASON] We're alread disabling popups.
	'allow-popups-to-escape-sandbox': false,
	// [MDN] Lets the resource start a presentation session.
	// [REASON] Prevents embed from navigating away from tldraw and pretending to be us
	'allow-presentation': false,
	// [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
	// [REASON] We don't want anyone else to access our storage
	'allow-storage-access-by-user-activation': false,
	// [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
	// [REASON] Prevents embed from navigating away from tldraw and pretending to be us
	'allow-top-navigation': false,
	// [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
	// [REASON] Prevents embed from navigating away from tldraw and pretending to be us
	'allow-top-navigation-by-user-activation': false,
	// ========================================================================================
	// Enabled permissions
	// ========================================================================================
	// [MDN] Lets the resource run scripts (but not create popup windows).
	'allow-scripts': true,
	// [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
	'allow-same-origin': true,
	// [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
	'allow-forms': true,
}
var embedShapeTypeValidator = createShapeValidator(
	'embed',
	validation_exports.object({
		opacity: opacityValidator,
		w: validation_exports.nonZeroNumber,
		h: validation_exports.nonZeroNumber,
		url: validation_exports.string,
		tmpOldUrl: validation_exports.string.optional(),
		doesResize: validation_exports.boolean,
		overridePermissions: validation_exports
			.dict(
				validation_exports.setEnum(new Set(Object.keys(tlEmbedShapePermissionDefaults))),
				validation_exports.boolean.optional()
			)
			.optional(),
	})
)
var TLDRAW_APP_RE = /(^\/r\/[^/]+\/?$)/
var safeParseUrl = (url) => {
	try {
		return new URL(url)
	} catch (err) {
		return
	}
}
var EMBED_DEFINITIONS = [
	{
		type: 'tldraw',
		title: 'tldraw',
		hostnames: ['beta.tldraw.com', 'lite.tldraw.com', 'www.tldraw.com'],
		minWidth: 300,
		minHeight: 300,
		width: 720,
		height: 500,
		doesResize: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
				return url
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
				return url
			}
			return
		},
	},
	{
		type: 'codesandbox',
		title: 'CodeSandbox',
		hostnames: ['codesandbox.io'],
		minWidth: 300,
		minHeight: 300,
		width: 720,
		height: 500,
		doesResize: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			const matches = urlObj && urlObj.pathname.match(/\/s\/([^/]+)\/?/)
			if (matches) {
				return `https://codesandbox.io/embed/${matches[1]}`
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			const matches = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/)
			if (matches) {
				return `https://codesandbox.io/s/${matches[1]}`
			}
			return
		},
	},
	{
		type: 'codepen',
		title: 'Codepen',
		hostnames: ['codepen.io'],
		minWidth: 300,
		minHeight: 300,
		width: 520,
		height: 400,
		doesResize: true,
		toEmbedUrl: (url) => {
			const CODEPEN_URL_REGEXP = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/
			const matches = url.match(CODEPEN_URL_REGEXP)
			if (matches) {
				const [_, user, id] = matches
				return `https://codepen.io/${user}/embed/${id}`
			}
			return
		},
		fromEmbedUrl: (url) => {
			const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/
			const matches = url.match(CODEPEN_EMBED_REGEXP)
			if (matches) {
				const [_, user, id] = matches
				return `https://codepen.io/${user}/pen/${id}`
			}
			return
		},
	},
	{
		type: 'scratch',
		title: 'Scratch',
		hostnames: ['scratch.mit.edu'],
		width: 520,
		height: 400,
		doesResize: false,
		toEmbedUrl: (url) => {
			const SCRATCH_URL_REGEXP = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/
			const matches = url.match(SCRATCH_URL_REGEXP)
			if (matches) {
				const [_, id] = matches
				return `https://scratch.mit.edu/projects/embed/${id}`
			}
			return
		},
		fromEmbedUrl: (url) => {
			const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/
			const matches = url.match(SCRATCH_EMBED_REGEXP)
			if (matches) {
				const [_, id] = matches
				return `https://scratch.mit.edu/projects/${id}`
			}
			return
		},
	},
	{
		type: 'youtube',
		title: 'YouTube',
		hostnames: ['*.youtube.com', 'youtube.com', 'youtu.be'],
		width: 800,
		height: 450,
		doesResize: true,
		overridePermissions: {
			'allow-presentation': true,
		},
		isAspectRatioLocked: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (!urlObj) return
			const hostname = urlObj.hostname.replace(/^www./, '')
			if (hostname === 'youtu.be') {
				const videoId = urlObj.pathname.split('/').filter(Boolean)[0]
				return `https://www.youtube.com/embed/${videoId}`
			} else if (
				(hostname === 'youtube.com' || hostname === 'm.youtube.com') &&
				urlObj.pathname.match(/^\/watch/)
			) {
				const videoId = urlObj.searchParams.get('v')
				return `https://www.youtube.com/embed/${videoId}`
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (!urlObj) return
			const hostname = urlObj.hostname.replace(/^www./, '')
			if (hostname === 'youtube.com') {
				const matches = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/)
				if (matches) {
					return `https://www.youtube.com/watch?v=${matches[1]}`
				}
			}
			return
		},
	},
	{
		type: 'figma',
		title: 'Figma',
		hostnames: ['figma.com'],
		width: 720,
		height: 500,
		doesResize: true,
		toEmbedUrl: (url) => {
			if (
				!!url.match(
					// eslint-disable-next-line no-useless-escape
					/https:\/\/([\w\.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
				) &&
				!url.includes('figma.com/embed')
			) {
				return `https://www.figma.com/embed?embed_host=share&url=${url}`
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
				const outUrl = urlObj.searchParams.get('url')
				if (outUrl) {
					return outUrl
				}
			}
			return
		},
	},
	{
		type: 'google_maps',
		title: 'Google Maps',
		hostnames: ['google.*'],
		width: 720,
		height: 500,
		doesResize: true,
		toEmbedUrl: (url) => {
			if (url.includes('/maps/')) {
				const match = url.match(/@(.*),(.*),(.*)z/)
				let result
				if (match) {
					const [, lat, lng, z2] = match
					const host = new URL(url).host.replace('www.', '')
					result = `https://${host}/maps/embed/v1/view?key=${define_process_default.env.NEXT_PUBLIC_GC_API_KEY}&center=${lat},${lng}&zoom=${z2}`
				} else {
					result = ''
				}
				return result
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (!urlObj) return
			const matches = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/)
			if (matches && urlObj.searchParams.has('center') && urlObj.searchParams.get('zoom')) {
				const zoom = urlObj.searchParams.get('zoom')
				const [lat, lon] = urlObj.searchParams.get('center').split(',')
				return `https://www.google.com/maps/@${lat},${lon},${zoom}z`
			}
			return
		},
	},
	{
		type: 'google_calendar',
		title: 'Google Calendar',
		hostnames: ['calendar.google.*'],
		width: 720,
		height: 500,
		minWidth: 460,
		minHeight: 360,
		doesResize: true,
		instructionLink: 'https://support.google.com/calendar/answer/41207?hl=en',
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			const cidQs = urlObj?.searchParams.get('cid')
			if (urlObj?.pathname.match(/\/calendar\/u\/0/) && cidQs) {
				urlObj.pathname = '/calendar/embed'
				const keys = Array.from(urlObj.searchParams.keys())
				for (const key of keys) {
					urlObj.searchParams.delete(key)
				}
				urlObj.searchParams.set('src', cidQs)
				return urlObj.href
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			const srcQs = urlObj?.searchParams.get('src')
			if (urlObj?.pathname.match(/\/calendar\/embed/) && srcQs) {
				urlObj.pathname = '/calendar/u/0'
				const keys = Array.from(urlObj.searchParams.keys())
				for (const key of keys) {
					urlObj.searchParams.delete(key)
				}
				urlObj.searchParams.set('cid', srcQs)
				return urlObj.href
			}
			return
		},
	},
	{
		type: 'google_slides',
		title: 'Google Slides',
		hostnames: ['docs.google.*'],
		width: 720,
		height: 500,
		minWidth: 460,
		minHeight: 360,
		doesResize: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj?.pathname.match(/^\/presentation/) && urlObj?.pathname.match(/\/pub\/?$/)) {
				urlObj.pathname = urlObj.pathname.replace(/\/pub$/, '/embed')
				const keys = Array.from(urlObj.searchParams.keys())
				for (const key of keys) {
					urlObj.searchParams.delete(key)
				}
				return urlObj.href
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj?.pathname.match(/^\/presentation/) && urlObj?.pathname.match(/\/embed\/?$/)) {
				urlObj.pathname = urlObj.pathname.replace(/\/embed$/, '/pub')
				const keys = Array.from(urlObj.searchParams.keys())
				for (const key of keys) {
					urlObj.searchParams.delete(key)
				}
				return urlObj.href
			}
			return
		},
	},
	{
		type: 'github_gist',
		title: 'GitHub Gist',
		hostnames: ['gist.github.com'],
		width: 720,
		height: 500,
		doesResize: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([^/]+)/)) {
				return url
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([^/]+)/)) {
				return url
			}
			return
		},
	},
	{
		type: 'replit',
		title: 'Replit',
		hostnames: ['replit.com'],
		width: 720,
		height: 500,
		doesResize: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/)) {
				return `${url}?embed=true`
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (
				urlObj &&
				urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) &&
				urlObj.searchParams.has('embed')
			) {
				urlObj.searchParams.delete('embed')
				return urlObj.href
			}
			return
		},
	},
	{
		type: 'felt',
		title: 'Felt',
		hostnames: ['felt.com'],
		width: 720,
		height: 500,
		doesResize: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/^\/map\//)) {
				return urlObj.origin + '/embed' + urlObj.pathname
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
				urlObj.pathname = urlObj.pathname.replace(/^\/embed/, '')
				return urlObj.href
			}
			return
		},
	},
	{
		type: 'spotify',
		title: 'Spotify',
		hostnames: ['open.spotify.com'],
		width: 720,
		height: 500,
		minHeight: 500,
		overrideOutlineRadius: 12,
		doesResize: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/^\/(artist|album)\//)) {
				return urlObj.origin + '/embed' + urlObj.pathname
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
				return urlObj.origin + urlObj.pathname.replace(/^\/embed/, '')
			}
			return
		},
	},
	{
		type: 'vimeo',
		title: 'Vimeo',
		hostnames: ['vimeo.com', 'player.vimeo.com'],
		width: 640,
		height: 360,
		doesResize: true,
		isAspectRatioLocked: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.hostname === 'vimeo.com') {
				if (urlObj.pathname.match(/^\/[0-9]+/)) {
					return (
						'https://player.vimeo.com/video/' + urlObj.pathname.split('/')[1] + '?title=0&byline=0'
					)
				}
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.hostname === 'player.vimeo.com') {
				const matches = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/)
				if (matches) {
					return 'https://vimeo.com/' + matches[1]
				}
			}
			return
		},
	},
	{
		type: 'excalidraw',
		title: 'Excalidraw',
		hostnames: ['excalidraw.com'],
		width: 720,
		height: 500,
		doesResize: true,
		isAspectRatioLocked: true,
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.hash.match(/#room=/)) {
				return url
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.hash.match(/#room=/)) {
				return url
			}
			return
		},
	},
	{
		type: 'observable',
		title: 'Observable',
		hostnames: ['observablehq.com'],
		width: 720,
		height: 500,
		doesResize: true,
		isAspectRatioLocked: false,
		backgroundColor: '#fff',
		toEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/)) {
				return `${urlObj.origin}/embed${urlObj.pathname}?cell=*`
			}
			if (urlObj && urlObj.pathname.match(/^\/d\/([^/]+)\/?$/)) {
				const pathName = urlObj.pathname.replace(/^\/d/, '')
				return `${urlObj.origin}/embed${pathName}?cell=*`
			}
			return
		},
		fromEmbedUrl: (url) => {
			const urlObj = safeParseUrl(url)
			if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
				return `${urlObj.origin}${urlObj.pathname.replace('/embed', '')}#cell-*`
			}
			if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
				return `${urlObj.origin}${urlObj.pathname.replace('/embed', '/d')}#cell-*`
			}
			return
		},
	},
]
var Versions12 = {
	GenOriginalUrlInEmbed: 1,
}
var embedShapeTypeMigrations = defineMigrations({
	currentVersion: Versions12.GenOriginalUrlInEmbed,
	migrators: {
		[Versions12.GenOriginalUrlInEmbed]: {
			// add tmpOldUrl property
			up: (shape) => {
				const url = shape.props.url
				const host = new URL(url).host.replace('www.', '')
				let originalUrl
				for (const localEmbedDef of EMBED_DEFINITIONS) {
					if (localEmbedDef.hostnames.includes(host)) {
						try {
							originalUrl = localEmbedDef.fromEmbedUrl(url)
						} catch (err) {
							console.warn(err)
						}
					}
				}
				return {
					...shape,
					props: {
						...shape.props,
						tmpOldUrl: shape.props.url,
						url: originalUrl ?? '',
					},
				}
			},
			// remove tmpOldUrl property
			down: (shape) => {
				let newUrl = shape.props.tmpOldUrl
				if (!newUrl || newUrl === '') {
					const url = shape.props.url
					const host = new URL(url).host.replace('www.', '')
					for (const localEmbedDef of EMBED_DEFINITIONS) {
						if (localEmbedDef.hostnames.includes(host)) {
							try {
								newUrl = localEmbedDef.toEmbedUrl(url)
							} catch (err) {
								console.warn(err)
							}
						}
					}
				}
				const { tmpOldUrl, ...props } = shape.props
				return {
					...shape,
					props: {
						...props,
						url: newUrl ?? '',
					},
				}
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLFrameShape.ts
init_define_process()
var frameShapeTypeValidator = createShapeValidator(
	'frame',
	validation_exports.object({
		opacity: opacityValidator,
		w: validation_exports.nonZeroNumber,
		h: validation_exports.nonZeroNumber,
		name: validation_exports.string,
	})
)
var frameShapeTypeMigrations = defineMigrations({})

// ../packages/tlschema/src/shapes/TLGeoShape.ts
init_define_process()
var geoShapeTypeValidator = createShapeValidator(
	'geo',
	validation_exports.object({
		geo: geoValidator,
		labelColor: colorValidator,
		color: colorValidator,
		fill: fillValidator,
		dash: dashValidator,
		size: sizeValidator,
		opacity: opacityValidator,
		font: fontValidator,
		align: alignValidator,
		verticalAlign: verticalAlignValidator,
		url: validation_exports.string,
		w: validation_exports.nonZeroNumber,
		h: validation_exports.nonZeroNumber,
		growY: validation_exports.positiveNumber,
		text: validation_exports.string,
	})
)
var Versions13 = {
	AddUrlProp: 1,
	AddLabelColor: 2,
	RemoveJustify: 3,
	AddCheckBox: 4,
	AddVerticalAlign: 5,
	MigrateLegacyAlign: 6,
}
var geoShapeTypeMigrations = defineMigrations({
	currentVersion: Versions13.MigrateLegacyAlign,
	migrators: {
		[Versions13.AddUrlProp]: {
			up: (shape) => {
				return { ...shape, props: { ...shape.props, url: '' } }
			},
			down: (shape) => {
				const { url: _, ...props } = shape.props
				return { ...shape, props }
			},
		},
		[Versions13.AddLabelColor]: {
			up: (record) => {
				return {
					...record,
					props: {
						...record.props,
						labelColor: 'black',
					},
				}
			},
			down: (record) => {
				const { labelColor: _, ...props } = record.props
				return {
					...record,
					props,
				}
			},
		},
		[Versions13.RemoveJustify]: {
			up: (shape) => {
				let newAlign = shape.props.align
				if (newAlign === 'justify') {
					newAlign = 'start'
				}
				return {
					...shape,
					props: {
						...shape.props,
						align: newAlign,
					},
				}
			},
			down: (shape) => {
				return { ...shape }
			},
		},
		[Versions13.AddCheckBox]: {
			up: (shape) => {
				return { ...shape }
			},
			down: (shape) => {
				return {
					...shape,
					props: {
						...shape.props,
						geo: shape.props.geo === 'check-box' ? 'rectangle' : shape.props.geo,
					},
				}
			},
		},
		[Versions13.AddVerticalAlign]: {
			up: (shape) => {
				return {
					...shape,
					props: {
						...shape.props,
						verticalAlign: 'middle',
					},
				}
			},
			down: (shape) => {
				const { verticalAlign: _, ...props } = shape.props
				return {
					...shape,
					props,
				}
			},
		},
		[Versions13.MigrateLegacyAlign]: {
			up: (shape) => {
				let newAlign
				switch (shape.props.align) {
					case 'start':
						newAlign = 'start-legacy'
						break
					case 'end':
						newAlign = 'end-legacy'
						break
					default:
						newAlign = 'middle-legacy'
						break
				}
				return {
					...shape,
					props: {
						...shape.props,
						align: newAlign,
					},
				}
			},
			down: (shape) => {
				let oldAlign
				switch (shape.props.align) {
					case 'start-legacy':
						oldAlign = 'start'
						break
					case 'end-legacy':
						oldAlign = 'end'
						break
					case 'middle-legacy':
						oldAlign = 'middle'
						break
					default:
						oldAlign = shape.props.align
				}
				return {
					...shape,
					props: {
						...shape.props,
						align: oldAlign,
					},
				}
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLGroupShape.ts
init_define_process()
var groupShapeTypeValidator = createShapeValidator(
	'group',
	validation_exports.object({
		opacity: opacityValidator,
	})
)
var groupShapeTypeMigrations = defineMigrations({})

// ../packages/tlschema/src/shapes/TLImageShape.ts
init_define_process()
var cropValidator = validation_exports.object({
	topLeft: validation_exports.point,
	bottomRight: validation_exports.point,
})
var imageShapeTypeValidator = createShapeValidator(
	'image',
	validation_exports.object({
		opacity: opacityValidator,
		w: validation_exports.nonZeroNumber,
		h: validation_exports.nonZeroNumber,
		playing: validation_exports.boolean,
		url: validation_exports.string,
		assetId: assetIdValidator.nullable(),
		crop: cropValidator.nullable(),
	})
)
var Versions14 = {
	AddUrlProp: 1,
	AddCropProp: 2,
}
var imageShapeTypeMigrations = defineMigrations({
	currentVersion: Versions14.AddCropProp,
	migrators: {
		[Versions14.AddUrlProp]: {
			up: (shape) => {
				return { ...shape, props: { ...shape.props, url: '' } }
			},
			down: (shape) => {
				const { url: _, ...props } = shape.props
				return { ...shape, props }
			},
		},
		[Versions14.AddCropProp]: {
			up: (shape) => {
				return { ...shape, props: { ...shape.props, crop: null } }
			},
			down: (shape) => {
				const { crop: _, ...props } = shape.props
				return { ...shape, props }
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLLineShape.ts
init_define_process()
var lineShapeTypeValidator = createShapeValidator(
	'line',
	validation_exports.object({
		color: colorValidator,
		dash: dashValidator,
		size: sizeValidator,
		opacity: opacityValidator,
		spline: splineValidator,
		handles: validation_exports.dict(validation_exports.string, handleTypeValidator),
	})
)
var lineShapeTypeMigrations = defineMigrations({})

// ../packages/tlschema/src/shapes/TLNoteShape.ts
init_define_process()
var noteShapeTypeValidator = createShapeValidator(
	'note',
	validation_exports.object({
		color: colorValidator,
		size: sizeValidator,
		font: fontValidator,
		align: alignValidator,
		opacity: opacityValidator,
		growY: validation_exports.positiveNumber,
		url: validation_exports.string,
		text: validation_exports.string,
	})
)
var Versions15 = {
	AddUrlProp: 1,
	RemoveJustify: 2,
	MigrateLegacyAlign: 3,
}
var noteShapeTypeMigrations = defineMigrations({
	currentVersion: Versions15.MigrateLegacyAlign,
	migrators: {
		[Versions15.AddUrlProp]: {
			up: (shape) => {
				return { ...shape, props: { ...shape.props, url: '' } }
			},
			down: (shape) => {
				const { url: _, ...props } = shape.props
				return { ...shape, props }
			},
		},
		[Versions15.RemoveJustify]: {
			up: (shape) => {
				let newAlign = shape.props.align
				if (newAlign === 'justify') {
					newAlign = 'start'
				}
				return {
					...shape,
					props: {
						...shape.props,
						align: newAlign,
					},
				}
			},
			down: (shape) => {
				return { ...shape }
			},
		},
		[Versions15.MigrateLegacyAlign]: {
			up: (shape) => {
				let newAlign
				switch (shape.props.align) {
					case 'start':
						newAlign = 'start-legacy'
						break
					case 'end':
						newAlign = 'end-legacy'
						break
					default:
						newAlign = 'middle-legacy'
						break
				}
				return {
					...shape,
					props: {
						...shape.props,
						align: newAlign,
					},
				}
			},
			down: (shape) => {
				let oldAlign
				switch (shape.props.align) {
					case 'start-legacy':
						oldAlign = 'start'
						break
					case 'end-legacy':
						oldAlign = 'end'
						break
					case 'middle-legacy':
						oldAlign = 'middle'
						break
					default:
						oldAlign = shape.props.align
				}
				return {
					...shape,
					props: {
						...shape.props,
						align: oldAlign,
					},
				}
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLTextShape.ts
init_define_process()
var textShapeTypeValidator = createShapeValidator(
	'text',
	validation_exports.object({
		color: colorValidator,
		size: sizeValidator,
		font: fontValidator,
		align: alignValidator,
		opacity: opacityValidator,
		w: validation_exports.nonZeroNumber,
		text: validation_exports.string,
		scale: validation_exports.nonZeroNumber,
		autoSize: validation_exports.boolean,
	})
)
var Versions16 = {
	RemoveJustify: 1,
}
var textShapeTypeMigrations = defineMigrations({
	currentVersion: Versions16.RemoveJustify,
	migrators: {
		[Versions16.RemoveJustify]: {
			up: (shape) => {
				let newAlign = shape.props.align
				if (newAlign === 'justify') {
					newAlign = 'start'
				}
				return {
					...shape,
					props: {
						...shape.props,
						align: newAlign,
					},
				}
			},
			down: (shape) => {
				return { ...shape }
			},
		},
	},
})

// ../packages/tlschema/src/shapes/TLVideoShape.ts
init_define_process()
var videoShapeTypeValidator = createShapeValidator(
	'video',
	validation_exports.object({
		opacity: opacityValidator,
		w: validation_exports.nonZeroNumber,
		h: validation_exports.nonZeroNumber,
		time: validation_exports.number,
		playing: validation_exports.boolean,
		url: validation_exports.string,
		assetId: assetIdValidator.nullable(),
	})
)
var Versions17 = {
	AddUrlProp: 1,
}
var videoShapeTypeMigrations = defineMigrations({
	currentVersion: Versions17.AddUrlProp,
	migrators: {
		[Versions17.AddUrlProp]: {
			up: (shape) => {
				return { ...shape, props: { ...shape.props, url: '' } }
			},
			down: (shape) => {
				const { url: _, ...props } = shape.props
				return { ...shape, props }
			},
		},
	},
})

// ../packages/tlschema/src/createTLSchema.ts
var DEFAULT_SHAPES = {
	arrow: { migrations: arrowShapeTypeMigrations, validator: arrowShapeTypeValidator },
	bookmark: { migrations: bookmarkShapeTypeMigrations, validator: bookmarkShapeTypeValidator },
	draw: { migrations: drawShapeTypeMigrations, validator: drawShapeTypeValidator },
	embed: { migrations: embedShapeTypeMigrations, validator: embedShapeTypeValidator },
	frame: { migrations: frameShapeTypeMigrations, validator: frameShapeTypeValidator },
	geo: { migrations: geoShapeTypeMigrations, validator: geoShapeTypeValidator },
	group: { migrations: groupShapeTypeMigrations, validator: groupShapeTypeValidator },
	image: { migrations: imageShapeTypeMigrations, validator: imageShapeTypeValidator },
	line: { migrations: lineShapeTypeMigrations, validator: lineShapeTypeValidator },
	note: { migrations: noteShapeTypeMigrations, validator: noteShapeTypeValidator },
	text: { migrations: textShapeTypeMigrations, validator: textShapeTypeValidator },
	video: { migrations: videoShapeTypeMigrations, validator: videoShapeTypeValidator },
}
function createTLSchema(opts = {}) {
	const { customShapes = {} } = opts
	const defaultShapeSubTypeEntries = Object.entries(DEFAULT_SHAPES)
	const customShapeSubTypeEntries = Object.entries(customShapes)
	const shapeSubTypeMigrationsWithCustomSubTypeMigrations = {
		...Object.fromEntries(defaultShapeSubTypeEntries.map(([k2, v3]) => [k2, v3.migrations])),
		...Object.fromEntries(
			customShapeSubTypeEntries.map(([k2, v3]) => [k2, v3.migrations ?? defineMigrations({})])
		),
	}
	const validatorWithCustomShapeValidators = validation_exports.model(
		'shape',
		validation_exports.union('type', {
			...Object.fromEntries(defaultShapeSubTypeEntries.map(([k2, v3]) => [k2, v3.validator])),
			...Object.fromEntries(
				customShapeSubTypeEntries.map(([k2, v3]) => [k2, v3.validator ?? validation_exports.any])
			),
		})
	)
	const shapeRecord = createRecordType('shape', {
		migrations: defineMigrations({
			currentVersion: rootShapeTypeMigrations.currentVersion,
			firstVersion: rootShapeTypeMigrations.firstVersion,
			migrators: rootShapeTypeMigrations.migrators,
			subTypeKey: 'type',
			subTypeMigrations: shapeSubTypeMigrationsWithCustomSubTypeMigrations,
		}),
		validator: validatorWithCustomShapeValidators,
		scope: 'document',
	}).withDefaultProperties(() => ({ x: 0, y: 0, rotation: 0, isLocked: false }))
	return StoreSchema.create(
		{
			asset: AssetRecordType,
			camera: CameraRecordType,
			document: DocumentRecordType,
			instance: InstanceRecordType,
			instance_page_state: InstancePageStateRecordType,
			page: PageRecordType,
			shape: shapeRecord,
			user_document: UserDocumentRecordType,
			instance_presence: InstancePresenceRecordType,
			pointer: PointerRecordType,
		},
		{
			snapshotMigrations: storeMigrations,
			onValidationFailure,
			createIntegrityChecker,
		}
	)
}

// ../packages/tlschema/src/fixup.ts
init_define_process()
function CLIENT_FIXUP_SCRIPT(persistedStore) {
	const records = Object.values(persistedStore)
	for (let i3 = 0; i3 < records.length; i3++) {
		if (!records[i3]) continue
		const { record } = fixupRecord(records[i3])
		if (record) {
			persistedStore[records[i3].id] = record
		} else {
			delete persistedStore[records[i3].id]
		}
	}
	return persistedStore
}
function fixupRecord(oldRecord) {
	const issues = []
	let record = JSON.parse(JSON.stringify(oldRecord))
	switch (record.typeName) {
		case 'user_presence': {
			if (!record.cursor) {
				issues.push('no cursor')
				record.cursor = { x: 0, y: 0 }
			}
			if (record.cursor.x === void 0 || record.cursor.x === null) {
				issues.push('no cursor x')
				record.cursor.x = 0
			}
			if (record.cursor.y === void 0 || record.cursor.y === null) {
				issues.push('no cursor y')
				record.cursor.y = 0
			}
			break
		}
		case 'asset': {
			switch (record.type) {
				case 'image':
				case 'video': {
					if (!record.props) {
						issues.push('no props in asset')
						record.props = {
							w: 100,
							h: 100,
							name: 'old_asset',
							isAnimated: false,
							mimeType: null,
							src: null,
						}
					}
					if (!record.props.mimeType) {
						issues.push('no mimeType in asset props')
						record.props.mimeType = 'image/png'
					}
					if (!record.props.src) {
						issues.push('no src in asset props')
						record.props.src = ''
					}
					if (record.props.isAnimated == null) {
						issues.push('no isAnimated in asset props')
						record.props.isAnimated = false
					}
					if (record.props.name === void 0) {
						record.props.name = 'asset'
					}
					if ('width' in record) {
						issues.push('width in asset')
						record.props.w = record.width
						delete record.width
					}
					if (
						'width' in record.props &&
						typeof record.props.width === 'number' &&
						record.props.width
					) {
						issues.push('no w in asset props')
						record.props.w = record.props.width
						delete record.props.width
					}
					if ('height' in record) {
						issues.push('height in asset')
						record.props.h = record.height
						delete record.height
					}
					if (
						'height' in record.props &&
						typeof record.props.height === 'number' &&
						record.props.height
					) {
						issues.push('no h in asset props')
						record.props.h = record.props.height
						delete record.props.height
					}
					if (!record.props.w) {
						issues.push('no w in asset props')
						record.props.w = 100
					}
					if (!record.props.h) {
						issues.push('no h in asset props')
						record.props.h = 100
					}
					if ('src' in record) {
						issues.push('src in asset')
						record.props.src = record.src
						delete record.src
					}
					if ('name' in record) {
						issues.push('name in asset')
						delete record.name
					}
					break
				}
				case 'bookmark':
					if (!record.props) {
						issues.push('no asset props')
						record.props = {
							title: '',
							description: '',
							image: '',
							src: 'url' in record && typeof record.url === 'string' ? record.url : '',
						}
					}
					if (!record.props.title) {
						issues.push('no title in bookmark asset props')
						record.props.title = ''
					}
					if (!record.props.description) {
						issues.push('no description in bookmark asset props')
						record.props.description = ''
					}
					if (!record.props.image) {
						issues.push('no image in bookmark asset props')
						record.props.image = ''
					}
					if ('src' in record) {
						issues.push('leftover src in bookmark asset')
						delete record.src
					}
					if ('width' in record) {
						issues.push('leftover width in bookmark asset')
						delete record.width
					}
					if ('height' in record) {
						issues.push('leftover height in bookmark asset')
						delete record.height
					}
					if ('name' in record) {
						issues.push('leftover name in bookmark asset')
						delete record.name
					}
					if ('meta' in record) {
						delete record.meta
					}
					break
			}
			break
		}
		case 'camera': {
			if (record.x === void 0 || record.x === null) {
				issues.push('no x in camera')
				record.x = 0
			}
			if (record.y === void 0 || record.y === null) {
				issues.push('no y in camera')
				record.y = 0
			}
			break
		}
		case 'instance': {
			if ('props' in record) {
				issues.push('leftover props in instance')
				delete record.props
			}
			if (record.isToolLocked === void 0) {
				issues.push('no isToolLocked in instance')
				record.isToolLocked = false
			}
			if (record.propsForNextShape === void 0) {
				issues.push('no props in instance')
				record.propsForNextShape = {
					opacity: '1',
					color: 'black',
					dash: 'draw',
					fill: 'none',
					size: 'm',
					icon: 'file',
					font: 'draw',
					align: 'middle',
					geo: 'rectangle',
					arrowheadStart: 'none',
					arrowheadEnd: 'arrow',
					spline: 'line',
				}
			}
			if ('url' in record.propsForNextShape) {
				issues.push('leftover url in instance.propsForNextShape')
				delete record.propsForNextShape.url
			}
			if ('lang' in record.propsForNextShape) {
				issues.push('leftover lang in instance.propsForNextShape')
				delete record.propsForNextShape.lang
			}
			if (record.exportBackground === void 0) {
				issues.push(`no export background in ${record.typeName}`)
				record.exportBackground = false
			}
			if (record.brush === void 0) {
				issues.push(`no brush in ${record.typeName}`)
				record.brush = null
			}
			if (record.scribble === void 0) {
				issues.push(`no scribble in ${record.typeName}`)
				record.scribble = null
			}
			if (record.dialog !== void 0) {
				issues.push(`no dialog in ${record.typeName}`)
				delete record.dialog
			}
			if (record.screenBounds === void 0) {
				issues.push(`no screen bounds in ${record.typeName}`)
				record.screenBounds = { x: 0, y: 0, w: 1080, h: 720 }
			}
			break
		}
		case 'user': {
			if (!record.name) {
				issues.push(`no name in user`)
				record.name = 'User'
			}
			if (!record.locale) {
				issues.push(`no locale in user`)
				record.locale = 'en'
			}
			if ('cursor' in record) {
				issues.push('leftover cursor in user')
				delete record.cursor
			}
			if ('color' in record) {
				issues.push('leftover color in user')
				delete record.color
			}
			if ('brush' in record) {
				issues.push('leftover brush in user')
				delete record.brush
			}
			if ('selectedIds' in record) {
				issues.push('leftover selectedIds in user')
				delete record.selectedIds
			}
			if ('scribble' in record) {
				issues.push('leftover scribble in user')
				delete record.scribble
			}
			if ('currentPageId' in record) {
				issues.push('leftover currentPageId in user')
				delete record.currentPageId
			}
			break
		}
		case 'user_document': {
			if (record.isMobileMode === void 0) {
				issues.push(`no ismobilemode in user document`)
				record.isMobileMode = false
			}
			if (record.isSnapMode === void 0) {
				issues.push(`no issnapmode in user document`)
				record.isSnapMode = false
			}
			break
		}
		case 'shape': {
			if ('url' in record) {
				delete record.url
			}
			if (record.x === void 0 || record.x === null) {
				issues.push(`some bug in ${record.typeName} ${record.type}`)
				record.x = 0
			}
			if (record.y === void 0 || record.y === null) {
				issues.push(`some bug in ${record.typeName} ${record.type}`)
				record.y = 0
			}
			if (record.type === 'image') {
				if (record.props.playing === void 0) {
					issues.push(`some bug in ${record.typeName} ${record.type}`)
					record.props.playing = false
				}
				if ('loaded' in record.props) {
					delete record.props.loaded
				}
			}
			if (record.type === 'arrow') {
				if (record.props.start.type === 'binding') {
					if (
						record.props.start.normalizedAnchor.x === void 0 ||
						record.props.start.normalizedAnchor.x === null
					) {
						issues.push(`some bug in ${record.typeName} ${record.type}`)
						record.props.start.normalizedAnchor.x = 0
					}
					if (
						record.props.start.normalizedAnchor.y === void 0 ||
						record.props.start.normalizedAnchor.y === null
					) {
						issues.push(`some bug in ${record.typeName} ${record.type}`)
						record.props.start.normalizedAnchor.y = 0
					}
				} else {
					if (record.props.start.x === void 0 || record.props.start.x === null) {
						issues.push(`some bug in ${record.typeName} ${record.type}`)
						record.props.start.x = 0
					}
					if (record.props.start.y === void 0 || record.props.start.y === null) {
						issues.push(`some bug in ${record.typeName} ${record.type}`)
						record.props.start.y = 0
					}
					if ('boundShapeId' in record.props.start) {
						issues.push(`leftover bound shape id in arrow`)
						delete record.props.start.boundShapeId
					}
					if ('normalizedAnchor' in record.props.start) {
						issues.push(`leftover normalize anchor in arrow`)
						delete record.props.start.normalizedAnchor
					}
					if ('isExact' in record.props.start) {
						issues.push(`leftover isExact in arrow`)
						delete record.props.start.isExact
					}
				}
				if (record.props.end.type === 'binding') {
					if (
						record.props.end.normalizedAnchor.x === void 0 ||
						record.props.end.normalizedAnchor.x === null
					) {
						issues.push(`some bug in ${record.typeName}  ${record.type}`)
						record.props.end.normalizedAnchor.x = 0
					}
					if (
						record.props.end.normalizedAnchor.y === void 0 ||
						record.props.end.normalizedAnchor.y === null
					) {
						issues.push(`some bug in ${record.typeName} ${record.type}`)
						record.props.end.normalizedAnchor.y = 0
					}
				} else {
					if (record.props.end.x === void 0 || record.props.end.x === null) {
						issues.push(`no x in arrow end`)
						record.props.end.x = 0
					}
					if (record.props.end.y === void 0 || record.props.end.y === null) {
						issues.push(`no y in arrow end`)
						record.props.end.y = 0
					}
					if ('boundShapeId' in record.props.end) {
						issues.push(`leftover bound shape id in arrow`)
						delete record.props.end.boundShapeId
					}
					if ('normalizedAnchor' in record.props.end) {
						issues.push(`leftover normalize anchor in arrow`)
						delete record.props.end.normalizedAnchor
					}
					if ('isExact' in record.props.end) {
						issues.push(`leftover isExact in arrow`)
						delete record.props.end.isExact
					}
				}
			}
			if (
				record.type === 'note' ||
				record.type === 'video' ||
				record.type === 'image' ||
				record.type === 'geo' ||
				record.type === 'bookmark'
			) {
				if (record.props.url === void 0) {
					issues.push(`missing url prop in ${record.type} shape`)
					record.props.url = ''
				}
			}
			if (record.type === 'bookmark') {
				if (record.props.assetId === void 0) {
					issues.push(`some bug in ${record.typeName}  ${record.type}`)
					record.props.assetId = null
				}
				if ('src' in record) {
					issues.push(`leftover src in bookmark`)
					delete record.src
				}
			}
			if (record.type === 'geo') {
				if ('width' in record.props) {
					issues.push(`leftover width in geo`)
					delete record.props.width
				}
				if ('height' in record.props) {
					issues.push(`leftover height in geo`)
					delete record.props.height
				}
			}
			if (record.type === 'draw') {
				if (record.props.segments === void 0) {
					issues.push(`some bug in ${record.typeName}  ${record.type}`)
					record.props.segments = [
						{
							points: [
								{ x: 0, y: 0, z: 0.5 },
								{ x: 1, y: 1, z: 0.5 },
							],
							type: 'free',
						},
					]
				}
				for (const segment of record.props.segments) {
					for (const point2 of segment.points) {
						if (point2.x === void 0 || point2.y === null) {
							issues.push(`some bug in ${record.typeName}`)
							point2.x = 0
						}
						if (point2.y === void 0 || point2.y === null) {
							issues.push(`some bug in ${record.typeName}`)
							point2.y = 0
						}
					}
				}
				if ('points' in record.props) {
					delete record.props.points
				}
			}
			if (record.type === 'bookmark') {
				if ('loaded' in record.props) {
					issues.push('leftover loaded in bookmark')
					delete record.props.loaded
				}
			}
			if (record.type === 'draw') {
				if ('points' in record.props && record.props.segments === void 0) {
					record.props.segments = [{ type: 'free', points: record.props.points }]
				}
			}
			if (record.type === 'image') {
				if (record.props.w < 1) {
					record.props.w = 1
					issues.push(`zero w image in ${record.typeName}`)
				}
				if (record.props.h < 1) {
					record.props.h = 1
					issues.push(`zero h image in ${record.typeName}`)
				}
			}
			if (record.type === 'embed') {
				if ('loaded' in record.props) {
					issues.push('leftover loaded in embed')
					delete record.props.loaded
				}
			}
			break
		}
		case void 0: {
			record = null
		}
	}
	return { record, issues }
}

// ../packages/tlschema/src/geometry-types.ts
init_define_process()

// ../packages/tlschema/src/shapes/TLIconShape.ts
init_define_process()
var iconShapeTypeValidator = createShapeValidator(
	'icon',
	validation_exports.object({
		size: sizeValidator,
		icon: iconValidator,
		dash: dashValidator,
		color: colorValidator,
		opacity: opacityValidator,
		scale: validation_exports.number,
	})
)
var iconShapeTypeMigrations = defineMigrations({})

// ../packages/tlschema/src/translations.ts
init_define_process()

// ../packages/tlschema/src/languages.ts
init_define_process()
var LANGUAGES = [
	{ locale: 'ar', label: '\u0639\u0631\u0628\u064A' },
	{ locale: 'ca', label: 'Catal\xE0' },
	{ locale: 'da', label: 'Danish' },
	{ locale: 'de', label: 'Deutsch' },
	{ locale: 'en', label: 'English' },
	{ locale: 'es', label: 'Espa\xF1ol' },
	{ locale: 'fa', label: '\u0641\u0627\u0631\u0633\u06CC' },
	{ locale: 'fi', label: 'Suomi' },
	{ locale: 'fr', label: 'Fran\xE7ais' },
	{ locale: 'gl', label: 'Galego' },
	{ locale: 'he', label: '\u05E2\u05D1\u05E8\u05D9\u05EA' },
	{ locale: 'it', label: 'Italiano' },
	{ locale: 'ja', label: '\u65E5\u672C\u8A9E' },
	{ locale: 'ko-kr', label: '\uD55C\uAD6D\uC5B4' },
	{ locale: 'ku', label: '\u06A9\u0648\u0631\u062F\u06CC' },
	{ locale: 'hi-in', label: '\u0939\u093F\u0928\u094D\u0926\u0940' },
	{ locale: 'hu', label: 'Magyar' },
	{ locale: 'my', label: '\u1019\u103C\u1014\u103A\u1019\u102C\u1005\u102C' },
	{ locale: 'ne', label: '\u0928\u0947\u092A\u093E\u0932\u0940' },
	{ locale: 'no', label: 'Norwegian' },
	{ locale: 'pl', label: 'Polski' },
	{ locale: 'pt-br', label: 'Portugu\xEAs - Brasil' },
	{ locale: 'pt-pt', label: 'Portugu\xEAs - Europeu' },
	{ locale: 'ro', label: 'Rom\xE2n\u0103' },
	{ locale: 'ru', label: 'Russian' },
	{ locale: 'sv', label: 'Svenska' },
	{ locale: 'te', label: '\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41' },
	{ locale: 'th', label: '\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22' },
	{ locale: 'tr', label: 'T\xFCrk\xE7e' },
	{ locale: 'uk', label: 'Ukrainian' },
	{ locale: 'vi', label: 'Ti\u1EBFng Vi\u1EC7t' },
	{ locale: 'zh-cn', label: 'Chinese - Simplified' },
	{ locale: 'zh-tw', label: '\u7E41\u9AD4\u4E2D\u6587 (\u53F0\u7063)' },
]

// ../packages/tlschema/src/translations.ts
function getDefaultTranslationLocale() {
	const locales = typeof window !== 'undefined' ? window.navigator.languages ?? ['en'] : ['en']
	return _getDefaultTranslationLocale(locales)
}
function _getDefaultTranslationLocale(locales) {
	for (const locale of locales) {
		const supportedLocale = getSupportedLocale(locale)
		if (supportedLocale) {
			return supportedLocale
		}
	}
	return 'en'
}
var DEFAULT_LOCALE_REGIONS = {
	zh: 'zh-cn',
	pt: 'pt-br',
	ko: 'ko-kr',
	hi: 'hi-in',
}
function getSupportedLocale(locale) {
	const exactMatch = LANGUAGES.find((t4) => t4.locale === locale.toLowerCase())
	if (exactMatch) {
		return exactMatch.locale
	}
	const [language, region] = locale.split(/[-_]/).map((s3) => s3.toLowerCase())
	if (region) {
		const languageMatch = LANGUAGES.find((t4) => t4.locale === language)
		if (languageMatch) {
			return languageMatch.locale
		}
	}
	if (language in DEFAULT_LOCALE_REGIONS) {
		return DEFAULT_LOCALE_REGIONS[language]
	}
	return null
}

// ../packages/tlschema/src/util-types.ts
init_define_process()

// ../packages/editor/src/lib/TldrawEditor.tsx
init_define_process()
var import_react39 = __toESM(require_react())

// ../packages/editor/src/lib/app/App.ts
init_define_process()

// ../packages/primitives/src/index.ts
init_define_process()

// ../packages/primitives/src/lib/Box2d.ts
init_define_process()

// ../packages/primitives/src/lib/Vec2d.ts
init_define_process()

// ../packages/primitives/src/lib/easings.ts
init_define_process()
var EASINGS = {
	linear: (t4) => t4,
	easeInQuad: (t4) => t4 * t4,
	easeOutQuad: (t4) => t4 * (2 - t4),
	easeInOutQuad: (t4) => (t4 < 0.5 ? 2 * t4 * t4 : -1 + (4 - 2 * t4) * t4),
	easeInCubic: (t4) => t4 * t4 * t4,
	easeOutCubic: (t4) => --t4 * t4 * t4 + 1,
	easeInOutCubic: (t4) =>
		t4 < 0.5 ? 4 * t4 * t4 * t4 : (t4 - 1) * (2 * t4 - 2) * (2 * t4 - 2) + 1,
	easeInQuart: (t4) => t4 * t4 * t4 * t4,
	easeOutQuart: (t4) => 1 - --t4 * t4 * t4 * t4,
	easeInOutQuart: (t4) => (t4 < 0.5 ? 8 * t4 * t4 * t4 * t4 : 1 - 8 * --t4 * t4 * t4 * t4),
	easeInQuint: (t4) => t4 * t4 * t4 * t4 * t4,
	easeOutQuint: (t4) => 1 + --t4 * t4 * t4 * t4 * t4,
	easeInOutQuint: (t4) =>
		t4 < 0.5 ? 16 * t4 * t4 * t4 * t4 * t4 : 1 + 16 * --t4 * t4 * t4 * t4 * t4,
	easeInSine: (t4) => 1 - Math.cos((t4 * Math.PI) / 2),
	easeOutSine: (t4) => Math.sin((t4 * Math.PI) / 2),
	easeInOutSine: (t4) => -(Math.cos(Math.PI * t4) - 1) / 2,
	easeInExpo: (t4) => (t4 <= 0 ? 0 : Math.pow(2, 10 * t4 - 10)),
	easeOutExpo: (t4) => (t4 >= 1 ? 1 : 1 - Math.pow(2, -10 * t4)),
	easeInOutExpo: (t4) =>
		t4 <= 0
			? 0
			: t4 >= 1
			? 1
			: t4 < 0.5
			? Math.pow(2, 20 * t4 - 10) / 2
			: (2 - Math.pow(2, -20 * t4 + 10)) / 2,
}

// ../packages/primitives/src/lib/Vec2d.ts
var Vec2d = class {
	constructor(x3 = 0, y3 = 0, z2 = 1) {
		this.x = x3
		this.y = y3
		this.z = z2
	}
	get pressure() {
		return this.z
	}
	set(x3 = this.x, y3 = this.y, z2 = this.z) {
		this.x = x3
		this.y = y3
		this.z = z2
		return this
	}
	setTo({ x: x3 = 0, y: y3 = 0, z: z2 = 1 }) {
		this.x = x3
		this.y = y3
		this.z = z2
		return this
	}
	rot(r3) {
		if (r3 === 0) return this
		const { x: x3, y: y3 } = this
		const s3 = Math.sin(r3)
		const c3 = Math.cos(r3)
		this.x = x3 * c3 - y3 * s3
		this.y = x3 * s3 + y3 * c3
		return this
	}
	rotWith(C2, r3) {
		if (r3 === 0) return this
		const x3 = this.x - C2.x
		const y3 = this.y - C2.y
		const s3 = Math.sin(r3)
		const c3 = Math.cos(r3)
		this.x = C2.x + (x3 * c3 - y3 * s3)
		this.y = C2.y + (x3 * s3 + y3 * c3)
		return this
	}
	clone() {
		const { x: x3, y: y3, z: z2 } = this
		return new Vec2d(x3, y3, z2)
	}
	sub(V2) {
		this.x -= V2.x
		this.y -= V2.y
		return this
	}
	subXY(x3, y3) {
		this.x -= x3
		this.y -= y3
		return this
	}
	subScalar(n3) {
		this.x -= n3
		this.y -= n3
		return this
	}
	add(V2) {
		this.x += V2.x
		this.y += V2.y
		return this
	}
	addXY(x3, y3) {
		this.x += x3
		this.y += y3
		return this
	}
	addScalar(n3) {
		this.x += n3
		this.y += n3
		return this
	}
	clamp(min2, max) {
		this.x = Math.max(this.x, min2)
		this.y = Math.max(this.y, min2)
		if (max !== void 0) {
			this.x = Math.min(this.x, max)
			this.y = Math.min(this.y, max)
		}
		return this
	}
	div(t4) {
		this.x /= t4
		this.y /= t4
		return this
	}
	divV(V2) {
		this.x /= V2.x
		this.y /= V2.y
		return this
	}
	mul(t4) {
		this.x *= t4
		this.y *= t4
		return this
	}
	mulV(V2) {
		this.x *= V2.x
		this.y *= V2.y
		return this
	}
	abs() {
		this.x = Math.abs(this.x)
		this.y = Math.abs(this.y)
		return this
	}
	nudge(B, distance) {
		const tan = Vec2d.Tan(B, this)
		return this.add(tan.mul(distance))
	}
	neg() {
		this.x *= -1
		this.y *= -1
		return this
	}
	cross(V2) {
		this.x = this.y * V2.z - this.z * V2.y
		this.y = this.z * V2.x - this.x * V2.z
		return this
	}
	dpr(V2) {
		return Vec2d.Dpr(this, V2)
	}
	cpr(V2) {
		return Vec2d.Cpr(this, V2)
	}
	len2() {
		return Vec2d.Len2(this)
	}
	len() {
		return Vec2d.Len(this)
	}
	pry(V2) {
		return Vec2d.Pry(this, V2)
	}
	per() {
		const { x: x3, y: y3 } = this
		this.x = y3
		this.y = -x3
		return this
	}
	uni() {
		return Vec2d.Uni(this)
	}
	tan(V2) {
		return Vec2d.Tan(this, V2)
	}
	dist(V2) {
		return Vec2d.Dist(this, V2)
	}
	distanceToLineSegment(A2, B) {
		return Vec2d.DistanceToLineSegment(A2, B, this)
	}
	slope(B) {
		return Vec2d.Slope(this, B)
	}
	snapToGrid(gridSize) {
		this.x = Math.round(this.x / gridSize) * gridSize
		this.y = Math.round(this.y / gridSize) * gridSize
		return this
	}
	angle(B) {
		return Vec2d.Angle(this, B)
	}
	toAngle() {
		return Vec2d.ToAngle(this)
	}
	lrp(B, t4) {
		this.x = this.x + (B.x - this.x) * t4
		this.y = this.y + (B.y - this.y) * t4
		return this
	}
	equals(B) {
		return Vec2d.Equals(this, B)
	}
	equalsXY(x3, y3) {
		return Vec2d.EqualsXY(this, x3, y3)
	}
	norm() {
		const l3 = this.len()
		this.x = l3 === 0 ? 0 : this.x / l3
		this.y = l3 === 0 ? 0 : this.y / l3
		return this
	}
	toFixed() {
		return Vec2d.ToFixed(this)
	}
	toString() {
		return Vec2d.ToString(Vec2d.ToFixed(this))
	}
	toJson() {
		return Vec2d.ToJson(this)
	}
	toArray() {
		return Vec2d.ToArray(this)
	}
	static Add(A2, B) {
		return new Vec2d(A2.x + B.x, A2.y + B.y)
	}
	static AddXY(A2, x3, y3) {
		return new Vec2d(A2.x + x3, A2.y + y3)
	}
	static Sub(A2, B) {
		return new Vec2d(A2.x - B.x, A2.y - B.y)
	}
	static SubXY(A2, x3, y3) {
		return new Vec2d(A2.x - x3, A2.y - y3)
	}
	static AddScalar(A2, n3) {
		return new Vec2d(A2.x + n3, A2.y + n3)
	}
	static SubScalar(A2, n3) {
		return new Vec2d(A2.x - n3, A2.y - n3)
	}
	static Div(A2, t4) {
		return new Vec2d(A2.x / t4, A2.y / t4)
	}
	static Mul(A2, t4) {
		return new Vec2d(A2.x * t4, A2.y * t4)
	}
	static DivV(A2, B) {
		return new Vec2d(A2.x / B.x, A2.y / B.y)
	}
	static MulV(A2, B) {
		return new Vec2d(A2.x * B.x, A2.y * B.y)
	}
	static Neg(A2) {
		return new Vec2d(-A2.x, -A2.y)
	}
	static Per(A2) {
		return new Vec2d(A2.y, -A2.x)
	}
	static Dist2(A2, B) {
		return Vec2d.Sub(A2, B).len2()
	}
	static Abs(A2) {
		return new Vec2d(Math.abs(A2.x), Math.abs(A2.y))
	}
	static Dist(A2, B) {
		return Math.hypot(A2.y - B.y, A2.x - B.x)
	}
	static Dpr(A2, B) {
		return A2.x * B.x + A2.y * B.y
	}
	static Cross(A2, V2) {
		return new Vec2d(
			A2.y * V2.z - A2.z * V2.y,
			A2.z * V2.x - A2.x * V2.z
			// A.z = A.x * V.y - A.y * V.x
		)
	}
	static Cpr(A2, B) {
		return A2.x * B.y - B.x * A2.y
	}
	static Len2(A2) {
		return A2.x * A2.x + A2.y * A2.y
	}
	static Len(A2) {
		return Math.sqrt(Vec2d.Len2(A2))
	}
	static Pry(A2, B) {
		return Vec2d.Dpr(A2, B) / Vec2d.Len(B)
	}
	static Uni(A2) {
		return Vec2d.Div(A2, Vec2d.Len(A2))
	}
	static Tan(A2, B) {
		return Vec2d.Uni(Vec2d.Sub(A2, B))
	}
	static Min(A2, B) {
		return new Vec2d(Math.min(A2.x, B.x), Math.min(A2.y, B.y))
	}
	static Max(A2, B) {
		return new Vec2d(Math.max(A2.x, B.x), Math.max(A2.y, B.y))
	}
	static From({ x: x3, y: y3, z: z2 = 1 }) {
		return new Vec2d(x3, y3, z2)
	}
	static FromArray(v3) {
		return new Vec2d(v3[0], v3[1])
	}
	static Rot(A2, r3 = 0) {
		const s3 = Math.sin(r3)
		const c3 = Math.cos(r3)
		return new Vec2d(A2.x * c3 - A2.y * s3, A2.x * s3 + A2.y * c3)
	}
	static RotWith(A2, C2, r3) {
		const x3 = A2.x - C2.x
		const y3 = A2.y - C2.y
		const s3 = Math.sin(r3)
		const c3 = Math.cos(r3)
		return new Vec2d(C2.x + (x3 * c3 - y3 * s3), C2.y + (x3 * s3 + y3 * c3))
	}
	/**
	 * Get the nearest point on a line with a known unit vector that passes through point A
	 *
	 * ```ts
	 * Vec.nearestPointOnLineThroughPoint(A, u, Point)
	 * ```
	 *
	 * @param A - Any point on the line
	 * @param u - The unit vector for the line.
	 * @param P - A point not on the line to test.
	 */
	static NearestPointOnLineThroughPoint(A2, u3, P2) {
		return Vec2d.Mul(u3, Vec2d.Sub(P2, A2).pry(u3)).add(A2)
	}
	static NearestPointOnLineSegment(A2, B, P2, clamp3 = true) {
		const u3 = Vec2d.Tan(B, A2)
		const C2 = Vec2d.Add(A2, Vec2d.Mul(u3, Vec2d.Sub(P2, A2).pry(u3)))
		if (clamp3) {
			if (C2.x < Math.min(A2.x, B.x)) return Vec2d.Cast(A2.x < B.x ? A2 : B)
			if (C2.x > Math.max(A2.x, B.x)) return Vec2d.Cast(A2.x > B.x ? A2 : B)
			if (C2.y < Math.min(A2.y, B.y)) return Vec2d.Cast(A2.y < B.y ? A2 : B)
			if (C2.y > Math.max(A2.y, B.y)) return Vec2d.Cast(A2.y > B.y ? A2 : B)
		}
		return C2
	}
	static DistanceToLineThroughPoint(A2, u3, P2) {
		return Vec2d.Dist(P2, Vec2d.NearestPointOnLineThroughPoint(A2, u3, P2))
	}
	static DistanceToLineSegment(A2, B, P2, clamp3 = true) {
		return Vec2d.Dist(P2, Vec2d.NearestPointOnLineSegment(A2, B, P2, clamp3))
	}
	static Snap(A2, step = 1) {
		return new Vec2d(Math.round(A2.x / step) * step, Math.round(A2.y / step) * step)
	}
	static Cast(A2) {
		if (A2 instanceof Vec2d) return A2
		return Vec2d.From(A2)
	}
	static Slope(A2, B) {
		if (A2.x === B.y) return NaN
		return (A2.y - B.y) / (A2.x - B.x)
	}
	static Angle(A2, B) {
		return Math.atan2(B.y - A2.y, B.x - A2.x)
	}
	static Lrp(A2, B, t4) {
		return Vec2d.Sub(B, A2).mul(t4).add(A2)
	}
	static Med(A2, B) {
		return new Vec2d((A2.x + B.x) / 2, (A2.y + B.y) / 2)
	}
	static Equals(A2, B) {
		return Math.abs(A2.x - B.x) < 1e-4 && Math.abs(A2.y - B.y) < 1e-4
	}
	static EqualsXY(A2, x3, y3) {
		return A2.x === x3 && A2.y === y3
	}
	static Clockwise(A2, B, C2) {
		return (C2.x - A2.x) * (B.y - A2.y) - (B.x - A2.x) * (C2.y - A2.y) < 0
	}
	static Rescale(A2, n3) {
		const l3 = Vec2d.Len(A2)
		return new Vec2d((n3 * A2.x) / l3, (n3 * A2.y) / l3)
	}
	static ScaleWithOrigin(A2, scale, origin) {
		return Vec2d.Sub(A2, origin).mul(scale).add(origin)
	}
	static ToFixed(A2, n3 = 2) {
		return new Vec2d(+A2.x.toFixed(n3), +A2.y.toFixed(n3), +A2.z.toFixed(n3))
	}
	static Nudge(A2, B, distance) {
		return Vec2d.Add(A2, Vec2d.Tan(B, A2).mul(distance))
	}
	static ToString(A2) {
		return `${A2.x}, ${A2.y}`
	}
	static ToAngle(A2) {
		let r3 = Math.atan2(A2.y, A2.x)
		if (r3 < 0) r3 += Math.PI * 2
		return r3
	}
	static ToArray(A2) {
		return [A2.x, A2.y, A2.z]
	}
	static ToJson(A2) {
		const { x: x3, y: y3, z: z2 } = A2
		return { x: x3, y: y3, z: z2 }
	}
	static Average(arr) {
		const len = arr.length
		const avg = new Vec2d(0, 0)
		for (let i3 = 0; i3 < len; i3++) {
			avg.add(arr[i3])
		}
		return avg.div(len)
	}
	static Clamp(A2, min2, max) {
		if (max === void 0) {
			return new Vec2d(Math.min(Math.max(A2.x, min2)), Math.min(Math.max(A2.y, min2)))
		}
		return new Vec2d(Math.min(Math.max(A2.x, min2), max), Math.min(Math.max(A2.y, min2), max))
	}
	/**
	 * Get an array of points (with simulated pressure) between two points.
	 *
	 * @param A - The first point.
	 * @param B - The second point.
	 * @param steps - The number of points to return.
	 */
	static PointsBetween(A2, B, steps = 6) {
		const results = []
		for (let i3 = 0; i3 < steps; i3++) {
			const t4 = EASINGS.easeInQuad(i3 / (steps - 1))
			const point2 = Vec2d.Lrp(A2, B, t4)
			point2.z = Math.min(1, 0.5 + Math.abs(0.5 - ease(t4)) * 0.65)
			results.push(point2)
		}
		return results
	}
	static SnapToGrid(A2, gridSize = 8) {
		return new Vec2d(Math.round(A2.x / gridSize) * gridSize, Math.round(A2.y / gridSize) * gridSize)
	}
}
var ease = (t4) => (t4 < 0.5 ? 2 * t4 * t4 : -1 + (4 - 2 * t4) * t4)

// ../packages/primitives/src/lib/utils.ts
init_define_process()
var PI = Math.PI
var TAU = PI / 2
var PI2 = PI * 2
var EPSILON = Math.PI / 180
var SIN = Math.sin
function clamp(n3, min2, max) {
	return Math.max(min2, typeof max !== 'undefined' ? Math.min(n3, max) : n3)
}
function toPrecision(n3, precision = 1e10) {
	if (!n3) return 0
	return Math.round(n3 * precision) / precision
}
function approximately(a3, b3, precision = 1e-6) {
	return Math.abs(a3 - b3) <= precision
}
function perimeterOfEllipse(rx, ry) {
	const h3 = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2)
	const p3 = PI * (rx + ry) * (1 + (3 * h3) / (10 + Math.sqrt(4 - 3 * h3)))
	return p3
}
function canolicalizeRotation(a3) {
	a3 = a3 % PI2
	if (a3 < 0) {
		a3 = a3 + PI2
	} else if (a3 === 0) {
		a3 = 0
	}
	return a3
}
function shortAngleDist(a0, a1) {
	const da = (a1 - a0) % PI2
	return ((2 * da) % PI2) - da
}
function longAngleDist(a0, a1) {
	return PI2 - shortAngleDist(a0, a1)
}
function lerpAngles(a0, a1, t4) {
	return a0 + shortAngleDist(a0, a1) * t4
}
function angleDelta(a0, a1) {
	return shortAngleDist(a0, a1)
}
function getSweep(C2, A2, B) {
	return angleDelta(Vec2d.Angle(C2, A2), Vec2d.Angle(C2, B))
}
function clampRadians(r3) {
	return (PI2 + r3) % PI2
}
function snapAngle(r3, segments) {
	const seg = PI2 / segments
	let ang = (Math.floor((clampRadians(r3) + seg / 2) / seg) * seg) % PI2
	if (ang < PI) ang += PI2
	if (ang > PI) ang -= PI2
	return ang
}
function areAnglesCompatible(a3, b3) {
	return a3 === b3 || approximately((a3 % (Math.PI / 2)) - (b3 % (Math.PI / 2)), 0)
}
function degreesToRadians(d3) {
	return (d3 * PI) / 180
}
function radiansToDegrees(r3) {
	return (r3 * 180) / PI
}
function getArcLength(C2, r3, A2, B) {
	const sweep = getSweep(C2, A2, B)
	return r3 * PI2 * (sweep / PI2)
}
function getPointOnCircle(cx, cy, r3, a3) {
	return new Vec2d(cx + r3 * Math.cos(a3), cy + r3 * Math.sin(a3))
}
function getPolygonVertices(width, height, sides) {
	const cx = width / 2
	const cy = height / 2
	const pointsOnPerimeter = []
	for (let i3 = 0; i3 < sides; i3++) {
		const step = PI2 / sides
		const t4 = -TAU + i3 * step
		pointsOnPerimeter.push(new Vec2d(cx + cx * Math.cos(t4), cy + cy * Math.sin(t4)))
	}
	return pointsOnPerimeter
}
function rangesOverlap(a0, a1, b0, b1) {
	return a0 < b1 && b0 < a1
}
function rangeIntersection(a0, a1, b0, b1) {
	const min2 = Math.max(a0, b0)
	const max = Math.min(a1, b1)
	if (min2 <= max) {
		return [min2, max]
	}
	return null
}
var getStarBounds = (sides, w3, h3) => {
	const step = PI2 / sides / 2
	const rightMostIndex = Math.floor(sides / 4) * 2
	const leftMostIndex = sides * 2 - rightMostIndex
	const topMostIndex = 0
	const bottomMostIndex = Math.floor(sides / 2) * 2
	const maxX = (Math.cos(-TAU + rightMostIndex * step) * w3) / 2
	const minX = (Math.cos(-TAU + leftMostIndex * step) * w3) / 2
	const minY = (Math.sin(-TAU + topMostIndex * step) * h3) / 2
	const maxY = (Math.sin(-TAU + bottomMostIndex * step) * h3) / 2
	return new Box2d(0, 0, maxX - minX, maxY - minY)
}
function cross(x3, y3, z2) {
	return (y3.x - x3.x) * (z2.y - x3.y) - (z2.x - x3.x) * (y3.y - x3.y)
}
function pointInPolygon(A2, points2) {
	let windingNumber = 0
	let a3
	let b3
	for (let i3 = 0; i3 < points2.length; i3++) {
		a3 = points2[i3]
		b3 = points2[(i3 + 1) % points2.length]
		if (a3.y <= A2.y) {
			if (b3.y > A2.y && cross(a3, b3, A2) > 0) {
				windingNumber += 1
			}
		} else if (b3.y <= A2.y && cross(a3, b3, A2) < 0) {
			windingNumber -= 1
		}
	}
	return windingNumber !== 0
}
function pointNearToPolyline(A2, points2, distance = 8) {
	const len = points2.length
	for (let i3 = 1; i3 < len; i3++) {
		const p1 = points2[i3 - 1]
		const p22 = points2[i3]
		const d3 = Vec2d.DistanceToLineSegment(p1, p22, A2)
		if (d3 < distance) return true
	}
	return false
}
function toDomPrecision(v3) {
	return +v3.toFixed(4)
}

// ../packages/primitives/src/lib/Box2d.ts
var _Box2d = class {
	constructor(x3 = 0, y3 = 0, w3 = 0, h3 = 0) {
		this.x = x3
		this.y = y3
		this.w = w3
		this.h = h3
	}
	x = 0
	y = 0
	w = 0
	h = 0
	get point() {
		return new Vec2d(this.x, this.y)
	}
	set point(val) {
		this.x = val.x
		this.y = val.y
	}
	get minX() {
		return this.x
	}
	set minX(n3) {
		this.x = n3
	}
	get midX() {
		return this.x + this.w / 2
	}
	get maxX() {
		return this.x + this.w
	}
	get minY() {
		return this.y
	}
	set minY(n3) {
		this.y = n3
	}
	get midY() {
		return this.y + this.h / 2
	}
	get maxY() {
		return this.y + this.h
	}
	get width() {
		return this.w
	}
	set width(n3) {
		this.w = n3
	}
	get height() {
		return this.h
	}
	set height(n3) {
		this.h = n3
	}
	get aspectRatio() {
		return this.width / this.height
	}
	get center() {
		return new Vec2d(this.midX, this.midY)
	}
	set center(v3) {
		this.minX = v3.x - this.width / 2
		this.minY = v3.y - this.height / 2
	}
	get corners() {
		return [
			new Vec2d(this.minX, this.minY),
			new Vec2d(this.maxX, this.minY),
			new Vec2d(this.maxX, this.maxY),
			new Vec2d(this.minX, this.maxY),
		]
	}
	get snapPoints() {
		return [
			new Vec2d(this.minX, this.minY),
			new Vec2d(this.maxX, this.minY),
			new Vec2d(this.maxX, this.maxY),
			new Vec2d(this.minX, this.maxY),
			this.center,
		]
	}
	get sides() {
		const { corners } = this
		return [
			[corners[0], corners[1]],
			[corners[1], corners[2]],
			[corners[2], corners[3]],
			[corners[3], corners[0]],
		]
	}
	get size() {
		return new Vec2d(this.w, this.h)
	}
	toFixed() {
		this.x = toPrecision(this.x)
		this.y = toPrecision(this.y)
		this.w = toPrecision(this.w)
		this.h = toPrecision(this.h)
		return this
	}
	setTo(B) {
		this.x = B.x
		this.y = B.y
		this.w = B.w
		this.h = B.h
		return this
	}
	set(x3 = 0, y3 = 0, w3 = 0, h3 = 0) {
		this.x = x3
		this.y = y3
		this.w = w3
		this.h = h3
		return this
	}
	expand(A2) {
		const minX = Math.min(this.minX, A2.minX)
		const minY = Math.min(this.minY, A2.minY)
		const maxX = Math.max(this.maxX, A2.maxX)
		const maxY = Math.max(this.maxY, A2.maxY)
		this.x = minX
		this.y = minY
		this.w = maxX - minX
		this.h = maxY - minY
		return this
	}
	expandBy(n3) {
		this.x -= n3
		this.y -= n3
		this.w += n3 * 2
		this.h += n3 * 2
		return this
	}
	scale(n3) {
		this.x /= n3
		this.y /= n3
		this.w /= n3
		this.h /= n3
		return this
	}
	clone() {
		const { x: x3, y: y3, w: w3, h: h3 } = this
		return new _Box2d(x3, y3, w3, h3)
	}
	translate(delta) {
		this.x += delta.x
		this.y += delta.y
		return this
	}
	snapToGrid(size) {
		const minX = Math.round(this.minX / size) * size
		const minY = Math.round(this.minY / size) * size
		const maxX = Math.round(this.maxX / size) * size
		const maxY = Math.round(this.maxY / size) * size
		this.minX = minX
		this.minY = minY
		this.width = Math.max(1, maxX - minX)
		this.height = Math.max(1, maxY - minY)
	}
	collides(B) {
		return _Box2d.Collides(this, B)
	}
	contains(B) {
		return _Box2d.Contains(this, B)
	}
	includes(B) {
		return _Box2d.Includes(this, B)
	}
	containsPoint(V2, y3) {
		return _Box2d.ContainsPoint(this, V2, y3)
	}
	getHandlePoint(handle) {
		switch (handle) {
			case 'top_left':
				return new Vec2d(this.minX, this.minY)
			case 'top_right':
				return new Vec2d(this.maxX, this.minY)
			case 'bottom_left':
				return new Vec2d(this.minX, this.maxY)
			case 'bottom_right':
				return new Vec2d(this.maxX, this.maxY)
			case 'top':
				return new Vec2d(this.midX, this.minY)
			case 'right':
				return new Vec2d(this.maxX, this.midY)
			case 'bottom':
				return new Vec2d(this.midX, this.maxY)
			case 'left':
				return new Vec2d(this.minX, this.midY)
		}
	}
	toJson() {
		return { x: this.minX, y: this.minY, w: this.w, h: this.h }
	}
	resize(handle, dx, dy) {
		const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = this
		let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = this
		switch (handle) {
			case 'left':
			case 'top_left':
			case 'bottom_left': {
				b0x += dx
				break
			}
			case 'right':
			case 'top_right':
			case 'bottom_right': {
				b1x += dx
				break
			}
		}
		switch (handle) {
			case 'top':
			case 'top_left':
			case 'top_right': {
				b0y += dy
				break
			}
			case 'bottom':
			case 'bottom_left':
			case 'bottom_right': {
				b1y += dy
				break
			}
		}
		const scaleX = (b1x - b0x) / (a1x - a0x)
		const scaleY = (b1y - b0y) / (a1y - a0y)
		const flipX = scaleX < 0
		const flipY = scaleY < 0
		if (flipX) {
			const t4 = b1x
			b1x = b0x
			b0x = t4
		}
		if (flipY) {
			const t4 = b1y
			b1y = b0y
			b0y = t4
		}
		this.minX = b0x
		this.minY = b0y
		this.width = Math.abs(b1x - b0x)
		this.height = Math.abs(b1y - b0y)
	}
	union(box) {
		const minX = Math.min(this.minX, box.x)
		const minY = Math.min(this.minY, box.y)
		const maxX = Math.max(this.maxX, box.x + box.w)
		const maxY = Math.max(this.maxY, box.y + box.h)
		this.x = minX
		this.y = minY
		this.width = maxX - minX
		this.height = maxY - minY
		return this
	}
	static From(box) {
		return new _Box2d(box.x, box.y, box.w, box.h)
	}
	static FromPoints(points2) {
		if (points2.length === 0) return new _Box2d()
		let minX = Infinity
		let minY = Infinity
		let maxX = -Infinity
		let maxY = -Infinity
		let point2
		for (let i3 = 0, n3 = points2.length; i3 < n3; i3++) {
			point2 = points2[i3]
			minX = Math.min(point2.x, minX)
			minY = Math.min(point2.y, minY)
			maxX = Math.max(point2.x, maxX)
			maxY = Math.max(point2.y, maxY)
		}
		return new _Box2d(minX, minY, maxX - minX, maxY - minY)
	}
	static Expand(A2, B) {
		const minX = Math.min(B.minX, A2.minX)
		const minY = Math.min(B.minY, A2.minY)
		const maxX = Math.max(B.maxX, A2.maxX)
		const maxY = Math.max(B.maxY, A2.maxY)
		return new _Box2d(minX, minY, maxX - minX, maxY - minY)
	}
	static ExpandBy(A2, n3) {
		return new _Box2d(A2.minX - n3, A2.minY - n3, A2.width + n3 * 2, A2.height + n3 * 2)
	}
	static Resize(box, handle, dx, dy, isAspectRatioLocked = false) {
		const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = box
		let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = box
		switch (handle) {
			case 'left':
			case 'top_left':
			case 'bottom_left': {
				b0x += dx
				break
			}
			case 'right':
			case 'top_right':
			case 'bottom_right': {
				b1x += dx
				break
			}
		}
		switch (handle) {
			case 'top':
			case 'top_left':
			case 'top_right': {
				b0y += dy
				break
			}
			case 'bottom':
			case 'bottom_left':
			case 'bottom_right': {
				b1y += dy
				break
			}
		}
		const scaleX = (b1x - b0x) / (a1x - a0x)
		const scaleY = (b1y - b0y) / (a1y - a0y)
		const flipX = scaleX < 0
		const flipY = scaleY < 0
		if (isAspectRatioLocked) {
			const aspectRatio = (a1x - a0x) / (a1y - a0y)
			const bw = Math.abs(b1x - b0x)
			const bh = Math.abs(b1y - b0y)
			const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / aspectRatio)
			const th = bh * (scaleX < 0 ? 1 : -1) * aspectRatio
			const isTall = aspectRatio < bw / bh
			switch (handle) {
				case 'top_left': {
					if (isTall) b0y = b1y + tw
					else b0x = b1x + th
					break
				}
				case 'top_right': {
					if (isTall) b0y = b1y + tw
					else b1x = b0x - th
					break
				}
				case 'bottom_right': {
					if (isTall) b1y = b0y - tw
					else b1x = b0x - th
					break
				}
				case 'bottom_left': {
					if (isTall) b1y = b0y - tw
					else b0x = b1x + th
					break
				}
				case 'bottom':
				case 'top': {
					const m3 = (b0x + b1x) / 2
					const w3 = bh * aspectRatio
					b0x = m3 - w3 / 2
					b1x = m3 + w3 / 2
					break
				}
				case 'left':
				case 'right': {
					const m3 = (b0y + b1y) / 2
					const h3 = bw / aspectRatio
					b0y = m3 - h3 / 2
					b1y = m3 + h3 / 2
					break
				}
			}
		}
		if (flipX) {
			const t4 = b1x
			b1x = b0x
			b0x = t4
		}
		if (flipY) {
			const t4 = b1y
			b1y = b0y
			b0y = t4
		}
		const final = new _Box2d(b0x, b0y, Math.abs(b1x - b0x), Math.abs(b1y - b0y))
		return {
			box: final,
			scaleX: +((final.width / box.width) * (scaleX > 0 ? 1 : -1)).toFixed(5),
			scaleY: +((final.height / box.height) * (scaleY > 0 ? 1 : -1)).toFixed(5),
		}
	}
	equals(other) {
		return _Box2d.Equals(this, other)
	}
	static Equals(a3, b3) {
		return b3.x === a3.x && b3.y === a3.y && b3.w === a3.w && b3.h === a3.h
	}
}
var Box2d = _Box2d
__publicField(Box2d, 'Collides', (A2, B) => {
	return !(A2.maxX < B.minX || A2.minX > B.maxX || A2.maxY < B.minY || A2.minY > B.maxY)
})
__publicField(Box2d, 'Contains', (A2, B) => {
	return A2.minX < B.minX && A2.minY < B.minY && A2.maxY > B.maxY && A2.maxX > B.maxX
})
__publicField(Box2d, 'Includes', (A2, B) => {
	return _Box2d.Collides(A2, B) || _Box2d.Contains(A2, B)
})
__publicField(Box2d, 'ContainsPoint', (A2, B, y3) => {
	if (typeof B === 'number') {
		return !(B < A2.minX || y3 < A2.minY || B > A2.maxX || y3 > A2.maxY)
	}
	return !(B.x < A2.minX || B.y < A2.minY || B.x > A2.maxX || B.y > A2.maxY)
})
__publicField(Box2d, 'Common', (boxes) => {
	let minX = Infinity
	let minY = Infinity
	let maxX = -Infinity
	let maxY = -Infinity
	for (let i3 = 0; i3 < boxes.length; i3++) {
		const B = boxes[i3]
		minX = Math.min(minX, B.minX)
		minY = Math.min(minY, B.minY)
		maxX = Math.max(maxX, B.maxX)
		maxY = Math.max(maxY, B.maxY)
	}
	return new _Box2d(minX, minY, maxX - minX, maxY - minY)
})
__publicField(Box2d, 'Sides', (A2, inset = 0) => {
	const { corners } = A2
	if (inset) {
	}
	return [
		[corners[0], corners[1]],
		[corners[1], corners[2]],
		[corners[2], corners[3]],
		[corners[3], corners[0]],
	]
})
function flipSelectionHandleY(handle) {
	switch (handle) {
		case 'top':
			return 'bottom'
		case 'bottom':
			return 'top'
		case 'top_left':
			return 'bottom_left'
		case 'top_right':
			return 'bottom_right'
		case 'bottom_left':
			return 'top_left'
		case 'bottom_right':
			return 'top_right'
		default:
			return handle
	}
}
function flipSelectionHandleX(handle) {
	switch (handle) {
		case 'left':
			return 'right'
		case 'right':
			return 'left'
		case 'top_left':
			return 'top_right'
		case 'top_right':
			return 'top_left'
		case 'bottom_left':
			return 'bottom_right'
		case 'bottom_right':
			return 'bottom_left'
		default:
			return handle
	}
}
function isSelectionCorner(selection) {
	return (
		selection === 'top_left' ||
		selection === 'top_right' ||
		selection === 'bottom_right' ||
		selection === 'bottom_left'
	)
}

// ../packages/primitives/src/lib/CubicSegment2d.ts
init_define_process()

// ../packages/primitives/src/lib/BaseSegment2d.ts
init_define_process()
var BaseSegment2d = class {
	constructor(values) {
		this._values = values
	}
	/**
	 * The segment's values. Do not modify these directly. Instead, use the `values` setter or
	 * `update` method.
	 *
	 * @internal
	 */
	_values
	/**
	 * A private set of cached values, used for lookups and computations. Changing any of the
	 * segment's values will clear this object.
	 *
	 * @internal
	 */
	_computed = {}
	/**
	 * The values for the curve segment.
	 *
	 * @public
	 */
	get values() {
		return this._values
	}
	set values(values) {
		this._values = values
		this._computed = {}
	}
	/**
	 * The length of the curve segment.
	 *
	 * @public
	 */
	get length() {
		if (this._computed.length !== void 0) {
			return this._computed.length
		}
		const { lut } = this
		let prev = lut[0]
		let result = 0
		for (let i3 = 1; i3 < lut.length; i3++) {
			const curr = lut[i3]
			result += prev.dist(curr)
			prev = curr
		}
		this._computed.length = result
		return result
	}
	/**
	 * The bounding box containing the curve segment.
	 *
	 * @public
	 */
	get bounds() {
		if (this._computed.bounds !== void 0) {
			return this._computed.bounds
		}
		let minX = Infinity
		let minY = Infinity
		let maxX = -Infinity
		let maxY = -Infinity
		const { lut } = this
		for (const pt of lut) {
			minX = Math.min(pt.x, minX)
			minY = Math.min(pt.y, minY)
			maxX = Math.max(pt.x, maxX)
			maxY = Math.max(pt.y, maxY)
		}
		const result = new Box2d(minX, minY, maxX - minX, maxY - minY)
		this._computed.bounds = result
		return result
	}
	/**
	 * A lookup table consisting of values.p points along the segment. Used to compute lengths,
	 * closest points, etc. This should only be _computed once (when first requested) per set of
	 * values.
	 *
	 * @public
	 */
	get lut() {
		if (this._computed.lut) {
			return this._computed.lut
		}
		const { p: p3 } = this.values
		const result = []
		for (let i3 = 0; i3 < p3 + 1; i3++) {
			result.push(this.getPoint(i3 / p3))
		}
		this._computed.lut = result
		return result
	}
	/**
	 * A point half-way along the length of the segment.
	 *
	 * @public
	 */
	get midPoint() {
		if (this._computed.midPoint) {
			return this._computed.midPoint
		}
		const result = this.getPoint(0.5)
		this._computed.midPoint = result
		return result
	}
	/**
	 * An SVG path for the segment.
	 *
	 * @public
	 */
	get path() {
		if (this._computed.path) {
			return this._computed.path
		}
		const result = this.getPath()
		this._computed.path = result
		return result
	}
	/**
	 * Evaluate a point at a length along the curve segment.
	 *
	 * @param length - The length to find the point value.
	 * @public
	 */
	getPointAtLength(length) {
		const t4 = Math.max(0, Math.min(1, length / this.length))
		return this.getPoint(t4)
	}
	/**
	 * Get the normal at distance t along the curve segment.
	 *
	 * @param t - The distance (0-1) to find the normal.
	 * @public
	 */
	getNormal(t4) {
		return this.getPoint(t4 - 25e-4)
			.tan(this.getPoint(t4 + 25e-4))
			.per()
			.uni()
			.toFixed()
	}
	/**
	 * Get the normal at a length along the curve segment.
	 *
	 * @param length - The length to find the normal.
	 * @public
	 */
	getNormalAtLength(length) {
		return this.getNormal(length / this.length)
	}
	/**
	 * Get the closest point on the segment to an arbitrary point.
	 *
	 * @param point - The arbitrary point.
	 * @public
	 */
	getClosestPointTo(point2) {
		const { lut } = this
		let closestT = 0
		let closestPoint = lut[0]
		let closestDistance = lut[0].dist(point2)
		for (let i3 = 1; i3 < lut.length; i3++) {
			const distance = Vec2d.Dist(lut[i3], point2)
			if (distance < closestDistance) {
				closestDistance = distance
				closestPoint = lut[i3]
				closestT = i3 / lut.length
			}
		}
		const step = 1 / this.values.p
		for (
			let t4 = Math.max(0, closestT - step / 2);
			t4 < Math.min(1, closestT + step / 2);
			t4 += step / 10
		) {
			const pt = this.getPoint(t4)
			const distance = Vec2d.Dist(pt, point2)
			if (distance < closestDistance) {
				closestDistance = distance
				closestPoint = pt
			}
		}
		return { point: closestPoint, distance: closestDistance }
	}
	/**
	 * Set one or more values. Updating the segment will clear cached values.
	 *
	 * @param values - A partial of the segment's values object.
	 * @public
	 */
	update(values) {
		this._computed = {}
		this.values = { ...this.values, ...values }
	}
}

// ../packages/primitives/src/lib/CubicSegment2d.ts
var CubicSegment2d = class extends BaseSegment2d {
	constructor(a3, b3, c3, d3, p3 = 25) {
		super({ a: a3, b: b3, c: c3, d: d3, p: p3 })
	}
	[Symbol.iterator] = function* () {
		const { a: a3, b: b3, c: c3, d: d3 } = this.values
		yield* [a3, b3, c3, d3]
	}
	getPath(head = true) {
		const { a: a3, b: b3, c: c3, d: d3 } = this.values
		if (Vec2d.Equals(a3, d3)) return ''
		return `${head ? `M${a3.x.toFixed(2)},${a3.y.toFixed(2)}C` : ``}${b3.x.toFixed(
			2
		)},${b3.y.toFixed(2)} ${c3.x.toFixed(2)},${c3.y.toFixed(2)} ${d3.x.toFixed(2)},${d3.y.toFixed(
			2
		)}`
	}
	getPoint(t4) {
		const { a: a3, b: b3, c: c3, d: d3 } = this.values
		return new Vec2d(
			(1 - t4) * (1 - t4) * (1 - t4) * a3.x +
				3 * ((1 - t4) * (1 - t4)) * t4 * b3.x +
				3 * (1 - t4) * (t4 * t4) * c3.x +
				t4 * t4 * t4 * d3.x,
			(1 - t4) * (1 - t4) * (1 - t4) * a3.y +
				3 * ((1 - t4) * (1 - t4)) * t4 * b3.y +
				3 * (1 - t4) * (t4 * t4) * c3.y +
				t4 * t4 * t4 * d3.y
		)
	}
	getX(t4) {
		const { a: a3, b: b3, c: c3, d: d3 } = this.values
		return (
			(1 - t4) * (1 - t4) * (1 - t4) * a3.x +
			3 * ((1 - t4) * (1 - t4)) * t4 * b3.x +
			3 * (1 - t4) * (t4 * t4) * c3.x +
			t4 * t4 * t4 * d3.x
		)
	}
	getY(t4) {
		const { a: a3, b: b3, c: c3, d: d3 } = this.values
		return (
			(1 - t4) * (1 - t4) * (1 - t4) * a3.y +
			3 * ((1 - t4) * (1 - t4)) * t4 * b3.y +
			3 * (1 - t4) * (t4 * t4) * c3.y +
			t4 * t4 * t4 * d3.y
		)
	}
}

// ../packages/primitives/src/lib/CubicSpline2d.ts
init_define_process()

// ../packages/primitives/src/lib/BaseSpline2d.ts
init_define_process()
var BaseSpline2d = class {
	constructor(points2, p3 = 50, k2 = 1) {
		this.points = points2
		this.p = p3
		this.k = k2
	}
	computed = {}
	get length() {
		if (this.computed.length !== void 0) {
			return this.computed.length
		}
		const { segments } = this
		const result = segments.reduce((acc, curr) => acc + curr.length, 0)
		this.computed.length = result
		return result
	}
	get bounds() {
		if (this.computed.bounds !== void 0) {
			return this.computed.bounds
		}
		const { segments } = this
		const result = Box2d.Common(segments.map((segment) => segment.bounds))
		this.computed.bounds = result
		return result
	}
	get head() {
		const { points: points2 } = this
		return points2[0]
	}
	get tail() {
		const { points: points2 } = this
		return points2[points2.length - 1]
	}
	get path() {
		if (this.computed.path !== void 0) {
			return this.computed.path
		}
		const result = this.segments
			.map((segment) => segment.path)
			.filter((i3) => i3 !== void 0 && i3 !== null && i3 !== '')
			.join(' ')
		this.computed.path = result
		return result
	}
	addPoint(point2) {
		const { points: points2, k: k2, p: p3 } = this
		points2.push(point2)
		this.computed = {}
		this.getSegmentsFromPoints(this.points, p3, k2)
		return this
	}
	removePoint(point2) {
		const { points: points2, k: k2, p: p3 } = this
		const index2 = typeof point2 === 'number' ? Math.floor(point2) : points2.indexOf(point2)
		if (index2 === -1) return this
		points2.splice(index2, 1)
		this.computed = {}
		this.getSegmentsFromPoints(this.points, p3, k2)
		return this
	}
	getPointAtLength(length) {
		const { segments } = this
		let remaining = length
		if (length <= 0) return segments[0].getPoint(0)
		if (length >= this.length) return segments[segments.length - 1].getPoint(1)
		for (let i3 = 0; i3 < segments.length; i3++) {
			const segment = segments[i3]
			const { length: segmentLength } = segment
			if (remaining < segmentLength) {
				return segment.getPoint(remaining / segmentLength)
			}
			remaining -= segment.length
		}
		return segments[segments.length - 1].getPoint(1)
	}
	getPoint(t4) {
		if (t4 <= 0) return this.segments[0].getPoint(0)
		if (t4 >= 1) return this.segments[this.segments.length - 1].getPoint(1)
		return this.getPointAtLength(t4 * this.length)
	}
	getNormal(t4) {
		const { length } = this
		return this.getNormalAtLength(t4 * length)
	}
	getNormalAtLength(t4) {
		const { segments } = this
		if (t4 < 0) return new Vec2d(0, 0)
		let remaining = t4
		for (const segment of segments) {
			const segmentLength = segment.length
			if (remaining <= segmentLength) {
				return segment.getNormal(remaining / segmentLength)
			}
			remaining -= segmentLength
		}
		return new Vec2d(0, 0)
	}
	getClosestPointTo(point2) {
		const { head, segments } = this
		let closestPoint = head
		let closestDistance = Vec2d.Dist(point2, head)
		for (const segment of segments) {
			const p3 = segment.getClosestPointTo(point2)
			if (p3.distance < closestDistance) {
				closestDistance = p3.distance
				closestPoint = p3.point
			}
		}
		return { point: closestPoint, distance: closestDistance }
	}
}

// ../packages/primitives/src/lib/CubicSpline2d.ts
var CubicSpline2d = class extends BaseSpline2d {
	constructor(points2, k2 = 1.2, p3 = 20) {
		super(points2, k2, p3)
		this.segments = this.getSegmentsFromPoints(points2, k2, p3)
	}
	segments
	getSegmentsFromPoints(points2, k2 = 1.25, p3 = 20) {
		const len = points2.length
		const last2 = len - 2
		const results = []
		for (let i3 = 0; i3 < len - 1; i3++) {
			const p0 = i3 === 0 ? points2[0] : points2[i3 - 1]
			const p1 = points2[i3]
			const p22 = points2[i3 + 1]
			const p32 = i3 === last2 ? p22 : points2[i3 + 2]
			results.push(
				new CubicSegment2d(
					p1,
					i3 === 0
						? p0
						: new Vec2d(p1.x + ((p22.x - p0.x) / 6) * k2, p1.y + ((p22.y - p0.y) / 6) * k2),
					i3 === last2
						? p22
						: new Vec2d(p22.x - ((p32.x - p1.x) / 6) * k2, p22.y - ((p32.y - p1.y) / 6) * k2),
					p22,
					p3
				)
			)
		}
		return results
	}
	static FromPoints(points2) {
		return new CubicSpline2d(points2)
	}
}

// ../packages/primitives/src/lib/LineSegment2d.ts
init_define_process()
var LineSegment2d = class extends BaseSegment2d {
	constructor(a3, b3, p3 = 2) {
		super({ a: a3, b: b3, p: p3 })
		this.a = a3
		this.b = b3
		this.values.p = Math.max(10, Math.ceil(this.length / 20))
	}
	get length() {
		return Vec2d.Dist(this.a, this.b)
	}
	get tangent() {
		return Vec2d.Tan(this.a, this.b)
	}
	get angle() {
		return Vec2d.Angle(this.a, this.b)
	}
	get bounds() {
		return Box2d.FromPoints([this.a, this.b])
	}
	getX(t4) {
		const { a: a3, b: b3 } = this.values
		return a3.x + (b3.x - a3.x) * t4
	}
	getY(t4) {
		const { a: a3, b: b3 } = this.values
		return a3.y + (b3.y - a3.y) * t4
	}
	getPoint(t4) {
		const { a: a3, b: b3 } = this.values
		return Vec2d.Lrp(a3, b3, t4)
	}
	getPath(head = true) {
		const { a: a3, b: b3 } = this.values
		if (Vec2d.Equals(a3, b3)) return ''
		return head ? `M${a3.x},${a3.y}L${b3.x},${b3.y}` : `${b3.x},${b3.y}`
	}
	getNormal() {
		const { a: a3, b: b3 } = this.values
		return Vec2d.Sub(a3, b3).per().uni().toFixed()
	}
	/**
	 * Get the closest point on the segment to an arbitrary point.
	 *
	 * @param point - The arbitrary point.
	 * @public
	 */
	getClosestPointTo(point2) {
		const { a: a3, b: b3 } = this.values
		const closestPoint = Vec2d.NearestPointOnLineSegment(a3, b3, point2)
		const closestDistance = closestPoint.dist(point2)
		return { point: closestPoint, distance: closestDistance }
	}
	static Length(A2) {
		return Vec2d.Dist(A2.a, A2.b)
	}
	static Tangent(A2) {
		return Vec2d.Tan(A2.a, A2.b)
	}
	static Angle(A2) {
		return Vec2d.Angle(A2.a, A2.b)
	}
}

// ../packages/primitives/src/lib/Matrix2d.ts
init_define_process()
var _Matrix2d = class {
	constructor(a3, b3, c3, d3, e2, f3) {
		this.a = a3
		this.b = b3
		this.c = c3
		this.d = d3
		this.e = e2
		this.f = f3
	}
	a = 1
	b = 0
	c = 0
	d = 1
	e = 0
	f = 0
	equals(m3) {
		return (
			this.a === m3.a &&
			this.b === m3.b &&
			this.c === m3.c &&
			this.d === m3.d &&
			this.e === m3.e &&
			this.f === m3.f
		)
	}
	identity() {
		this.a = 1
		this.b = 0
		this.c = 0
		this.d = 1
		this.e = 0
		this.f = 0
		return this
	}
	multiply(m3) {
		const m22 = m3
		const { a: a3, b: b3, c: c3, d: d3, e: e2, f: f3 } = this
		this.a = a3 * m22.a + c3 * m22.b
		this.c = a3 * m22.c + c3 * m22.d
		this.e = a3 * m22.e + c3 * m22.f + e2
		this.b = b3 * m22.a + d3 * m22.b
		this.d = b3 * m22.c + d3 * m22.d
		this.f = b3 * m22.e + d3 * m22.f + f3
		return this
	}
	rotate(r3, cx, cy) {
		if (r3 === 0) return this
		if (cx === void 0) return this.multiply(_Matrix2d.Rotate(r3))
		return this.translate(cx, cy).multiply(_Matrix2d.Rotate(r3)).translate(-cx, -cy)
	}
	translate(x3, y3) {
		return this.multiply(_Matrix2d.Translate(x3, y3))
	}
	scale(x3, y3) {
		return this.multiply(_Matrix2d.Scale(x3, y3))
	}
	invert() {
		const { a: a3, b: b3, c: c3, d: d3, e: e2, f: f3 } = this
		const denom = a3 * d3 - b3 * c3
		this.a = d3 / denom
		this.b = b3 / -denom
		this.c = c3 / -denom
		this.d = a3 / denom
		this.e = (d3 * e2 - c3 * f3) / -denom
		this.f = (b3 * e2 - a3 * f3) / denom
		return this
	}
	applyToPoint(point2) {
		return _Matrix2d.applyToPoint(this, point2)
	}
	applyToPoints(points2) {
		return _Matrix2d.applyToPoints(this, points2)
	}
	decomposed() {
		return _Matrix2d.Decompose(this)
	}
	toCssString() {
		return _Matrix2d.toCssString(this)
	}
	setTo(model2) {
		Object.assign(this, model2)
		return this
	}
	decompose() {
		return _Matrix2d.Decompose(this)
	}
	clone() {
		return new _Matrix2d(this.a, this.b, this.c, this.d, this.e, this.f)
	}
	/* --------------------- Static --------------------- */
	static Identity() {
		return new _Matrix2d(1, 0, 0, 1, 0, 0)
	}
	static Translate(x3, y3) {
		return new _Matrix2d(1, 0, 0, 1, x3, y3)
	}
	static Rotate(r3, cx, cy) {
		if (r3 === 0) return _Matrix2d.Identity()
		const cosAngle = Math.cos(r3)
		const sinAngle = Math.sin(r3)
		const rotationMatrix2d = new _Matrix2d(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0)
		if (cx === void 0) return rotationMatrix2d
		return _Matrix2d.Compose(
			_Matrix2d.Translate(cx, cy),
			rotationMatrix2d,
			_Matrix2d.Translate(-cx, -cy)
		)
	}
	static Multiply(m1, m22) {
		return {
			a: m1.a * m22.a + m1.c * m22.b,
			c: m1.a * m22.c + m1.c * m22.d,
			e: m1.a * m22.e + m1.c * m22.f + m1.e,
			b: m1.b * m22.a + m1.d * m22.b,
			d: m1.b * m22.c + m1.d * m22.d,
			f: m1.b * m22.e + m1.d * m22.f + m1.f,
		}
	}
	static Inverse(m3) {
		const denom = m3.a * m3.d - m3.b * m3.c
		return {
			a: m3.d / denom,
			b: m3.b / -denom,
			c: m3.c / -denom,
			d: m3.a / denom,
			e: (m3.d * m3.e - m3.c * m3.f) / -denom,
			f: (m3.b * m3.e - m3.a * m3.f) / denom,
		}
	}
	static Absolute(m3) {
		const denom = m3.a * m3.d - m3.b * m3.c
		return {
			a: m3.d / denom,
			b: m3.b / -denom,
			c: m3.c / -denom,
			d: m3.a / denom,
			e: (m3.d * m3.e - m3.c * m3.f) / denom,
			f: (m3.b * m3.e - m3.a * m3.f) / -denom,
		}
	}
	static Compose(...matrices) {
		const matrix = _Matrix2d.Identity()
		for (let i3 = 0, n3 = matrices.length; i3 < n3; i3++) {
			matrix.multiply(matrices[i3])
		}
		return matrix
	}
	static Decompose(m3) {
		let scaleX, scaleY, rotation
		if (m3.a !== 0 || m3.c !== 0) {
			const hypotAc = Math.hypot(m3.a, m3.c)
			scaleX = hypotAc
			scaleY = (m3.a * m3.d - m3.b * m3.c) / hypotAc
			rotation = Math.acos(m3.a / hypotAc) * (m3.c > 0 ? -1 : 1)
		} else if (m3.b !== 0 || m3.d !== 0) {
			const hypotBd = Math.hypot(m3.b, m3.d)
			scaleX = (m3.a * m3.d - m3.b * m3.c) / hypotBd
			scaleY = hypotBd
			rotation = TAU + Math.acos(m3.b / hypotBd) * (m3.d > 0 ? -1 : 1)
		} else {
			scaleX = 0
			scaleY = 0
			rotation = 0
		}
		return {
			x: m3.e,
			y: m3.f,
			scaleX,
			scaleY,
			rotation: clampRadians(rotation),
		}
	}
	static Smooth(m3, precision = 1e10) {
		m3.a = Math.round(m3.a * precision) / precision
		m3.b = Math.round(m3.b * precision) / precision
		m3.c = Math.round(m3.c * precision) / precision
		m3.d = Math.round(m3.d * precision) / precision
		m3.e = Math.round(m3.e * precision) / precision
		m3.f = Math.round(m3.f * precision) / precision
		return m3
	}
	static toCssString(m3) {
		return `matrix(${toDomPrecision(m3.a)}, ${toDomPrecision(m3.b)}, ${toDomPrecision(
			m3.c
		)}, ${toDomPrecision(m3.d)}, ${toDomPrecision(m3.e)}, ${toDomPrecision(m3.f)})`
	}
	static applyToPoint(m3, point2) {
		return new Vec2d(
			m3.a * point2.x + m3.c * point2.y + m3.e,
			m3.b * point2.x + m3.d * point2.y + m3.f,
			point2.z
		)
	}
	static applyToXY(m3, x3, y3) {
		return [m3.a * x3 + m3.c * y3 + m3.e, m3.b * x3 + m3.d * y3 + m3.f]
	}
	static applyToPoints(m3, points2) {
		return points2.map(
			(point2) =>
				new Vec2d(
					m3.a * point2.x + m3.c * point2.y + m3.e,
					m3.b * point2.x + m3.d * point2.y + m3.f,
					point2.z
				)
		)
	}
	static applyToBounds(m3, box) {
		return new Box2d(m3.e + box.minX, m3.f + box.minY, box.width, box.height)
	}
	static From(m3) {
		return new _Matrix2d(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f)
	}
}
var Matrix2d = _Matrix2d
__publicField(Matrix2d, 'Scale', (x3, y3, cx, cy) => {
	const scaleMatrix2d = new _Matrix2d(x3, 0, 0, 0, y3, 0)
	if (cx === void 0) return scaleMatrix2d
	return _Matrix2d.Compose(
		_Matrix2d.Translate(cx, cy),
		scaleMatrix2d,
		_Matrix2d.Translate(-cx, -cy)
	)
})

// ../packages/primitives/src/lib/Polyline2d.ts
init_define_process()
var Polyline2d = class extends BaseSpline2d {
	constructor(points2, k2 = 1.2, p3 = 20) {
		super(points2, k2, p3)
		this.segments = this.getSegmentsFromPoints(points2, p3)
	}
	segments
	getSegmentsFromPoints(points2, p3 = 50) {
		const segments = []
		for (let i3 = 0; i3 < points2.length - 1; i3++) {
			segments.push(new LineSegment2d(points2[i3], points2[i3 + 1], p3))
		}
		return segments
	}
	static FromPoints(points2) {
		return new Polyline2d(points2)
	}
}

// ../packages/primitives/src/lib/freehand/getStroke.ts
init_define_process()

// ../packages/primitives/src/lib/freehand/getStrokeOutlinePoints.ts
init_define_process()
var { PI: PI3 } = Math
var FIXED_PI = PI3 + 1e-4
function getStrokeOutlinePoints(strokePoints, options = {}) {
	const { size = 16, smoothing = 0.5, start = {}, end = {}, last: isComplete = false } = options
	const { cap: capStart = true } = start
	const { cap: capEnd = true } = end
	if (strokePoints.length === 0 || size <= 0) {
		return []
	}
	const firstStrokePoint = strokePoints[0]
	const lastStrokePoint = strokePoints[strokePoints.length - 1]
	const totalLength = lastStrokePoint.runningLength
	const taperStart =
		start.taper === false ? 0 : start.taper === true ? Math.max(size, totalLength) : start.taper
	const taperEnd =
		end.taper === false ? 0 : end.taper === true ? Math.max(size, totalLength) : end.taper
	const minDistance = Math.pow(size * smoothing, 2)
	const leftPts = []
	const rightPts = []
	let prevVector = strokePoints[0].vector
	let pl = strokePoints[0].point
	let pr = pl
	let tl = pl
	let tr = pr
	let isPrevPointSharpCorner = false
	let strokePoint
	for (let i3 = 0; i3 < strokePoints.length; i3++) {
		strokePoint = strokePoints[i3]
		const { point: point2, vector } = strokePoints[i3]
		const prevDpr = strokePoint.vector.dpr(prevVector)
		const nextVector = (i3 < strokePoints.length - 1 ? strokePoints[i3 + 1] : strokePoints[i3])
			.vector
		const nextDpr = i3 < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1
		const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner
		const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2
		if (isPointSharpCorner || isNextPointSharpCorner) {
			if (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {
				const offset2 = prevVector.clone().mul(strokePoint.radius)
				const cpr = prevVector.clone().cpr(nextVector)
				if (cpr < 0) {
					tl = Vec2d.Add(point2, offset2)
					tr = Vec2d.Sub(point2, offset2)
				} else {
					tl = Vec2d.Sub(point2, offset2)
					tr = Vec2d.Add(point2, offset2)
				}
				leftPts.push(tl)
				rightPts.push(tr)
			} else {
				const offset2 = prevVector.clone().mul(strokePoint.radius).per()
				const start2 = Vec2d.Sub(strokePoint.input, offset2)
				for (let step = 1 / 13, t4 = 0; t4 < 1; t4 += step) {
					tl = Vec2d.RotWith(start2, strokePoint.input, FIXED_PI * t4)
					leftPts.push(tl)
					tr = Vec2d.RotWith(start2, strokePoint.input, FIXED_PI + FIXED_PI * -t4)
					rightPts.push(tr)
				}
			}
			pl = tl
			pr = tr
			if (isNextPointSharpCorner) {
				isPrevPointSharpCorner = true
			}
			continue
		}
		isPrevPointSharpCorner = false
		if (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {
			const offset2 = Vec2d.Per(vector).mul(strokePoint.radius)
			leftPts.push(Vec2d.Sub(point2, offset2))
			rightPts.push(Vec2d.Add(point2, offset2))
			continue
		}
		const offset = Vec2d.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius)
		tl = Vec2d.Sub(point2, offset)
		if (i3 <= 1 || Vec2d.Dist2(pl, tl) > minDistance) {
			leftPts.push(tl)
			pl = tl
		}
		tr = Vec2d.Add(point2, offset)
		if (i3 <= 1 || Vec2d.Dist2(pr, tr) > minDistance) {
			rightPts.push(tr)
			pr = tr
		}
		prevVector = vector
		continue
	}
	const firstPoint = firstStrokePoint.point
	const lastPoint =
		strokePoints.length > 1
			? strokePoints[strokePoints.length - 1].point
			: Vec2d.AddXY(firstStrokePoint.point, 1, 1)
	if (strokePoints.length === 1) {
		if (!(taperStart || taperEnd) || isComplete) {
			const start2 = Vec2d.Add(
				firstPoint,
				Vec2d.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)
			)
			const dotPts = []
			for (let step = 1 / 13, t4 = step; t4 <= 1; t4 += step) {
				dotPts.push(Vec2d.RotWith(start2, firstPoint, FIXED_PI * 2 * t4))
			}
			return dotPts
		}
	}
	const startCap = []
	if (taperStart || (taperEnd && strokePoints.length === 1)) {
	} else if (capStart) {
		for (let step = 1 / 8, t4 = step; t4 <= 1; t4 += step) {
			const pt = Vec2d.RotWith(rightPts[0], firstPoint, FIXED_PI * t4)
			startCap.push(pt)
		}
	} else {
		const cornersVector = Vec2d.Sub(leftPts[0], rightPts[0])
		const offsetA = Vec2d.Mul(cornersVector, 0.5)
		const offsetB = Vec2d.Mul(cornersVector, 0.51)
		startCap.push(
			Vec2d.Sub(firstPoint, offsetA),
			Vec2d.Sub(firstPoint, offsetB),
			Vec2d.Add(firstPoint, offsetB),
			Vec2d.Add(firstPoint, offsetA)
		)
	}
	const endCap = []
	const direction = lastStrokePoint.vector.clone().per().neg()
	if (taperEnd || (taperStart && strokePoints.length === 1)) {
		endCap.push(lastPoint)
	} else if (capEnd) {
		const start2 = Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius))
		for (let step = 1 / 29, t4 = step; t4 < 1; t4 += step) {
			endCap.push(Vec2d.RotWith(start2, lastPoint, FIXED_PI * 3 * t4))
		}
	} else {
		endCap.push(
			Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius)),
			Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius * 0.99)),
			Vec2d.Sub(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius * 0.99)),
			Vec2d.Sub(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius))
		)
	}
	return leftPts.concat(endCap, rightPts.reverse(), startCap)
}

// ../packages/primitives/src/lib/freehand/getStrokePoints.ts
init_define_process()
var MIN_START_PRESSURE = 0.025
var MIN_END_PRESSURE = 0.01
function getStrokePoints(rawInputPoints, options = {}) {
	const { streamline = 0.5, size = 16, simulatePressure = false } = options
	if (rawInputPoints.length === 0) return []
	const t4 = 0.15 + (1 - streamline) * 0.85
	let pts = rawInputPoints.map(Vec2d.From)
	let pointsRemovedFromNearEnd = 0
	if (!simulatePressure) {
		let pt2 = pts[0]
		while (pt2) {
			if (pt2.z >= MIN_START_PRESSURE) break
			pts.shift()
			pt2 = pts[0]
		}
	}
	if (!simulatePressure) {
		let pt2 = pts[pts.length - 1]
		while (pt2) {
			if (pt2.z >= MIN_END_PRESSURE) break
			pts.pop()
			pt2 = pts[pts.length - 1]
		}
	}
	if (pts.length === 0)
		return [
			{
				point: Vec2d.From(rawInputPoints[0]),
				input: Vec2d.From(rawInputPoints[0]),
				pressure: simulatePressure ? 0.5 : 0.15,
				vector: new Vec2d(1, 1),
				distance: 0,
				runningLength: 0,
				radius: 1,
			},
		]
	let pt = pts[1]
	while (pt) {
		if (Vec2d.Dist(pt, pts[0]) > size / 3) break
		pts[0].z = Math.max(pts[0].z, pt.z)
		pts.splice(1, 1)
		pt = pts[1]
	}
	const last2 = pts.pop()
	pt = pts[pts.length - 1]
	while (pt) {
		if (Vec2d.Dist(pt, last2) > size / 3) break
		pts.pop()
		pt = pts[pts.length - 1]
		pointsRemovedFromNearEnd++
	}
	pts.push(last2)
	const isComplete =
		options.last ||
		!options.simulatePressure ||
		(pts.length > 1 && Vec2d.Dist(pts[pts.length - 1], pts[pts.length - 2]) < size) ||
		pointsRemovedFromNearEnd > 0
	if (pts.length === 2 && options.simulatePressure) {
		const last3 = pts[1]
		pts = pts.slice(0, -1)
		for (let i3 = 1; i3 < 5; i3++) {
			const next = Vec2d.Lrp(pts[0], last3, i3 / 4)
			next.z = ((pts[0].z + (last3.z - pts[0].z)) * i3) / 4
			pts.push(next)
		}
	}
	const strokePoints = [
		{
			point: pts[0],
			input: pts[0],
			pressure: simulatePressure ? 0.5 : pts[0].z,
			vector: new Vec2d(1, 1),
			distance: 0,
			runningLength: 0,
			radius: 1,
		},
	]
	let totalLength = 0
	let prev = strokePoints[0]
	let point2, distance
	if (isComplete && streamline > 0) {
		pts.push(pts[pts.length - 1].clone())
	}
	for (let i3 = 1, n3 = pts.length; i3 < n3; i3++) {
		point2 =
			!t4 || (options.last && i3 === n3 - 1)
				? pts[i3].clone()
				: pts[i3].clone().lrp(prev.point, 1 - t4)
		if (prev.point.equals(point2)) continue
		distance = Vec2d.Dist(point2, prev.point)
		totalLength += distance
		if (i3 < 4 && totalLength < size) {
			continue
		}
		prev = {
			input: pts[i3],
			// The adjusted point
			point: point2,
			// The input pressure (or .5 if not specified)
			pressure: simulatePressure ? 0.5 : pts[i3].z,
			// The vector from the current point to the previous point
			vector: Vec2d.Sub(prev.point, point2).uni(),
			// The distance between the current point and the previous point
			distance,
			// The total distance so far
			runningLength: totalLength,
			// The stroke point's radius
			radius: 1,
		}
		strokePoints.push(prev)
	}
	if (strokePoints[1]?.vector) {
		strokePoints[0].vector = strokePoints[1].vector.clone()
	}
	if (totalLength < 1) {
		const maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s3) => s3.pressure))
		strokePoints.forEach((s3) => (s3.pressure = maxPressureAmongPoints))
	}
	return strokePoints
}

// ../packages/primitives/src/lib/freehand/setStrokePointRadii.ts
init_define_process()
var { min } = Math
var RATE_OF_PRESSURE_CHANGE = 0.275
function setStrokePointRadii(strokePoints, options) {
	const {
		size = 16,
		thinning = 0.5,
		simulatePressure = true,
		easing = (t4) => t4,
		start = {},
		end = {},
	} = options
	const { easing: taperStartEase = EASINGS.easeOutQuad } = start
	const { easing: taperEndEase = EASINGS.easeOutCubic } = end
	const totalLength = strokePoints[strokePoints.length - 1].runningLength
	let firstRadius
	let prevPressure = strokePoints[0].pressure
	let strokePoint
	if (!simulatePressure && totalLength < size) {
		const max = strokePoints.reduce((max2, curr) => Math.max(max2, curr.pressure), 0.5)
		strokePoints.forEach((sp) => {
			sp.pressure = max
			sp.radius = size * easing(0.5 - thinning * (0.5 - sp.pressure))
		})
		return strokePoints
	} else {
		let p3
		for (let i3 = 0, n3 = strokePoints.length; i3 < n3; i3++) {
			strokePoint = strokePoints[i3]
			if (strokePoint.runningLength > size * 5) break
			const sp = min(1, strokePoint.distance / size)
			if (simulatePressure) {
				const rp = min(1, 1 - sp)
				p3 = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE))
			} else {
				p3 = min(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5)
			}
			prevPressure = prevPressure + (p3 - prevPressure) * 0.5
		}
		for (let i3 = 0; i3 < strokePoints.length; i3++) {
			strokePoint = strokePoints[i3]
			if (thinning) {
				let { pressure } = strokePoint
				const sp = min(1, strokePoint.distance / size)
				if (simulatePressure) {
					const rp = min(1, 1 - sp)
					pressure = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE))
				} else {
					pressure = min(
						1,
						prevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)
					)
				}
				strokePoint.radius = size * easing(0.5 - thinning * (0.5 - pressure))
				prevPressure = pressure
			} else {
				strokePoint.radius = size / 2
			}
			if (firstRadius === void 0) {
				firstRadius = strokePoint.radius
			}
		}
	}
	const taperStart =
		start.taper === false ? 0 : start.taper === true ? Math.max(size, totalLength) : start.taper
	const taperEnd =
		end.taper === false ? 0 : end.taper === true ? Math.max(size, totalLength) : end.taper
	if (taperStart || taperEnd) {
		for (let i3 = 0; i3 < strokePoints.length; i3++) {
			strokePoint = strokePoints[i3]
			const { runningLength } = strokePoint
			const ts = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1
			const te =
				totalLength - runningLength < taperEnd
					? taperEndEase((totalLength - runningLength) / taperEnd)
					: 1
			strokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts, te))
		}
	}
	return strokePoints
}

// ../packages/primitives/src/lib/freehand/getStroke.ts
function getStroke(points2, options = {}) {
	return getStrokeOutlinePoints(
		setStrokePointRadii(getStrokePoints(points2, options), options),
		options
	)
}

// ../packages/primitives/src/lib/freehand/types.ts
init_define_process()

// ../packages/primitives/src/lib/intersect.ts
init_define_process()
function intersectLineSegmentLineSegment(a1, a22, b1, b22) {
	const ABx = a1.x - b1.x
	const ABy = a1.y - b1.y
	const BVx = b22.x - b1.x
	const BVy = b22.y - b1.y
	const AVx = a22.x - a1.x
	const AVy = a22.y - a1.y
	const ua_t = BVx * ABy - BVy * ABx
	const ub_t = AVx * ABy - AVy * ABx
	const u_b = BVy * AVx - BVx * AVy
	if (ua_t === 0 || ub_t === 0) return null
	if (u_b === 0) return null
	if (u_b !== 0) {
		const ua = ua_t / u_b
		const ub = ub_t / u_b
		if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
			return Vec2d.AddXY(a1, ua * AVx, ua * AVy)
		}
	}
	return null
}
function intersectLineSegmentCircle(a1, a22, c3, r3) {
	const a3 = (a22.x - a1.x) * (a22.x - a1.x) + (a22.y - a1.y) * (a22.y - a1.y)
	const b3 = 2 * ((a22.x - a1.x) * (a1.x - c3.x) + (a22.y - a1.y) * (a1.y - c3.y))
	const cc =
		c3.x * c3.x +
		c3.y * c3.y +
		a1.x * a1.x +
		a1.y * a1.y -
		2 * (c3.x * a1.x + c3.y * a1.y) -
		r3 * r3
	const deter = b3 * b3 - 4 * a3 * cc
	if (deter < 0) return null
	if (deter === 0) return null
	const e2 = Math.sqrt(deter)
	const u1 = (-b3 + e2) / (2 * a3)
	const u22 = (-b3 - e2) / (2 * a3)
	if ((u1 < 0 || u1 > 1) && (u22 < 0 || u22 > 1)) {
		return null
	}
	const result = []
	if (0 <= u1 && u1 <= 1) result.push(Vec2d.Lrp(a1, a22, u1))
	if (0 <= u22 && u22 <= 1) result.push(Vec2d.Lrp(a1, a22, u22))
	if (result.length === 0) return null
	return result
}
function intersectLineSegmentPolyline(a1, a22, points2) {
	const result = []
	let segmentIntersection
	for (let i3 = 0, n3 = points2.length - 1; i3 < n3; i3++) {
		segmentIntersection = intersectLineSegmentLineSegment(a1, a22, points2[i3], points2[i3 + 1])
		if (segmentIntersection) result.push(segmentIntersection)
	}
	if (result.length === 0) return null
	return result
}
function intersectLineSegmentPolygon(a1, a22, points2) {
	const result = []
	let segmentIntersection
	for (let i3 = 1, n3 = points2.length; i3 < n3 + 1; i3++) {
		segmentIntersection = intersectLineSegmentLineSegment(
			a1,
			a22,
			points2[i3 - 1],
			points2[i3 % points2.length]
		)
		if (segmentIntersection) result.push(segmentIntersection)
	}
	if (result.length === 0) return null
	return result
}
function intersectCircleCircle(c1, r1, c22, r22) {
	let dx = c22.x - c1.x
	let dy = c22.y - c1.y
	const d3 = Math.sqrt(dx * dx + dy * dy),
		x3 = (d3 * d3 - r22 * r22 + r1 * r1) / (2 * d3),
		y3 = Math.sqrt(r1 * r1 - x3 * x3)
	dx /= d3
	dy /= d3
	return [
		new Vec2d(c1.x + dx * x3 - dy * y3, c1.y + dy * x3 + dx * y3),
		new Vec2d(c1.x + dx * x3 + dy * y3, c1.y + dy * x3 - dx * y3),
	]
}
function intersectCirclePolygon(c3, r3, points2) {
	const result = []
	let a3, b3, int
	for (let i3 = 0, n3 = points2.length; i3 < n3; i3++) {
		a3 = points2[i3]
		b3 = points2[(i3 + 1) % points2.length]
		int = intersectLineSegmentCircle(a3, b3, c3, r3)
		if (int) result.push(...int)
	}
	if (result.length === 0) return null
	return result
}
function intersectCirclePolyline(c3, r3, points2) {
	const result = []
	let a3, b3, int
	for (let i3 = 1, n3 = points2.length; i3 < n3; i3++) {
		a3 = points2[i3 - 1]
		b3 = points2[i3]
		int = intersectLineSegmentCircle(a3, b3, c3, r3)
		if (int) result.push(...int)
	}
	if (result.length === 0) return null
	return result
}
function ccw(A2, B, C2) {
	return (C2.y - A2.y) * (B.x - A2.x) > (B.y - A2.y) * (C2.x - A2.x)
}
function linesIntersect(A2, B, C2, D3) {
	return ccw(A2, C2, D3) !== ccw(B, C2, D3) && ccw(A2, B, C2) !== ccw(A2, B, D3)
}
function intersectPolygonPolygon(polygonA, polygonB) {
	const result = []
	let a3, b3, c3, d3
	for (let i3 = 0, n3 = polygonA.length; i3 < n3; i3++) {
		a3 = polygonA[i3]
		if (pointInPolygon(a3, polygonB)) {
			result.push(a3)
		}
	}
	for (let i3 = 0, n3 = polygonB.length; i3 < n3; i3++) {
		a3 = polygonB[i3]
		if (pointInPolygon(a3, polygonA)) {
			result.push(a3)
		}
	}
	for (let i3 = 0, n3 = polygonA.length; i3 < n3; i3++) {
		a3 = polygonA[i3]
		b3 = polygonA[(i3 + 1) % polygonA.length]
		for (let j = 0, m3 = polygonB.length; j < m3; j++) {
			c3 = polygonB[j]
			d3 = polygonB[(j + 1) % polygonB.length]
			const intersection = intersectLineSegmentLineSegment(a3, b3, c3, d3)
			if (intersection !== null) {
				result.push(intersection)
			}
		}
	}
	if (result.length === 0) return null
	return orderClockwise(result)
}
function orderClockwise(points2) {
	const C2 = Vec2d.Average(points2)
	return points2.sort((A2, B) => Vec2d.Angle(C2, A2) - Vec2d.Angle(C2, B))
}
function polygonsIntersect(a3, b3) {
	let a0, a1, b0, b1
	for (let i3 = 0, n3 = a3.length; i3 < n3; i3++) {
		a0 = a3[i3]
		a1 = a3[(i3 + 1) % n3]
		for (let j = 0, m3 = b3.length; j < m3; j++) {
			b0 = b3[j]
			b1 = b3[(j + 1) % m3]
			if (linesIntersect(a0, a1, b0, b1)) return true
		}
	}
	return false
}

// ../packages/primitives/src/lib/polygon-helpers.ts
init_define_process()
function precise(A2) {
	return `${toDomPrecision(A2.x)},${toDomPrecision(A2.y)} `
}
function rng2(seed = '') {
	let x3 = 0
	let y3 = 0
	let z2 = 0
	let w3 = 0
	function next() {
		const t4 = x3 ^ (x3 << 11)
		x3 = y3
		y3 = z2
		z2 = w3
		w3 ^= ((w3 >>> 19) ^ t4 ^ (t4 >>> 8)) >>> 0
		return (w3 / 4294967296) * 2
	}
	for (let k2 = 0; k2 < seed.length + 64; k2++) {
		x3 ^= seed.charCodeAt(k2) | 0
		next()
	}
	return next
}
function getRoundedInkyPolygonPath(points2) {
	let polylineA = `M`
	const len = points2.length
	let p0
	let p1
	let p22
	for (let i3 = 0, n3 = len; i3 < n3; i3 += 3) {
		p0 = points2[i3]
		p1 = points2[i3 + 1]
		p22 = points2[i3 + 2]
		polylineA += `${precise(p0)}L${precise(p1)}Q${precise(p22)}`
	}
	polylineA += `${precise(points2[0])}`
	return polylineA
}
function getRoundedPolygonPoints(id, outline, offset, roundness, passes) {
	const results = []
	const random = rng2(id)
	let p0 = outline[0]
	let p1
	const len = outline.length
	for (let i3 = 0, n3 = len * passes; i3 < n3; i3++) {
		p1 = Vec2d.AddXY(outline[(i3 + 1) % len], random() * offset, random() * offset)
		const delta = Vec2d.Sub(p1, p0)
		const distance = Vec2d.Len(delta)
		const vector = Vec2d.Div(delta, distance).mul(Math.min(distance / 4, roundness))
		results.push(Vec2d.Add(p0, vector), Vec2d.Add(p1, vector.neg()), p1)
		p0 = p1
	}
	return results
}
function getDrawLinePathData(id, outline, strokeWidth) {
	let innerPathData = `M${precise(outline[0])}L`
	let outerPathData1 = `M${precise(outline[0])}L`
	let outerPathData2 = `M${precise(outline[0])}L`
	const offset = strokeWidth / 3
	const roundness = strokeWidth * 2
	const random = rng2(id)
	let p0 = outline[0]
	let p1
	let s0 = outline[0]
	let s1
	const len = outline.length
	for (let i3 = 0, n3 = len - 1; i3 < n3; i3++) {
		p1 = Vec2d.AddXY(outline[i3 + 1], random() * offset, random() * offset)
		s1 = Vec2d.AddXY(outline[i3 + 1], random(), random() * offset)
		const delta = Vec2d.Sub(p1, p0)
		const distance = Vec2d.Len(delta)
		const vector = Vec2d.Div(delta, distance).mul(Math.min(distance / 4, roundness))
		const q0 = Vec2d.Add(p0, vector)
		const q1 = Vec2d.Add(p1, vector.neg())
		const sDelta = Vec2d.Sub(s1, s0)
		const sDistance = Vec2d.Len(sDelta)
		const sVector = Vec2d.Div(sDelta, sDistance).mul(Math.min(sDistance / 4, roundness))
		const sq0 = Vec2d.Add(s0, sVector)
		const sq1 = Vec2d.Add(s1, sVector.neg())
		if (i3 === n3 - 1) {
			innerPathData += `${precise(q0)} L ${precise(p1)}`
			outerPathData1 += `${precise(q0)} L ${precise(p1)}`
			outerPathData2 += `${precise(sq0)} L ${precise(s1)}`
		} else {
			innerPathData += `${precise(q0)}L ${precise(q1)}Q ${precise(p1)}`
			outerPathData1 += `${precise(q0)}L ${precise(q1)}Q ${precise(p1)}`
			outerPathData2 += `${precise(sq0)}L ${precise(sq1)}Q ${precise(s1)}`
			p0 = p1
			s0 = s1
		}
	}
	return [innerPathData, outerPathData1 + outerPathData2]
}

// ../packages/editor/src/lib/app/App.ts
var import_eventemitter3 = __toESM(require_eventemitter3())

// ../packages/editor/src/lib/constants.ts
init_define_process()
var MAX_SHAPES_PER_PAGE = 2e3
var MAX_PAGES = 40
var REMOVE_SYMBOL = Symbol('remove')
var ANIMATION_MEDIUM_MS = 320
var ZOOMS = [0.1, 0.25, 0.5, 1, 2, 4, 8]
var MIN_ZOOM = 0.1
var MAX_ZOOM = 8
var FOLLOW_CHASE_PROPORTION = 0.5
var FOLLOW_CHASE_PAN_SNAP = 0.1
var FOLLOW_CHASE_PAN_UNSNAP = 0.2
var FOLLOW_CHASE_ZOOM_SNAP = 5e-3
var FOLLOW_CHASE_ZOOM_UNSNAP = 0.05
var MAJOR_NUDGE_FACTOR = 10
var MINOR_NUDGE_FACTOR = 1
var MAX_ASSET_WIDTH = 1e3
var MAX_ASSET_HEIGHT = 1e3
var GRID_INCREMENT = 5
var MIN_CROP_SIZE = 8
var DOUBLE_CLICK_DURATION = 450
var MULTI_CLICK_DURATION = 200
var COARSE_DRAG_DISTANCE = 6
var DRAG_DISTANCE = 4
var SVG_PADDING = 32
var HASH_PATERN_ZOOM_NAMES = {}
for (let zoom = 1; zoom <= Math.ceil(MAX_ZOOM); zoom++) {
	HASH_PATERN_ZOOM_NAMES[zoom + '_dark'] = `hash_pattern_zoom_${zoom}_dark`
	HASH_PATERN_ZOOM_NAMES[zoom + '_light'] = `hash_pattern_zoom_${zoom}_light`
}
var DEFAULT_ANIMATION_OPTIONS = {
	duration: 0,
	easing: EASINGS.easeInOutCubic,
}
var HAND_TOOL_FRICTION = 0.09
var MIN_ARROW_LENGTH = 48
var BOUND_ARROW_OFFSET = 10
var WAY_TOO_BIG_ARROW_BEND_FACTOR = 10
var DEFAULT_BOOKMARK_WIDTH = 300
var DEFAULT_BOOKMARK_HEIGHT = 320
var ROTATING_SHADOWS = [
	{
		offsetX: 0,
		offsetY: 2,
		blur: 4,
		spread: 0,
		color: '#00000029',
	},
	{
		offsetX: 0,
		offsetY: 3,
		blur: 6,
		spread: 0,
		color: '#0000001f',
	},
]
var GRID_STEPS = [
	{ min: -1, mid: 0.15, step: 100 },
	{ min: 0.05, mid: 0.375, step: 25 },
	{ min: 0.15, mid: 1, step: 5 },
	{ min: 0.7, mid: 2.5, step: 1 },
]
var TEXT_PROPS = {
	lineHeight: 1.35,
	fontWeight: 'normal',
	fontVariant: 'normal',
	fontStyle: 'normal',
	padding: '0px',
	maxWidth: 'auto',
}
var FONT_SIZES = {
	s: 18,
	m: 24,
	l: 36,
	xl: 44,
}
var LABEL_FONT_SIZES = {
	s: 18,
	m: 22,
	l: 26,
	xl: 32,
}
var ARROW_LABEL_FONT_SIZES = {
	s: 18,
	m: 20,
	l: 24,
	xl: 28,
}
var FONT_FAMILIES = {
	draw: 'var(--tl-font-draw)',
	sans: 'var(--tl-font-sans)',
	serif: 'var(--tl-font-serif)',
	mono: 'var(--tl-font-mono)',
}
var STYLES = {
	color: [
		{ id: 'black', type: 'color', icon: 'color' },
		{ id: 'grey', type: 'color', icon: 'color' },
		{ id: 'light-violet', type: 'color', icon: 'color' },
		{ id: 'violet', type: 'color', icon: 'color' },
		{ id: 'blue', type: 'color', icon: 'color' },
		{ id: 'light-blue', type: 'color', icon: 'color' },
		{ id: 'yellow', type: 'color', icon: 'color' },
		{ id: 'orange', type: 'color', icon: 'color' },
		{ id: 'green', type: 'color', icon: 'color' },
		{ id: 'light-green', type: 'color', icon: 'color' },
		{ id: 'light-red', type: 'color', icon: 'color' },
		{ id: 'red', type: 'color', icon: 'color' },
	],
	fill: [
		{ id: 'none', type: 'fill', icon: 'fill-none' },
		{ id: 'semi', type: 'fill', icon: 'fill-semi' },
		{ id: 'solid', type: 'fill', icon: 'fill-solid' },
		{ id: 'pattern', type: 'fill', icon: 'fill-pattern' },
	],
	dash: [
		{ id: 'draw', type: 'dash', icon: 'dash-draw' },
		{ id: 'dashed', type: 'dash', icon: 'dash-dashed' },
		{ id: 'dotted', type: 'dash', icon: 'dash-dotted' },
		{ id: 'solid', type: 'dash', icon: 'dash-solid' },
	],
	size: [
		{ id: 's', type: 'size', icon: 'size-small' },
		{ id: 'm', type: 'size', icon: 'size-medium' },
		{ id: 'l', type: 'size', icon: 'size-large' },
		{ id: 'xl', type: 'size', icon: 'size-extra-large' },
	],
	opacity: [
		{ id: '0.1', type: 'opacity', icon: 'color' },
		{ id: '0.25', type: 'opacity', icon: 'color' },
		{ id: '0.5', type: 'opacity', icon: 'color' },
		{ id: '0.75', type: 'opacity', icon: 'color' },
		{ id: '1', type: 'opacity', icon: 'color' },
	],
	font: [
		{ id: 'draw', type: 'font', icon: 'font-draw' },
		{ id: 'sans', type: 'font', icon: 'font-sans' },
		{ id: 'serif', type: 'font', icon: 'font-serif' },
		{ id: 'mono', type: 'font', icon: 'font-mono' },
	],
	align: [
		{ id: 'start', type: 'align', icon: 'text-align-left' },
		{ id: 'middle', type: 'align', icon: 'text-align-center' },
		{ id: 'end', type: 'align', icon: 'text-align-right' },
	],
	verticalAlign: [
		{ id: 'start', type: 'verticalAlign', icon: 'vertical-align-start' },
		{ id: 'middle', type: 'verticalAlign', icon: 'vertical-align-center' },
		{ id: 'end', type: 'verticalAlign', icon: 'vertical-align-end' },
	],
	geo: [
		{ id: 'rectangle', type: 'geo', icon: 'geo-rectangle' },
		{ id: 'ellipse', type: 'geo', icon: 'geo-ellipse' },
		{ id: 'triangle', type: 'geo', icon: 'geo-triangle' },
		{ id: 'diamond', type: 'geo', icon: 'geo-diamond' },
		{ id: 'pentagon', type: 'geo', icon: 'geo-pentagon' },
		{ id: 'hexagon', type: 'geo', icon: 'geo-hexagon' },
		{ id: 'octagon', type: 'geo', icon: 'geo-octagon' },
		{ id: 'star', type: 'geo', icon: 'geo-star' },
		{ id: 'rhombus', type: 'geo', icon: 'geo-rhombus' },
		{ id: 'rhombus-2', type: 'geo', icon: 'geo-rhombus-2' },
		{ id: 'oval', type: 'geo', icon: 'geo-oval' },
		{ id: 'trapezoid', type: 'geo', icon: 'geo-trapezoid' },
		{ id: 'arrow-right', type: 'geo', icon: 'geo-arrow-right' },
		{ id: 'arrow-left', type: 'geo', icon: 'geo-arrow-left' },
		{ id: 'arrow-up', type: 'geo', icon: 'geo-arrow-up' },
		{ id: 'arrow-down', type: 'geo', icon: 'geo-arrow-down' },
		{ id: 'x-box', type: 'geo', icon: 'geo-x-box' },
		{ id: 'check-box', type: 'geo', icon: 'geo-check-box' },
	],
	arrowheadStart: [
		{ id: 'none', type: 'arrowheadStart', icon: 'arrowhead-none' },
		{ id: 'arrow', type: 'arrowheadStart', icon: 'arrowhead-arrow' },
		{ id: 'triangle', type: 'arrowheadStart', icon: 'arrowhead-triangle' },
		{ id: 'square', type: 'arrowheadStart', icon: 'arrowhead-square' },
		{ id: 'dot', type: 'arrowheadStart', icon: 'arrowhead-dot' },
		{ id: 'diamond', type: 'arrowheadStart', icon: 'arrowhead-diamond' },
		{ id: 'inverted', type: 'arrowheadStart', icon: 'arrowhead-triangle-inverted' },
		{ id: 'bar', type: 'arrowheadStart', icon: 'arrowhead-bar' },
	],
	arrowheadEnd: [
		{ id: 'none', type: 'arrowheadEnd', icon: 'arrowhead-none' },
		{ id: 'arrow', type: 'arrowheadEnd', icon: 'arrowhead-arrow' },
		{ id: 'triangle', type: 'arrowheadEnd', icon: 'arrowhead-triangle' },
		{ id: 'square', type: 'arrowheadEnd', icon: 'arrowhead-square' },
		{ id: 'dot', type: 'arrowheadEnd', icon: 'arrowhead-dot' },
		{ id: 'diamond', type: 'arrowheadEnd', icon: 'arrowhead-diamond' },
		{ id: 'inverted', type: 'arrowheadEnd', icon: 'arrowhead-triangle-inverted' },
		{ id: 'bar', type: 'arrowheadEnd', icon: 'arrowhead-bar' },
	],
	spline: [
		{ id: 'line', type: 'spline', icon: 'spline-line' },
		{ id: 'cubic', type: 'spline', icon: 'spline-cubic' },
	],
}
var BLACKLISTED_PROPS = /* @__PURE__ */ new Set([
	'bend',
	'w',
	'h',
	'start',
	'end',
	'text',
	'name',
	'url',
	'growY',
])

// ../packages/editor/src/lib/hooks/usePattern.tsx
init_define_process()
var import_react2 = __toESM(require_react())

// ../packages/editor/src/lib/utils/debug-flags.ts
init_define_process()
var debugFlags = {
	preventDefaultLogging: createDebugValue('tldrawPreventDefaultLogging', false),
	pointerCaptureLogging: createDebugValue('tldrawPointerCaptureLogging', false),
	pointerCaptureTracking: createDebugValue('tldrawPointerCaptureTracking', false),
	pointerCaptureTrackingObject: createDebugValue(
		'tldrawPointerCaptureTrackingObject',
		// ideally we wouldn't store this mutable value in an atom but it's not
		// a big deal for debug values
		/* @__PURE__ */ new Map(),
		false
	),
	elementRemovalLogging: createDebugValue('tldrawElementRemovalLogging', false),
	debugSvg: createDebugValue('tldrawDebugSvg', false),
	throwToBlob: createDebugValue('tldrawThrowToBlob', false),
	peopleMenu: createDebugValue('tldrawPeopleMenu', false),
	logMessages: createDebugValue('tldrawUiLog', []),
	resetConnectionEveryPing: createDebugValue('tldrawResetConnectionEveryPing', false),
	debugCursors: createDebugValue('tldrawDebugCursors', false),
}
debugFlags.logMessages.set([])
if (typeof window !== 'undefined') {
	window.tldrawLog = (message) => {
		debugFlags.logMessages.set(debugFlags.logMessages.value.concat(message))
	}
}
if (typeof Element !== 'undefined') {
	const nativeElementRemoveChild = Element.prototype.removeChild
	react('element removal logging', () => {
		if (debugFlags.elementRemovalLogging.value) {
			Element.prototype.removeChild = function (child) {
				console.warn('[tldraw] removing child:', child)
				return nativeElementRemoveChild.call(this, child)
			}
		} else {
			Element.prototype.removeChild = nativeElementRemoveChild
		}
	})
}
function createDebugValue(name, initialValue, shouldStore = true) {
	if (typeof window === 'undefined') {
		return atom(`debug:${name}`, initialValue)
	}
	const storedValue = shouldStore ? getStoredInitialValue(name) : null
	const value = atom(`debug:${name}`, storedValue ?? initialValue)
	if (shouldStore) {
		react(`debug:${name}`, () => {
			const currentValue = value.value
			try {
				if (currentValue === initialValue) {
					window.sessionStorage.removeItem(`debug:${name}`)
				} else {
					window.sessionStorage.setItem(`debug:${name}`, JSON.stringify(currentValue))
				}
			} catch {}
		})
	}
	Object.defineProperty(window, name, {
		get() {
			return value.value
		},
		set(newValue) {
			value.set(newValue)
		},
		configurable: true,
	})
	return value
}
function getStoredInitialValue(name) {
	try {
		return JSON.parse(window.sessionStorage.getItem(`debug:${name}`) ?? 'null')
	} catch (err) {
		return null
	}
}

// ../packages/editor/src/lib/hooks/useApp.ts
init_define_process()
var import_react = __toESM(require_react())
var AppContext = import_react.default.createContext({})
var useApp = () => {
	return import_react.default.useContext(AppContext)
}

// ../packages/editor/src/lib/hooks/usePattern.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime())
var TILE_PATTERN_SIZE = 8
var generateImage = (dpr, currentZoom, darkMode) => {
	return new Promise((resolve, reject) => {
		const size = TILE_PATTERN_SIZE * currentZoom * dpr
		const canvasEl = document.createElement('canvas')
		canvasEl.width = size
		canvasEl.height = size
		const ctx = canvasEl.getContext('2d')
		if (!ctx) throw new Error('No canvas')
		ctx.fillStyle = darkMode ? '#212529' : '#f8f9fa'
		ctx.fillRect(0, 0, size, size)
		ctx.globalCompositeOperation = 'destination-out'
		ctx.lineCap = 'round'
		ctx.lineWidth = 1.25 * currentZoom * dpr
		const t4 = 8 / 12
		const s3 = (v3) => v3 * currentZoom * dpr
		ctx.beginPath()
		ctx.moveTo(s3(t4 * 1), s3(t4 * 3))
		ctx.lineTo(s3(t4 * 3), s3(t4 * 1))
		ctx.moveTo(s3(t4 * 5), s3(t4 * 7))
		ctx.lineTo(s3(t4 * 7), s3(t4 * 5))
		ctx.moveTo(s3(t4 * 9), s3(t4 * 11))
		ctx.lineTo(s3(t4 * 11), s3(t4 * 9))
		ctx.stroke()
		canvasEl.toBlob((blob) => {
			if (!blob || debugFlags.throwToBlob.value) {
				reject()
			} else {
				resolve(blob)
			}
		})
	})
}
var canvasBlob = (size, fn) => {
	const canvas = document.createElement('canvas')
	canvas.width = size[0]
	canvas.height = size[1]
	fn(canvas.getContext('2d'))
	return canvas.toDataURL()
}
var getDefaultPatterns = () => {
	const defaultPatterns = []
	for (let i3 = 1; i3 <= Math.ceil(MAX_ZOOM); i3++) {
		const whitePixelBlob = canvasBlob([1, 1], (ctx) => {
			ctx.fillStyle = '#e8e8e8'
			ctx.fillRect(0, 0, 1, 1)
		})
		const blackPixelBlob = canvasBlob([1, 1], (ctx) => {
			ctx.fillStyle = '#2c3036'
			ctx.fillRect(0, 0, 1, 1)
		})
		defaultPatterns.push({
			zoom: i3,
			url: whitePixelBlob,
			darkMode: false,
		})
		defaultPatterns.push({
			zoom: i3,
			url: blackPixelBlob,
			darkMode: true,
		})
	}
	return defaultPatterns
}
var usePattern = () => {
	const app = useApp()
	const dpr = app.devicePixelRatio
	const [isReady, setIsReady] = (0, import_react2.useState)(false)
	const defaultPatterns = (0, import_react2.useMemo)(() => getDefaultPatterns(), [])
	const [backgroundUrls, setBackgroundUrls] = (0, import_react2.useState)(defaultPatterns)
	;(0, import_react2.useEffect)(() => {
		const promises = []
		for (let i3 = 1; i3 <= Math.ceil(MAX_ZOOM); i3++) {
			promises.push(
				generateImage(dpr, i3, false).then((blob) => ({
					zoom: i3,
					url: URL.createObjectURL(blob),
					darkMode: false,
				}))
			)
			promises.push(
				generateImage(dpr, i3, true).then((blob) => ({
					zoom: i3,
					url: URL.createObjectURL(blob),
					darkMode: true,
				}))
			)
		}
		let isCancelled = false
		Promise.all(promises).then((urls) => {
			if (isCancelled) return
			setBackgroundUrls(urls)
			setIsReady(true)
		})
		return () => {
			isCancelled = true
			setIsReady(false)
		}
	}, [dpr])
	const context = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
		children: backgroundUrls.map((item) => {
			const key = item.zoom + (item.darkMode ? '_dark' : '_light')
			return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
				'pattern',
				{
					id: HASH_PATERN_ZOOM_NAMES[key],
					width: TILE_PATTERN_SIZE,
					height: TILE_PATTERN_SIZE,
					patternUnits: 'userSpaceOnUse',
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)('image', {
						href: item.url,
						width: TILE_PATTERN_SIZE,
						height: TILE_PATTERN_SIZE,
					}),
				},
				key
			)
		}),
	})
	return { context, isReady }
}
var t = 8 / 12
function exportPatternSvgDefs(backgroundColor) {
	const divEl = document.createElement('div')
	divEl.innerHTML = `
		<svg>
			<defs>
				<mask id="hash_pattern_mask">
					<rect x="0" y="0" width="8" height="8" fill="white" />
					<g
						strokeLinecap="round"
						stroke="black"
					>
						<line x1="${t * 1}" y1="${t * 3}" x2="${t * 3}" y2="${t * 1}" />
						<line x1="${t * 5}" y1="${t * 7}" x2="${t * 7}" y2="${t * 5}" />
						<line x1="${t * 9}" y1="${t * 11}" x2="${t * 11}" y2="${t * 9}" />
					</g>
				</mask>
				<pattern
					id="hash_pattern"
					width="8"
					height="8"
					patternUnits="userSpaceOnUse"
				>
					<rect x="0" y="0" width="8" height="8" fill="${backgroundColor}" mask="url(#hash_pattern_mask)" />
				</pattern>
			</defs>
		</svg>
	`
	return divEl.querySelectorAll('defs > *')
}

// ../packages/editor/src/lib/utils/WeakMapCache.ts
init_define_process()
var WeakMapCache = class {
	items = /* @__PURE__ */ new WeakMap()
	get(item, cb) {
		if (!this.items.has(item)) {
			this.items.set(item, cb(item))
		}
		return this.items.get(item)
	}
	access(item) {
		return this.items.get(item)
	}
	set(item, value) {
		this.items.set(item, value)
	}
	has(item) {
		return this.items.has(item)
	}
	invalidate(item) {
		this.items.delete(item)
	}
	bust() {
		this.items = /* @__PURE__ */ new WeakMap()
	}
}

// ../packages/editor/src/lib/utils/assets.ts
init_define_process()
var import_lodash2 = __toESM(require_lodash2())

// ../packages/editor/src/lib/utils/is-gif-animated.ts
init_define_process()
function getDataBlocksLength(buffer, offset) {
	let length = 0
	while (buffer[offset + length]) {
		length += buffer[offset + length] + 1
	}
	return length + 1
}
function isGIF(buffer) {
	const enc = new TextDecoder('ascii')
	const header = enc.decode(buffer.slice(0, 3))
	return header === 'GIF'
}
function isAnimated(buffer) {
	const view = new Uint8Array(buffer)
	let hasColorTable, colorTableSize
	let offset = 0
	let imagesCount = 0
	if (!isGIF(buffer)) {
		return false
	}
	hasColorTable = view[10] & 128
	colorTableSize = view[10] & 7
	offset += 6
	offset += 7
	offset += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0
	while (imagesCount < 2 && offset < view.length) {
		switch (view[offset]) {
			case 44:
				imagesCount += 1
				hasColorTable = view[offset + 9] & 128
				colorTableSize = view[offset + 9] & 7
				offset += 10
				offset += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0
				offset += getDataBlocksLength(view, offset + 1) + 1
				break
			case 33:
				offset += 2
				offset += getDataBlocksLength(view, offset)
				break
			case 59:
				offset = view.length
				break
			default:
				offset = view.length
				break
		}
	}
	return imagesCount > 1
}

// ../packages/editor/src/lib/utils/png.ts
init_define_process()

// ../node_modules/crc/mjs/crc32.js
init_define_process()

// ../node_modules/crc/mjs/calculators/crc32.js
init_define_process()
var TABLE = [
	0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274,
	2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548,
	1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990,
	1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096,
	1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722,
	1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980,
	1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974,
	1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192,
	31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290,
	251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444,
	476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902,
	314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960,
	984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506,
	879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948,
	654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054,
	702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384,
	2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930,
	2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580,
	2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526,
	2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888,
	2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850,
	2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804,
	3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542,
	2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920,
	3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634,
	3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012,
	4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934,
	4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896,
	3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818,
	3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108,
	3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614,
	3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117,
]
if (typeof Int32Array !== 'undefined') {
	TABLE = new Int32Array(TABLE)
}
var crc32 = (current, previous) => {
	let crc2 = previous === 0 ? 0 : ~~previous ^ -1
	for (let index2 = 0; index2 < current.length; index2++) {
		crc2 = TABLE[(crc2 ^ current[index2]) & 255] ^ (crc2 >>> 8)
	}
	return crc2 ^ -1
}
var crc32_default = crc32

// ../node_modules/crc/mjs/define_crc.js
init_define_process()

// ../node_modules/crc/mjs/create_buffer.js
init_define_process()
var import_buffer = __toESM(require_buffer(), 1)
var createBuffer = (value, encoding) => import_buffer.Buffer.from(value, encoding)
var create_buffer_default = createBuffer

// ../node_modules/crc/mjs/define_crc.js
function defineCrc(model2, calculator) {
	const result = (value, previous) => calculator(create_buffer_default(value), previous) >>> 0
	result.signed = (value, previous) => calculator(create_buffer_default(value), previous)
	result.unsigned = result
	result.model = model2
	return result
}

// ../node_modules/crc/mjs/crc32.js
var crc32_default2 = defineCrc('crc-32', crc32_default)

// ../packages/editor/src/lib/utils/png.ts
function isPng(view, offset) {
	if (
		view.getUint8(offset + 0) === 137 &&
		view.getUint8(offset + 1) === 80 &&
		view.getUint8(offset + 2) === 78 &&
		view.getUint8(offset + 3) === 71 &&
		view.getUint8(offset + 4) === 13 &&
		view.getUint8(offset + 5) === 10 &&
		view.getUint8(offset + 6) === 26 &&
		view.getUint8(offset + 7) === 10
	) {
		return true
	}
	return false
}
function getChunkType(view, offset) {
	return [
		String.fromCharCode(view.getUint8(offset)),
		String.fromCharCode(view.getUint8(offset + 1)),
		String.fromCharCode(view.getUint8(offset + 2)),
		String.fromCharCode(view.getUint8(offset + 3)),
	].join('')
}
function crc(arrayBuffer) {
	return crc32_default2(arrayBuffer)
}
var LEN_SIZE = 4
var CRC_SIZE = 4
function readChunks(view, offset = 0) {
	const chunks = {}
	if (!isPng(view, offset)) {
		throw new Error('Not a PNG')
	}
	offset += 8
	while (offset <= view.buffer.byteLength) {
		const start = offset
		const len = view.getInt32(offset)
		offset += 4
		const chunkType = getChunkType(view, offset)
		if (chunkType === 'IDAT' && chunks[chunkType]) {
			offset += len + LEN_SIZE + CRC_SIZE
			continue
		}
		if (chunkType === 'IEND') {
			break
		}
		chunks[chunkType] = {
			start,
			dataOffset: offset + 4,
			size: len,
		}
		offset += len + LEN_SIZE + CRC_SIZE
	}
	return chunks
}
function parsePhys(view, offset) {
	return {
		ppux: view.getUint32(offset),
		ppuy: view.getUint32(offset + 4),
		unit: view.getUint8(offset + 4),
	}
}
function findChunk(view, type) {
	const chunks = readChunks(view)
	return chunks[type]
}
function setPhysChunk(view, dpr = 1, options) {
	let offset = 46
	let size = 0
	const res1 = findChunk(view, 'pHYs')
	if (res1) {
		offset = res1.start
		size = res1.size
	}
	const res2 = findChunk(view, 'IDAT')
	if (res2) {
		offset = res2.start
		size = 0
	}
	const pHYsData = new ArrayBuffer(21)
	const pHYsDataView = new DataView(pHYsData)
	pHYsDataView.setUint32(0, 9)
	pHYsDataView.setUint8(4, 'p'.charCodeAt(0))
	pHYsDataView.setUint8(5, 'H'.charCodeAt(0))
	pHYsDataView.setUint8(6, 'Y'.charCodeAt(0))
	pHYsDataView.setUint8(7, 's'.charCodeAt(0))
	const DPI_96 = 2835.5
	pHYsDataView.setInt32(8, DPI_96 * dpr)
	pHYsDataView.setInt32(12, DPI_96 * dpr)
	pHYsDataView.setInt8(16, 1)
	const crcBit = new Uint8Array(pHYsData.slice(4, 17))
	pHYsDataView.setInt32(17, crc(crcBit))
	const startBuf = view.buffer.slice(0, offset)
	const endBuf = view.buffer.slice(offset + size)
	return new Blob([startBuf, pHYsData, endBuf], options)
}

// ../packages/editor/src/lib/utils/assets.ts
var ACCEPTED_IMG_TYPE = ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml']
var ACCEPTED_VID_TYPE = ['video/mp4', 'video/quicktime']
var ACCEPTED_ASSET_TYPE = ACCEPTED_IMG_TYPE.concat(ACCEPTED_VID_TYPE).join(', ')
var isImage = (ext) => ACCEPTED_IMG_TYPE.includes(ext)
async function getVideoSizeFromSrc(src) {
	return await new Promise((resolve, reject) => {
		const video = document.createElement('video')
		video.onloadeddata = () => resolve({ w: video.videoWidth, h: video.videoHeight })
		video.onerror = (e2) => {
			console.error(e2)
			reject(new Error('Could not get video size'))
		}
		video.crossOrigin = 'anonymous'
		video.src = src
	})
}
async function base64ToFile(dataURL) {
	return fetch(dataURL).then(function (result) {
		return result.arrayBuffer()
	})
}
async function getImageSizeFromSrc(dataURL) {
	return await new Promise((resolve, reject) => {
		const img = new Image()
		img.onload = async () => {
			try {
				const blob = await base64ToFile(dataURL)
				const view = new DataView(blob)
				if (isPng(view, 0)) {
					const physChunk = findChunk(view, 'pHYs')
					if (physChunk) {
						const physData = parsePhys(view, physChunk.dataOffset)
						if (physData.unit === 0 && physData.ppux === physData.ppuy) {
							const pixelRatio = Math.round(physData.ppux / 2834.5)
							resolve({ w: img.width / pixelRatio, h: img.height / pixelRatio })
							return
						}
					}
				}
				resolve({ w: img.width, h: img.height })
			} catch (err) {
				console.error(err)
				resolve({ w: img.width, h: img.height })
			}
		}
		img.onerror = (err) => {
			console.error(err)
			reject(new Error('Could not get image size'))
		}
		img.crossOrigin = 'anonymous'
		img.src = dataURL
	})
}
async function getResizedImageDataUrl(dataURLForImage, width, height) {
	return await new Promise((resolve) => {
		const img = new Image()
		img.onload = () => {
			const canvas = document.createElement('canvas')
			const ctx = canvas.getContext('2d')
			if (!ctx) return
			canvas.width = width * 2
			canvas.height = height * 2
			ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
			const newDataURL = canvas.toDataURL()
			resolve(newDataURL)
		}
		img.crossOrigin = 'anonymous'
		img.src = dataURLForImage
	})
}
async function getMediaAssetFromFile(file) {
	return await new Promise((resolve, reject) => {
		const reader = new FileReader()
		reader.onerror = () => reject(reader.error)
		reader.onload = async () => {
			let dataUrl = reader.result
			const isImageType = isImage(file.type)
			const sizeFn = isImageType ? getImageSizeFromSrc : getVideoSizeFromSrc
			if (file.type === 'video/quicktime' && dataUrl.includes('video/quicktime')) {
				dataUrl = dataUrl.replace('video/quicktime', 'video/mp4')
			}
			const originalSize = await sizeFn(dataUrl)
			const size = containBoxSize(originalSize, { w: MAX_ASSET_WIDTH, h: MAX_ASSET_HEIGHT })
			if (size !== originalSize && (file.type === 'image/jpeg' || file.type === 'image/png')) {
				dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h)
			}
			const assetId = AssetRecordType.createCustomId(getHashForString(dataUrl))
			const metadata = await getFileMetaData(file)
			const asset = {
				id: assetId,
				type: isImageType ? 'image' : 'video',
				typeName: 'asset',
				props: {
					name: file.name,
					src: dataUrl,
					w: size.w,
					h: size.h,
					mimeType: file.type,
					isAnimated: metadata.isAnimated,
				},
			}
			resolve(asset)
		}
		reader.readAsDataURL(file)
	})
}
async function getFileMetaData(file) {
	if (file.type === 'image/gif') {
		return await new Promise((resolve, reject) => {
			const reader = new FileReader()
			reader.onerror = () => reject(reader.error)
			reader.onload = () => {
				resolve({
					isAnimated: reader.result ? isAnimated(reader.result) : false,
				})
			}
			reader.readAsArrayBuffer(file)
		})
	}
	return {
		isAnimated: isImage(file.type) ? false : true,
	}
}
function containBoxSize(originalSize, containBoxSize2) {
	const overByXScale = originalSize.w / containBoxSize2.w
	const overByYScale = originalSize.h / containBoxSize2.h
	if (overByXScale <= 1 && overByYScale <= 1) {
		return originalSize
	} else if (overByXScale > overByYScale) {
		return {
			w: originalSize.w / overByXScale,
			h: originalSize.h / overByXScale,
		}
	} else {
		return {
			w: originalSize.w / overByYScale,
			h: originalSize.h / overByYScale,
		}
	}
}
async function createShapesFromFiles(app, files, position, _ignoreParent = false) {
	const pagePoint = new Vec2d(position.x, position.y)
	const newAssetsForFiles = /* @__PURE__ */ new Map()
	const shapePartials = await Promise.all(
		files.map(async (file, i3) => {
			if (!file.type) throw new Error('No mime type')
			if (!ACCEPTED_IMG_TYPE.concat(ACCEPTED_VID_TYPE).includes(file.type)) {
				console.warn(`${file.name} not loaded - Extension not allowed.`)
				return null
			}
			try {
				const asset = await app.onCreateAssetFromFile(file)
				if (asset.type === 'bookmark') return
				if (!asset) throw Error('Could not create an asset')
				newAssetsForFiles.set(file, asset)
				const shapePartial = {
					id: createShapeId(),
					type: asset.type,
					x: pagePoint.x + i3,
					y: pagePoint.y,
					props: {
						w: asset.props.w,
						h: asset.props.h,
						opacity: '1',
					},
				}
				return shapePartial
			} catch (error) {
				console.error(error)
				return null
			}
		})
	)
	const results = compact(shapePartials).sort((a3, b3) => a3.x - b3.x)
	if (results.length === 0) return
	for (let i3 = 0; i3 < results.length; i3++) {
		const model2 = results[i3]
		if (i3 === 0) {
			model2.x -= model2.props.w / 2
			model2.y -= model2.props.h / 2
		} else {
			const prevModel = results[i3 - 1]
			model2.x = prevModel.x + prevModel.props.w
			model2.y = prevModel.y
		}
	}
	const shapeUpdates = await Promise.all(
		files.map(async (file, i3) => {
			const shape = results[i3]
			if (!shape) return
			const asset = newAssetsForFiles.get(file)
			if (!asset) return
			let existing = app.getAssetById(asset.id)
			if (existing) {
				newAssetsForFiles.delete(file)
				if (shape.props) {
					shape.props.assetId = existing.id
				}
				return shape
			}
			existing = app.getAssetBySrc(asset.props.src)
			if (existing) {
				if (shape.props) {
					shape.props.assetId = existing.id
				}
				return shape
			}
			if (shape.props) {
				shape.props.assetId = asset.id
			}
			return shape
		})
	)
	const filteredUpdates = compact(shapeUpdates)
	app.createAssets(compact([...newAssetsForFiles.values()]))
	app.createShapes(filteredUpdates)
	app.setSelectedIds(filteredUpdates.map((s3) => s3.id))
	const { selectedIds, viewportPageBounds } = app
	const pageBounds = Box2d.Common(compact(selectedIds.map((id) => app.getPageBoundsById(id))))
	if (pageBounds && !viewportPageBounds.contains(pageBounds)) {
		app.zoomToSelection()
	}
}
function createEmbedShapeAtPoint(app, url, point2, props) {
	app.createShapes(
		[
			{
				id: createShapeId(),
				type: 'embed',
				x: point2.x - (props.width || 450) / 2,
				y: point2.y - (props.height || 450) / 2,
				props: {
					w: props.width,
					h: props.height,
					doesResize: props.doesResize,
					url,
					opacity: '1',
				},
			},
		],
		true
	)
}
async function createBookmarkShapeAtPoint(app, url, point2) {
	const assetId = AssetRecordType.createCustomId(getHashForString(url))
	const existing = app.getAssetById(assetId)
	if (existing) {
		app.createShapes([
			{
				id: app.createShapeId(),
				type: 'bookmark',
				x: point2.x - 150,
				y: point2.y - 160,
				props: {
					assetId: existing.id,
					url: existing.props.src,
					opacity: '1',
				},
			},
		])
		return
	}
	app.batch(async () => {
		const shapeId = createShapeId()
		app.createShapes(
			[
				{
					id: shapeId,
					type: 'bookmark',
					x: point2.x,
					y: point2.y,
					props: {
						url,
						opacity: '1',
					},
				},
			],
			true
		)
		const meta = await app.onCreateBookmarkFromUrl(url)
		if (meta) {
			app.createAssets([
				{
					id: assetId,
					typeName: 'asset',
					type: 'bookmark',
					props: {
						src: url,
						description: meta.description,
						image: meta.image,
						title: meta.title,
					},
				},
			])
			app.updateShapes([
				{
					id: shapeId,
					type: 'bookmark',
					props: {
						assetId,
						opacity: '1',
					},
				},
			])
		}
	})
}
async function createAssetShapeAtPoint(app, svgString, point2) {
	const svg = new DOMParser().parseFromString(svgString, 'image/svg+xml').querySelector('svg')
	if (!svg) {
		throw new Error('No <svg/> element present')
	}
	let width = parseFloat(svg.getAttribute('width') || '0')
	let height = parseFloat(svg.getAttribute('height') || '0')
	if (!(width && height)) {
		document.body.appendChild(svg)
		const box = svg.getBoundingClientRect()
		document.body.removeChild(svg)
		width = box.width
		height = box.height
	}
	const asset = await app.onCreateAssetFromFile(
		new File([svgString], 'asset.svg', { type: 'image/svg+xml' })
	)
	if (asset.type !== 'bookmark') {
		asset.props.w = width
		asset.props.h = height
	}
	app.batch(() => {
		app.createAssets([asset])
		app.createShapes(
			[
				{
					id: createShapeId(),
					type: 'image',
					x: point2.x - width / 2,
					y: point2.y - height / 2,
					props: {
						assetId: asset.id,
						w: width,
						h: height,
						opacity: '1',
					},
				},
			],
			true
		)
	})
}
var isValidHttpURL = (url) => {
	try {
		const u3 = new URL(url)
		return u3.protocol === 'http:' || u3.protocol === 'https:'
	} catch (e2) {
		return false
	}
}
var getValidHttpURLList = (url) => {
	const urls = url.split(/[\n\s]/)
	for (const url2 of urls) {
		try {
			const u3 = new URL(url2)
			if (!(u3.protocol === 'http:' || u3.protocol === 'https:')) {
				return
			}
		} catch (e2) {
			return
		}
	}
	return (0, import_lodash2.default)(urls)
}
var isSvgText = (text) => {
	return /^<svg/.test(text)
}
function dataUrlToFile(url, filename, mimeType) {
	return fetch(url)
		.then(function (res) {
			return res.arrayBuffer()
		})
		.then(function (buf) {
			return new File([buf], filename, { type: mimeType })
		})
}

// ../packages/editor/src/lib/utils/data.ts
init_define_process()

// ../node_modules/is-plain-object/dist/is-plain-object.mjs
init_define_process()

// ../packages/editor/src/lib/utils/data.ts
function uniqueId() {
	return nanoid()
}
function getIncrementedName(name, others) {
	let result = name
	const set = new Set(others)
	while (set.has(result)) {
		result = /^.*(\d+)$/.exec(result)?.[1]
			? result.replace(/(\d+)(?=\D?)$/, (m3) => {
					return (+m3 + 1).toString()
			  })
			: `${result} 1`
	}
	return result
}

// ../packages/editor/src/lib/utils/props-for-next-shape.ts
init_define_process()
function setPropsForNextShape(previousProps, newProps) {
	let nextProps = null
	for (const [prop, value] of Object.entries(newProps)) {
		if (!TL_STYLE_TYPES.has(prop)) continue
		if (!nextProps) nextProps = { ...previousProps }
		nextProps[prop] = value
	}
	return nextProps ?? previousProps
}

// ../packages/editor/src/lib/utils/rotation.ts
init_define_process()
function getRotationSnapshot({ app }) {
	const {
		selectionRotation,
		selectionPageCenter,
		inputs: { originPagePoint },
		selectedShapes,
	} = app
	return {
		selectionPageCenter,
		initialCursorAngle: selectionPageCenter.angle(originPagePoint),
		initialSelectionRotation: selectionRotation,
		shapeSnapshots: selectedShapes.map((shape) => ({
			shape: structuredClone(shape),
			initialPagePoint: app.getPagePointById(shape.id),
		})),
	}
}
function applyRotationToSnapshotShapes({ delta, app, snapshot, stage }) {
	const { selectionPageCenter, shapeSnapshots } = snapshot
	app.updateShapes(
		shapeSnapshots.map(({ shape, initialPagePoint }) => {
			const parentTransform = isShapeId(shape.parentId)
				? app.getPageTransformById(shape.parentId)
				: Matrix2d.Identity()
			const newPagePoint = Vec2d.RotWith(initialPagePoint, selectionPageCenter, delta)
			const newLocalPoint = Matrix2d.applyToPoint(
				// use the current parent transform in case it has moved/resized since the start
				// (e.g. if rotating a shape at the edge of a group)
				Matrix2d.Inverse(parentTransform),
				newPagePoint
			)
			const newRotation = canolicalizeRotation(shape.rotation + delta)
			return {
				id: shape.id,
				type: shape.type,
				x: newLocalPoint.x,
				y: newLocalPoint.y,
				rotation: newRotation,
			}
		})
	)
	const changes = []
	shapeSnapshots.forEach(({ shape }) => {
		const current = app.getShapeById(shape.id)
		if (!current) return
		const util = app.getShapeUtil(shape)
		if (stage === 'start' || stage === 'one-off') {
			const changeStart = util.onRotateStart?.(shape)
			if (changeStart) changes.push(changeStart)
		}
		const changeUpdate = util.onRotate?.(shape, current)
		if (changeUpdate) changes.push(changeUpdate)
		if (stage === 'end' || stage === 'one-off') {
			const changeEnd = util.onRotateEnd?.(shape, current)
			if (changeEnd) changes.push(changeEnd)
		}
	})
	if (changes.length > 0) {
		app.updateShapes(changes)
	}
}

// ../packages/editor/src/lib/app/derivations/arrowBindingsIndex.ts
init_define_process()
function isArrowType(shape) {
	return shape.type === 'arrow'
}
var arrowBindingsIndex = (store) => {
	const shapeHistory = store.query.filterHistory('shape')
	const arrowQuery = store.query.records('shape', () => ({ type: { eq: 'arrow' } }))
	function fromScratch() {
		const allArrows = arrowQuery.value
		const bindings2Arrows = {}
		for (const arrow2 of allArrows) {
			const { start, end } = arrow2.props
			if (start.type === 'binding') {
				const arrows = bindings2Arrows[start.boundShapeId]
				if (arrows) arrows.push({ arrowId: arrow2.id, handleId: 'start' })
				else bindings2Arrows[start.boundShapeId] = [{ arrowId: arrow2.id, handleId: 'start' }]
			}
			if (end.type === 'binding') {
				const arrows = bindings2Arrows[end.boundShapeId]
				if (arrows) arrows.push({ arrowId: arrow2.id, handleId: 'end' })
				else bindings2Arrows[end.boundShapeId] = [{ arrowId: arrow2.id, handleId: 'end' }]
			}
		}
		return bindings2Arrows
	}
	return computed('arrowBindingsIndex', (_lastValue, lastComputedEpoch) => {
		if (isUninitialized(_lastValue)) {
			return fromScratch()
		}
		const lastValue = _lastValue
		const diff = shapeHistory.getDiffSince(lastComputedEpoch)
		if (diff === RESET_VALUE) {
			return fromScratch()
		}
		let nextValue = void 0
		function ensureNewArray(boundShapeId) {
			if (!nextValue) {
				nextValue = { ...lastValue }
			}
			if (!nextValue[boundShapeId]) {
				nextValue[boundShapeId] = []
			} else if (nextValue[boundShapeId] === lastValue[boundShapeId]) {
				nextValue[boundShapeId] = [...nextValue[boundShapeId]]
			}
		}
		function removingBinding(boundShapeId, arrowId, handleId) {
			ensureNewArray(boundShapeId)
			nextValue[boundShapeId] = nextValue[boundShapeId].filter(
				(binding) => binding.arrowId !== arrowId || binding.handleId !== handleId
			)
			if (nextValue[boundShapeId].length === 0) {
				delete nextValue[boundShapeId]
			}
		}
		function addBinding(boundShapeId, arrowId, handleId) {
			ensureNewArray(boundShapeId)
			nextValue[boundShapeId].push({ arrowId, handleId })
		}
		for (const changes of diff) {
			for (const newShape of Object.values(changes.added)) {
				if (isArrowType(newShape)) {
					const { start, end } = newShape.props
					if (start.type === 'binding') {
						addBinding(start.boundShapeId, newShape.id, 'start')
					}
					if (end.type === 'binding') {
						addBinding(end.boundShapeId, newShape.id, 'end')
					}
				}
			}
			for (const [prev, next] of Object.values(changes.updated)) {
				if (!isArrowType(prev) || !isArrowType(next)) continue
				for (const handle of ['start', 'end']) {
					const prevTerminal = prev.props[handle]
					const nextTerminal = next.props[handle]
					if (prevTerminal.type === 'binding' && nextTerminal.type === 'point') {
						removingBinding(prevTerminal.boundShapeId, prev.id, handle)
					} else if (prevTerminal.type === 'point' && nextTerminal.type === 'binding') {
						addBinding(nextTerminal.boundShapeId, next.id, handle)
					} else if (
						prevTerminal.type === 'binding' &&
						nextTerminal.type === 'binding' &&
						prevTerminal.boundShapeId !== nextTerminal.boundShapeId
					) {
						removingBinding(prevTerminal.boundShapeId, prev.id, handle)
						addBinding(nextTerminal.boundShapeId, next.id, handle)
					}
				}
			}
			for (const prev of Object.values(changes.removed)) {
				if (isArrowType(prev)) {
					const { start, end } = prev.props
					if (start.type === 'binding') {
						removingBinding(start.boundShapeId, prev.id, 'start')
					}
					if (end.type === 'binding') {
						removingBinding(end.boundShapeId, prev.id, 'end')
					}
				}
			}
		}
		return nextValue ?? lastValue
	})
}

// ../packages/editor/src/lib/app/derivations/parentsToChildrenWithIndexes.ts
init_define_process()
var parentsToChildrenWithIndexes = (store) => {
	const shapeIds = store.query.ids('shape')
	function fromScratch() {
		const result = {}
		shapeIds.value.forEach((id) => {
			const shape = store.get(id)
			if (!result[shape.parentId]) {
				result[shape.parentId] = []
			}
			result[shape.parentId].push([id, shape.index])
		})
		Object.values(result).forEach((arr) => arr.sort((a3, b3) => (a3[1] < b3[1] ? -1 : 1)))
		return result
	}
	return computed('parentsToChildrenWithIndexes', (lastValue, lastComputedEpoch) => {
		if (isUninitialized(lastValue)) {
			return fromScratch()
		}
		const diff = store.history.getDiffSince(lastComputedEpoch)
		if (diff === RESET_VALUE) {
			return fromScratch()
		}
		if (diff.length === 0) return lastValue
		let newValue = null
		const ensureNewArray = (parentId) => {
			if (!newValue) {
				newValue = { ...lastValue }
			}
			if (!newValue[parentId]) {
				newValue[parentId] = []
			} else if (newValue[parentId] === lastValue[parentId]) {
				newValue[parentId] = [...newValue[parentId]]
			}
		}
		const toSort = /* @__PURE__ */ new Set()
		let changes
		for (let i3 = 0, n3 = diff.length; i3 < n3; i3++) {
			changes = diff[i3]
			for (const record of Object.values(changes.added)) {
				if (!isShape(record)) continue
				ensureNewArray(record.parentId)
				newValue[record.parentId].push([record.id, record.index])
				toSort.add(newValue[record.parentId])
			}
			for (const [from, to] of Object.values(changes.updated)) {
				if (!isShape(to)) continue
				if (!isShape(from)) continue
				if (from.parentId !== to.parentId) {
					ensureNewArray(from.parentId)
					ensureNewArray(to.parentId)
					newValue[from.parentId].splice(
						newValue[from.parentId].findIndex((i4) => i4[0] === to.id),
						1
					)
					newValue[to.parentId].push([to.id, to.index])
					toSort.add(newValue[to.parentId])
				} else if (from.index !== to.index) {
					ensureNewArray(to.parentId)
					const idx = newValue[to.parentId].findIndex((i4) => i4[0] === to.id)
					newValue[to.parentId][idx] = [to.id, to.index]
					toSort.add(newValue[to.parentId])
				}
			}
			for (const record of Object.values(changes.removed)) {
				if (!isShape(record)) continue
				ensureNewArray(record.parentId)
				newValue[record.parentId].splice(
					newValue[record.parentId].findIndex((i4) => i4[0] === record.id),
					1
				)
			}
		}
		for (const arr of toSort) {
			arr.sort((a3, b3) => (a3[1] < b3[1] ? -1 : 1))
		}
		return newValue ?? lastValue
	})
}

// ../packages/editor/src/lib/app/derivations/shapeIdsInCurrentPage.ts
init_define_process()
var isShapeInPage = (store, pageId, shape) => {
	while (!PageRecordType.isId(shape.parentId)) {
		const parent = store.get(shape.parentId)
		if (!parent) return false
		shape = parent
	}
	return shape.parentId === pageId
}
var shapeIdsInCurrentPage = (store, getCurrentPageId) => {
	const shapesIndex = store.query.ids('shape')
	let lastPageId = null
	function fromScratch() {
		const currentPageId = getCurrentPageId()
		lastPageId = currentPageId
		return new Set(
			[...shapesIndex.value].filter((id) => isShapeInPage(store, currentPageId, store.get(id)))
		)
	}
	return computed('_shapeIdsInCurrentPage', (prevValue, lastComputedEpoch) => {
		if (isUninitialized(prevValue)) {
			return fromScratch()
		}
		const currentPageId = getCurrentPageId()
		if (currentPageId !== lastPageId) {
			return fromScratch()
		}
		const diff = store.history.getDiffSince(lastComputedEpoch)
		if (diff === RESET_VALUE) {
			return fromScratch()
		}
		const builder = new IncrementalSetConstructor(prevValue)
		for (const changes of diff) {
			for (const record of Object.values(changes.added)) {
				if (isShape(record) && isShapeInPage(store, currentPageId, record)) {
					builder.add(record.id)
				}
			}
			for (const [_from, to] of Object.values(changes.updated)) {
				if (isShape(to)) {
					if (isShapeInPage(store, currentPageId, to)) {
						builder.add(to.id)
					} else {
						builder.remove(to.id)
					}
				}
			}
			for (const id of Object.keys(changes.removed)) {
				if (isShapeId(id)) {
					builder.remove(id)
				}
			}
		}
		const result = builder.get()
		if (!result) {
			return prevValue
		}
		return withDiff(result.value, result.diff)
	})
}

// ../packages/editor/src/lib/app/managers/ActiveAreaManager.ts
init_define_process()
var DEFAULT_OFFSETS = {
	top: 10,
	left: 10,
	bottom: 10,
	right: 10,
}
function getActiveAreaScreenSpace(app) {
	const containerEl = app.getContainer()
	const el = containerEl.querySelector('*[data-tldraw-area="active-drawing"]')
	const out = {
		...DEFAULT_OFFSETS,
		width: 0,
		height: 0,
	}
	if (el && containerEl) {
		const cBbbox = containerEl.getBoundingClientRect()
		const bbox = el.getBoundingClientRect()
		out.top = bbox.top
		out.left = bbox.left
		out.bottom = cBbbox.height - bbox.bottom
		out.right = cBbbox.width - bbox.right
	}
	out.width = app.viewportScreenBounds.width - out.left - out.right
	out.height = app.viewportScreenBounds.height - out.top - out.bottom
	return out
}
function getActiveAreaPageSpace(app) {
	const out = getActiveAreaScreenSpace(app)
	const z2 = app.zoomLevel
	out.left /= z2
	out.right /= z2
	out.top /= z2
	out.bottom /= z2
	out.width /= z2
	out.height /= z2
	return out
}
var ActiveAreaManager = class {
	constructor(app) {
		this.app = app
		window.addEventListener('resize', this.updateOffsets)
		this.app.disposables.add(this.dispose)
	}
	offsets = atom('activeAreaOffsets', DEFAULT_OFFSETS)
	updateOffsets = () => {
		const offsets = getActiveAreaPageSpace(this.app)
		this.offsets.set(offsets)
	}
	// Clear the listener
	dispose = () => {
		window.addEventListener('resize', this.updateOffsets)
	}
}

// ../packages/editor/src/lib/app/managers/CameraManager.ts
init_define_process()
var CAMERA_SETTLE_TIMEOUT = 12
var CameraManager = class {
	constructor(app) {
		this.app = app
	}
	state = atom('camera state', 'idle')
	timeoutRemaining = 0
	decay = (elapsed) => {
		this.timeoutRemaining -= elapsed
		if (this.timeoutRemaining <= 0) {
			this.state.set('idle')
			this.app.off('tick', this.decay)
			this.app.updateCullingBounds()
		}
	}
	tick = () => {
		this.timeoutRemaining = CAMERA_SETTLE_TIMEOUT
		if (this.state.__unsafe__getWithoutCapture() === 'idle') {
			this.state.set('moving')
			this.app.on('tick', this.decay)
		}
	}
}

// ../packages/editor/src/lib/app/managers/ClickManager.ts
init_define_process()
var MAX_CLICK_DISTANCE = 40
var ClickManager = class {
	constructor(app) {
		this.app = app
	}
	_clickId = ''
	_clickTimeout
	_clickScreenPoint
	_previousScreenPoint
	_getClickTimeout = (state, id = uniqueId()) => {
		this._clickId = id
		clearTimeout(this._clickTimeout)
		this._clickTimeout = setTimeout(
			() => {
				if (this._clickState === state && this._clickId === id) {
					switch (this._clickState) {
						case 'pendingTriple': {
							this.app.dispatch({
								...this.lastPointerInfo,
								type: 'click',
								name: 'double_click',
								phase: 'settle',
							})
							break
						}
						case 'pendingQuadruple': {
							this.app.dispatch({
								...this.lastPointerInfo,
								type: 'click',
								name: 'triple_click',
								phase: 'settle',
							})
							break
						}
						case 'pendingOverflow': {
							this.app.dispatch({
								...this.lastPointerInfo,
								type: 'click',
								name: 'quadruple_click',
								phase: 'settle',
							})
							break
						}
						default: {
						}
					}
					this._clickState = 'idle'
				}
			},
			state === 'idle' || state === 'pendingDouble' ? DOUBLE_CLICK_DURATION : MULTI_CLICK_DURATION
		)
	}
	/**
	 * The current click state.
	 *
	 * @internal
	 */
	_clickState = 'idle'
	/**
	 * The current click state.
	 *
	 * @public
	 */
	get clickState() {
		return this._clickState
	}
	lastPointerInfo = {}
	/**
	 * Start the double click timeout.
	 *
	 * @param info - The event info.
	 */
	transformPointerDownEvent = (info) => {
		if (!this._clickState) return info
		this._clickScreenPoint = Vec2d.From(info.point)
		if (
			this._previousScreenPoint &&
			this._previousScreenPoint.dist(this._clickScreenPoint) > MAX_CLICK_DISTANCE
		) {
			this._clickState = 'idle'
		}
		this._previousScreenPoint = this._clickScreenPoint
		this.lastPointerInfo = info
		switch (this._clickState) {
			case 'idle': {
				this._clickState = 'pendingDouble'
				this._clickTimeout = this._getClickTimeout(this._clickState)
				return info
			}
			case 'pendingDouble': {
				this._clickState = 'pendingTriple'
				this._clickTimeout = this._getClickTimeout(this._clickState)
				return {
					...info,
					type: 'click',
					name: 'double_click',
					phase: 'down',
				}
			}
			case 'pendingTriple': {
				this._clickState = 'pendingQuadruple'
				this._clickTimeout = this._getClickTimeout(this._clickState)
				return {
					...info,
					type: 'click',
					name: 'triple_click',
					phase: 'down',
				}
			}
			case 'pendingQuadruple': {
				this._clickState = 'pendingOverflow'
				this._clickTimeout = this._getClickTimeout(this._clickState)
				return {
					...info,
					type: 'click',
					name: 'quadruple_click',
					phase: 'down',
				}
			}
			case 'pendingOverflow': {
				this._clickState = 'overflow'
				this._clickTimeout = this._getClickTimeout(this._clickState)
				return info
			}
			default: {
				this._clickTimeout = this._getClickTimeout(this._clickState)
				return info
			}
		}
	}
	/**
	 * Emit click_up events on pointer up.
	 *
	 * @param info - The event info.
	 */
	transformPointerUpEvent = (info) => {
		if (!this._clickState) return info
		this._clickScreenPoint = Vec2d.From(info.point)
		switch (this._clickState) {
			case 'pendingTriple': {
				return {
					...this.lastPointerInfo,
					type: 'click',
					name: 'double_click',
					phase: 'up',
				}
			}
			case 'pendingQuadruple': {
				return {
					...this.lastPointerInfo,
					type: 'click',
					name: 'triple_click',
					phase: 'up',
				}
			}
			case 'pendingOverflow': {
				return {
					...this.lastPointerInfo,
					type: 'click',
					name: 'quadruple_click',
					phase: 'up',
				}
			}
			default: {
				return info
			}
		}
	}
	/**
	 * Cancel the double click timeout.
	 *
	 * @internal
	 */
	cancelDoubleClickTimeout = () => {
		this._clickTimeout = clearTimeout(this._clickTimeout)
		this._clickState = 'idle'
	}
	/**
	 * Handle a move event, possibly cancelling the click timeout.
	 *
	 * @internal
	 */
	handleMove = () => {
		if (
			this._clickState !== 'idle' &&
			this._clickScreenPoint &&
			this._clickScreenPoint.dist(this.app.inputs.currentScreenPoint) >
				(this.app.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE)
		) {
			this.cancelDoubleClickTimeout()
		}
	}
}

// ../packages/editor/src/lib/app/managers/DprManager.ts
init_define_process()
var DprManager = class {
	constructor(app) {
		this.app = app
		this.rebind()
		this.app.disposables.add(this.dispose)
	}
	_currentMM
	// Set a listener to update the dpr when the device pixel ratio changes
	rebind() {
		this.dispose()
		this._currentMM = this.getMedia()
		this._currentMM?.addEventListener('change', this.updateDevicePixelRatio)
	}
	dpr = atom('devicePixelRatio', typeof window === 'undefined' ? 1 : window.devicePixelRatio)
	// Get the media query list for the device pixel ratio
	getMedia() {
		if (window.matchMedia) {
			return matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`)
		}
	}
	// Update the device pixel ratio atom
	updateDevicePixelRatio = () => {
		this.dpr.set(window.devicePixelRatio)
		this.rebind()
	}
	// Clear the listener
	dispose = () => {
		this._currentMM?.removeEventListener('change', this.updateDevicePixelRatio)
	}
}

// ../packages/editor/src/lib/app/managers/HistoryManager.ts
init_define_process()

// ../packages/editor/src/lib/app/managers/Stack.ts
init_define_process()
function stack2(items) {
	if (items) {
		let result = EMPTY_STACK_ITEM
		while (items.length) {
			result = result.push(items.pop())
		}
		return result
	}
	return EMPTY_STACK_ITEM
}
var EmptyStackItem = class {
	length = 0
	head = null
	tail = this
	push(head) {
		return new StackItem(head, this)
	}
	toArray() {
		return EMPTY_ARRAY
	}
	[Symbol.iterator]() {
		return {
			next() {
				return { value: void 0, done: true }
			},
		}
	}
}
var EMPTY_STACK_ITEM = new EmptyStackItem()
var StackItem = class {
	constructor(head, tail) {
		this.head = head
		this.tail = tail
		this.length = tail.length + 1
	}
	length
	push(head) {
		return new StackItem(head, this)
	}
	toArray() {
		return Array.from(this)
	}
	[Symbol.iterator]() {
		let stack3 = this
		return {
			next() {
				if (stack3.length) {
					const value = stack3.head
					stack3 = stack3.tail
					return { value, done: false }
				} else {
					return { value: void 0, done: true }
				}
			},
		}
	}
}

// ../packages/editor/src/lib/app/managers/HistoryManager.ts
var HistoryManager = class {
	// A flag for whether the user is in a batch operation
	constructor(ctx, onBatchComplete, annotateError2) {
		this.ctx = ctx
		this.onBatchComplete = onBatchComplete
		this.annotateError = annotateError2
	}
	_undos = atom('HistoryManager.undos', stack2())
	// Updated by each action that includes and undo
	_redos = atom('HistoryManager.redos', stack2())
	// Updated when a user undoes
	_batchDepth = 0
	_commands = {}
	get numUndos() {
		return this._undos.value.length
	}
	get numRedos() {
		return this._redos.value.length
	}
	createCommand = (name, constructor, handle) => {
		if (this._commands[name]) {
			throw new Error(`Duplicate command: ${name}`)
		}
		this._commands[name] = handle
		const exec = (...args) => {
			if (!this._batchDepth) {
				this.batch(() => exec(...args))
				return this.ctx
			}
			const result = constructor(...args)
			if (!result) {
				return this.ctx
			}
			const { data, ephemeral, squashing, preservesRedoStack } = result
			this.ignoringUpdates((undos, redos) => {
				handle.do(data)
				return { undos, redos }
			})
			if (!ephemeral) {
				const prev = this._undos.value.head
				if (
					squashing &&
					prev &&
					prev.type === 'command' &&
					prev.name === name &&
					prev.preservesRedoStack === preservesRedoStack
				) {
					this._undos.update((undos) =>
						undos.tail.push({
							...prev,
							id: uniqueId(),
							data: devFreeze(handle.squash(prev.data, data)),
						})
					)
				} else {
					this._undos.update((undos) =>
						undos.push({
							type: 'command',
							name,
							data: devFreeze(data),
							id: uniqueId(),
							preservesRedoStack,
						})
					)
				}
				if (!result.preservesRedoStack) {
					this._redos.set(stack2())
				}
				this.ctx.emit('change-history', { reason: 'push' })
			}
			return this.ctx
		}
		return exec
	}
	batch = (fn) => {
		try {
			this._batchDepth++
			if (this._batchDepth === 1) {
				transact(() => {
					const mostRecentActionId = this._undos.value.head?.id
					fn()
					if (mostRecentActionId !== this._undos.value.head?.id) {
						this.onBatchComplete()
					}
				})
			} else {
				fn()
			}
		} catch (error) {
			this.annotateError(error)
			throw error
		} finally {
			this._batchDepth--
		}
		return this
	}
	ignoringUpdates = (fn) => {
		let undos = this._undos.value
		let redos = this._redos.value
		this._undos.set(stack2())
		this._redos.set(stack2())
		try {
			;({ undos, redos } = transact(() => fn(undos, redos)))
		} finally {
			this._undos.set(undos)
			this._redos.set(redos)
		}
	}
	// History
	_undo = ({ pushToRedoStack, toMark = void 0 }) => {
		this.ignoringUpdates((undos, redos) => {
			if (undos.length === 0) {
				return { undos, redos }
			}
			while (undos.head?.type === 'STOP') {
				const mark = undos.head
				undos = undos.tail
				if (pushToRedoStack) {
					redos = redos.push(mark)
				}
				if (mark.id === toMark) {
					this.ctx.emit(
						'change-history',
						pushToRedoStack ? { reason: 'undo' } : { reason: 'bail', markId: toMark }
					)
					return { undos, redos }
				}
			}
			if (undos.length === 0) {
				this.ctx.emit(
					'change-history',
					pushToRedoStack ? { reason: 'undo' } : { reason: 'bail', markId: toMark }
				)
				return { undos, redos }
			}
			while (undos.head) {
				const command = undos.head
				undos = undos.tail
				if (pushToRedoStack) {
					redos = redos.push(command)
				}
				if (command.type === 'STOP') {
					if (command.onUndo && (!toMark || command.id === toMark)) {
						this.ctx.emit(
							'change-history',
							pushToRedoStack ? { reason: 'undo' } : { reason: 'bail', markId: toMark }
						)
						return { undos, redos }
					}
				} else {
					const handler = this._commands[command.name]
					handler.undo(command.data)
				}
			}
			this.ctx.emit(
				'change-history',
				pushToRedoStack ? { reason: 'undo' } : { reason: 'bail', markId: toMark }
			)
			return { undos, redos }
		})
		return this
	}
	undo = () => {
		this._undo({ pushToRedoStack: true })
		return this
	}
	redo = () => {
		this.ignoringUpdates((undos, redos) => {
			if (redos.length === 0) {
				return { undos, redos }
			}
			while (redos.head?.type === 'STOP') {
				undos = undos.push(redos.head)
				redos = redos.tail
			}
			if (redos.length === 0) {
				this.ctx.emit('change-history', { reason: 'redo' })
				return { undos, redos }
			}
			while (redos.head) {
				const command = redos.head
				undos = undos.push(redos.head)
				redos = redos.tail
				if (command.type === 'STOP') {
					if (command.onRedo) {
						break
					}
				} else {
					const handler = this._commands[command.name]
					if (handler.redo) {
						handler.redo(command.data)
					} else {
						handler.do(command.data)
					}
				}
			}
			this.ctx.emit('change-history', { reason: 'redo' })
			return { undos, redos }
		})
		return this
	}
	bail = () => {
		this._undo({ pushToRedoStack: false })
		return this
	}
	bailToMark = (id) => {
		this._undo({ pushToRedoStack: false, toMark: id })
		return this
	}
	mark = (id = uniqueId(), onUndo = true, onRedo = true) => {
		const mostRecent = this._undos.value.head
		if (mostRecent && mostRecent.type === 'STOP') {
			if (mostRecent.id === id && mostRecent.onUndo === onUndo && mostRecent.onRedo === onRedo) {
				return mostRecent.id
			}
		}
		this._undos.update((undos) => undos.push({ type: 'STOP', id, onUndo, onRedo }))
		this.ctx.emit('mark-history', { id })
		return id
	}
	clear() {
		this._undos.set(stack2())
		this._redos.set(stack2())
	}
}

// ../packages/editor/src/lib/app/managers/SnapManager.ts
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLLineUtil/TLLineUtil.tsx
init_define_process()

// ../packages/editor/src/lib/components/SVGContainer.tsx
init_define_process()
var import_jsx_runtime2 = __toESM(require_jsx_runtime())
function SVGContainer({ children, className = '', ...rest }) {
	return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)('svg', {
		...rest,
		className: `tl-svg-container ${className}`,
		children,
	})
}

// ../packages/editor/src/lib/app/shapeutils/TLShapeUtil.ts
init_define_process()
var points = new WeakMapCache()
var transforms = new WeakMapCache()
var TLShapeUtil = class {
	constructor(app, type) {
		this.app = app
		this.type = type
	}
	/**
	 * Check if a shape is of this type.
	 *
	 * @param shape - The shape to check.
	 * @returns Whether the shape is of this type.
	 * @public
	 */
	is(shape) {
		return shape.type === this.type
	}
	/**
	 * Whether the shape can be scrolled while editing.
	 *
	 * @public
	 */
	canScroll = () => false
	/**
	 * Whether the shape can be bound to by an arrow.
	 *
	 * @public
	 */
	canUnmount = () => true
	/**
	 * Whether the shape can be bound to by an arrow.
	 *
	 * @param _otherShape - The other shape attempting to bind to this shape.
	 * @public
	 */
	canBind = (_shape, _otherShape) => true
	/**
	 * Whether the shape can be double clicked to edit.
	 *
	 * @public
	 */
	canEdit = () => false
	/**
	 * Whether the shape can be resized.
	 *
	 * @public
	 */
	canResize = () => true
	/**
	 * Whether the shape can be cropped.
	 *
	 * @public
	 */
	canCrop = () => false
	/**
	 * Bounds of the shape to edit.
	 *
	 * Note: this could be a text area within a shape for example arrow labels.
	 *
	 * @public
	 */
	getEditingBounds = (shape) => {
		return this.bounds(shape)
	}
	/**
	 * Whether the shape's outline is closed.
	 *
	 * @public
	 */
	isClosed = () => true
	/**
	 * Whether the shape should hide its resize handles when selected.
	 *
	 * @public
	 */
	hideResizeHandles = () => false
	/**
	 * Whether the shape should hide its resize handles when selected.
	 *
	 * @public
	 */
	hideRotateHandle = () => false
	/**
	 * Whether the shape should hide its selection bounds background when selected.
	 *
	 * @public
	 */
	hideSelectionBoundsBg = () => false
	/**
	 * Whether the shape should hide its selection bounds foreground when selected.
	 *
	 * @public
	 */
	hideSelectionBoundsFg = () => false
	/**
	 * Whether the shape's aspect ratio is locked.
	 *
	 * @public
	 */
	isAspectRatioLocked = () => false
	get handlesCache() {
		return this.app.store.createComputedCache('handles:' + this.type, (shape) => {
			return this.getHandles(shape)
		})
	}
	/**
	 * Get the cached handles (this should not be overridden!)
	 *
	 * @param shape - The shape.
	 * @public
	 */
	handles(shape) {
		if (!this.getHandles) return EMPTY_ARRAY
		return this.handlesCache.get(shape.id) ?? EMPTY_ARRAY
	}
	get boundsCache() {
		return this.app.store.createComputedCache('bounds:' + this.type, (shape) => {
			return this.getBounds(shape)
		})
	}
	/**
	 * Get the cached bounds for the shape.
	 *
	 * @param shape - The shape.
	 * @public
	 */
	bounds(shape) {
		const result = this.boundsCache.get(shape.id) ?? new Box2d()
		if (result.width === 0 || result.height === 0) {
			return new Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1))
		}
		return result
	}
	/**
	 * Get the cached transform. Do not override this method!
	 *
	 * @param shape - The shape.
	 * @public
	 */
	transform(shape) {
		return transforms.get(shape, (shape2) =>
			Matrix2d.Compose(Matrix2d.Translate(shape2.x, shape2.y), Matrix2d.Rotate(shape2.rotation))
		)
	}
	/**
	 * Get the cached point. Do not override this method!
	 *
	 * @param shape - The shape.
	 * @public
	 */
	point(shape) {
		return points.get(shape, (shape2) => ({ x: shape2.x, y: shape2.y }))
	}
	get outlineCache() {
		return this.app.store.createComputedCache('outline:' + this.type, (shape) => {
			return this.getOutline(shape)
		})
	}
	/**
	 * Get the shape's outline. Do not override this method!
	 *
	 * @param shape - The shape.
	 * @public
	 */
	outline(shape) {
		return this.outlineCache.get(shape.id) ?? EMPTY_ARRAY
	}
	/**
	 * Get the shape's snap points.
	 *
	 * @param shape - The shape.
	 * @public
	 */
	snapPoints(shape) {
		return this.bounds(shape).snapPoints
	}
	/**
	 * Get the shape's cached center.
	 *
	 * @param shape - The shape.
	 * @public
	 */
	center(shape) {
		return this.getCenter(shape)
	}
	/**
	 * Get whether the shape can receive children of a given type.
	 *
	 * @param type - The shape type.
	 * @public
	 */
	canReceiveNewChildrenOfType(type) {
		return false
	}
	/**
	 * Get whether the shape can receive children of a given type.
	 *
	 * @param shape - The shape type.
	 * @param shapes - The shapes that are being dropped.
	 * @public
	 */
	canDropShapes(shape, shapes) {
		return false
	}
	/**
	 * Get whether a point intersects the shape.
	 *
	 * @param shape - The shape.
	 * @param point - The point to test.
	 * @returns Whether the point intersects the shape.
	 * @public
	 */
	hitTestPoint(shape, point2) {
		return this.bounds(shape).containsPoint(point2)
	}
	/**
	 * Get whether a point intersects the shape.
	 *
	 * @param shape - The shape.
	 * @param A - The line segment's first point.
	 * @param B - The line segment's second point.
	 * @returns Whether the line segment intersects the shape.
	 * @public
	 */
	hitTestLineSegment(shape, A2, B) {
		const outline = this.outline(shape)
		for (let i3 = 0; i3 < outline.length; i3++) {
			const C2 = outline[i3]
			const D3 = outline[(i3 + 1) % outline.length]
			if (linesIntersect(A2, B, C2, D3)) return true
		}
		return false
	}
	/** @internal */
	expandSelectionOutlinePx(shape) {
		return 0
	}
	//  Events
	/**
	 * A callback called just before a shape is created. This method provides a last chance to modify
	 * the created shape.
	 *
	 * @example
	 *
	 * ```ts
	 * onBeforeCreate = (next) => {
	 * 	return { ...next, x: next.x + 1 }
	 * }
	 * ```
	 *
	 * @param next - The next shape.
	 * @returns The next shape or void.
	 * @public
	 */
	onBeforeCreate
	/**
	 * A callback called just before a shape is updated. This method provides a last chance to modify
	 * the updated shape.
	 *
	 * @example
	 *
	 * ```ts
	 * onBeforeUpdate = (prev, next) => {
	 * 	if (prev.x === next.x) {
	 * 		return { ...next, x: next.x + 1 }
	 * 	}
	 * }
	 * ```
	 *
	 * @param prev - The previous shape.
	 * @param next - The next shape.
	 * @returns The next shape or void.
	 * @public
	 */
	onBeforeUpdate
	/**
	 * A callback called when some other shapes are dragged over this one.
	 *
	 * @example
	 *
	 * ```ts
	 * onDragShapesOver = (shape, shapes) => {
	 * 	return { shouldHint: true }
	 * }
	 * ```
	 *
	 * @param shape - The shape.
	 * @param shapes - The shapes that are being dragged over this one.
	 * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.
	 * @public
	 */
	onDragShapesOver
	/**
	 * A callback called when some other shapes are dragged out of this one.
	 *
	 * @param shape - The shape.
	 * @param shapes - The shapes that are being dragged out.
	 * @public
	 */
	onDragShapesOut
	/**
	 * A callback called when some other shapes are dropped over this one.
	 *
	 * @param shape - The shape.
	 * @param shapes - The shapes that are being dropped over this one.
	 * @public
	 */
	onDropShapesOver
	/**
	 * A callback called when a shape starts being resized.
	 *
	 * @param shape - The shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onResizeStart
	/**
	 * A callback called when a shape changes from a resize.
	 *
	 * @param shape - The shape at the start of the resize.
	 * @param info - Info about the resize.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onResize
	/**
	 * A callback called when a shape finishes resizing.
	 *
	 * @param initial - The shape at the start of the resize.
	 * @param current - The current shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onResizeEnd
	/**
	 * A callback called when a shape starts being translated.
	 *
	 * @param shape - The shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onTranslateStart
	/**
	 * A callback called when a shape changes from a translation.
	 *
	 * @param initial - The shape at the start of the translation.
	 * @param current - The current shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onTranslate
	/**
	 * A callback called when a shape finishes translating.
	 *
	 * @param initial - The shape at the start of the translation.
	 * @param current - The current shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onTranslateEnd
	/**
	 * A callback called when a shape starts being rotated.
	 *
	 * @param shape - The shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onRotateStart
	/**
	 * A callback called when a shape changes from a rotation.
	 *
	 * @param initial - The shape at the start of the rotation.
	 * @param current - The current shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onRotate
	/**
	 * A callback called when a shape finishes rotating.
	 *
	 * @param initial - The shape at the start of the rotation.
	 * @param current - The current shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onRotateEnd
	/**
	 * A callback called when a shape's handle changes.
	 *
	 * @param shape - The shape.
	 * @param info - An object containing the handle and whether the handle is 'precise' or not.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onHandleChange
	/**
	 * Not currently used.
	 *
	 * @internal
	 */
	onBindingChange
	/**
	 * A callback called when a shape's children change.
	 *
	 * @param shape - The shape.
	 * @returns An array of shape updates, or void.
	 * @public
	 */
	onChildrenChange
	/**
	 * A callback called when a shape's handle is double clicked.
	 *
	 * @param shape - The shape.
	 * @param handle - The handle that is double-clicked.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onDoubleClickHandle
	/**
	 * A callback called when a shape's edge is double clicked.
	 *
	 * @param shape - The shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onDoubleClickEdge
	/**
	 * A callback called when a shape is double clicked.
	 *
	 * @param shape - The shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onDoubleClick
	/**
	 * A callback called when a shape is clicked.
	 *
	 * @param shape - The shape.
	 * @returns A change to apply to the shape, or void.
	 * @public
	 */
	onClick
	/**
	 * A callback called when a shape finishes being editing.
	 *
	 * @param shape - The shape.
	 * @public
	 */
	onEditEnd
}
__publicField(TLShapeUtil, 'type')
__decorateClass([computed], TLShapeUtil.prototype, 'handlesCache', 1)
__decorateClass([computed], TLShapeUtil.prototype, 'boundsCache', 1)
__decorateClass([computed], TLShapeUtil.prototype, 'outlineCache', 1)

// ../packages/editor/src/lib/app/shapeutils/shared/ShapeFill.tsx
init_define_process()
var React3 = __toESM(require_react())

// ../node_modules/signia-react/dist/esm/index.mjs
init_define_process()

// ../node_modules/signia-react/dist/esm/track.mjs
init_define_process()
var import_react4 = __toESM(require_react(), 1)

// ../node_modules/signia-react/dist/esm/useStateTracking.mjs
init_define_process()
var import_react3 = __toESM(require_react(), 1)
function useStateTracking(name, render) {
	const renderRef = import_react3.default.useRef(render)
	renderRef.current = render
	const [scheduler, subscribe, getSnapshot] = import_react3.default.useMemo(() => {
		let scheduleUpdate = null
		const subscribe2 = (cb) => {
			scheduleUpdate = cb
			return () => {
				scheduleUpdate = null
			}
		}
		const scheduler2 = new EffectScheduler(
			`useStateTracking(${name})`,
			// this is what `scheduler.execute()` will call
			() => renderRef.current?.(),
			// this is what will be invoked when signia detects a change in an upstream reactive value
			{
				scheduleEffect() {
					scheduleUpdate?.()
				},
			}
		)
		const getSnapshot2 = () => scheduler2.scheduleCount
		return [scheduler2, subscribe2, getSnapshot2]
	}, [name])
	import_react3.default.useSyncExternalStore(subscribe, getSnapshot, getSnapshot)
	import_react3.default.useEffect(() => {
		scheduler.attach()
		scheduler.maybeScheduleEffect()
		return () => {
			scheduler.detach()
		}
	}, [scheduler])
	return scheduler.execute()
}

// ../node_modules/signia-react/dist/esm/track.mjs
var ProxyHandlers = {
	/**
	 * This is a function call trap for functional components. When this is called, we know it means
	 * React did run 'Component()', that means we can use any hooks here to setup our effect and
	 * store.
	 *
	 * With the native Proxy, all other calls such as access/setting to/of properties will be
	 * forwarded to the target Component, so we don't need to copy the Component's own or inherited
	 * properties.
	 *
	 * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
	 */
	apply(Component3, thisArg, argumentsList) {
		return useStateTracking(Component3.displayName ?? Component3.name ?? 'tracked(???)', () =>
			Component3.apply(thisArg, argumentsList)
		)
	},
}
var ReactMemoSymbol = Symbol.for('react.memo')
var ReactForwardRefSymbol = Symbol.for('react.forward_ref')
function track(baseComponent) {
	let compare = null
	const $$typeof = baseComponent['$$typeof']
	if ($$typeof === ReactMemoSymbol) {
		baseComponent = baseComponent.type
		compare = baseComponent.compare
	}
	if ($$typeof === ReactForwardRefSymbol) {
		return (0, import_react4.memo)(
			(0, import_react4.forwardRef)(new Proxy(baseComponent.render, ProxyHandlers))
		)
	}
	return (0, import_react4.memo)(new Proxy(baseComponent, ProxyHandlers), compare)
}

// ../node_modules/signia-react/dist/esm/useAtom.mjs
init_define_process()
var import_react5 = __toESM(require_react(), 1)

// ../node_modules/signia-react/dist/esm/useComputed.mjs
init_define_process()
var import_react6 = __toESM(require_react(), 1)
function useComputed() {
	const name = arguments[0]
	const compute = arguments[1]
	const opts = arguments.length === 3 ? void 0 : arguments[2]
	const deps = arguments.length === 3 ? arguments[2] : arguments[3]
	return (0, import_react6.useMemo)(() => computed(`useComputed(${name})`, compute, opts), deps)
}

// ../node_modules/signia-react/dist/esm/useValue.mjs
init_define_process()
var import_react7 = __toESM(require_react(), 1)
function useValue() {
	const args = arguments
	const deps = args.length === 3 ? args[2] : [args[0]]
	const name = args.length === 3 ? args[0] : `useValue(${args[0].name})`
	const isInRender = (0, import_react7.useRef)(true)
	isInRender.current = true
	const $val = (0, import_react7.useMemo)(() => {
		if (args.length === 1) {
			return args[0]
		}
		return computed(name, () => {
			if (isInRender.current) {
				return args[1]()
			} else {
				try {
					return args[1]()
				} catch {
					return {}
				}
			}
		})
	}, deps)
	try {
		const { subscribe, getSnapshot } = (0, import_react7.useMemo)(() => {
			return {
				subscribe: (listen) => {
					return react(`useValue(${name})`, () => {
						$val.value
						listen()
					})
				},
				getSnapshot: () => $val.value,
			}
		}, [$val])
		return (0, import_react7.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot)
	} finally {
		isInRender.current = false
	}
}

// ../node_modules/signia-react/dist/esm/wrapJsx.mjs
init_define_process()
var import_react8 = __toESM(require_react(), 1)
var ReactMemoType = Symbol.for('react.memo')
var ReactForwardRefType = Symbol.for('react.forward_ref')

// ../packages/editor/src/lib/app/shapeutils/shared/ShapeFill.tsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime())
var ShapeFill = React3.memo(function ShapeFill2({ d: d3, color, fill }) {
	switch (fill) {
		case 'none': {
			return /* @__PURE__ */ (0,
			import_jsx_runtime3.jsx)('path', { className: 'tl-hitarea-stroke', fill: 'none', d: d3 })
		}
		case 'solid': {
			return /* @__PURE__ */ (0,
			import_jsx_runtime3.jsx)('path', { className: 'tl-hitarea-fill-solid', fill: `var(--palette-${color}-semi)`, d: d3 })
		}
		case 'semi': {
			return /* @__PURE__ */ (0,
			import_jsx_runtime3.jsx)('path', { className: 'tl-hitarea-fill-solid', fill: `var(--palette-solid)`, d: d3 })
		}
		case 'pattern': {
			return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(PatternFill, { color, fill, d: d3 })
		}
	}
})
var PatternFill = function PatternFill2({ d: d3, color }) {
	const app = useApp()
	const zoomLevel = useValue('zoomLevel', () => app.zoomLevel, [app])
	const isDarkMode = useValue('isDarkMode', () => app.isDarkMode, [app])
	const intZoom = Math.ceil(zoomLevel)
	const teenyTiny = app.zoomLevel <= 0.18
	return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime3.jsx)('path', {
				className: 'tl-hitarea-fill-solid',
				fill: `var(--palette-${color}-pattern)`,
				d: d3,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime3.jsx)('path', {
				fill: teenyTiny
					? `var(--palette-${color}-semi)`
					: `url(#${HASH_PATERN_ZOOM_NAMES[intZoom + (isDarkMode ? '_dark' : '_light')]})`,
				d: d3,
			}),
		],
	})
}
function getShapeFillSvg({ d: d3, color, fill, colors }) {
	if (fill === 'none') {
		return
	}
	if (fill === 'pattern') {
		const gEl = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		const path1El = document.createElementNS('http://www.w3.org/2000/svg', 'path')
		path1El.setAttribute('d', d3)
		path1El.setAttribute('fill', colors.pattern[color])
		const path2El = document.createElementNS('http://www.w3.org/2000/svg', 'path')
		path2El.setAttribute('d', d3)
		path2El.setAttribute('fill', `url(#hash_pattern)`)
		gEl.appendChild(path1El)
		gEl.appendChild(path2El)
		return gEl
	}
	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	path.setAttribute('d', d3)
	switch (fill) {
		case 'semi': {
			path.setAttribute('fill', colors.solid)
			break
		}
		case 'solid': {
			{
				path.setAttribute('fill', colors.semi[color])
			}
			break
		}
	}
	return path
}
function getSvgWithShapeFill(foregroundPath, backgroundPath) {
	if (backgroundPath) {
		const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		g3.appendChild(backgroundPath)
		g3.appendChild(foregroundPath)
		return g3
	} else {
		return foregroundPath
	}
}

// ../packages/editor/src/lib/app/shapeutils/shared/getPerfectDashProps.ts
init_define_process()
function getPerfectDashProps(totalLength, strokeWidth, opts = {}) {
	const {
		closed = false,
		snap = 1,
		start = 'outset',
		end = 'outset',
		lengthRatio = 2,
		style = 'dashed',
	} = opts
	let dashLength = 0
	let dashCount = 0
	let ratio = 1
	let gapLength = 0
	let strokeDashoffset = 0
	switch (style) {
		case 'dashed': {
			ratio = 1
			dashLength = Math.min(strokeWidth * lengthRatio, totalLength / 4)
			break
		}
		case 'dotted': {
			ratio = 100
			dashLength = strokeWidth / ratio
			break
		}
		default: {
			return {
				strokeDasharray: 'none',
				strokeDashoffset: 'none',
			}
		}
	}
	if (!closed) {
		if (start === 'outset') {
			totalLength += dashLength / 2
			strokeDashoffset += dashLength / 2
		} else if (start === 'skip') {
			totalLength -= dashLength
			strokeDashoffset -= dashLength
		}
		if (end === 'outset') {
			totalLength += dashLength / 2
		} else if (end === 'skip') {
			totalLength -= dashLength
		}
	}
	dashCount = Math.floor(totalLength / dashLength / (2 * ratio))
	dashCount -= dashCount % snap
	if (dashCount < 3 && style === 'dashed') {
		if (totalLength / strokeWidth < 5) {
			dashLength = totalLength
			dashCount = 1
			gapLength = 0
		} else {
			dashLength = totalLength * 0.333
			gapLength = totalLength * 0.333
		}
	} else {
		dashCount = Math.max(dashCount, 3)
		dashLength = totalLength / dashCount / (2 * ratio)
		if (closed) {
			strokeDashoffset = dashLength / 2
			gapLength = (totalLength - dashCount * dashLength) / dashCount
		} else {
			gapLength = (totalLength - dashCount * dashLength) / Math.max(1, dashCount - 1)
		}
	}
	return {
		strokeDasharray: [dashLength, gapLength].join(' '),
		strokeDashoffset: strokeDashoffset.toString(),
	}
}

// ../packages/editor/src/lib/app/shapeutils/shared/useForceSolid.ts
init_define_process()
function useForceSolid() {
	const app = useApp()
	return useValue('zoom', () => app.zoomLevel < 0.35, [app])
}

// ../packages/editor/src/lib/app/shapeutils/TLLineUtil/components/getLinePath.ts
init_define_process()

// ../packages/editor/src/lib/utils/svg.ts
init_define_process()
function getPointerInfo(e2, container) {
	e2.isKilled = true
	const { top, left } = container.getBoundingClientRect()
	return {
		point: {
			x: e2.clientX - left,
			y: e2.clientY - top,
			z: e2.pressure,
		},
		shiftKey: e2.shiftKey,
		altKey: e2.altKey,
		ctrlKey: e2.metaKey || e2.ctrlKey,
		pointerId: e2.pointerId,
		button: e2.button,
		isPen: e2.pointerType === 'pen',
	}
}
function precise2(A2) {
	return `${toDomPrecision(A2.x)},${toDomPrecision(A2.y)} `
}
function average(A2, B) {
	return `${toDomPrecision((A2.x + B.x) / 2)},${toDomPrecision((A2.y + B.y) / 2)} `
}
function getSvgPathFromStroke(points2, closed = true) {
	const len = points2.length
	if (len < 2) {
		return ''
	}
	let a3 = points2[0]
	let b3 = points2[1]
	if (len === 2) {
		return `M${precise2(a3)}L${precise2(b3)}`
	}
	let result = ''
	for (let i3 = 2, max = len - 1; i3 < max; i3++) {
		a3 = points2[i3]
		b3 = points2[i3 + 1]
		result += average(a3, b3)
	}
	if (closed) {
		return `M${average(points2[0], points2[1])}Q${precise2(points2[1])}${average(
			points2[1],
			points2[2]
		)}T${result}${average(points2[len - 1], points2[0])}${average(points2[0], points2[1])}Z`
	} else {
		return `M${precise2(points2[0])}Q${precise2(points2[1])}${average(points2[1], points2[2])}${
			points2.length > 3 ? 'T' : ''
		}${result}L${precise2(points2[len - 1])}`
	}
}
function getSvgPathFromStrokePoints(points2, closed = false) {
	const len = points2.length
	if (len < 2) {
		return ''
	}
	let a3 = points2[0].point
	let b3 = points2[1].point
	if (len === 2) {
		return `M${precise2(a3)}L${precise2(b3)}`
	}
	let result = ''
	for (let i3 = 2, max = len - 1; i3 < max; i3++) {
		a3 = points2[i3].point
		b3 = points2[i3 + 1].point
		result += average(a3, b3)
	}
	if (closed) {
		return `M${average(points2[0].point, points2[1].point)}Q${precise2(points2[1].point)}${average(
			points2[1].point,
			points2[2].point
		)}T${result}${average(points2[len - 1].point, points2[0].point)}${average(
			points2[0].point,
			points2[1].point
		)}Z`
	} else {
		return `M${precise2(points2[0].point)}Q${precise2(points2[1].point)}${average(
			points2[1].point,
			points2[2].point
		)}${points2.length > 3 ? 'T' : ''}${result}L${precise2(points2[len - 1].point)}`
	}
}

// ../packages/editor/src/lib/app/shapeutils/TLLineUtil/components/getLinePath.ts
function getLinePoints(spline) {
	const { segments } = spline
	const allPoints = []
	for (let j = 0, k2 = segments.length; j < k2; j++) {
		const segment = segments[j]
		const lut = segment.lut
		const n3 = lut.length - 1
		if (j > 0) {
			allPoints.push(Vec2d.Lrp(lut[0], lut[1], 0.25))
		} else {
			allPoints.push(lut[0])
		}
		for (let i3 = 1; i3 < n3; i3++) {
			allPoints.push(lut[i3])
		}
		if (j < k2 - 1) {
			allPoints.push(Vec2d.Lrp(lut[n3 - 1], lut[n3], 0.75))
		} else {
			allPoints.push(lut[n3])
		}
	}
	return allPoints
}
function getLineDrawFreehandOptions(strokeWidth) {
	return {
		size: strokeWidth,
		thinning: 0.4,
		streamline: 0,
		smoothing: 0.5,
		simulatePressure: true,
		last: true,
	}
}
function getLineStrokePoints(shape, spline, strokeWidth) {
	const points2 = getLinePoints(spline)
	const options = getLineDrawFreehandOptions(strokeWidth)
	return getStrokePoints(points2, options)
}
function getLineDrawStrokeOutlinePoints(shape, spline, strokeWidth) {
	const options = getLineDrawFreehandOptions(strokeWidth)
	return getStrokeOutlinePoints(
		setStrokePointRadii(getLineStrokePoints(shape, spline, strokeWidth), options),
		options
	)
}
function getLineDrawPath(shape, spline, strokeWidth) {
	const stroke = getLineDrawStrokeOutlinePoints(shape, spline, strokeWidth)
	return getSvgPathFromStroke(stroke)
}
function getLineIndicatorPath(shape, spline, strokeWidth) {
	if (shape.props.dash === 'draw') {
		const strokePoints = getLineStrokePoints(shape, spline, strokeWidth)
		return getSvgPathFromStrokePoints(strokePoints)
	}
	return spline.path
}

// ../packages/editor/src/lib/app/shapeutils/TLLineUtil/components/getLineSvg.ts
init_define_process()
function getDrawLineShapeSvg({ shape, strokeWidth, spline, color }) {
	const pfPath = getLineDrawPath(shape, spline, strokeWidth)
	const p3 = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	p3.setAttribute('stroke-width', '0')
	p3.setAttribute('stroke', 'none')
	p3.setAttribute('fill', color)
	p3.setAttribute('d', pfPath)
	return p3
}
function getDashedLineShapeSvg({ dash, strokeWidth, spline, color }) {
	const { segments } = spline
	const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
	g3.setAttribute('stroke', color)
	g3.setAttribute('stroke-width', strokeWidth.toString())
	segments.forEach((segment, i3) => {
		const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(segment.length, strokeWidth, {
			style: dash,
			start: i3 > 0 ? 'outset' : 'none',
			end: i3 < segments.length - 1 ? 'outset' : 'none',
		})
		path.setAttribute('stroke-dasharray', strokeDasharray.toString())
		path.setAttribute('stroke-dashoffset', strokeDashoffset.toString())
		path.setAttribute('d', segment.path)
		path.setAttribute('fill', 'none')
		g3.appendChild(path)
	})
	return g3
}
function getSolidLineShapeSvg({ strokeWidth, spline, color }) {
	const { path } = spline
	const p3 = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	p3.setAttribute('stroke-width', strokeWidth.toString())
	p3.setAttribute('stroke', color)
	p3.setAttribute('fill', 'none')
	p3.setAttribute('d', path)
	return p3
}
function getLineSvg(shape, spline, color, strokeWidth) {
	switch (shape.props.dash) {
		case 'draw':
			return getDrawLineShapeSvg({
				shape,
				strokeWidth,
				spline,
				color,
			})
		case 'solid':
			return getSolidLineShapeSvg({
				strokeWidth,
				spline,
				color,
			})
		default:
			return getDashedLineShapeSvg({
				strokeWidth,
				spline,
				dash: shape.props.dash,
				color,
			})
	}
}

// ../packages/editor/src/lib/app/shapeutils/TLLineUtil/TLLineUtil.tsx
var import_jsx_runtime4 = __toESM(require_jsx_runtime())
var splinesCache = new WeakMapCache()
var handlesCache = new WeakMapCache()
var TLLineUtil = class extends TLShapeUtil {
	hideResizeHandles = () => true
	hideRotateHandle = () => true
	hideSelectionBoundsBg = () => true
	hideSelectionBoundsFg = () => true
	isClosed = () => false
	defaultProps() {
		return {
			opacity: '1',
			dash: 'draw',
			size: 'm',
			color: 'black',
			spline: 'line',
			handles: {
				start: {
					id: 'start',
					type: 'vertex',
					canBind: false,
					index: 'a1',
					x: 0,
					y: 0,
				},
				end: {
					id: 'end',
					type: 'vertex',
					canBind: false,
					index: 'a2',
					x: 0,
					y: 0,
				},
			},
		}
	}
	getBounds(shape) {
		const spline = getSplineForLineShape(shape)
		return spline.bounds
	}
	getCenter(shape) {
		return this.bounds(shape).center
	}
	getHandles(shape) {
		return handlesCache.get(shape.props, () => {
			const handles = shape.props.handles
			const spline = getSplineForLineShape(shape)
			const sortedHandles = Object.values(handles).sort(sortByIndex)
			const results = sortedHandles.slice()
			for (let i3 = 0; i3 < spline.segments.length; i3++) {
				const segment = spline.segments[i3]
				const point2 = segment.getPoint(0.5)
				const index2 = getIndexBetween(sortedHandles[i3].index, sortedHandles[i3 + 1].index)
				results.push({
					id: `mid-${i3}`,
					type: 'create',
					index: index2,
					x: point2.x,
					y: point2.y,
				})
			}
			return results.sort(sortByIndex)
		})
	}
	getOutline(shape) {
		return getLinePoints(getSplineForLineShape(shape))
	}
	//   Events
	onResize = (shape, info) => {
		const { scaleX, scaleY } = info
		const handles = deepCopy(shape.props.handles)
		Object.values(shape.props.handles).forEach(({ id, x: x3, y: y3 }) => {
			handles[id].x = x3 * scaleX
			handles[id].y = y3 * scaleY
		})
		return {
			props: {
				handles,
			},
		}
	}
	onHandleChange = (shape, { handle }) => {
		const next = deepCopy(shape)
		switch (handle.id) {
			case 'start':
			case 'end': {
				next.props.handles[handle.id] = {
					...next.props.handles[handle.id],
					x: handle.x,
					y: handle.y,
				}
				break
			}
			default: {
				const id = 'handle:' + handle.index
				const existing = shape.props.handles[id]
				if (existing) {
					next.props.handles[id] = {
						...existing,
						x: handle.x,
						y: handle.y,
					}
				} else {
					next.props.handles[id] = {
						id,
						type: 'vertex',
						canBind: false,
						index: handle.index,
						x: handle.x,
						y: handle.y,
					}
				}
				break
			}
		}
		return next
	}
	hitTestPoint(shape, point2) {
		const zoomLevel = this.app.zoomLevel
		const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel
		return pointNearToPolyline(point2, this.outline(shape), offsetDist)
	}
	hitTestLineSegment(shape, A2, B) {
		return intersectLineSegmentPolyline(A2, B, this.outline(shape)) !== null
	}
	render(shape) {
		const forceSolid = useForceSolid()
		const spline = getSplineForLineShape(shape)
		const strokeWidth = this.app.getStrokeWidth(shape.props.size)
		const { dash, color } = shape.props
		if (shape.props.spline === 'line') {
			if (dash === 'solid') {
				const outline = spline.points
				const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
				return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(SVGContainer, {
					id: shape.id,
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ShapeFill, {
							d: pathData,
							fill: 'none',
							color,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)('path', {
							d: pathData,
							stroke: 'currentColor',
							strokeWidth,
							fill: 'none',
						}),
					],
				})
			}
			if (dash === 'dashed' || dash === 'dotted') {
				const outline = spline.points
				const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
				return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(SVGContainer, {
					id: shape.id,
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ShapeFill, {
							d: pathData,
							fill: 'none',
							color,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)('g', {
							stroke: 'currentColor',
							strokeWidth,
							children: spline.segments.map((segment, i3) => {
								const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
									segment.length,
									strokeWidth,
									{
										style: dash,
										start: i3 > 0 ? 'outset' : 'none',
										end: i3 < spline.segments.length - 1 ? 'outset' : 'none',
									}
								)
								return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
									'path',
									{
										strokeDasharray,
										strokeDashoffset,
										d: segment.path,
										fill: 'none',
									},
									i3
								)
							}),
						}),
					],
				})
			}
			if (dash === 'draw') {
				const outline = spline.points
				const [innerPathData, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
				return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(SVGContainer, {
					id: shape.id,
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ShapeFill, {
							d: innerPathData,
							fill: 'none',
							color,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)('path', {
							d: outerPathData,
							stroke: 'currentColor',
							strokeWidth,
							fill: 'none',
						}),
					],
				})
			}
		}
		if (shape.props.spline === 'cubic') {
			const splinePath = spline.path
			if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
				return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(SVGContainer, {
					id: shape.id,
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ShapeFill, {
							d: splinePath,
							fill: 'none',
							color,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)('path', {
							strokeWidth,
							stroke: 'currentColor',
							fill: 'none',
							d: splinePath,
						}),
					],
				})
			}
			if (dash === 'dashed' || dash === 'dotted') {
				return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(SVGContainer, {
					id: shape.id,
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ShapeFill, {
							d: splinePath,
							fill: 'none',
							color,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)('g', {
							stroke: 'currentColor',
							strokeWidth,
							children: spline.segments.map((segment, i3) => {
								const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
									segment.length,
									strokeWidth,
									{
										style: dash,
										start: i3 > 0 ? 'outset' : 'none',
										end: i3 < spline.segments.length - 1 ? 'outset' : 'none',
									}
								)
								return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
									'path',
									{
										strokeDasharray,
										strokeDashoffset,
										d: segment.path,
										fill: 'none',
									},
									i3
								)
							}),
						}),
					],
				})
			}
			if (dash === 'draw') {
				return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(SVGContainer, {
					id: shape.id,
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ShapeFill, {
							d: splinePath,
							fill: 'none',
							color,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime4.jsx)('path', {
							d: getLineDrawPath(shape, spline, strokeWidth),
							strokeWidth: 1,
							stroke: 'currentColor',
							fill: 'currentColor',
						}),
					],
				})
			}
		}
	}
	indicator(shape) {
		const strokeWidth = this.app.getStrokeWidth(shape.props.size)
		const spline = getSplineForLineShape(shape)
		const { dash } = shape.props
		let path
		if (shape.props.spline === 'line') {
			const outline = spline.points
			if (dash === 'solid' || dash === 'dotted' || dash === 'dashed') {
				path = 'M' + outline[0] + 'L' + outline.slice(1)
			} else {
				const [innerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
				path = innerPathData
			}
		} else {
			path = getLineIndicatorPath(shape, spline, strokeWidth)
		}
		return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)('path', { d: path })
	}
	toSvg(shape, _font, colors) {
		const { color: _color, size } = shape.props
		const color = colors.fill[_color]
		const spline = getSplineForLineShape(shape)
		return getLineSvg(shape, spline, color, this.app.getStrokeWidth(size))
	}
}
__publicField(TLLineUtil, 'type', 'line')
function getSplineForLineShape(shape) {
	return splinesCache.get(shape.props, () => {
		const { spline, handles } = shape.props
		const handlePoints = Object.values(handles).sort(sortByIndex).map(Vec2d.From)
		switch (spline) {
			case 'cubic': {
				return new CubicSpline2d(handlePoints, handlePoints.length === 2 ? 2 : 1.2, 20)
			}
			case 'line': {
				return new Polyline2d(handlePoints)
			}
		}
	})
}

// ../packages/editor/src/lib/app/managers/SnapManager.ts
var round = (x3) => {
	const decimalPlacesTolerance = 8
	return Math.round(x3 * 10 ** decimalPlacesTolerance) / 10 ** decimalPlacesTolerance
}
function findAdjacentGaps(gaps, shapeId, gapLength, direction, intersection) {
	const matches = gaps.filter(
		(gap) =>
			(direction === 'forward' ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) &&
			round(gap.length) === round(gapLength) &&
			rangeIntersection(
				gap.breadthIntersection[0],
				gap.breadthIntersection[1],
				intersection[0],
				intersection[1]
			)
	)
	if (matches.length === 0) return []
	const nextNodes = /* @__PURE__ */ new Set()
	for (const match of matches) {
		const node = direction === 'forward' ? match.endNode.id : match.startNode.id
		if (!nextNodes.has(node)) {
			nextNodes.add(node)
			matches.push(
				...findAdjacentGaps(
					gaps,
					node,
					gapLength,
					direction,
					rangeIntersection(
						match.breadthIntersection[0],
						match.breadthIntersection[1],
						intersection[0],
						intersection[1]
					)
				)
			)
		}
	}
	return matches
}
function dedupeGapSnaps(snaps) {
	snaps.sort((a3, b3) => b3.gaps.length - a3.gaps.length)
	for (let i3 = snaps.length - 1; i3 > 0; i3--) {
		const snap = snaps[i3]
		for (let j = i3 - 1; j >= 0; j--) {
			const otherSnap = snaps[j]
			if (
				otherSnap.direction === snap.direction &&
				snap.gaps.every(
					(gap) =>
						otherSnap.gaps.some(
							(otherGap) =>
								round(gap.startEdge[0].x) === round(otherGap.startEdge[0].x) &&
								round(gap.startEdge[0].y) === round(otherGap.startEdge[0].y) &&
								round(gap.startEdge[1].x) === round(otherGap.startEdge[1].x) &&
								round(gap.startEdge[1].y) === round(otherGap.startEdge[1].y)
						) &&
						otherSnap.gaps.some(
							(otherGap) =>
								round(gap.endEdge[0].x) === round(otherGap.endEdge[0].x) &&
								round(gap.endEdge[0].y) === round(otherGap.endEdge[0].y) &&
								round(gap.endEdge[1].x) === round(otherGap.endEdge[1].x) &&
								round(gap.endEdge[1].y) === round(otherGap.endEdge[1].y)
						)
				)
			) {
				snaps.splice(i3, 1)
				break
			}
		}
	}
}
var SnapManager = class {
	constructor(app) {
		this.app = app
	}
	_snapLines = atom('snapLines', void 0)
	get lines() {
		return this._snapLines.value ?? EMPTY_ARRAY
	}
	clear() {
		if (this.lines.length) {
			this._snapLines.set(void 0)
		}
	}
	setLines(lines) {
		this._snapLines.set(lines)
	}
	get snapPointsCache() {
		return this.app.store.createComputedCache('snapPoints', (shape) => {
			const pageTransfrorm = this.app.getPageTransformById(shape.id)
			if (!pageTransfrorm) return void 0
			const util = this.app.getShapeUtil(shape)
			const snapPoints = util.snapPoints(shape)
			return snapPoints.map((point2, i3) => {
				const { x: x3, y: y3 } = Matrix2d.applyToPoint(pageTransfrorm, point2)
				return { x: x3, y: y3, id: `${shape.id}:${i3}` }
			})
		})
	}
	get snapThreshold() {
		return 8 / this.app.zoomLevel
	}
	get visibleShapesNotInSelection() {
		const selectedIds = this.app.selectedIds
		const result = /* @__PURE__ */ new Set()
		const processParent = (parentId) => {
			const children = this.app.getSortedChildIds(parentId)
			for (const id of children) {
				const shape = this.app.getShapeById(id)
				if (!shape) continue
				if (shape.type === 'arrow') continue
				if (selectedIds.includes(id)) continue
				if (!this.app.isShapeInViewport(shape.id)) continue
				if (shape.type === 'group') {
					processParent(id)
					continue
				}
				result.add({ id: shape.id, pageBounds: this.app.getPageBoundsById(shape.id) })
				if (shape.type !== 'frame') {
					processParent(id)
				}
			}
		}
		const commonFrameAncestor = this.app.findCommonAncestor(
			compact(selectedIds.map((id) => this.app.getShapeById(id))),
			(parent) => parent.type === 'frame'
		)
		processParent(commonFrameAncestor ?? this.app.currentPageId)
		return result
	}
	get visibleSnapPointsNotInSelection() {
		const result = []
		for (const shape of this.visibleShapesNotInSelection) {
			const snapPoints = this.snapPointsCache.get(shape.id)
			if (snapPoints) {
				result.push(...snapPoints)
			}
		}
		return result
	}
	get visibleGaps() {
		const horizontal = []
		const vertical = []
		const sortedShapesHorizontal = [...this.visibleShapesNotInSelection].sort((a3, b3) => {
			return a3.pageBounds.minX - b3.pageBounds.minX
		})
		for (let i3 = 0; i3 < sortedShapesHorizontal.length; i3++) {
			const startNode = sortedShapesHorizontal[i3]
			for (let j = i3 + 1; j < sortedShapesHorizontal.length; j++) {
				const endNode = sortedShapesHorizontal[j]
				if (
					// is there space between the boxes
					startNode.pageBounds.maxX < endNode.pageBounds.minX && // and they overlap in the y axis
					rangesOverlap(
						startNode.pageBounds.minY,
						startNode.pageBounds.maxY,
						endNode.pageBounds.minY,
						endNode.pageBounds.maxY
					)
				) {
					horizontal.push({
						startNode,
						endNode,
						startEdge: [
							new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.minY),
							new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.maxY),
						],
						endEdge: [
							new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.minY),
							new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.maxY),
						],
						length: endNode.pageBounds.minX - startNode.pageBounds.maxX,
						breadthIntersection: rangeIntersection(
							startNode.pageBounds.minY,
							startNode.pageBounds.maxY,
							endNode.pageBounds.minY,
							endNode.pageBounds.maxY
						),
					})
				}
			}
		}
		const sortedShapesVertical = sortedShapesHorizontal.slice(0).sort((a3, b3) => {
			return a3.pageBounds.minY - b3.pageBounds.minY
		})
		for (let i3 = 0; i3 < sortedShapesVertical.length; i3++) {
			const startNode = sortedShapesVertical[i3]
			for (let j = i3 + 1; j < sortedShapesVertical.length; j++) {
				const endNode = sortedShapesVertical[j]
				if (
					// is there space between the boxes
					startNode.pageBounds.maxY < endNode.pageBounds.minY && // do they overlap in the x axis
					rangesOverlap(
						startNode.pageBounds.minX,
						startNode.pageBounds.maxX,
						endNode.pageBounds.minX,
						endNode.pageBounds.maxX
					)
				) {
					vertical.push({
						startNode,
						endNode,
						startEdge: [
							new Vec2d(startNode.pageBounds.minX, startNode.pageBounds.maxY),
							new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.maxY),
						],
						endEdge: [
							new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.minY),
							new Vec2d(endNode.pageBounds.maxX, endNode.pageBounds.minY),
						],
						length: endNode.pageBounds.minY - startNode.pageBounds.maxY,
						breadthIntersection: rangeIntersection(
							startNode.pageBounds.minX,
							startNode.pageBounds.maxX,
							endNode.pageBounds.minX,
							endNode.pageBounds.maxX
						),
					})
				}
			}
		}
		return { horizontal, vertical }
	}
	snapTranslate({ lockedAxis, initialSelectionPageBounds, initialSelectionSnapPoints, dragDelta }) {
		const isXLocked = lockedAxis === 'x'
		const isYLocked = lockedAxis === 'y'
		const selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta)
		const selectionSnapPoints = initialSelectionSnapPoints.map(({ x: x3, y: y3 }, i3) => ({
			id: 'selection:' + i3,
			x: x3 + dragDelta.x,
			y: y3 + dragDelta.y,
		}))
		const otherNodeSnapPoints = this.visibleSnapPointsNotInSelection
		const nearestSnapsX = []
		const nearestSnapsY = []
		const minOffset = new Vec2d(this.snapThreshold, this.snapThreshold)
		this.findPointSnaps({
			minOffset,
			nearestSnapsX,
			nearestSnapsY,
			otherNodeSnapPoints,
			selectionSnapPoints,
		})
		this.findGapSnaps({ selectionPageBounds, nearestSnapsX, nearestSnapsY, minOffset })
		const nudge = new Vec2d(
			isXLocked ? 0 : nearestSnapsX[0]?.nudge ?? 0,
			isYLocked ? 0 : nearestSnapsY[0]?.nudge ?? 0
		)
		minOffset.x = 0
		minOffset.y = 0
		nearestSnapsX.length = 0
		nearestSnapsY.length = 0
		selectionSnapPoints.forEach((s3) => {
			s3.x += nudge.x
			s3.y += nudge.y
		})
		selectionPageBounds.translate(nudge)
		this.findPointSnaps({
			minOffset,
			nearestSnapsX,
			nearestSnapsY,
			otherNodeSnapPoints,
			selectionSnapPoints,
		})
		this.findGapSnaps({
			selectionPageBounds,
			nearestSnapsX,
			nearestSnapsY,
			minOffset,
		})
		const pointSnaps = this.getPointSnapLines({
			nearestSnapsX,
			nearestSnapsY,
		})
		const gapSnaps = this.getGapSnapLines({
			selectionPageBounds,
			nearestSnapsX,
			nearestSnapsY,
		})
		this._snapLines.set([...gapSnaps, ...pointSnaps])
		return { nudge }
	}
	// for a handle of a line:
	// - find the nearest snap point
	// - return the nudge vector to snap to that point
	// note: this happens within page space
	snapLineHandleTranslate({ lineId, handleId, handlePoint }) {
		const line = this.app.getShapeById(lineId)
		if (!line) {
			return { nudge: new Vec2d(0, 0) }
		}
		const util = this.app.getShapeUtil(TLLineUtil)
		const handles = util.handles(line).sort(sortByIndex)
		if (handles.length < 3) return { nudge: new Vec2d(0, 0) }
		const handleNumber = handles.findIndex((h3) => h3.id === handleId)
		const handle = handles[handleNumber]
		const segmentNumber = handle.type === 'vertex' ? handleNumber / 2 : (handleNumber + 1) / 2
		const spline = getSplineForLineShape(line)
		const ignoreCount = 1
		const pageTransform = this.app.getPageTransform(line)
		const pageHeadSegments = spline.segments
			.slice(0, Math.max(0, segmentNumber - ignoreCount))
			.map((s3) => Matrix2d.applyToPoints(pageTransform, s3.lut))
		const pageTailSegments = spline.segments
			.slice(segmentNumber + ignoreCount)
			.map((s3) => Matrix2d.applyToPoints(pageTransform, s3.lut))
		return this.snapHandleTranslate({
			handlePoint,
			additionalOutlines: [...pageHeadSegments, ...pageTailSegments],
		})
	}
	// for a handle:
	// - find the nearest snap point from all non-selected shapes
	// - return the nudge vector to snap to that point
	// note: this happens within page space
	snapHandleTranslate({ handlePoint, additionalOutlines = [] }) {
		const visibleShapesNotInSelection = this.visibleShapesNotInSelection
		const pageOutlines = []
		for (const visibleShape of visibleShapesNotInSelection) {
			const shape = this.app.getShapeById(visibleShape.id)
			if (shape.type === 'text' || shape.type === 'icon') {
				continue
			}
			const outline = deepCopy(this.app.getOutlineById(visibleShape.id))
			const isClosed = this.app.getShapeUtil(shape).isClosed?.(shape)
			if (isClosed) {
				outline.push(outline[0])
			}
			pageOutlines.push(Matrix2d.applyToPoints(this.app.getPageTransformById(shape.id), outline))
		}
		let minDistance = this.snapThreshold
		let nearestPoint = null
		for (const outline of [...pageOutlines, ...additionalOutlines]) {
			for (let i3 = 0; i3 < outline.length - 1; i3++) {
				const C2 = outline[i3]
				const D3 = outline[i3 + 1]
				const distance = Vec2d.DistanceToLineSegment(C2, D3, handlePoint)
				if (isNaN(distance)) continue
				if (distance < minDistance) {
					minDistance = distance
					nearestPoint = Vec2d.NearestPointOnLineSegment(C2, D3, handlePoint)
				}
			}
		}
		if (nearestPoint) {
			const snapLines = []
			snapLines.push({
				id: uniqueId(),
				type: 'points',
				points: [nearestPoint],
			})
			this._snapLines.set(snapLines)
			return {
				nudge: Vec2d.Sub(nearestPoint, handlePoint),
			}
		}
		return { nudge: new Vec2d(0, 0) }
	}
	snapResize({
		initialSelectionPageBounds,
		dragDelta,
		handle: originalHandle,
		isAspectRatioLocked,
		isResizingFromCenter,
	}) {
		const {
			box: unsnappedResizedPageBounds,
			scaleX,
			scaleY,
		} = Box2d.Resize(
			initialSelectionPageBounds,
			originalHandle,
			isResizingFromCenter ? dragDelta.x * 2 : dragDelta.x,
			isResizingFromCenter ? dragDelta.y * 2 : dragDelta.y,
			isAspectRatioLocked
		)
		let handle = originalHandle
		if (scaleX < 0) {
			handle = flipSelectionHandleX(handle)
		}
		if (scaleY < 0) {
			handle = flipSelectionHandleY(handle)
		}
		if (isResizingFromCenter) {
			unsnappedResizedPageBounds.center = initialSelectionPageBounds.center
		}
		const isXLocked = handle === 'top' || handle === 'bottom'
		const isYLocked = handle === 'left' || handle === 'right'
		const selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds)
		const otherNodeSnapPoints = this.visibleSnapPointsNotInSelection
		const nearestSnapsX = []
		const nearestSnapsY = []
		const minOffset = new Vec2d(this.snapThreshold, this.snapThreshold)
		this.findPointSnaps({
			minOffset,
			nearestSnapsX,
			nearestSnapsY,
			otherNodeSnapPoints,
			selectionSnapPoints,
		})
		const nudge = new Vec2d(
			isXLocked ? 0 : nearestSnapsX[0]?.nudge ?? 0,
			isYLocked ? 0 : nearestSnapsY[0]?.nudge ?? 0
		)
		if (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {
			const primaryNudgeAxis =
				nearestSnapsX.length && nearestSnapsY.length
					? Math.abs(nudge.x) < Math.abs(nudge.y)
						? 'x'
						: 'y'
					: nearestSnapsX.length
					? 'x'
					: 'y'
			const ratio = initialSelectionPageBounds.aspectRatio
			if (primaryNudgeAxis === 'x') {
				nearestSnapsY.length = 0
				nudge.y = nudge.x / ratio
				if (handle === 'bottom_left' || handle === 'top_right') {
					nudge.y = -nudge.y
				}
			} else {
				nearestSnapsX.length = 0
				nudge.x = nudge.y * ratio
				if (handle === 'bottom_left' || handle === 'top_right') {
					nudge.x = -nudge.x
				}
			}
		}
		const snappedDelta = Vec2d.Add(dragDelta, nudge)
		const { box: snappedResizedPageBounds } = Box2d.Resize(
			initialSelectionPageBounds,
			originalHandle,
			isResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x,
			isResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y,
			isAspectRatioLocked
		)
		if (isResizingFromCenter) {
			snappedResizedPageBounds.center = initialSelectionPageBounds.center
		}
		const snappedSelectionPoints = getResizeSnapPointsForHandle('any', snappedResizedPageBounds)
		nearestSnapsX.length = 0
		nearestSnapsY.length = 0
		minOffset.x = 0
		minOffset.y = 0
		this.findPointSnaps({
			minOffset,
			nearestSnapsX,
			nearestSnapsY,
			otherNodeSnapPoints,
			selectionSnapPoints: snappedSelectionPoints,
		})
		const pointSnaps = this.getPointSnapLines({
			nearestSnapsX,
			nearestSnapsY,
		})
		this._snapLines.set([...pointSnaps])
		return { nudge }
	}
	findPointSnaps({
		selectionSnapPoints,
		otherNodeSnapPoints,
		minOffset,
		nearestSnapsX,
		nearestSnapsY,
	}) {
		for (const thisSnapPoint of selectionSnapPoints) {
			for (const otherSnapPoint of otherNodeSnapPoints) {
				const offset = Vec2d.Sub(thisSnapPoint, otherSnapPoint)
				const offsetX = Math.abs(offset.x)
				const offsetY = Math.abs(offset.y)
				if (round(offsetX) <= round(minOffset.x)) {
					if (round(offsetX) < round(minOffset.x)) {
						nearestSnapsX.length = 0
					}
					nearestSnapsX.push({
						type: 'points',
						points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
						nudge: otherSnapPoint.x - thisSnapPoint.x,
					})
					minOffset.x = offsetX
				}
				if (round(offsetY) <= round(minOffset.y)) {
					if (round(offsetY) < round(minOffset.y)) {
						nearestSnapsY.length = 0
					}
					nearestSnapsY.push({
						type: 'points',
						points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
						nudge: otherSnapPoint.y - thisSnapPoint.y,
					})
					minOffset.y = offsetY
				}
			}
		}
	}
	findGapSnaps({ selectionPageBounds, minOffset, nearestSnapsX, nearestSnapsY }) {
		for (const gap of this.visibleGaps.horizontal) {
			if (
				!rangesOverlap(
					gap.breadthIntersection[0],
					gap.breadthIntersection[1],
					selectionPageBounds.minY,
					selectionPageBounds.maxY
				)
			) {
				continue
			}
			const gapMidX = gap.startEdge[0].x + gap.length / 2
			const centerNudge = gapMidX - selectionPageBounds.center.x
			const gapIsLargerThanSelection = gap.length > selectionPageBounds.width
			if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.x)) {
				if (round(Math.abs(centerNudge)) < round(minOffset.x)) {
					nearestSnapsX.length = 0
				}
				minOffset.x = Math.abs(centerNudge)
				const snap = {
					type: 'gap_center',
					gap,
					nudge: centerNudge,
				}
				const otherCenterSnap = nearestSnapsX.find(({ type }) => type === 'gap_center')
				const gapBreadthsOverlap =
					otherCenterSnap &&
					rangeIntersection(
						gap.breadthIntersection[0],
						gap.breadthIntersection[1],
						otherCenterSnap.gap.breadthIntersection[0],
						otherCenterSnap.gap.breadthIntersection[1]
					)
				if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
					nearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap
				} else if (!otherCenterSnap || !gapBreadthsOverlap) {
					nearestSnapsX.push(snap)
				}
			}
			const duplicationLeftX = gap.startNode.pageBounds.minX - gap.length
			const selectionRightX = selectionPageBounds.maxX
			const duplicationLeftNudge = duplicationLeftX - selectionRightX
			if (round(Math.abs(duplicationLeftNudge)) <= round(minOffset.x)) {
				if (round(Math.abs(duplicationLeftNudge)) < round(minOffset.x)) {
					nearestSnapsX.length = 0
				}
				minOffset.x = Math.abs(duplicationLeftNudge)
				nearestSnapsX.push({
					type: 'gap_duplicate',
					gap,
					protrusionDirection: 'left',
					nudge: duplicationLeftNudge,
				})
			}
			const duplicationRightX = gap.endNode.pageBounds.maxX + gap.length
			const selectionLeftX = selectionPageBounds.minX
			const duplicationRightNudge = duplicationRightX - selectionLeftX
			if (round(Math.abs(duplicationRightNudge)) <= round(minOffset.x)) {
				if (round(Math.abs(duplicationRightNudge)) < round(minOffset.x)) {
					nearestSnapsX.length = 0
				}
				minOffset.x = Math.abs(duplicationRightNudge)
				nearestSnapsX.push({
					type: 'gap_duplicate',
					gap,
					protrusionDirection: 'right',
					nudge: duplicationRightNudge,
				})
			}
		}
		for (const gap of this.visibleGaps.vertical) {
			if (
				!rangesOverlap(
					gap.breadthIntersection[0],
					gap.breadthIntersection[1],
					selectionPageBounds.minX,
					selectionPageBounds.maxX
				)
			) {
				continue
			}
			const gapMidY = gap.startEdge[0].y + gap.length / 2
			const centerNudge = gapMidY - selectionPageBounds.center.y
			const gapIsLargerThanSelection = gap.length > selectionPageBounds.height
			if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.y)) {
				if (round(Math.abs(centerNudge)) < round(minOffset.y)) {
					nearestSnapsY.length = 0
				}
				minOffset.y = Math.abs(centerNudge)
				const snap = {
					type: 'gap_center',
					gap,
					nudge: centerNudge,
				}
				const otherCenterSnap = nearestSnapsY.find(({ type }) => type === 'gap_center')
				const gapBreadthsOverlap =
					otherCenterSnap &&
					rangesOverlap(
						otherCenterSnap.gap.breadthIntersection[0],
						otherCenterSnap.gap.breadthIntersection[1],
						gap.breadthIntersection[0],
						gap.breadthIntersection[1]
					)
				if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
					nearestSnapsY[nearestSnapsY.indexOf(otherCenterSnap)] = snap
				} else if (!otherCenterSnap || !gapBreadthsOverlap) {
					nearestSnapsY.push(snap)
				}
				continue
			}
			const duplicationTopY = gap.startNode.pageBounds.minY - gap.length
			const selectionBottomY = selectionPageBounds.maxY
			const duplicationTopNudge = duplicationTopY - selectionBottomY
			if (round(Math.abs(duplicationTopNudge)) <= round(minOffset.y)) {
				if (round(Math.abs(duplicationTopNudge)) < round(minOffset.y)) {
					nearestSnapsY.length = 0
				}
				minOffset.y = Math.abs(duplicationTopNudge)
				nearestSnapsY.push({
					type: 'gap_duplicate',
					gap,
					protrusionDirection: 'top',
					nudge: duplicationTopNudge,
				})
			}
			const duplicationBottomY = gap.endNode.pageBounds.maxY + gap.length
			const selectionTopY = selectionPageBounds.minY
			const duplicationBottomNudge = duplicationBottomY - selectionTopY
			if (round(Math.abs(duplicationBottomNudge)) <= round(minOffset.y)) {
				if (round(Math.abs(duplicationBottomNudge)) < round(minOffset.y)) {
					nearestSnapsY.length = 0
				}
				minOffset.y = Math.abs(duplicationBottomNudge)
				nearestSnapsY.push({
					type: 'gap_duplicate',
					gap,
					protrusionDirection: 'bottom',
					nudge: duplicationBottomNudge,
				})
			}
		}
	}
	getPointSnapLines({ nearestSnapsX, nearestSnapsY }) {
		const snapGroupsX = {}
		const snapGroupsY = {}
		const result = []
		if (nearestSnapsX.length > 0) {
			for (const snap of nearestSnapsX) {
				if (snap.type === 'points') {
					const key = round(snap.points.otherPoint.x)
					if (!snapGroupsX[key]) {
						snapGroupsX[key] = []
					}
					snapGroupsX[key].push(snap.points)
				}
			}
		}
		if (nearestSnapsY.length > 0) {
			for (const snap of nearestSnapsY) {
				if (snap.type === 'points') {
					const key = round(snap.points.otherPoint.y)
					if (!snapGroupsY[key]) {
						snapGroupsY[key] = []
					}
					snapGroupsY[key].push(snap.points)
				}
			}
		}
		for (const [_, snapGroup] of Object.entries(snapGroupsX).concat(Object.entries(snapGroupsY))) {
			result.push({
				id: uniqueId(),
				type: 'points',
				points: dedupe(
					snapGroup
						.map((snap) => Vec2d.From(snap.otherPoint))
						.concat(snapGroup.map((snap) => Vec2d.From(snap.thisPoint))),
					(a3, b3) => a3.equals(b3)
				),
			})
		}
		return result
	}
	getGapSnapLines({ selectionPageBounds, nearestSnapsX, nearestSnapsY }) {
		const selectionSides = {
			top: selectionPageBounds.sides[0],
			right: selectionPageBounds.sides[1],
			// need bottom and left to be sorted asc, which .sides is not.
			bottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],
			left: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]],
		}
		const result = []
		if (nearestSnapsX.length > 0) {
			for (const snap of nearestSnapsX) {
				if (snap.type === 'gap_center') {
					const newGapsLength = (snap.gap.length - selectionPageBounds.width) / 2
					const gapBreadthIntersection = rangeIntersection(
						snap.gap.breadthIntersection[0],
						snap.gap.breadthIntersection[1],
						selectionPageBounds.minY,
						selectionPageBounds.maxY
					)
					result.push({
						type: 'gaps',
						direction: 'horizontal',
						id: uniqueId(),
						gaps: [
							...findAdjacentGaps(
								this.visibleGaps.horizontal,
								snap.gap.startNode.id,
								newGapsLength,
								'backward',
								gapBreadthIntersection
							),
							{
								startEdge: snap.gap.startEdge,
								endEdge: selectionSides.left,
							},
							{
								startEdge: selectionSides.right,
								endEdge: snap.gap.endEdge,
							},
							...findAdjacentGaps(
								this.visibleGaps.horizontal,
								snap.gap.endNode.id,
								newGapsLength,
								'forward',
								gapBreadthIntersection
							),
						],
					})
				}
				if (snap.type === 'gap_duplicate') {
					const gapBreadthIntersection = rangeIntersection(
						snap.gap.breadthIntersection[0],
						snap.gap.breadthIntersection[1],
						selectionPageBounds.minY,
						selectionPageBounds.maxY
					)
					result.push({
						type: 'gaps',
						direction: 'horizontal',
						id: uniqueId(),
						gaps:
							snap.protrusionDirection === 'left'
								? [
										{
											startEdge: selectionSides.right,
											endEdge: [
												Vec2d.Add(snap.gap.startEdge[0], {
													x: -snap.gap.startNode.pageBounds.width,
													y: 0,
												}),
												Vec2d.Add(snap.gap.startEdge[1], {
													x: -snap.gap.startNode.pageBounds.width,
													y: 0,
												}),
											],
										},
										{
											startEdge: snap.gap.startEdge,
											endEdge: snap.gap.endEdge,
										},
										...findAdjacentGaps(
											this.visibleGaps.horizontal,
											snap.gap.endNode.id,
											snap.gap.length,
											'forward',
											gapBreadthIntersection
										),
								  ]
								: [
										...findAdjacentGaps(
											this.visibleGaps.horizontal,
											snap.gap.startNode.id,
											snap.gap.length,
											'backward',
											gapBreadthIntersection
										),
										{
											startEdge: snap.gap.startEdge,
											endEdge: snap.gap.endEdge,
										},
										{
											startEdge: [
												Vec2d.Add(snap.gap.endEdge[0], {
													x: snap.gap.endNode.pageBounds.width,
													y: 0,
												}),
												Vec2d.Add(snap.gap.endEdge[1], {
													x: snap.gap.endNode.pageBounds.width,
													y: 0,
												}),
											],
											endEdge: selectionSides.left,
										},
								  ],
					})
				}
			}
		}
		if (nearestSnapsY.length > 0) {
			for (const snap of nearestSnapsY) {
				if (snap.type === 'gap_center') {
					const newGapsLength = (snap.gap.length - selectionPageBounds.height) / 2
					const gapBreadthIntersection = rangeIntersection(
						snap.gap.breadthIntersection[0],
						snap.gap.breadthIntersection[1],
						selectionPageBounds.minX,
						selectionPageBounds.maxX
					)
					result.push({
						type: 'gaps',
						direction: 'vertical',
						id: uniqueId(),
						gaps: [
							...findAdjacentGaps(
								this.visibleGaps.vertical,
								snap.gap.startNode.id,
								newGapsLength,
								'backward',
								gapBreadthIntersection
							),
							{
								startEdge: snap.gap.startEdge,
								endEdge: selectionSides.top,
							},
							{
								startEdge: selectionSides.bottom,
								endEdge: snap.gap.endEdge,
							},
							...findAdjacentGaps(
								this.visibleGaps.vertical,
								snap.gap.endNode.id,
								newGapsLength,
								'forward',
								gapBreadthIntersection
							),
						],
					})
				}
				if (snap.type === 'gap_duplicate') {
					const gapBreadthIntersection = rangeIntersection(
						snap.gap.breadthIntersection[0],
						snap.gap.breadthIntersection[1],
						selectionPageBounds.minX,
						selectionPageBounds.maxX
					)
					result.push({
						type: 'gaps',
						direction: 'vertical',
						id: uniqueId(),
						gaps:
							snap.protrusionDirection === 'top'
								? [
										{
											startEdge: selectionSides.bottom,
											endEdge: [
												Vec2d.Add(snap.gap.startEdge[0], {
													x: 0,
													y: -snap.gap.startNode.pageBounds.height,
												}),
												Vec2d.Add(snap.gap.startEdge[1], {
													x: 0,
													y: -snap.gap.startNode.pageBounds.height,
												}),
											],
										},
										{
											startEdge: snap.gap.startEdge,
											endEdge: snap.gap.endEdge,
										},
										...findAdjacentGaps(
											this.visibleGaps.vertical,
											snap.gap.endNode.id,
											snap.gap.length,
											'forward',
											gapBreadthIntersection
										),
								  ]
								: [
										...findAdjacentGaps(
											this.visibleGaps.vertical,
											snap.gap.startNode.id,
											snap.gap.length,
											'backward',
											gapBreadthIntersection
										),
										{
											startEdge: snap.gap.startEdge,
											endEdge: snap.gap.endEdge,
										},
										{
											startEdge: [
												Vec2d.Add(snap.gap.endEdge[0], {
													x: 0,
													y: snap.gap.endNode.pageBounds.height,
												}),
												Vec2d.Add(snap.gap.endEdge[1], {
													x: 0,
													y: snap.gap.endNode.pageBounds.height,
												}),
											],
											endEdge: selectionSides.top,
										},
								  ],
					})
				}
			}
		}
		dedupeGapSnaps(result)
		return result
	}
}
__decorateClass([computed], SnapManager.prototype, 'snapPointsCache', 1)
__decorateClass([computed], SnapManager.prototype, 'visibleShapesNotInSelection', 1)
__decorateClass([computed], SnapManager.prototype, 'visibleSnapPointsNotInSelection', 1)
__decorateClass([computed], SnapManager.prototype, 'visibleGaps', 1)
function getResizeSnapPointsForHandle(handle, selectionPageBounds) {
	const { minX, maxX, minY, maxY } = selectionPageBounds
	const result = []
	switch (handle) {
		case 'top':
		case 'left':
		case 'top_left':
		case 'any':
			result.push({
				id: 'top_left',
				handle: 'top_left',
				x: minX,
				y: minY,
			})
	}
	switch (handle) {
		case 'top':
		case 'right':
		case 'top_right':
		case 'any':
			result.push({
				id: 'top_right',
				handle: 'top_right',
				x: maxX,
				y: minY,
			})
	}
	switch (handle) {
		case 'bottom':
		case 'right':
		case 'bottom_right':
		case 'any':
			result.push({
				id: 'bottom_right',
				handle: 'bottom_right',
				x: maxX,
				y: maxY,
			})
	}
	switch (handle) {
		case 'bottom':
		case 'left':
		case 'bottom_left':
		case 'any':
			result.push({
				id: 'bottom_left',
				handle: 'bottom_left',
				x: minX,
				y: maxY,
			})
	}
	return result
}

// ../packages/editor/src/lib/app/managers/TextManager.ts
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLTextUtil/TextHelpers.ts
init_define_process()
var INDENT = '  '
var _TextHelpers = class {
	static insertTextFirefox(field, text) {
		field.setRangeText(
			text,
			field.selectionStart || 0,
			field.selectionEnd || 0,
			'end'
			// Without this, the cursor is either at the beginning or text remains selected
		)
		field.dispatchEvent(
			new InputEvent('input', {
				data: text,
				inputType: 'insertText',
				isComposing: false,
				// TODO: fix @types/jsdom, this shouldn't be required
			})
		)
	}
	/**
	 * Inserts text at the cursor’s position, replacing any selection, with **undo** support and by
	 * firing the input event.
	 */
	static insert(field, text) {
		const document2 = field.ownerDocument
		const initialFocus = document2.activeElement
		if (initialFocus !== field) {
			field.focus()
		}
		if (!document2.execCommand('insertText', false, text)) {
			_TextHelpers.insertTextFirefox(field, text)
		}
		if (initialFocus === document2.body) {
			field.blur()
		} else if (initialFocus instanceof HTMLElement && initialFocus !== field) {
			initialFocus.focus()
		}
	}
	/**
	 * Replaces the entire content, equivalent to field.value = text but with **undo** support and by
	 * firing the input event.
	 */
	static set(field, text) {
		field.select()
		_TextHelpers.insert(field, text)
	}
	/** Get the selected text in a field or an empty string if nothing is selected. */
	static getSelection(field) {
		const { selectionStart, selectionEnd } = field
		return field.value.slice(
			selectionStart ? selectionStart : void 0,
			selectionEnd ? selectionEnd : void 0
		)
	}
	/**
	 * Adds the wrappingText before and after field’s selection (or cursor). If endWrappingText is
	 * provided, it will be used instead of wrappingText at on the right.
	 */
	static wrapSelection(field, wrap2, wrapEnd) {
		const { selectionStart, selectionEnd } = field
		const selection = _TextHelpers.getSelection(field)
		_TextHelpers.insert(field, wrap2 + selection + (wrapEnd ?? wrap2))
		field.selectionStart = (selectionStart || 0) + wrap2.length
		field.selectionEnd = (selectionEnd || 0) + wrap2.length
	}
	/** Finds and replaces strings and regex in the field’s value. */
	static replace(field, searchValue, replacer) {
		let drift = 0
		field.value.replace(searchValue, (...args) => {
			const matchStart = drift + args[args.length - 2]
			const matchLength = args[0].length
			field.selectionStart = matchStart
			field.selectionEnd = matchStart + matchLength
			const replacement = typeof replacer === 'string' ? replacer : replacer(...args)
			_TextHelpers.insert(field, replacement)
			field.selectionStart = matchStart
			drift += replacement.length - matchLength
			return replacement
		})
	}
	static findLineEnd(value, currentEnd) {
		const lastLineStart = value.lastIndexOf('\n', currentEnd - 1) + 1
		if (value.charAt(lastLineStart) !== '	') {
			return currentEnd
		}
		return lastLineStart + 1
	}
	static indent(element) {
		const { selectionStart, selectionEnd, value } = element
		const selectedContrast = value.slice(selectionStart, selectionEnd)
		const lineBreakCount = /\n/g.exec(selectedContrast)?.length
		if (lineBreakCount && lineBreakCount > 0) {
			const firstLineStart = value.lastIndexOf('\n', selectionStart - 1) + 1
			const newSelection = element.value.slice(firstLineStart, selectionEnd - 1)
			const indentedText = newSelection.replace(
				/^|\n/g,
				// Match all line starts
				`$&${INDENT}`
			)
			const replacementsCount = indentedText.length - newSelection.length
			element.setSelectionRange(firstLineStart, selectionEnd - 1)
			_TextHelpers.insert(element, indentedText)
			element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount)
		} else {
			_TextHelpers.insert(element, INDENT)
		}
	}
	// The first line should always be unindented
	// The last line should only be unindented if the selection includes any characters after \n
	static unindent(element) {
		const { selectionStart, selectionEnd, value } = element
		const firstLineStart = value.lastIndexOf('\n', selectionStart - 1) + 1
		const minimumSelectionEnd = _TextHelpers.findLineEnd(value, selectionEnd)
		const newSelection = element.value.slice(firstLineStart, minimumSelectionEnd)
		const indentedText = newSelection.replace(/(^|\n)(\t| {1,2})/g, '$1')
		const replacementsCount = newSelection.length - indentedText.length
		element.setSelectionRange(firstLineStart, minimumSelectionEnd)
		_TextHelpers.insert(element, indentedText)
		const firstLineIndentation = /\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))
		const difference = firstLineIndentation ? firstLineIndentation[0].length : 0
		const newSelectionStart = selectionStart - difference
		element.setSelectionRange(
			selectionStart - difference,
			Math.max(newSelectionStart, selectionEnd - replacementsCount)
		)
	}
	static indentCE(element) {
		const selection = window.getSelection()
		const value = element.innerText
		const selectionStart = getCaretIndex(element) ?? 0
		const selectionEnd = getCaretIndex(element) ?? 0
		const selectedContrast = value.slice(selectionStart, selectionEnd)
		const lineBreakCount = /\n/g.exec(selectedContrast)?.length
		if (lineBreakCount && lineBreakCount > 0) {
			const firstLineStart = value.lastIndexOf('\n', selectionStart - 1) + 1
			const newSelection = value.slice(firstLineStart, selectionEnd - 1)
			const indentedText = newSelection.replace(
				/^|\n/g,
				// Match all line starts
				`$&${INDENT}`
			)
			const replacementsCount = indentedText.length - newSelection.length
			if (selection) {
				selection.setBaseAndExtent(
					element,
					selectionStart + 1,
					element,
					selectionEnd + replacementsCount
				)
			}
		} else {
			const selection2 = window.getSelection()
			element.innerText = value.slice(0, selectionStart) + INDENT + value.slice(selectionStart)
			selection2?.setBaseAndExtent(element, selectionStart + 1, element, selectionStart + 2)
		}
	}
	static unindentCE(element) {
		const selection = window.getSelection()
		const value = element.innerText
		const selectionStart = getCaretIndex(element) ?? 0
		const selectionEnd = getCaretIndex(element) ?? 0
		const firstLineStart = value.lastIndexOf('\n', selectionStart - 1) + 1
		const minimumSelectionEnd = _TextHelpers.findLineEnd(value, selectionEnd)
		const newSelection = value.slice(firstLineStart, minimumSelectionEnd)
		const indentedText = newSelection.replace(/(^|\n)(\t| {1,2})/g, '$1')
		const replacementsCount = newSelection.length - indentedText.length
		if (selection) {
			selection.setBaseAndExtent(element, firstLineStart, element, minimumSelectionEnd)
			const firstLineIndentation = /\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))
			const difference = firstLineIndentation ? firstLineIndentation[0].length : 0
			const newSelectionStart = selectionStart - difference
			selection.setBaseAndExtent(
				element,
				selectionStart - difference,
				element,
				Math.max(newSelectionStart, selectionEnd - replacementsCount)
			)
		}
	}
	static normalizeText(text) {
		return text.replace(_TextHelpers.fixNewLines, '\n')
	}
	static normalizeTextForDom(text) {
		return text
			.replace(_TextHelpers.fixNewLines, '\n')
			.split('\n')
			.map((x3) => x3 || ' ')
			.join('\n')
	}
}
var TextHelpers = _TextHelpers
__publicField(TextHelpers, 'fixNewLines', /\r?\n|\r/g)
function getCaretIndex(element) {
	if (typeof window.getSelection === 'undefined') return
	const selection = window.getSelection()
	if (!selection) return
	let position = 0
	if (selection.rangeCount !== 0) {
		const range = selection.getRangeAt(0)
		const preCaretRange = range.cloneRange()
		preCaretRange.selectNodeContents(element)
		preCaretRange.setEnd(range.endContainer, range.endOffset)
		position = preCaretRange.toString().length
	}
	return position
}

// ../packages/editor/src/lib/app/managers/TextManager.ts
var textAlignmentsForLtr = {
	start: 'left',
	'start-legacy': 'left',
	middle: 'center',
	'middle-legacy': 'center',
	end: 'right',
	'end-legacy': 'right',
}
var spaceCharacterRegex = /\s/
var TextManager = class {
	constructor(app) {
		this.app = app
	}
	getTextElement() {
		const oldElm = document.querySelector('.tl-text-measure')
		oldElm?.remove()
		const elm = document.createElement('div')
		this.app.getContainer().appendChild(elm)
		elm.id = `__textMeasure_${uniqueId()}`
		elm.classList.add('tl-text')
		elm.classList.add('tl-text-measure')
		elm.tabIndex = -1
		return elm
	}
	measureText = (textToMeasure, opts) => {
		const elm = this.getTextElement()
		elm.setAttribute('dir', 'ltr')
		elm.style.setProperty('font-family', opts.fontFamily)
		elm.style.setProperty('font-style', opts.fontStyle)
		elm.style.setProperty('font-weight', opts.fontWeight)
		elm.style.setProperty('font-size', opts.fontSize + 'px')
		elm.style.setProperty('line-height', opts.lineHeight * opts.fontSize + 'px')
		elm.style.setProperty('width', opts.width)
		elm.style.setProperty('min-width', opts.minWidth ?? null)
		elm.style.setProperty('max-width', opts.maxWidth)
		elm.style.setProperty('padding', opts.padding)
		elm.textContent = TextHelpers.normalizeTextForDom(textToMeasure)
		const rect = elm.getBoundingClientRect()
		return {
			x: 0,
			y: 0,
			w: rect.width,
			h: rect.height,
		}
	}
	/**
	 * Given an html element, measure the position of each span of unbroken
	 * word/white-space characters within any text nodes it contains.
	 */
	measureElementTextNodeSpans(element, { shouldTruncateToFirstLine = false } = {}) {
		const spans = []
		const elmBounds = element.getBoundingClientRect()
		const offsetX = -elmBounds.left
		const offsetY = -elmBounds.top
		const range = new Range()
		const textNode = element.childNodes[0]
		let idx = 0
		let currentSpan = null
		let prevCharWasSpaceCharacter = null
		let prevCharTop = 0
		let didTruncate = false
		for (const childNode of element.childNodes) {
			if (childNode.nodeType !== Node.TEXT_NODE) continue
			for (const char of childNode.textContent ?? '') {
				range.setStart(textNode, idx)
				range.setEnd(textNode, idx + char.length)
				const rects = range.getClientRects()
				const rect = rects[rects.length - 1]
				const top = rect.top + offsetY
				const left = rect.left + offsetX
				const right = rect.right + offsetX
				const isSpaceCharacter = spaceCharacterRegex.test(char)
				if (
					// If we're at a word boundary...
					isSpaceCharacter !== prevCharWasSpaceCharacter || // ...or we're on a different line...
					top !== prevCharTop || // ...or we're at the start of the text and haven't created a span yet...
					!currentSpan
				) {
					if (currentSpan) {
						if (shouldTruncateToFirstLine && top !== prevCharTop) {
							didTruncate = true
							break
						}
						spans.push(currentSpan)
					}
					currentSpan = {
						box: { x: left, y: top, w: rect.width, h: rect.height },
						text: char,
					}
				} else {
					currentSpan.box.w = right - currentSpan.box.x
					currentSpan.text += char
				}
				prevCharWasSpaceCharacter = isSpaceCharacter
				prevCharTop = top
				idx += char.length
			}
		}
		if (currentSpan) {
			spans.push(currentSpan)
		}
		return { spans, didTruncate }
	}
	/**
	 * Measure text into individual spans. Spans are created by rendering the
	 * text, then dividing it up according to line breaks and word boundaries.
	 *
	 * It works by having the browser render the text, then measuring the
	 * position of each character. You can use this to replicate the text-layout
	 * algorithm of the current browser in e.g. an SVG export.
	 */
	measureTextSpans(textToMeasure, opts) {
		const shouldTruncateToFirstLine =
			opts.overflow === 'truncate-ellipsis' || opts.overflow === 'truncate-clip'
		const element = this.getTextElement()
		const elementWidth = Math.ceil(opts.width - opts.padding * 2)
		element.style.setProperty('width', `${elementWidth}px`)
		element.style.setProperty('height', 'min-content')
		element.style.setProperty('dir', 'ltr')
		element.style.setProperty('font-size', `${opts.fontSize}px`)
		element.style.setProperty('font-family', opts.fontFamily)
		element.style.setProperty('font-weight', opts.fontWeight)
		element.style.setProperty('line-height', `${opts.lineHeight * opts.fontSize}px`)
		element.style.setProperty('text-align', textAlignmentsForLtr[opts.textAlign])
		if (shouldTruncateToFirstLine) {
			element.style.setProperty('overflow-wrap', 'anywhere')
			element.style.setProperty('word-break', 'break-all')
		}
		element.textContent = textToMeasure
		const { spans, didTruncate } = this.measureElementTextNodeSpans(element, {
			shouldTruncateToFirstLine,
		})
		if (opts.overflow === 'truncate-ellipsis' && didTruncate) {
			element.textContent = '\u2026'
			const ellipsisWidth = Math.ceil(this.measureElementTextNodeSpans(element).spans[0].box.w)
			element.style.setProperty('width', `${elementWidth - ellipsisWidth}px`)
			element.textContent = textToMeasure
			const truncatedSpans = this.measureElementTextNodeSpans(element, {
				shouldTruncateToFirstLine: true,
			}).spans
			const lastSpan = truncatedSpans[truncatedSpans.length - 1]
			truncatedSpans.push({
				text: '\u2026',
				box: {
					x: Math.min(lastSpan.box.x + lastSpan.box.w, opts.width - opts.padding - ellipsisWidth),
					y: lastSpan.box.y,
					w: ellipsisWidth,
					h: lastSpan.box.h,
				},
			})
			return truncatedSpans
		}
		element.remove()
		return spans
	}
}

// ../packages/editor/src/lib/app/managers/TickManager.ts
init_define_process()
var TickManager = class {
	constructor(app) {
		this.app = app
		this.app.disposables.add(this.dispose)
		this.start()
	}
	raf
	isPaused = true
	last = 0
	t = 0
	start = () => {
		this.isPaused = false
		cancelAnimationFrame(this.raf)
		this.raf = requestAnimationFrame(this.tick)
		this.last = Date.now()
	}
	tick = () => {
		if (this.isPaused) {
			return
		}
		const now = Date.now()
		const elapsed = now - this.last
		this.last = now
		this.t += elapsed
		this.app.emit('frame', elapsed)
		if (this.t < 16) {
			this.raf = requestAnimationFrame(this.tick)
			return
		}
		this.t -= 16
		this.updatePointerVelocity(elapsed)
		this.app.emit('tick', elapsed)
		this.raf = requestAnimationFrame(this.tick)
	}
	// Clear the listener
	dispose = () => {
		this.isPaused = true
		cancelAnimationFrame(this.raf)
	}
	prevPoint = new Vec2d()
	updatePointerVelocity = (elapsed) => {
		const {
			prevPoint,
			app: {
				inputs: { currentScreenPoint, pointerVelocity },
			},
		} = this
		if (elapsed === 0) return
		const delta = Vec2d.Sub(currentScreenPoint, prevPoint)
		this.prevPoint = currentScreenPoint.clone()
		const length = delta.len()
		const direction = length ? delta.div(length) : new Vec2d(0, 0)
		const next = pointerVelocity.clone().lrp(direction.mul(length / elapsed), 0.5)
		if (Math.abs(next.x) < 0.01) next.x = 0
		if (Math.abs(next.y) < 0.01) next.y = 0
		if (!pointerVelocity.equals(next)) {
			this.app.inputs.pointerVelocity = next
		}
	}
}

// ../packages/editor/src/lib/app/managers/UserPreferencesManager.ts
init_define_process()
var UserPreferencesManager = class {
	constructor(editor) {
		this.editor = editor
	}
	updateUserPreferences = (userPreferences) => {
		this.editor.config.setUserPreferences({
			...this.editor.config.userPreferences.value,
			...userPreferences,
		})
	}
	get isDarkMode() {
		return this.editor.config.userPreferences.value.isDarkMode
	}
	get id() {
		return this.editor.config.userPreferences.value.id
	}
	get name() {
		return this.editor.config.userPreferences.value.name
	}
	get locale() {
		return this.editor.config.userPreferences.value.locale
	}
	get color() {
		return this.editor.config.userPreferences.value.color
	}
}

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/TLArrowUtil.tsx
init_define_process()
var React7 = __toESM(require_react())

// ../packages/editor/src/lib/app/shapeutils/shared/createTextSvgElementFromSpans.ts
init_define_process()

// ../packages/editor/src/lib/utils/string.ts
init_define_process()
function defaultEmptyAs(str, dflt) {
	if (str.match(/^\s*$/)) {
		return dflt
	}
	return str
}
function correctSpacesToNbsp(input) {
	return input.replace(/\s/g, '\xA0')
}

// ../packages/editor/src/lib/app/shapeutils/shared/createTextSvgElementFromSpans.ts
function createTextSvgElementFromSpans(app, spans, opts) {
	const { padding = 0 } = opts
	const textElm = document.createElementNS('http://www.w3.org/2000/svg', 'text')
	textElm.setAttribute('font-size', opts.fontSize + 'px')
	textElm.setAttribute('font-family', opts.fontFamily)
	textElm.setAttribute('font-style', opts.fontStyle)
	textElm.setAttribute('font-weight', opts.fontWeight)
	textElm.setAttribute('line-height', opts.lineHeight * opts.fontSize + 'px')
	textElm.setAttribute('dominant-baseline', 'mathematical')
	textElm.setAttribute('alignment-baseline', 'mathematical')
	if (spans.length === 0) return textElm
	const bounds = Box2d.From(spans[0].box)
	for (const { box } of spans) {
		bounds.union(box)
	}
	const offsetX = padding + (opts.offsetX ?? 0)
	const offsetY =
		(opts.offsetY ?? 0) +
		opts.fontSize / 2 +
		(opts.verticalTextAlign === 'start'
			? padding
			: opts.verticalTextAlign === 'end'
			? opts.height - padding - bounds.height
			: (Math.ceil(opts.height) - bounds.height) / 2)
	let currentLineTop = null
	for (const { text, box } of spans) {
		const didBreakLine = currentLineTop !== null && box.y > currentLineTop
		if (didBreakLine) {
			const lineBreakTspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
			lineBreakTspan.setAttribute('alignment-baseline', 'mathematical')
			lineBreakTspan.setAttribute('x', offsetX + 'px')
			lineBreakTspan.setAttribute('y', box.y + offsetY + 'px')
			lineBreakTspan.textContent = '\n'
			textElm.appendChild(lineBreakTspan)
		}
		const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
		tspan.setAttribute('alignment-baseline', 'mathematical')
		tspan.setAttribute('x', box.x + offsetX + 'px')
		tspan.setAttribute('y', box.y + offsetY + 'px')
		const cleanText = correctSpacesToNbsp(text)
		tspan.textContent = cleanText
		textElm.appendChild(tspan)
		currentLineTop = box.y
	}
	if (opts.stroke && opts.strokeWidth) {
		textElm.setAttribute('stroke', opts.stroke)
		textElm.setAttribute('stroke-width', opts.strokeWidth + 'px')
	}
	if (opts.fill) {
		textElm.setAttribute('fill', opts.fill)
	}
	return textElm
}

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/arrowheads.ts
init_define_process()
function getArrowPoints(info, side, strokeWidth) {
	const PT = side === 'end' ? info.end.point : info.start.point
	const PB = side === 'end' ? info.start.point : info.end.point
	const compareLength = info.isStraight ? Vec2d.Dist(PB, PT) : Math.abs(info.bodyArc.length)
	const length = Math.max(Math.min(compareLength / 5, strokeWidth * 3), strokeWidth)
	let P0
	if (info.isStraight) {
		P0 = Vec2d.Nudge(PT, PB, length)
	} else {
		const ints = intersectCircleCircle(PT, length, info.handleArc.center, info.handleArc.radius)
		P0 =
			side === 'end'
				? info.handleArc.sweepFlag
					? ints[0]
					: ints[1]
				: info.handleArc.sweepFlag
				? ints[1]
				: ints[0]
	}
	return {
		point: PT,
		int: P0,
	}
}
function getArrowhead({ point: point2, int }) {
	const PL = Vec2d.RotWith(int, point2, PI / 6)
	const PR = Vec2d.RotWith(int, point2, -PI / 6)
	return `M ${PL.x} ${PL.y} L ${point2.x} ${point2.y} L ${PR.x} ${PR.y}`
}
function getTriangleHead({ point: point2, int }) {
	const PL = Vec2d.RotWith(int, point2, PI / 6)
	const PR = Vec2d.RotWith(int, point2, -PI / 6)
	return `M ${PL.x} ${PL.y} L ${point2.x} ${point2.y} L ${PR.x} ${PR.y} Z`
}
function getInvertedTriangleHead({ point: point2, int }) {
	const d3 = Vec2d.Sub(int, point2).div(2)
	const PL = Vec2d.Add(point2, Vec2d.Rot(d3, TAU))
	const PR = Vec2d.Sub(point2, Vec2d.Rot(d3, TAU))
	return `M ${PL.x} ${PL.y} L ${int.x} ${int.y} L ${PR.x} ${PR.y} Z`
}
function getDotHead({ point: point2, int }) {
	const A2 = Vec2d.Lrp(point2, int, 0.45)
	const r3 = Vec2d.Dist(A2, point2)
	return `M ${A2.x - r3},${A2.y}
  a ${r3},${r3} 0 1,0 ${r3 * 2},0
  a ${r3},${r3} 0 1,0 -${r3 * 2},0 `
}
function getDiamondHead({ point: point2, int }) {
	const PB = Vec2d.Lrp(point2, int, 0.75)
	const PL = Vec2d.RotWith(PB, point2, PI / 4)
	const PR = Vec2d.RotWith(PB, point2, -PI / 4)
	const PQ = Vec2d.Lrp(PL, PR, 0.5)
	PQ.add(Vec2d.Sub(PQ, point2))
	return `M ${PQ.x} ${PQ.y} L ${PL.x} ${PL.y} ${point2.x} ${point2.y} L ${PR.x} ${PR.y} Z`
}
function getSquareHead({ int, point: point2 }) {
	const PB = Vec2d.Lrp(point2, int, 0.85)
	const d3 = Vec2d.Sub(PB, point2).div(2)
	const PL1 = Vec2d.Add(point2, Vec2d.Rot(d3, TAU))
	const PR1 = Vec2d.Sub(point2, Vec2d.Rot(d3, TAU))
	const PL2 = Vec2d.Add(PB, Vec2d.Rot(d3, TAU))
	const PR2 = Vec2d.Sub(PB, Vec2d.Rot(d3, TAU))
	return `M ${PL1.x} ${PL1.y} L ${PL2.x} ${PL2.y} L ${PR2.x} ${PR2.y} L ${PR1.x} ${PR1.y} Z`
}
function getBarHead({ int, point: point2 }) {
	const d3 = Vec2d.Sub(int, point2).div(2)
	const PL = Vec2d.Add(point2, Vec2d.Rot(d3, TAU))
	const PR = Vec2d.Sub(point2, Vec2d.Rot(d3, TAU))
	return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y}`
}
function getArrowheadPathForType(info, side, strokeWidth) {
	const type = side === 'end' ? info.end.arrowhead : info.start.arrowhead
	if (type === 'none') return
	const points2 = getArrowPoints(info, side, strokeWidth)
	if (!points2) return
	switch (type) {
		case 'bar':
			return getBarHead(points2)
		case 'square':
			return getSquareHead(points2)
		case 'diamond':
			return getDiamondHead(points2)
		case 'dot':
			return getDotHead(points2)
		case 'inverted':
			return getInvertedTriangleHead(points2)
		case 'arrow':
			return getArrowhead(points2)
		case 'triangle':
			return getTriangleHead(points2)
	}
	return ''
}

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/curved-arrow.ts
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/shared.ts
init_define_process()
function getIsArrowStraight(shape) {
	return Math.abs(shape.props.bend) < 8
}
function getBoundShapeInfoForTerminal(app, terminal) {
	if (terminal.type === 'point') {
		return
	}
	const shape = app.getShapeById(terminal.boundShapeId)
	const util = app.getShapeUtil(shape)
	const transform = app.getPageTransform(shape)
	return {
		shape,
		util,
		transform,
		isExact: terminal.isExact,
		didIntersect: false,
	}
}
function getArrowTerminalInArrowSpace(app, arrowPageTransform, terminal) {
	if (terminal.type === 'point') {
		return Vec2d.From(terminal)
	}
	const boundShape = app.getShapeById(terminal.boundShapeId)
	if (!boundShape) {
		console.error('Expected a bound shape!')
		return new Vec2d(0, 0)
	} else {
		const { point: point2, size } = app.getBounds(boundShape)
		const shapePoint = Vec2d.Add(point2, Vec2d.MulV(terminal.normalizedAnchor, size))
		const pagePoint = Matrix2d.applyToPoint(app.getPageTransform(boundShape), shapePoint)
		const arrowPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pagePoint)
		return arrowPoint
	}
}
function getArrowTerminalsInArrowSpace(app, shape) {
	const arrowPageTransform = app.getPageTransform(shape)
	const start = getArrowTerminalInArrowSpace(app, arrowPageTransform, shape.props.start)
	const end = getArrowTerminalInArrowSpace(app, arrowPageTransform, shape.props.end)
	return { start, end }
}

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/straight-arrow.ts
init_define_process()
function getStraightArrowInfo(app, shape) {
	const { start, end, arrowheadStart, arrowheadEnd } = shape.props
	const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(app, shape)
	const a3 = terminalsInArrowSpace.start.clone()
	const b3 = terminalsInArrowSpace.end.clone()
	const c3 = Vec2d.Med(a3, b3)
	const uAB = Vec2d.Sub(b3, a3).uni()
	const startShapeInfo = getBoundShapeInfoForTerminal(app, start)
	const endShapeInfo = getBoundShapeInfoForTerminal(app, end)
	const arrowPageTransform = app.getPageTransform(shape)
	updateArrowheadPointWithBoundShape(
		b3,
		// <-- will be mutated
		terminalsInArrowSpace.start,
		arrowPageTransform,
		endShapeInfo
	)
	updateArrowheadPointWithBoundShape(
		a3,
		// <-- will be mutated
		terminalsInArrowSpace.end,
		arrowPageTransform,
		startShapeInfo
	)
	let minDist = MIN_ARROW_LENGTH
	const isSelfIntersection =
		startShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape
	if (
		startShapeInfo &&
		endShapeInfo &&
		!isSelfIntersection &&
		!startShapeInfo.isExact &&
		!endShapeInfo.isExact
	) {
		if (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {
			if (startShapeInfo.util.isClosed(startShapeInfo.shape)) {
				a3.setTo(Vec2d.Nudge(b3, a3, minDist))
			}
		} else if (!endShapeInfo.didIntersect) {
			if (endShapeInfo.util.isClosed(endShapeInfo.shape)) {
				b3.setTo(Vec2d.Nudge(a3, b3, minDist))
			}
		}
	}
	const u3 = Vec2d.Sub(b3, a3).uni()
	const didFlip = !Vec2d.Equals(u3, uAB)
	if (!isSelfIntersection) {
		if (startShapeInfo && arrowheadStart !== 'none' && !startShapeInfo.isExact) {
			const offset =
				BOUND_ARROW_OFFSET +
				app.getStrokeWidth(shape.props.size) / 2 +
				('size' in startShapeInfo.shape.props
					? app.getStrokeWidth(startShapeInfo.shape.props.size) / 2
					: 0)
			minDist -= offset
			a3.nudge(b3, offset * (didFlip ? -1 : 1))
		}
		if (endShapeInfo && arrowheadEnd !== 'none' && !endShapeInfo.isExact) {
			const offset =
				BOUND_ARROW_OFFSET +
				app.getStrokeWidth(shape.props.size) / 2 +
				('size' in endShapeInfo.shape.props
					? app.getStrokeWidth(endShapeInfo.shape.props.size) / 2
					: 0)
			minDist -= offset
			b3.nudge(a3, offset * (didFlip ? -1 : 1))
		}
	}
	if (startShapeInfo && endShapeInfo) {
		if (didFlip) {
			b3.setTo(Vec2d.Add(a3, u3.mul(-minDist)))
		} else if (Vec2d.Dist(a3, b3) < MIN_ARROW_LENGTH / 2) {
			b3.setTo(Vec2d.Add(a3, u3.mul(MIN_ARROW_LENGTH / 2)))
		}
	}
	if (didFlip) {
		c3.setTo(Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end))
	} else {
		c3.setTo(Vec2d.Med(a3, b3))
	}
	const length = Vec2d.Dist(a3, b3)
	return {
		isStraight: true,
		start: {
			handle: terminalsInArrowSpace.start,
			point: a3,
			arrowhead: shape.props.arrowheadStart,
		},
		end: {
			handle: terminalsInArrowSpace.end,
			point: b3,
			arrowhead: shape.props.arrowheadEnd,
		},
		middle: c3,
		isValid: length > 0,
		length,
	}
}
function updateArrowheadPointWithBoundShape(point2, opposite, arrowPageTransform, targetShapeInfo) {
	if (targetShapeInfo === void 0) {
		return
	}
	if (targetShapeInfo.isExact) {
		return
	}
	const pageFrom = Matrix2d.applyToPoint(arrowPageTransform, opposite)
	const pageTo = Matrix2d.applyToPoint(arrowPageTransform, point2)
	const targetFrom = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageFrom)
	const targetTo = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageTo)
	const isClosed = targetShapeInfo.util.isClosed(targetShapeInfo.shape)
	const fn = isClosed ? intersectLineSegmentPolygon : intersectLineSegmentPolyline
	const intersection = fn(targetFrom, targetTo, targetShapeInfo.util.outline(targetShapeInfo.shape))
	let targetInt
	if (intersection !== null) {
		targetInt =
			intersection.sort((p1, p22) => Vec2d.Dist(p1, targetFrom) - Vec2d.Dist(p22, targetFrom))[0] ??
			(isClosed ? void 0 : targetTo)
	}
	if (targetInt === void 0) {
		return
	}
	const pageInt = Matrix2d.applyToPoint(targetShapeInfo.transform, targetInt)
	const arrowInt = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pageInt)
	point2.setTo(arrowInt)
	targetShapeInfo.didIntersect = true
}
function getStraightArrowHandlePath(info) {
	return getArrowPath(info.start.handle, info.end.handle)
}
function getSolidStraightArrowPath(info) {
	return getArrowPath(info.start.point, info.end.point)
}
function getArrowPath(start, end) {
	return `M${start.x},${start.y}L${end.x},${end.y}`
}

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/curved-arrow.ts
function getCurvedArrowInfo(app, shape, extraBend = 0) {
	const { arrowheadEnd, arrowheadStart } = shape.props
	const bend = shape.props.bend + extraBend
	if (Math.abs(bend) > Math.abs(shape.props.bend * WAY_TOO_BIG_ARROW_BEND_FACTOR)) {
		return getStraightArrowInfo(app, shape)
	}
	const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(app, shape)
	const med = Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end)
	const u3 = Vec2d.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start).uni()
	const middle = Vec2d.Add(med, u3.per().mul(-bend))
	const startShapeInfo = getBoundShapeInfoForTerminal(app, shape.props.start)
	const endShapeInfo = getBoundShapeInfoForTerminal(app, shape.props.end)
	const a3 = terminalsInArrowSpace.start.clone()
	const b3 = terminalsInArrowSpace.end.clone()
	const c3 = middle.clone()
	const handleArc = getArcInfo(a3, b3, c3)
	const arrowPageTransform = app.getPageTransform(shape)
	if (startShapeInfo && !startShapeInfo.isExact) {
		const startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, a3)
		const endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, b3)
		const centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center)
		const inverseTransform = Matrix2d.Inverse(startShapeInfo.transform)
		const startInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace)
		const endInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace)
		const centerInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace)
		const isClosed = startShapeInfo.util.isClosed(startShapeInfo.shape)
		const fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline
		let point2
		let intersections = fn(
			centerInStartShapeLocalSpace,
			handleArc.radius,
			startShapeInfo.util.outline(startShapeInfo.shape)
		)
		if (intersections) {
			intersections = intersections.filter(
				(pt) =>
					+Vec2d.Clockwise(startInStartShapeLocalSpace, pt, endInStartShapeLocalSpace) ===
					handleArc.sweepFlag
			)
			const angleToMiddle = Vec2d.Angle(handleArc.center, middle)
			const angleToStart = Vec2d.Angle(handleArc.center, terminalsInArrowSpace.start)
			const comparisonAngle = lerpAngles(angleToMiddle, angleToStart, 0.5)
			intersections.sort(
				(p0, p1) =>
					Math.abs(shortAngleDist(comparisonAngle, centerInStartShapeLocalSpace.angle(p0))) -
					Math.abs(shortAngleDist(comparisonAngle, centerInStartShapeLocalSpace.angle(p1)))
			)
			point2 = intersections[0] ?? (isClosed ? void 0 : startInStartShapeLocalSpace)
		} else {
			point2 = isClosed ? void 0 : startInStartShapeLocalSpace
		}
		if (point2) {
			a3.setTo(
				app.getPointInShapeSpace(shape, Matrix2d.applyToPoint(startShapeInfo.transform, point2))
			)
			startShapeInfo.didIntersect = true
			if (arrowheadStart !== 'none') {
				const offset =
					BOUND_ARROW_OFFSET +
					app.getStrokeWidth(shape.props.size) / 2 +
					('size' in startShapeInfo.shape.props
						? app.getStrokeWidth(startShapeInfo.shape.props.size) / 2
						: 0)
				a3.setTo(
					getPointOnCircle(
						handleArc.center.x,
						handleArc.center.y,
						handleArc.radius,
						lerpAngles(
							Vec2d.Angle(handleArc.center, a3),
							Vec2d.Angle(handleArc.center, middle),
							offset / Math.abs(getArcLength(handleArc.center, handleArc.radius, a3, middle))
						)
					)
				)
			}
		}
	}
	if (endShapeInfo && !endShapeInfo.isExact) {
		const startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, a3)
		const endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, b3)
		const centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center)
		const inverseTransform = Matrix2d.Inverse(endShapeInfo.transform)
		const startInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace)
		const endInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace)
		const centerInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace)
		const isClosed = endShapeInfo.util.isClosed(endShapeInfo.shape)
		const fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline
		const angleToMiddle = Vec2d.Angle(handleArc.center, middle)
		const angleToEnd = Vec2d.Angle(handleArc.center, terminalsInArrowSpace.end)
		const comparisonAngle = lerpAngles(angleToMiddle, angleToEnd, 0.5)
		let point2
		let intersections = fn(
			centerInEndShapeLocalSpace,
			handleArc.radius,
			endShapeInfo.util.outline(endShapeInfo.shape)
		)
		if (intersections) {
			intersections = intersections.filter(
				(pt) =>
					+Vec2d.Clockwise(startInEndShapeLocalSpace, pt, endInEndShapeLocalSpace) ===
					handleArc.sweepFlag
			)
			intersections.sort(
				(p0, p1) =>
					Math.abs(shortAngleDist(comparisonAngle, centerInEndShapeLocalSpace.angle(p0))) -
					Math.abs(shortAngleDist(comparisonAngle, centerInEndShapeLocalSpace.angle(p1)))
			)
			point2 = intersections[0] ?? (isClosed ? void 0 : endInEndShapeLocalSpace)
		} else {
			point2 = isClosed ? void 0 : endInEndShapeLocalSpace
		}
		if (point2) {
			b3.setTo(
				app.getPointInShapeSpace(shape, Matrix2d.applyToPoint(endShapeInfo.transform, point2))
			)
			endShapeInfo.didIntersect = true
			if (arrowheadEnd !== 'none') {
				let offset =
					BOUND_ARROW_OFFSET +
					app.getStrokeWidth(shape.props.size) / 2 +
					('size' in endShapeInfo.shape.props
						? app.getStrokeWidth(endShapeInfo.shape.props.size) / 2
						: 0)
				if (Vec2d.Dist(a3, b3) < MIN_ARROW_LENGTH) {
					offset *= -2
				}
				b3.setTo(
					getPointOnCircle(
						handleArc.center.x,
						handleArc.center.y,
						handleArc.radius,
						lerpAngles(
							Vec2d.Angle(handleArc.center, b3),
							Vec2d.Angle(handleArc.center, middle),
							offset / Math.abs(getArcLength(handleArc.center, handleArc.radius, b3, middle))
						)
					)
				)
			}
		}
	}
	const length = Math.abs(getArcLength(handleArc.center, handleArc.radius, a3, b3))
	if (length < MIN_ARROW_LENGTH / 2) {
		a3.setTo(terminalsInArrowSpace.start)
		b3.setTo(terminalsInArrowSpace.end)
	}
	if (
		startShapeInfo &&
		endShapeInfo &&
		startShapeInfo.shape !== endShapeInfo.shape &&
		!startShapeInfo.isExact &&
		!endShapeInfo.isExact
	) {
		const startAngle = Vec2d.Angle(handleArc.center, a3)
		const endAngle = Vec2d.Angle(handleArc.center, b3)
		const offset = handleArc.sweepFlag ? MIN_ARROW_LENGTH : -MIN_ARROW_LENGTH
		const arcLength = getArcLength(handleArc.center, handleArc.radius, b3, a3)
		const {
			center: { x: x3, y: y3 },
			radius,
		} = handleArc
		if (startShapeInfo && !startShapeInfo.didIntersect) {
			a3.setTo(
				getPointOnCircle(x3, y3, radius, lerpAngles(startAngle, endAngle, offset / arcLength))
			)
		}
		if (endShapeInfo && !endShapeInfo.didIntersect) {
			b3.setTo(
				getPointOnCircle(x3, y3, radius, lerpAngles(startAngle, endAngle, -offset / arcLength))
			)
		}
	}
	let midAngle = lerpAngles(
		Vec2d.Angle(handleArc.center, a3),
		Vec2d.Angle(handleArc.center, b3),
		0.5
	)
	let midPoint = getPointOnCircle(
		handleArc.center.x,
		handleArc.center.y,
		handleArc.radius,
		midAngle
	)
	if (+Vec2d.Clockwise(a3, midPoint, b3) !== handleArc.sweepFlag) {
		midAngle += PI
		midPoint = getPointOnCircle(handleArc.center.x, handleArc.center.y, handleArc.radius, midAngle)
	}
	c3.setTo(midPoint)
	const bodyArc = getArcInfo(a3, b3, c3)
	return {
		isStraight: false,
		start: {
			point: a3,
			handle: terminalsInArrowSpace.start,
			arrowhead: shape.props.arrowheadStart,
		},
		end: {
			point: b3,
			handle: terminalsInArrowSpace.end,
			arrowhead: shape.props.arrowheadEnd,
		},
		middle: c3,
		handleArc,
		bodyArc,
		isValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y),
	}
}
function getCurvedArrowHandlePath(info) {
	const {
		start,
		end,
		handleArc: { radius, largeArcFlag, sweepFlag },
	} = info
	return `M${start.handle.x},${start.handle.y} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.handle.x},${end.handle.y}`
}
function getSolidCurvedArrowPath(info) {
	const {
		start,
		end,
		bodyArc: { radius, largeArcFlag, sweepFlag },
	} = info
	return `M${start.point.x},${start.point.y} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.point.x},${end.point.y}`
}
function getArcInfo(a3, b3, c3) {
	const u3 = -2 * (a3.x * (b3.y - c3.y) - a3.y * (b3.x - c3.x) + b3.x * c3.y - c3.x * b3.y)
	const center = {
		x:
			((a3.x * a3.x + a3.y * a3.y) * (c3.y - b3.y) +
				(b3.x * b3.x + b3.y * b3.y) * (a3.y - c3.y) +
				(c3.x * c3.x + c3.y * c3.y) * (b3.y - a3.y)) /
			u3,
		y:
			((a3.x * a3.x + a3.y * a3.y) * (b3.x - c3.x) +
				(b3.x * b3.x + b3.y * b3.y) * (c3.x - a3.x) +
				(c3.x * c3.x + c3.y * c3.y) * (a3.x - b3.x)) /
			u3,
	}
	const radius = Vec2d.Dist(center, a3)
	const sweepFlag = +Vec2d.Clockwise(a3, c3, b3)
	const ab = Math.hypot(a3.y - b3.y, a3.x - b3.x)
	const bc = Math.hypot(b3.y - c3.y, b3.x - c3.x)
	const ca = Math.hypot(c3.y - a3.y, c3.x - a3.x)
	const theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2
	const largeArcFlag = +(PI > theta)
	const size = (PI2 - theta) * (sweepFlag ? 1 : -1)
	const length = size * radius
	return {
		center,
		radius,
		size,
		length,
		largeArcFlag,
		sweepFlag,
	}
}

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/components/ArrowTextLabel.tsx
init_define_process()
var React6 = __toESM(require_react())

// ../packages/editor/src/lib/utils/dom.ts
init_define_process()
var import_react9 = __toESM(require_react())
function loopToHtmlElement(elm) {
	if (elm instanceof HTMLElement) return elm
	if (elm.parentElement) return loopToHtmlElement(elm.parentElement)
	else throw Error('Could not find a parent element of an HTML type!')
}
function preventDefault(event) {
	event.preventDefault()
	if (debugFlags.preventDefaultLogging.value) {
		console.warn('preventDefault called on event:', event)
	}
}
function setPointerCapture(element, event) {
	element.setPointerCapture(event.pointerId)
	if (debugFlags.pointerCaptureTracking.value) {
		const trackingObj = debugFlags.pointerCaptureTrackingObject.value
		trackingObj.set(element, (trackingObj.get(element) ?? 0) + 1)
	}
	if (debugFlags.pointerCaptureLogging.value) {
		console.warn('setPointerCapture called on element:', element, event)
	}
}
function releasePointerCapture(element, event) {
	if (!element.hasPointerCapture(event.pointerId)) {
		return
	}
	element.releasePointerCapture(event.pointerId)
	if (debugFlags.pointerCaptureTracking.value) {
		const trackingObj = debugFlags.pointerCaptureTrackingObject.value
		if (trackingObj.get(element) === 1) {
			trackingObj.delete(element)
		} else if (trackingObj.has(element)) {
			trackingObj.set(element, trackingObj.get(element) - 1)
		} else {
			console.warn('Release without capture')
		}
	}
	if (debugFlags.pointerCaptureLogging.value) {
		console.warn('releasePointerCapture called on element:', element, event)
	}
}
function rotateBoxShadow(rotation, shadows) {
	const cssStrings = shadows.map((shadow) => {
		const { offsetX, offsetY, blur, spread, color } = shadow
		const vec = new Vec2d(offsetX, offsetY)
		const { x: x3, y: y3 } = vec.rot(-rotation)
		return `${x3}px ${y3}px ${blur}px ${spread}px ${color}`
	})
	return cssStrings.join(', ')
}
function usePrefersReducedMotion() {
	const [prefersReducedMotion, setPrefersReducedMotion] = (0, import_react9.useState)(false)
	;(0, import_react9.useEffect)(() => {
		const mql = window.matchMedia('(prefers-reduced-motion: reduce)')
		const handler = () => {
			setPrefersReducedMotion(mql.matches)
		}
		handler()
		mql.addEventListener('change', handler)
		return () => mql.removeEventListener('change', handler)
	}, [])
	return prefersReducedMotion
}
var truncateStringWithEllipsis = (str, maxLength) => {
	return str.length <= maxLength ? str : str.substring(0, maxLength - 3) + '...'
}
var stopEventPropagation = (e2) => e2.stopPropagation()

// ../packages/editor/src/lib/app/shapeutils/shared/useEditableText.ts
init_define_process()
var import_react10 = __toESM(require_react())
function useEditableText(id, type, text) {
	const app = useApp()
	const rInput = (0, import_react10.useRef)(null)
	const isEditing = useValue('isEditing', () => app.pageState.editingId === id, [app, id])
	const rSkipSelectOnFocus = (0, import_react10.useRef)(false)
	const rSelectionRanges = (0, import_react10.useRef)()
	const isEditableFromHover = useValue(
		'is editable hovering',
		() => {
			if (type === 'text' && app.isIn('text') && app.hoveredId === id) {
				return true
			}
			if (app.isIn('select.editing_shape')) {
				const { editingShape } = app
				if (!editingShape) return false
				return (
					// The shape must be hovered
					app.hoveredId === id && // the editing shape must be the same type as this shape
					editingShape.type === type && // and this shape must be capable of being editing in its current form
					app.getShapeUtil(editingShape).canEdit(editingShape)
				)
			}
			return false
		},
		[type, id]
	)
	const handleFocus = (0, import_react10.useCallback)(() => {
		if (isEditableFromHover) return
		requestAnimationFrame(() => {
			const elm = rInput.current
			if (!elm) return
			const shape = app.getShapeById(id)
			if (shape) {
				elm.value = shape.props.text
				if (elm.value.length && !rSkipSelectOnFocus.current) {
					elm.select()
				}
				rSkipSelectOnFocus.current = false
			}
		})
	}, [app, id, isEditableFromHover])
	const handleBlur = (0, import_react10.useCallback)(() => {
		const ranges = rSelectionRanges.current
		requestAnimationFrame(() => {
			const elm = rInput.current
			if (app.isIn('select.editing_shape') && elm) {
				if (ranges) {
					if (!ranges.length) {
						elm.focus()
					} else {
						rSkipSelectOnFocus.current = true
						elm.focus()
						const selection = window.getSelection()
						if (selection) {
							ranges.forEach((range) => selection.addRange(range))
						}
					}
				} else {
					elm.focus()
				}
			} else {
				window.getSelection()?.removeAllRanges()
				app.complete()
			}
		})
	}, [app])
	const handleKeyDown = (0, import_react10.useCallback)(
		(e2) => {
			if (e2.ctrlKey || e2.metaKey) stopEventPropagation(e2)
			switch (e2.key) {
				case 'Enter': {
					if (e2.ctrlKey || e2.metaKey) {
						app.complete()
					}
					break
				}
				case 'Tab': {
					preventDefault(e2)
					if (e2.shiftKey) {
						TextHelpers.unindent(e2.currentTarget)
					} else {
						TextHelpers.indent(e2.currentTarget)
					}
					break
				}
			}
		},
		[app]
	)
	const handleChange = (0, import_react10.useCallback)(
		(e2) => {
			let text2 = TextHelpers.normalizeText(e2.currentTarget.value)
			const untabbedText = text2.replace(/\t/g, INDENT)
			if (untabbedText !== text2) {
				const selectionStart = e2.currentTarget.selectionStart
				e2.currentTarget.value = untabbedText
				e2.currentTarget.selectionStart = selectionStart + (untabbedText.length - text2.length)
				e2.currentTarget.selectionEnd = selectionStart + (untabbedText.length - text2.length)
				text2 = untabbedText
			}
			app.updateShapes([{ id, type, props: { text: text2 } }])
		},
		[app, id, type]
	)
	const isEmpty = text.trim().length === 0
	;(0, import_react10.useEffect)(() => {
		const elm = rInput.current
		if (elm) {
			let updateSelection2 = function () {
				const selection = window.getSelection?.()
				if (selection && selection.type !== 'None') {
					const ranges = []
					if (selection) {
						for (let i3 = 0; i3 < selection.rangeCount; i3++) {
							ranges.push(selection.getRangeAt?.(i3))
						}
					}
					rSelectionRanges.current = ranges
				}
			}
			var updateSelection = updateSelection2
			document.addEventListener('selectionchange', updateSelection2)
			return () => {
				document.removeEventListener('selectionchange', updateSelection2)
			}
		}
	})
	return {
		rInput,
		isEditing,
		isEditableFromHover,
		handleFocus,
		handleBlur,
		handleKeyDown,
		handleChange,
		isEmpty,
	}
}

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/components/ArrowTextLabel.tsx
var import_jsx_runtime5 = __toESM(require_jsx_runtime())
var ArrowTextLabel = React6.memo(function ArrowTextLabel2({
	id,
	text,
	size,
	font,
	position,
	width,
	labelColor,
}) {
	const { rInput, isEditing, handleFocus, handleBlur, handleKeyDown, handleChange, isEmpty } =
		useEditableText(id, 'arrow', text)
	if (!isEditing && isEmpty) {
		return null
	}
	return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)('div', {
		className: 'tl-arrow-label',
		'data-font': font,
		'data-align': 'center',
		'data-hastext': !isEmpty,
		'data-isediting': isEditing,
		style: {
			textAlign: 'center',
			fontSize: ARROW_LABEL_FONT_SIZES[size],
			lineHeight: ARROW_LABEL_FONT_SIZES[size] * TEXT_PROPS.lineHeight + 'px',
			transform: `translate(${position.x}px, ${position.y}px)`,
			color: labelColor,
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)('div', {
			className: 'tl-arrow-label__inner',
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime5.jsx)('p', {
					style: { width: width ? width : '9px' },
					children: text ? TextHelpers.normalizeTextForDom(text) : ' ',
				}),
				isEditing && // Consider replacing with content-editable
					/* @__PURE__ */ (0, import_jsx_runtime5.jsx)('textarea', {
						ref: rInput,
						className: 'tl-text tl-text-input',
						name: 'text',
						tabIndex: -1,
						autoComplete: 'false',
						autoCapitalize: 'false',
						autoCorrect: 'false',
						autoSave: 'false',
						autoFocus: true,
						placeholder: '',
						spellCheck: 'true',
						wrap: 'off',
						dir: 'auto',
						datatype: 'wysiwyg',
						defaultValue: text,
						onFocus: handleFocus,
						onChange: handleChange,
						onKeyDown: handleKeyDown,
						onBlur: handleBlur,
						onContextMenu: stopEventPropagation,
					}),
			],
		}),
	})
})

// ../packages/editor/src/lib/app/shapeutils/TLArrowUtil/TLArrowUtil.tsx
var import_jsx_runtime6 = __toESM(require_jsx_runtime())
var globalRenderIndex = 0
var TLArrowUtil = class extends TLShapeUtil {
	canEdit = () => true
	canBind = () => false
	isClosed = () => false
	hideResizeHandles = () => true
	hideRotateHandle = () => true
	hideSelectionBoundsFg = () => true
	hideSelectionBoundsBg = () => true
	defaultProps() {
		return {
			opacity: '1',
			dash: 'draw',
			size: 'm',
			fill: 'none',
			color: 'black',
			labelColor: 'black',
			bend: 0,
			start: { type: 'point', x: 0, y: 0 },
			end: { type: 'point', x: 0, y: 0 },
			arrowheadStart: 'none',
			arrowheadEnd: 'arrow',
			text: '',
			font: 'draw',
		}
	}
	getCenter(shape) {
		return this.bounds(shape).center
	}
	getBounds(shape) {
		return Box2d.FromPoints(this.getOutlineWithoutLabel(shape))
	}
	getOutlineWithoutLabel(shape) {
		const info = this.getArrowInfo(shape)
		if (!info) {
			return []
		}
		if (info.isStraight) {
			if (info.isValid) {
				return [info.start.point, info.end.point]
			} else {
				return [new Vec2d(0, 0), new Vec2d(1, 1)]
			}
		}
		if (!info.isValid) {
			return [new Vec2d(0, 0), new Vec2d(1, 1)]
		}
		const pointsToPush = Math.max(5, Math.ceil(Math.abs(info.bodyArc.length) / 16))
		if (pointsToPush <= 0 && !isFinite(pointsToPush)) {
			return [new Vec2d(0, 0), new Vec2d(1, 1)]
		}
		const results = Array(pointsToPush)
		const startAngle = Vec2d.Angle(info.bodyArc.center, info.start.point)
		const endAngle = Vec2d.Angle(info.bodyArc.center, info.end.point)
		const a3 = info.bodyArc.sweepFlag ? endAngle : startAngle
		const b3 = info.bodyArc.sweepFlag ? startAngle : endAngle
		const l3 = info.bodyArc.largeArcFlag ? -longAngleDist(a3, b3) : shortAngleDist(a3, b3)
		const r3 = Math.max(1, info.bodyArc.radius)
		for (let i3 = 0; i3 < pointsToPush; i3++) {
			const t4 = i3 / (pointsToPush - 1)
			const angle = a3 + l3 * t4
			const point2 = getPointOnCircle(info.bodyArc.center.x, info.bodyArc.center.y, r3, angle)
			results[i3] = point2
		}
		return results
	}
	getOutline(shape) {
		const outlineWithoutLabel = this.getOutlineWithoutLabel(shape)
		const labelBounds = this.getLabelBounds(shape)
		if (!labelBounds) {
			return outlineWithoutLabel
		}
		const sides = labelBounds.sides
		const sideIndexes = [0, 1, 2, 3]
		let prevPoint = outlineWithoutLabel[0]
		let didAddLabel = false
		const result = [prevPoint]
		for (let i3 = 1; i3 < outlineWithoutLabel.length; i3++) {
			const nextPoint = outlineWithoutLabel[i3]
			if (!didAddLabel) {
				const nearestIntersectingSideIndex = minBy(
					sideIndexes.filter((sideIndex) =>
						linesIntersect(sides[sideIndex][0], sides[sideIndex][1], prevPoint, nextPoint)
					),
					(sideIndex) =>
						Vec2d.DistanceToLineSegment(sides[sideIndex][0], sides[sideIndex][1], prevPoint)
				)
				if (nearestIntersectingSideIndex !== void 0) {
					const intersectingPoint = Vec2d.NearestPointOnLineSegment(
						sides[nearestIntersectingSideIndex][0],
						sides[nearestIntersectingSideIndex][1],
						prevPoint
					)
					result.push(intersectingPoint)
					for (let j = 0; j < 4; j++) {
						const sideIndex = (nearestIntersectingSideIndex + j) % 4
						result.push(sides[sideIndex][1])
					}
					result.push(intersectingPoint)
					didAddLabel = true
				}
			}
			result.push(nextPoint)
			prevPoint = nextPoint
		}
		return result
	}
	snapPoints(_shape) {
		return EMPTY_ARRAY
	}
	get infoCache() {
		return this.app.store.createComputedCache('arrow infoCache', (shape) => {
			return getIsArrowStraight(shape)
				? getStraightArrowInfo(this.app, shape)
				: getCurvedArrowInfo(this.app, shape)
		})
	}
	getArrowInfo(shape) {
		return this.infoCache.get(shape.id)
	}
	getHandles(shape) {
		const info = this.infoCache.get(shape.id)
		return [
			{
				id: 'start',
				type: 'vertex',
				index: 'a0',
				x: info.start.handle.x,
				y: info.start.handle.y,
				canBind: true,
			},
			{
				id: 'middle',
				type: 'vertex',
				index: 'a2',
				x: info.middle.x,
				y: info.middle.y,
				canBind: false,
			},
			{
				id: 'end',
				type: 'vertex',
				index: 'a3',
				x: info.end.handle.x,
				y: info.end.handle.y,
				canBind: true,
			},
		]
	}
	onHandleChange = (shape, { handle, isPrecise: isPrecise2 }) => {
		const next = deepCopy(shape)
		switch (handle.id) {
			case 'start':
			case 'end': {
				const pageTransform = this.app.getPageTransformById(next.id)
				const pointInPageSpace = Matrix2d.applyToPoint(pageTransform, handle)
				if (this.app.inputs.ctrlKey) {
					next.props[handle.id] = {
						type: 'point',
						x: handle.x,
						y: handle.y,
					}
				} else {
					const target = last(
						this.app.sortedShapesArray.filter((hitShape) => {
							if (hitShape.id === shape.id) {
								return
							}
							const util = this.app.getShapeUtil(hitShape)
							if (!util.canBind(hitShape)) {
								return
							}
							const pageMask = this.app.getPageMaskById(hitShape.id)
							if (pageMask) {
								if (!pointInPolygon(pointInPageSpace, pageMask)) return
							}
							const pointInTargetSpace = this.app.getPointInShapeSpace(hitShape, pointInPageSpace)
							if (util.isClosed(hitShape)) {
								return pointInPolygon(pointInTargetSpace, util.outline(hitShape))
							}
							return util.hitTestPoint(hitShape, pointInTargetSpace)
						})
					)
					if (target) {
						const targetBounds = this.app.getBounds(target)
						const pointInTargetSpace = this.app.getPointInShapeSpace(target, pointInPageSpace)
						const prevHandle = next.props[handle.id]
						const startBindingId =
							shape.props.start.type === 'binding' && shape.props.start.boundShapeId
						const endBindingId = shape.props.end.type === 'binding' && shape.props.end.boundShapeId
						let precise3 =
							// If externally precise, then always precise
							isPrecise2 || // If the other handle is bound to the same shape, then precise
							((startBindingId || endBindingId) && startBindingId === endBindingId) || // If the other shape is not closed, then precise
							!this.app.getShapeUtil(target).isClosed(next)
						if (
							// If we're switching to a new bound shape, then precise only if moving slowly
							prevHandle.type === 'point' ||
							(prevHandle.type === 'binding' && target.id !== prevHandle.boundShapeId)
						) {
							precise3 = this.app.inputs.pointerVelocity.len() < 0.5
						}
						if (precise3) {
							precise3 =
								Vec2d.Dist(pointInTargetSpace, targetBounds.center) >
								Math.max(
									4,
									Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)
								) /
									this.app.zoomLevel
						}
						next.props[handle.id] = {
							type: 'binding',
							boundShapeId: target.id,
							normalizedAnchor: precise3
								? {
										x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
										y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
								  }
								: { x: 0.5, y: 0.5 },
							isExact: this.app.inputs.altKey,
						}
					} else {
						next.props[handle.id] = {
							type: 'point',
							x: handle.x,
							y: handle.y,
						}
					}
				}
				break
			}
			case 'middle': {
				const { start, end } = getArrowTerminalsInArrowSpace(this.app, next)
				const delta = Vec2d.Sub(end, start)
				const v3 = Vec2d.Per(delta)
				const med = Vec2d.Med(end, start)
				const A2 = Vec2d.Sub(med, v3)
				const B = Vec2d.Add(med, v3)
				const point2 = Vec2d.NearestPointOnLineSegment(A2, B, handle, false)
				let bend = Vec2d.Dist(point2, med)
				if (Vec2d.Clockwise(point2, end, med)) bend *= -1
				next.props.bend = bend
				break
			}
		}
		return next
	}
	onTranslateStart = (shape) => {
		let startBinding = shape.props.start.type === 'binding' ? shape.props.start.boundShapeId : null
		let endBinding = shape.props.end.type === 'binding' ? shape.props.end.boundShapeId : null
		if (
			(startBinding && this.app.isWithinSelection(startBinding)) ||
			(endBinding && this.app.isWithinSelection(endBinding))
		) {
			return
		}
		startBinding = null
		endBinding = null
		const { start, end } = getArrowTerminalsInArrowSpace(this.app, shape)
		return {
			id: shape.id,
			type: shape.type,
			props: {
				...shape.props,
				start: {
					type: 'point',
					x: start.x,
					y: start.y,
				},
				end: {
					type: 'point',
					x: end.x,
					y: end.y,
				},
			},
		}
	}
	onResize = (shape, info) => {
		const { scaleX, scaleY } = info
		const terminals = getArrowTerminalsInArrowSpace(this.app, shape)
		const { start, end } = deepCopy(shape.props)
		let { bend } = shape.props
		if (start.type === 'point') {
			start.x = terminals.start.x * scaleX
			start.y = terminals.start.y * scaleY
		}
		if (end.type === 'point') {
			end.x = terminals.end.x * scaleX
			end.y = terminals.end.y * scaleY
		}
		const mx = Math.abs(scaleX)
		const my = Math.abs(scaleY)
		if (scaleX < 0 && scaleY >= 0) {
			if (bend !== 0) {
				bend *= -1
				bend *= Math.max(mx, my)
			}
			if (start.type === 'binding') {
				start.normalizedAnchor.x = 1 - start.normalizedAnchor.x
			}
			if (end.type === 'binding') {
				end.normalizedAnchor.x = 1 - end.normalizedAnchor.x
			}
		} else if (scaleX >= 0 && scaleY < 0) {
			if (bend !== 0) {
				bend *= -1
				bend *= Math.max(mx, my)
			}
			if (start.type === 'binding') {
				start.normalizedAnchor.y = 1 - start.normalizedAnchor.y
			}
			if (end.type === 'binding') {
				end.normalizedAnchor.y = 1 - end.normalizedAnchor.y
			}
		} else if (scaleX >= 0 && scaleY >= 0) {
			if (bend !== 0) {
				bend *= Math.max(mx, my)
			}
		} else if (scaleX < 0 && scaleY < 0) {
			if (bend !== 0) {
				bend *= Math.max(mx, my)
			}
			if (start.type === 'binding') {
				start.normalizedAnchor.x = 1 - start.normalizedAnchor.x
				start.normalizedAnchor.y = 1 - start.normalizedAnchor.y
			}
			if (end.type === 'binding') {
				end.normalizedAnchor.x = 1 - end.normalizedAnchor.x
				end.normalizedAnchor.y = 1 - end.normalizedAnchor.y
			}
		}
		const next = {
			props: {
				start,
				end,
				bend,
			},
		}
		return next
	}
	onDoubleClickHandle = (shape, handle) => {
		switch (handle.id) {
			case 'start': {
				return {
					id: shape.id,
					type: shape.type,
					props: {
						...shape.props,
						arrowheadStart: shape.props.arrowheadStart === 'none' ? 'arrow' : 'none',
					},
				}
			}
			case 'end': {
				return {
					id: shape.id,
					type: shape.type,
					props: {
						...shape.props,
						arrowheadEnd: shape.props.arrowheadEnd === 'none' ? 'arrow' : 'none',
					},
				}
			}
		}
	}
	hitTestPoint(shape, point2) {
		const outline = this.outline(shape)
		const zoomLevel = this.app.zoomLevel
		const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel
		for (let i3 = 0; i3 < outline.length - 1; i3++) {
			const C2 = outline[i3]
			const D3 = outline[i3 + 1]
			if (Vec2d.DistanceToLineSegment(C2, D3, point2) < offsetDist) return true
		}
		return false
	}
	hitTestLineSegment(shape, A2, B) {
		const outline = this.outline(shape)
		for (let i3 = 0; i3 < outline.length - 1; i3++) {
			const C2 = outline[i3]
			const D3 = outline[i3 + 1]
			if (linesIntersect(A2, B, C2, D3)) return true
		}
		return false
	}
	render(shape) {
		const onlySelectedShape = this.app.onlySelectedShape
		const shouldDisplayHandles =
			this.app.isInAny(
				'select.idle',
				'select.pointing_handle',
				'select.dragging_handle',
				'arrow.dragging'
			) && !this.app.isReadOnly
		const info = this.getArrowInfo(shape)
		const bounds = this.bounds(shape)
		const labelSize = this.getLabelBounds(shape)
		const changeIndex = React7.useMemo(() => {
			return this.app.isSafari ? (globalRenderIndex += 1) : 0
		}, [shape])
		if (!info?.isValid) return null
		const strokeWidth = this.app.getStrokeWidth(shape.props.size)
		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
		let handlePath = null
		if (onlySelectedShape === shape && shouldDisplayHandles) {
			const sw = 2
			const { strokeDasharray: strokeDasharray2, strokeDashoffset: strokeDashoffset2 } =
				getPerfectDashProps(
					info.isStraight
						? Vec2d.Dist(info.start.handle, info.end.handle)
						: Math.abs(info.handleArc.length),
					sw,
					{
						end: 'skip',
						start: 'skip',
						lengthRatio: 2.5,
					}
				)
			handlePath =
				shape.props.start.type === 'binding' || shape.props.end.type === 'binding'
					? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', {
							className: 'tl-arrow-hint',
							d: info.isStraight
								? getStraightArrowHandlePath(info)
								: getCurvedArrowHandlePath(info),
							strokeDasharray: strokeDasharray2,
							strokeDashoffset: strokeDashoffset2,
							strokeWidth: sw,
							markerStart:
								shape.props.start.type === 'binding'
									? shape.props.start.isExact
										? ''
										: isPrecise(shape.props.start.normalizedAnchor)
										? 'url(#arrowhead-cross)'
										: 'url(#arrowhead-dot)'
									: '',
							markerEnd:
								shape.props.end.type === 'binding'
									? shape.props.end.isExact
										? ''
										: isPrecise(shape.props.end.normalizedAnchor)
										? 'url(#arrowhead-cross)'
										: 'url(#arrowhead-dot)'
									: '',
							opacity: 0.16,
					  })
					: null
		}
		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
			info.isStraight ? info.length : Math.abs(info.bodyArc.length),
			strokeWidth,
			{
				style: shape.props.dash,
			}
		)
		const maskStartArrowhead = !(
			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
		)
		const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
		const includeMask = maskStartArrowhead || maskEndArrowhead || labelSize
		const maskId = (shape.id + '_clip_' + changeIndex).replace(':', '_')
		return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, {
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(SVGContainer, {
					id: shape.id,
					style: { minWidth: 50, minHeight: 50 },
					children: [
						includeMask &&
							/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('defs', {
								children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)('mask', {
									id: maskId,
									children: [
										/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('rect', {
											x: toDomPrecision(-100 + bounds.minX),
											y: toDomPrecision(-100 + bounds.minY),
											width: toDomPrecision(bounds.width + 200),
											height: toDomPrecision(bounds.height + 200),
											fill: 'white',
										}),
										labelSize &&
											/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('rect', {
												x: toDomPrecision(labelSize.x),
												y: toDomPrecision(labelSize.y),
												width: toDomPrecision(labelSize.w),
												height: toDomPrecision(labelSize.h),
												fill: 'black',
												rx: 4,
												ry: 4,
											}),
										as &&
											maskStartArrowhead &&
											/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', {
												d: as,
												fill: info.start.arrowhead === 'arrow' ? 'none' : 'black',
												stroke: 'none',
											}),
										ae &&
											maskEndArrowhead &&
											/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', {
												d: ae,
												fill: info.end.arrowhead === 'arrow' ? 'none' : 'black',
												stroke: 'none',
											}),
									],
								}),
							}),
						/* @__PURE__ */ (0, import_jsx_runtime6.jsxs)('g', {
							fill: 'none',
							stroke: 'currentColor',
							strokeWidth,
							strokeLinejoin: 'round',
							strokeLinecap: 'round',
							pointerEvents: 'none',
							children: [
								handlePath,
								/* @__PURE__ */ (0, import_jsx_runtime6.jsxs)('g', {
									...(includeMask ? { mask: `url(#${maskId})` } : void 0),
									children: [
										includeMask &&
											/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('rect', {
												x: toDomPrecision(bounds.minX - 100),
												y: toDomPrecision(bounds.minY - 100),
												width: toDomPrecision(bounds.width + 200),
												height: toDomPrecision(bounds.height + 200),
												opacity: 0,
											}),
										/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', {
											d: path,
											strokeDasharray,
											strokeDashoffset,
										}),
									],
								}),
								as &&
									maskStartArrowhead &&
									shape.props.fill !== 'none' &&
									/* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ShapeFill, {
										d: as,
										color: shape.props.color,
										fill: shape.props.fill,
									}),
								ae &&
									maskEndArrowhead &&
									shape.props.fill !== 'none' &&
									/* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ShapeFill, {
										d: ae,
										color: shape.props.color,
										fill: shape.props.fill,
									}),
								as && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', { d: as }),
								ae && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', { d: ae }),
							],
						}),
						/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', {
							d: path,
							className: 'tl-hitarea-stroke',
						}),
					],
				}),
				/* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ArrowTextLabel, {
					id: shape.id,
					text: shape.props.text,
					font: shape.props.font,
					size: shape.props.size,
					position: info.middle,
					width: labelSize?.w ?? 0,
					labelColor: this.app.getCssColor(shape.props.labelColor),
				}),
			],
		})
	}
	indicator(shape) {
		const { start, end } = getArrowTerminalsInArrowSpace(this.app, shape)
		const info = this.getArrowInfo(shape)
		const bounds = this.bounds(shape)
		const labelSize = this.getLabelBounds(shape)
		if (!info) return null
		if (Vec2d.Equals(start, end)) return null
		const strokeWidth = this.app.getStrokeWidth(shape.props.size)
		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
		const includeMask =
			(as && info.start.arrowhead !== 'arrow') ||
			(ae && info.end.arrowhead !== 'arrow') ||
			labelSize !== null
		const maskId = (shape.id + '_clip').replace(':', '_')
		return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)('g', {
			children: [
				includeMask &&
					/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('defs', {
						children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)('mask', {
							id: maskId,
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('rect', {
									x: bounds.minX - 100,
									y: bounds.minY - 100,
									width: bounds.w + 200,
									height: bounds.h + 200,
									fill: 'white',
								}),
								labelSize &&
									/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('rect', {
										x: labelSize.x,
										y: labelSize.y,
										width: labelSize.w,
										height: labelSize.h,
										fill: 'black',
										rx: 4,
										ry: 4,
									}),
								as &&
									/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', {
										d: as,
										fill: info.start.arrowhead === 'arrow' ? 'none' : 'black',
										stroke: 'none',
									}),
								ae &&
									/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', {
										d: ae,
										fill: info.end.arrowhead === 'arrow' ? 'none' : 'black',
										stroke: 'none',
									}),
							],
						}),
					}),
				/* @__PURE__ */ (0, import_jsx_runtime6.jsxs)('g', {
					...(includeMask ? { mask: `url(#${maskId})` } : void 0),
					children: [
						includeMask &&
							/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('rect', {
								x: bounds.minX - 100,
								y: bounds.minY - 100,
								width: bounds.width + 200,
								height: bounds.height + 200,
								opacity: 0,
							}),
						/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', { d: path }),
					],
				}),
				as && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', { d: as }),
				ae && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)('path', { d: ae }),
				labelSize &&
					/* @__PURE__ */ (0, import_jsx_runtime6.jsx)('rect', {
						x: labelSize.x,
						y: labelSize.y,
						width: labelSize.w,
						height: labelSize.h,
						rx: 4,
						ry: 4,
					}),
			],
		})
	}
	get labelBoundsCache() {
		return this.app.store.createComputedCache('labelBoundsCache', (shape) => {
			const info = this.getArrowInfo(shape)
			const bounds = this.bounds(shape)
			const { text, font, size } = shape.props
			if (!info) return null
			if (!text.trim()) return null
			const { w: w3, h: h3 } = this.app.textMeasure.measureText(text, {
				...TEXT_PROPS,
				fontFamily: FONT_FAMILIES[font],
				fontSize: ARROW_LABEL_FONT_SIZES[size],
				width: 'fit-content',
			})
			let width = w3
			let height = h3
			if (bounds.width > bounds.height) {
				width = Math.max(Math.min(w3, 64), Math.min(bounds.width - 64, w3))
				const { w: squishedWidth, h: squishedHeight } = this.app.textMeasure.measureText(text, {
					...TEXT_PROPS,
					fontFamily: FONT_FAMILIES[font],
					fontSize: ARROW_LABEL_FONT_SIZES[size],
					width: width + 'px',
				})
				width = squishedWidth
				height = squishedHeight
			}
			if (width > 16 * ARROW_LABEL_FONT_SIZES[size]) {
				width = 16 * ARROW_LABEL_FONT_SIZES[size]
				const { w: squishedWidth, h: squishedHeight } = this.app.textMeasure.measureText(text, {
					...TEXT_PROPS,
					fontFamily: FONT_FAMILIES[font],
					fontSize: ARROW_LABEL_FONT_SIZES[size],
					width: width + 'px',
				})
				width = squishedWidth
				height = squishedHeight
			}
			return new Box2d(
				info.middle.x - (width + 8) / 2,
				info.middle.y - (height + 8) / 2,
				width + 8,
				height + 8
			)
		})
	}
	getLabelBounds(shape) {
		return this.labelBoundsCache.get(shape.id) || null
	}
	getEditingBounds = (shape) => {
		return this.getLabelBounds(shape) ?? new Box2d()
	}
	onEditEnd = (shape) => {
		const {
			id,
			type,
			props: { text },
		} = shape
		if (text.trimEnd() !== shape.props.text) {
			this.app.updateShapes([
				{
					id,
					type,
					props: {
						text: text.trimEnd(),
					},
				},
			])
		}
	}
	toSvg(shape, font, colors) {
		const color = colors.fill[shape.props.color]
		const info = this.getArrowInfo(shape)
		const strokeWidth = this.app.getStrokeWidth(shape.props.size)
		const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		if (!info) return g3
		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
		const bounds = this.bounds(shape)
		const labelSize = this.getLabelBounds(shape)
		const maskId = (shape.id + '_clip').replace(':', '_')
		if (as || ae || labelSize) {
			const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs')
			const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask')
			mask.id = maskId
			const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
			rect.setAttribute('x', bounds.minX - 100 + '')
			rect.setAttribute('y', bounds.minY - 100 + '')
			rect.setAttribute('width', bounds.width + 200 + '')
			rect.setAttribute('height', bounds.height + 200 + '')
			rect.setAttribute('fill', 'white')
			mask.appendChild(rect)
			if (as) mask.appendChild(getArrowheadSvgMask(as, info.start.arrowhead))
			if (ae) mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead))
			if (labelSize) {
				const labelMask = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
				labelMask.setAttribute('x', labelSize.x + '')
				labelMask.setAttribute('y', labelSize.y + '')
				labelMask.setAttribute('width', labelSize.w + '')
				labelMask.setAttribute('height', labelSize.h + '')
				labelMask.setAttribute('fill', 'black')
				mask.appendChild(labelMask)
			}
			defs.appendChild(mask)
			g3.appendChild(defs)
		}
		const g22 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		g22.setAttribute('mask', `url(#${maskId})`)
		g3.appendChild(g22)
		const rect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
		rect2.setAttribute('x', '-100')
		rect2.setAttribute('y', '-100')
		rect2.setAttribute('width', bounds.width + 200 + '')
		rect2.setAttribute('height', bounds.height + 200 + '')
		rect2.setAttribute('fill', 'transparent')
		rect2.setAttribute('stroke', 'none')
		g22.appendChild(rect2)
		const path = getArrowSvgPath(
			info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info),
			color,
			strokeWidth
		)
		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
			info.isStraight ? info.length : Math.abs(info.bodyArc.length),
			strokeWidth,
			{
				style: shape.props.dash,
			}
		)
		path.setAttribute('stroke-dasharray', strokeDasharray)
		path.setAttribute('stroke-dashoffset', strokeDashoffset)
		g22.appendChild(path)
		if (as) {
			g3.appendChild(
				getArrowheadSvgPath(
					as,
					shape.props.color,
					strokeWidth,
					shape.props.arrowheadStart === 'arrow' ? 'none' : shape.props.fill,
					colors
				)
			)
		}
		if (ae) {
			g3.appendChild(
				getArrowheadSvgPath(
					ae,
					shape.props.color,
					strokeWidth,
					shape.props.arrowheadEnd === 'arrow' ? 'none' : shape.props.fill,
					colors
				)
			)
		}
		if (labelSize) {
			const opts = {
				fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
				lineHeight: TEXT_PROPS.lineHeight,
				fontFamily: font,
				padding: 0,
				textAlign: 'middle',
				width: labelSize.w - 8,
				verticalTextAlign: 'middle',
				height: labelSize.h,
				fontStyle: 'normal',
				fontWeight: 'normal',
				overflow: 'wrap',
			}
			const textElm = createTextSvgElementFromSpans(
				this.app,
				this.app.textMeasure.measureTextSpans(shape.props.text, opts),
				opts
			)
			textElm.setAttribute('fill', colors.fill[shape.props.labelColor])
			const children = Array.from(textElm.children)
			children.forEach((child) => {
				const x3 = parseFloat(child.getAttribute('x') || '0')
				const y3 = parseFloat(child.getAttribute('y') || '0')
				child.setAttribute('x', x3 + 4 + labelSize.x + 'px')
				child.setAttribute('y', y3 + labelSize.y + 'px')
			})
			g3.appendChild(textElm)
		}
		return g3
	}
}
__publicField(TLArrowUtil, 'type', 'arrow')
__decorateClass([computed], TLArrowUtil.prototype, 'infoCache', 1)
__decorateClass([computed], TLArrowUtil.prototype, 'labelBoundsCache', 1)
function getArrowheadSvgMask(d3, arrowhead) {
	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	path.setAttribute('d', d3)
	path.setAttribute('fill', arrowhead === 'arrow' ? 'none' : 'black')
	path.setAttribute('stroke', 'none')
	return path
}
function getArrowSvgPath(d3, color, strokeWidth) {
	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	path.setAttribute('d', d3)
	path.setAttribute('fill', 'none')
	path.setAttribute('stroke', color)
	path.setAttribute('stroke-width', strokeWidth + '')
	return path
}
function getArrowheadSvgPath(d3, color, strokeWidth, fill, colors) {
	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	path.setAttribute('d', d3)
	path.setAttribute('fill', 'none')
	path.setAttribute('stroke', colors.fill[color])
	path.setAttribute('stroke-width', strokeWidth + '')
	const shapeFill = getShapeFillSvg({
		d: d3,
		fill,
		color,
		colors,
	})
	if (shapeFill) {
		const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		g3.appendChild(shapeFill)
		g3.appendChild(path)
		return g3
	} else {
		return path
	}
}
function isPrecise(normalizedAnchor) {
	return normalizedAnchor.x !== 0.5 || normalizedAnchor.y !== 0.5
}

// ../packages/editor/src/lib/app/shapeutils/TLFrameUtil/TLFrameUtil.tsx
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLBoxUtil.tsx
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/shared/resizeBox.ts
init_define_process()
var resizeBox = (shape, info, opts = {}) => {
	const { newPoint, handle, scaleX, scaleY } = info
	const { minWidth = 1, maxWidth = Infinity, minHeight = 1, maxHeight = Infinity } = opts
	let w3 = shape.props.w * scaleX
	let h3 = shape.props.h * scaleY
	const offset = new Vec2d(0, 0)
	if (w3 > 0) {
		if (w3 < minWidth) {
			switch (handle) {
				case 'top_left':
				case 'left':
				case 'bottom_left': {
					offset.x = w3 - minWidth
					break
				}
				case 'top':
				case 'bottom': {
					offset.x = (w3 - minWidth) / 2
					break
				}
				default: {
					offset.x = 0
				}
			}
			w3 = minWidth
		}
	} else {
		offset.x = w3
		w3 = -w3
		if (w3 < minWidth) {
			switch (handle) {
				case 'top_left':
				case 'left':
				case 'bottom_left': {
					offset.x = -w3
					break
				}
				default: {
					offset.x = -minWidth
				}
			}
			w3 = minWidth
		}
	}
	if (h3 > 0) {
		if (h3 < minHeight) {
			switch (handle) {
				case 'top_left':
				case 'top':
				case 'top_right': {
					offset.y = h3 - minHeight
					break
				}
				case 'right':
				case 'left': {
					offset.y = (h3 - minHeight) / 2
					break
				}
				default: {
					offset.y = 0
				}
			}
			h3 = minHeight
		}
	} else {
		offset.y = h3
		h3 = -h3
		if (h3 < minHeight) {
			switch (handle) {
				case 'top_left':
				case 'top':
				case 'top_right': {
					offset.y = -h3
					break
				}
				default: {
					offset.y = -minHeight
				}
			}
			h3 = minHeight
		}
	}
	const { x: x3, y: y3 } = offset.rot(shape.rotation).add(newPoint)
	return {
		x: x3,
		y: y3,
		props: {
			w: Math.min(maxWidth, w3),
			h: Math.min(maxHeight, h3),
		},
	}
}

// ../packages/editor/src/lib/app/shapeutils/TLBoxUtil.tsx
var TLBoxUtil = class extends TLShapeUtil {
	getBounds(shape) {
		return new Box2d(0, 0, shape.props.w, shape.props.h)
	}
	getCenter(shape) {
		return new Vec2d(shape.props.w / 2, shape.props.h / 2)
	}
	getOutline(shape) {
		return this.bounds(shape).corners
	}
	hitTestPoint(shape, point2) {
		return pointInPolygon(point2, this.outline(shape))
	}
	hitTestLineSegment(shape, A2, B) {
		const outline = this.outline(shape)
		for (let i3 = 0; i3 < outline.length; i3++) {
			const C2 = outline[i3]
			const D3 = outline[(i3 + 1) % outline.length]
			if (linesIntersect(A2, B, C2, D3)) return true
		}
		return false
	}
	onResize = (shape, info) => {
		return resizeBox(shape, info)
	}
}

// ../packages/editor/src/lib/app/shapeutils/TLFrameUtil/components/FrameHeading.tsx
init_define_process()
var import_react12 = __toESM(require_react())

// ../packages/editor/src/lib/hooks/useIsEditing.ts
init_define_process()
function useIsEditing(shapeId) {
	const app = useApp()
	return useValue('isEditing', () => app.editingId === shapeId, [app, shapeId])
}

// ../packages/editor/src/lib/app/shapeutils/TLFrameUtil/components/FrameLabelInput.tsx
init_define_process()
var import_react11 = __toESM(require_react())
var import_jsx_runtime7 = __toESM(require_jsx_runtime())
var FrameLabelInput = (0, import_react11.forwardRef)(({ id, name, isEditing }, ref) => {
	const app = useApp()
	const handleKeyDown = (0, import_react11.useCallback)(
		(e2) => {
			if (e2.key === 'Enter') {
				e2.stopPropagation()
				e2.currentTarget.blur()
				app.setEditingId(null)
			}
		},
		[app]
	)
	const handleBlur = (0, import_react11.useCallback)(
		(e2) => {
			const shape = app.getShapeById(id)
			if (!shape) return
			const name2 = shape.props.name
			const value = e2.currentTarget.value.trim()
			if (name2 === value) return
			app.updateShapes(
				[
					{
						id,
						type: 'frame',
						props: { name: value },
					},
				],
				true
			)
		},
		[id, app]
	)
	const handleChange = (0, import_react11.useCallback)(
		(e2) => {
			const shape = app.getShapeById(id)
			if (!shape) return
			const name2 = shape.props.name
			const value = e2.currentTarget.value
			if (name2 === value) return
			app.updateShapes(
				[
					{
						id,
						type: 'frame',
						props: { name: value },
					},
				],
				true
			)
		},
		[id, app]
	)
	return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)('div', {
		className: `tl-frame-label ${isEditing ? 'tl-frame-label__editing' : ''}`,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime7.jsx)('input', {
				className: 'tl-frame-name-input',
				ref,
				style: { display: isEditing ? void 0 : 'none' },
				value: name,
				autoFocus: true,
				onKeyDown: handleKeyDown,
				onBlur: handleBlur,
				onChange: handleChange,
			}),
			defaultEmptyAs(name, 'Frame') + String.fromCharCode(8203),
		],
	})
})

// ../packages/editor/src/lib/app/shapeutils/TLFrameUtil/components/FrameHeading.tsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime())
var FrameHeading = function FrameHeading2({ id, name, width, height }) {
	const app = useApp()
	const pageRotation = canolicalizeRotation(app.getPageRotationById(id))
	const isEditing = useIsEditing(id)
	const rInput = (0, import_react12.useRef)(null)
	;(0, import_react12.useEffect)(() => {
		const el = rInput.current
		if (el && isEditing) {
			el.focus()
			el.select()
			requestAnimationFrame(() => {
				if (document.activeElement !== el) {
					el.focus()
					el.select()
				}
			})
		}
	}, [rInput, isEditing])
	const offsetRotation = pageRotation + Math.PI / 4
	const scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4
	const labelSide = ['top', 'left', 'bottom', 'right'][Math.floor(scaledRotation)]
	let labelTranslate
	switch (labelSide) {
		case 'top':
			labelTranslate = ``
			break
		case 'right':
			labelTranslate = `translate(${toDomPrecision(width)}px, 0px) rotate(90deg)`
			break
		case 'bottom':
			labelTranslate = `translate(${toDomPrecision(width)}px, ${toDomPrecision(
				height
			)}px) rotate(180deg)`
			break
		case 'left':
			labelTranslate = `translate(0px, ${toDomPrecision(height)}px) rotate(270deg)`
			break
	}
	return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)('div', {
		className: 'tl-frame-heading',
		style: {
			overflow: isEditing ? 'visible' : 'hidden',
			maxWidth: `calc(var(--tl-zoom) * ${
				labelSide === 'top' || labelSide === 'bottom' ? Math.ceil(width) : Math.ceil(height)
			}px + var(--space-5))`,
			bottom: Math.ceil(height),
			transform: `${labelTranslate} scale(var(--tl-scale)) translateX(calc(-1 * var(--space-3))`,
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)('div', {
			className: 'tl-frame-heading-hit-area',
			children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(FrameLabelInput, {
				ref: rInput,
				id,
				name,
				isEditing,
			}),
		}),
	})
}

// ../packages/editor/src/lib/app/shapeutils/TLFrameUtil/TLFrameUtil.tsx
var import_jsx_runtime9 = __toESM(require_jsx_runtime())
var TLFrameUtil = class extends TLBoxUtil {
	canBind = () => true
	canEdit = () => true
	defaultProps() {
		return { opacity: '1', w: 160 * 2, h: 90 * 2, name: '' }
	}
	render(shape) {
		const bounds = this.bounds(shape)
		return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, {
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(SVGContainer, {
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime9.jsx)('rect', {
							className: 'tl-hitarea-stroke',
							width: bounds.width,
							height: bounds.height,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime9.jsx)('rect', {
							className: 'tl-frame__body',
							width: bounds.width,
							height: bounds.height,
							fill: 'none',
						}),
					],
				}),
				/* @__PURE__ */ (0, import_jsx_runtime9.jsx)(FrameHeading, {
					id: shape.id,
					name: shape.props.name,
					width: bounds.width,
					height: bounds.height,
				}),
			],
		})
	}
	toSvg(shape, font, colors) {
		const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
		rect.setAttribute('width', shape.props.w.toString())
		rect.setAttribute('height', shape.props.h.toString())
		rect.setAttribute('fill', colors.solid)
		rect.setAttribute('opacity', shape.props.opacity)
		rect.setAttribute('stroke', colors.fill.black)
		rect.setAttribute('stroke-width', '1')
		rect.setAttribute('rx', '1')
		rect.setAttribute('ry', '1')
		g3.appendChild(rect)
		const pageRotation = canolicalizeRotation(this.app.getPageRotationById(shape.id))
		const offsetRotation = pageRotation + Math.PI / 4
		const scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4
		const labelSide = ['top', 'left', 'bottom', 'right'][Math.floor(scaledRotation)]
		let labelTranslate
		switch (labelSide) {
			case 'top':
				labelTranslate = ``
				break
			case 'right':
				labelTranslate = `translate(${toDomPrecision(shape.props.w)}px, 0px) rotate(90deg)`
				break
			case 'bottom':
				labelTranslate = `translate(${toDomPrecision(shape.props.w)}px, ${toDomPrecision(
					shape.props.h
				)}px) rotate(180deg)`
				break
			case 'left':
				labelTranslate = `translate(0px, ${toDomPrecision(shape.props.h)}px) rotate(270deg)`
				break
			default:
				labelTranslate = ``
		}
		const opts = {
			fontSize: 12,
			fontFamily: 'Inter, sans-serif',
			textAlign: 'start',
			width: shape.props.w,
			height: 32,
			padding: 0,
			lineHeight: 1,
			fontStyle: 'normal',
			fontWeight: 'normal',
			overflow: 'truncate-ellipsis',
			verticalTextAlign: 'middle',
		}
		const spans = this.app.textMeasure.measureTextSpans(
			defaultEmptyAs(shape.props.name, 'Frame') + String.fromCharCode(8203),
			opts
		)
		const firstSpan = spans[0]
		const lastSpan = last(spans)
		const labelTextWidth = lastSpan.box.w + lastSpan.box.x - firstSpan.box.x
		const text = createTextSvgElementFromSpans(this.app, spans, {
			offsetY: -opts.height - 2,
			...opts,
		})
		text.style.setProperty('transform', labelTranslate)
		const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
		textBg.setAttribute('x', '-8px')
		textBg.setAttribute('y', -opts.height - 4 + 'px')
		textBg.setAttribute('width', labelTextWidth + 16 + 'px')
		textBg.setAttribute('height', `${opts.height}px`)
		textBg.setAttribute('rx', 4 + 'px')
		textBg.setAttribute('ry', 4 + 'px')
		textBg.setAttribute('fill', colors.background)
		g3.appendChild(textBg)
		g3.appendChild(text)
		return g3
	}
	indicator(shape) {
		const bounds = this.bounds(shape)
		return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)('rect', {
			width: toDomPrecision(bounds.width),
			height: toDomPrecision(bounds.height),
			className: `tl-frame-indicator`,
		})
	}
	canReceiveNewChildrenOfType = (_type) => {
		return true
	}
	canDropShapes = (_shape, _shapes) => {
		return true
	}
	onDragShapesOver = (frame2, shapes) => {
		if (!shapes.every((child) => child.parentId === frame2.id)) {
			this.app.reparentShapesById(
				shapes.map((shape) => shape.id),
				frame2.id
			)
			return { shouldHint: true }
		}
		return { shouldHint: false }
	}
	onDragShapesOut = (_shape, shapes) => {
		const parentId = this.app.getShapeById(_shape.parentId)
		const isInGroup = parentId?.type === 'group'
		if (isInGroup) {
			this.app.reparentShapesById(
				shapes.map((shape) => shape.id),
				parentId.id
			)
		} else {
			this.app.reparentShapesById(
				shapes.map((shape) => shape.id),
				this.app.currentPageId
			)
		}
	}
	onResizeEnd = (shape) => {
		const bounds = this.app.getPageBounds(shape)
		const children = this.app.getSortedChildIds(shape.id)
		const shapesToReparent = []
		for (const childId of children) {
			const childBounds = this.app.getPageBoundsById(childId)
			if (!bounds.includes(childBounds)) {
				shapesToReparent.push(childId)
			}
		}
		if (shapesToReparent.length > 0) {
			this.app.reparentShapesById(shapesToReparent, this.app.currentPageId)
		}
	}
}
__publicField(TLFrameUtil, 'type', 'frame')

// ../packages/editor/src/lib/app/shapeutils/TLGroupUtil/TLGroupUtil.tsx
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/shared/DashedOutlineBox.tsx
init_define_process()
var import_jsx_runtime10 = __toESM(require_jsx_runtime())
function DashedOutlineBox({ bounds, zoomLevel, className }) {
	return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)('g', {
		className,
		pointerEvents: 'none',
		strokeLinecap: 'round',
		strokeLinejoin: 'round',
		children: bounds.sides.map((side, i3) => {
			const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
				side[0].dist(side[1]),
				1 / zoomLevel,
				{
					style: 'dashed',
					lengthRatio: 4,
				}
			)
			return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
				'line',
				{
					x1: side[0].x,
					y1: side[0].y,
					x2: side[1].x,
					y2: side[1].y,
					strokeDasharray,
					strokeDashoffset,
				},
				i3
			)
		}),
	})
}

// ../packages/editor/src/lib/app/shapeutils/TLGroupUtil/TLGroupUtil.tsx
var import_jsx_runtime11 = __toESM(require_jsx_runtime())
var TLGroupUtil = class extends TLShapeUtil {
	hideSelectionBoundsBg = () => false
	hideSelectionBoundsFg = () => true
	canBind = () => false
	defaultProps() {
		return { opacity: '1' }
	}
	getBounds(shape) {
		const children = this.app.getSortedChildIds(shape.id)
		if (children.length === 0) {
			return new Box2d()
		}
		const allChildPoints = children.flatMap((childId) => {
			const shape2 = this.app.getShapeById(childId)
			return this.app
				.getOutlineById(childId)
				.map((point2) => Matrix2d.applyToPoint(this.app.getTransform(shape2), point2))
		})
		return Box2d.FromPoints(allChildPoints)
	}
	getCenter(shape) {
		return this.bounds(shape).center
	}
	getOutline(shape) {
		return this.bounds(shape).corners
	}
	render(shape) {
		const {
			erasingIdsSet,
			pageState: { hintingIds, focusLayerId },
			zoomLevel,
		} = this.app
		const isErasing = erasingIdsSet.has(shape.id)
		const isHintingOtherGroup =
			hintingIds.length > 0 &&
			hintingIds.some((id) => id !== shape.id && this.app.getShapeById(id)?.type === 'group')
		if (
			// always show the outline while we're erasing the group
			!isErasing && // show the outline while the group is focused unless something outside of the group is being hinted
			// this happens dropping shapes from a group onto some outside group
			(shape.id !== focusLayerId || isHintingOtherGroup)
		) {
			return null
		}
		const bounds = this.bounds(shape)
		return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(SVGContainer, {
			id: shape.id,
			children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(DashedOutlineBox, {
				className: 'tl-group',
				bounds,
				zoomLevel,
			}),
		})
	}
	indicator(shape) {
		const {
			camera: { z: zoomLevel },
		} = this.app
		const bounds = this.bounds(shape)
		return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(DashedOutlineBox, {
			className: '',
			bounds,
			zoomLevel,
		})
	}
	onChildrenChange = (group) => {
		const children = this.app.getSortedChildIds(group.id)
		if (children.length === 0) {
			if (this.app.pageState.focusLayerId === group.id) {
				this.app.popFocusLayer()
			}
			this.app.deleteShapes([group.id])
			return
		} else if (children.length === 1) {
			if (this.app.pageState.focusLayerId === group.id) {
				this.app.popFocusLayer()
			}
			this.app.reparentShapesById(children, group.parentId)
			this.app.deleteShapes([group.id])
			return
		}
	}
}
__publicField(TLGroupUtil, 'type', 'group')

// ../packages/editor/src/lib/app/shapeutils/TLTextUtil/TLTextUtil.tsx
init_define_process()

// ../packages/editor/src/lib/components/HTMLContainer.tsx
init_define_process()
var import_jsx_runtime12 = __toESM(require_jsx_runtime())
function HTMLContainer({ children, className = '', ...rest }) {
	return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)('div', {
		...rest,
		className: `tl-html-container ${className}`,
		children,
	})
}

// ../packages/editor/src/lib/app/shapeutils/shared/resizeScaled.ts
init_define_process()
function resizeScaled(shape, { initialBounds, scaleX, scaleY, newPoint }) {
	const scaleDelta = Math.max(0.01, Math.min(Math.abs(scaleX), Math.abs(scaleY)))
	const offset = new Vec2d(0, 0)
	if (scaleX < 0) {
		offset.x = -(initialBounds.width * scaleDelta)
	}
	if (scaleY < 0) {
		offset.y = -(initialBounds.height * scaleDelta)
	}
	const { x: x3, y: y3 } = Vec2d.Add(newPoint, offset.rot(shape.rotation))
	return {
		x: x3,
		y: y3,
		props: {
			scale: scaleDelta * shape.props.scale,
		},
	}
}

// ../packages/editor/src/lib/app/shapeutils/TLTextUtil/TLTextUtil.tsx
var import_jsx_runtime13 = __toESM(require_jsx_runtime())
var sizeCache = new WeakMapCache()
var TLTextUtil = class extends TLShapeUtil {
	canEdit = () => true
	isAspectRatioLocked = () => true
	defaultProps() {
		return {
			opacity: '1',
			color: 'black',
			size: 'm',
			w: 8,
			text: '',
			font: 'draw',
			align: 'middle',
			autoSize: true,
			scale: 1,
		}
	}
	// @computed
	// private get minDimensionsCache() {
	// 	return this.app.store.createSelectedComputedCache<
	// 		TLTextShape['props'],
	// 		{ width: number; height: number },
	// 		TLTextShape
	// 	>(
	// 		'text measure cache',
	// 		(shape) => {
	// 			return shape.props
	// 		},
	// 		(props) => getTextSize(this.app, props)
	// 	)
	// }
	getMinDimensions(shape) {
		return sizeCache.get(shape.props, (props) => getTextSize(this.app, props))
	}
	getBounds(shape) {
		const { scale } = shape.props
		const { width, height } = this.getMinDimensions(shape)
		return new Box2d(0, 0, width * scale, height * scale)
	}
	getOutline(shape) {
		const bounds = this.bounds(shape)
		return [
			new Vec2d(0, 0),
			new Vec2d(bounds.width, 0),
			new Vec2d(bounds.width, bounds.height),
			new Vec2d(0, bounds.height),
		]
	}
	getCenter(shape) {
		const bounds = this.bounds(shape)
		return new Vec2d(bounds.width / 2, bounds.height / 2)
	}
	render(shape) {
		const {
			id,
			type,
			props: { text },
		} = shape
		const { width, height } = this.getMinDimensions(shape)
		const {
			rInput,
			isEmpty,
			isEditing,
			isEditableFromHover,
			handleFocus,
			handleChange,
			handleKeyDown,
			handleBlur,
		} = useEditableText(id, type, text)
		return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(HTMLContainer, {
			id: shape.id,
			children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)('div', {
				className: 'tl-text-shape__wrapper tl-text-shadow',
				'data-font': shape.props.font,
				'data-align': shape.props.align,
				'data-hastext': !isEmpty,
				'data-isediting': isEditing || isEditableFromHover,
				'data-textwrap': true,
				style: {
					fontSize: FONT_SIZES[shape.props.size],
					lineHeight: FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + 'px',
					transform: `scale(${shape.props.scale})`,
					transformOrigin: 'top left',
					width: Math.max(1, width),
					height: Math.max(FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight, height),
				},
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime13.jsx)('div', {
						className: 'tl-text tl-text-content',
						dir: 'ltr',
						children: text,
					}),
					isEditing || isEditableFromHover
						? /* @__PURE__ */ (0, import_jsx_runtime13.jsx)('textarea', {
								ref: rInput,
								className: 'tl-text tl-text-input',
								name: 'text',
								tabIndex: -1,
								autoComplete: 'false',
								autoCapitalize: 'false',
								autoCorrect: 'false',
								autoSave: 'false',
								autoFocus: isEditing,
								placeholder: '',
								spellCheck: 'true',
								wrap: 'off',
								dir: 'ltr',
								datatype: 'wysiwyg',
								defaultValue: text,
								onFocus: handleFocus,
								onChange: handleChange,
								onKeyDown: handleKeyDown,
								onBlur: handleBlur,
								onTouchEnd: stopEventPropagation,
								onContextMenu: stopEventPropagation,
						  })
						: null,
				],
			}),
		})
	}
	indicator(shape) {
		const bounds = this.bounds(shape)
		return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)('rect', {
			width: toDomPrecision(bounds.width),
			height: toDomPrecision(bounds.height),
		})
	}
	toSvg(shape, font, colors) {
		const bounds = this.bounds(shape)
		const text = shape.props.text
		const width = bounds.width / (shape.props.scale ?? 1)
		const height = bounds.height / (shape.props.scale ?? 1)
		const opts = {
			fontSize: FONT_SIZES[shape.props.size],
			fontFamily: font,
			textAlign: shape.props.align,
			verticalTextAlign: 'middle',
			width,
			height,
			padding: 0,
			// no padding?
			lineHeight: TEXT_PROPS.lineHeight,
			fontStyle: 'normal',
			fontWeight: 'normal',
			overflow: 'wrap',
		}
		const color = colors.fill[shape.props.color]
		const groupEl = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		const textBgEl = createTextSvgElementFromSpans(
			this.app,
			this.app.textMeasure.measureTextSpans(text, opts),
			{
				...opts,
				stroke: colors.background,
				strokeWidth: 2,
				fill: colors.background,
				padding: 0,
			}
		)
		const textElm = textBgEl.cloneNode(true)
		textElm.setAttribute('fill', color)
		textElm.setAttribute('stroke', 'none')
		groupEl.append(textBgEl)
		groupEl.append(textElm)
		return groupEl
	}
	onResize = (shape, info) => {
		const { initialBounds, initialShape, scaleX, handle } = info
		if (info.mode === 'scale_shape' || (handle !== 'right' && handle !== 'left')) {
			return resizeScaled(shape, info)
		} else {
			const prevWidth = initialBounds.width
			let nextWidth = prevWidth * scaleX
			const offset = new Vec2d(0, 0)
			nextWidth = Math.max(1, Math.abs(nextWidth))
			if (handle === 'left') {
				offset.x = prevWidth - nextWidth
				if (scaleX < 0) {
					offset.x += nextWidth
				}
			} else {
				if (scaleX < 0) {
					offset.x -= nextWidth
				}
			}
			const { x: x3, y: y3 } = offset.rot(shape.rotation).add(initialShape)
			return {
				x: x3,
				y: y3,
				props: {
					w: nextWidth / initialShape.props.scale,
					autoSize: false,
				},
			}
		}
	}
	onBeforeCreate = (shape) => {
		if (!shape.props.autoSize) return
		if (shape.props.text.trim()) return
		const bounds = this.getMinDimensions(shape)
		return {
			...shape,
			x: shape.x - bounds.width / 2,
			y: shape.y - bounds.height / 2,
		}
	}
	onEditEnd = (shape) => {
		const {
			id,
			type,
			props: { text },
		} = shape
		const trimmedText = shape.props.text.trimEnd()
		if (trimmedText.length === 0) {
			this.app.deleteShapes([shape.id])
		} else {
			if (trimmedText !== shape.props.text) {
				this.app.updateShapes([
					{
						id,
						type,
						props: {
							text: text.trimEnd(),
						},
					},
				])
			}
		}
	}
	onBeforeUpdate = (prev, next) => {
		if (!next.props.autoSize) return
		const styleDidChange =
			prev.props.size !== next.props.size ||
			prev.props.align !== next.props.align ||
			prev.props.font !== next.props.font ||
			(prev.props.scale !== 1 && next.props.scale === 1)
		const textDidChange = prev.props.text !== next.props.text
		if (!styleDidChange && !textDidChange) return
		const boundsA = this.getMinDimensions(prev)
		const boundsB = getTextSize(this.app, next.props)
		const wA = boundsA.width * prev.props.scale
		const hA = boundsA.height * prev.props.scale
		const wB = boundsB.width * next.props.scale
		const hB = boundsB.height * next.props.scale
		let delta
		switch (next.props.align) {
			case 'middle': {
				delta = new Vec2d((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2)
				break
			}
			case 'end': {
				delta = new Vec2d(wB - wA, textDidChange ? 0 : (hB - hA) / 2)
				break
			}
			default: {
				if (textDidChange) break
				delta = new Vec2d(0, (hB - hA) / 2)
				break
			}
		}
		if (delta) {
			delta.rot(next.rotation)
			const { x: x3, y: y3 } = next
			return {
				...next,
				x: x3 - delta.x,
				y: y3 - delta.y,
				props: { ...next.props, w: wB },
			}
		} else {
			return {
				...next,
				props: { ...next.props, w: wB },
			}
		}
	}
	onDoubleClickEdge = (shape) => {
		if (!shape.props.autoSize) {
			return {
				id: shape.id,
				type: shape.type,
				props: {
					autoSize: true,
				},
			}
		}
		if (shape.props.scale !== 1) {
			return {
				id: shape.id,
				type: shape.type,
				props: {
					scale: 1,
				},
			}
		}
	}
}
__publicField(TLTextUtil, 'type', 'text')
function getTextSize(app, props) {
	const { font, text, autoSize, size, w: w3 } = props
	const minWidth = 16
	const fontSize = FONT_SIZES[size]
	const cw = autoSize
		? 'fit-content'
		: // `measureText` floors the number so we need to do the same here to avoid issues.
		  Math.floor(Math.max(minWidth, w3)) + 'px'
	const result = app.textMeasure.measureText(text, {
		...TEXT_PROPS,
		fontFamily: FONT_FAMILIES[font],
		fontSize,
		width: cw,
	})
	if (autoSize) {
		result.w += 1
	}
	return {
		width: Math.max(minWidth, result.w),
		height: Math.max(fontSize, result.h),
	}
}

// ../packages/editor/src/lib/app/statechart/RootState.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/StateNode.ts
init_define_process()

// ../packages/editor/src/lib/app/types/event-types.ts
init_define_process()
var EVENT_NAME_MAP = {
	wheel: 'onWheel',
	pointer_enter: 'onPointerEnter',
	pointer_leave: 'onPointerLeave',
	pointer_down: 'onPointerDown',
	pointer_move: 'onPointerMove',
	pointer_up: 'onPointerUp',
	right_click: 'onRightClick',
	middle_click: 'onMiddleClick',
	key_down: 'onKeyDown',
	key_up: 'onKeyUp',
	key_repeat: 'onKeyRepeat',
	cancel: 'onCancel',
	complete: 'onComplete',
	interrupt: 'onInterrupt',
	double_click: 'onDoubleClick',
	triple_click: 'onTripleClick',
	quadruple_click: 'onQuadrupleClick',
}

// ../packages/editor/src/lib/app/statechart/StateNode.ts
var StateNode = class {
	constructor(app, parent) {
		this.app = app
		const { id, children, initial } = this.constructor
		this.id = id
		this.current = atom('toolState' + this.id, void 0)
		this.path = computed('toolPath' + this.id, () => {
			const current = this.current.value
			return this.id + (current ? `.${current.path.value}` : '')
		})
		this.parent = parent ?? {}
		if (this.parent) {
			if (children && initial) {
				this.type = 'branch'
				this.initial = initial
				this.children = Object.fromEntries(
					children().map((Ctor) => [Ctor.id, new Ctor(this.app, this)])
				)
				this.current.set(this.children[this.initial])
			} else {
				this.type = 'leaf'
			}
		} else {
			this.type = 'root'
			if (children && initial) {
				this.initial = initial
				this.children = Object.fromEntries(
					children().map((Ctor) => [Ctor.id, new Ctor(this.app, this)])
				)
				this.current.set(this.children[this.initial])
			}
		}
	}
	path
	id
	current
	type
	styles = []
	initial
	children
	parent
	isActive = false
	transition(id, info) {
		const path = id.split('.')
		let currState = this
		for (let i3 = 0; i3 < path.length; i3++) {
			const id2 = path[i3]
			const prevChildState = currState.current.value
			const nextChildState = currState.children?.[id2]
			if (!nextChildState) {
				throw Error(`${currState.id} - no child state exists with the id ${id2}.`)
			}
			if (prevChildState?.id !== nextChildState.id) {
				prevChildState?.exit(info, id2)
				currState.current.set(nextChildState)
				nextChildState.enter(info, prevChildState?.id || 'initial')
				if (!nextChildState.isActive) break
			}
			currState = nextChildState
		}
		return this
	}
	handleEvent(info) {
		const cbName = EVENT_NAME_MAP[info.name]
		const x3 = this.current.value
		this[cbName]?.(info)
		if (this.current.value === x3 && this.isActive) {
			x3?.handleEvent(info)
		}
	}
	enter(info, from) {
		this.isActive = true
		this.onEnter?.(info, from)
		if (this.children && this.initial && this.isActive) {
			const initial = this.children[this.initial]
			this.current.set(initial)
			initial.enter(info, from)
		}
	}
	exit(info, from) {
		this.isActive = false
		this.onExit?.(info, from)
		if (!this.isActive) {
			this.current.value?.exit(info, from)
		}
	}
	onWheel
	onPointerEnter
	onPointerLeave
	onPointerDown
	onPointerMove
	onPointerUp
	onDoubleClick
	onTripleClick
	onQuadrupleClick
	onRightClick
	onMiddleClick
	onKeyDown
	onKeyUp
	onKeyRepeat
	onCancel
	onComplete
	onInterrupt
	onEnter
	onExit
}
__publicField(StateNode, 'id')
__publicField(StateNode, 'initial')
__publicField(StateNode, 'children')

// ../packages/editor/src/lib/app/statechart/TLArrowTool/TLArrowTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLArrowTool/children/Idle.ts
init_define_process()
var Idle = class extends StateNode {
	onPointerDown = (info) => {
		this.parent.transition('pointing', info)
	}
	onEnter = () => {
		this.app.setCursor({ type: 'cross' })
	}
	onCancel = () => {
		this.app.setSelectedTool('select')
	}
}
__publicField(Idle, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLArrowTool/children/Pointing.ts
init_define_process()
var Pointing = class extends StateNode {
	shape
	preciseTimeout = -1
	didTimeout = false
	startPreciseTimeout() {
		this.preciseTimeout = window.setTimeout(() => {
			if (!this.isActive) return
			if (!this.shape) return
			this.didTimeout = true
		}, 300)
	}
	clearPreciseTimeout() {
		clearTimeout(this.preciseTimeout)
	}
	onEnter = () => {
		const {
			inputs: { currentPagePoint },
		} = this.app
		this.didTimeout = false
		const shapeType = this.parent.shapeType
		this.app.mark('creating')
		const id = createShapeId()
		this.app.createShapes([
			{
				id,
				type: shapeType,
				x: currentPagePoint.x,
				y: currentPagePoint.y,
			},
		])
		const util = this.app.getShapeUtil(TLArrowUtil)
		const shape = this.app.getShapeById(id)
		if (!shape) return
		const handles = util.handles?.(shape)
		if (handles) {
			const point2 = this.app.getPointInShapeSpace(shape, currentPagePoint)
			const change = util.onHandleChange?.(shape, {
				handle: { ...handles[0], x: point2.x, y: point2.y },
				isPrecise: true,
			})
			if (change) {
				const startTerminal = change.props?.start
				if (startTerminal?.type === 'binding') {
					this.app.setHintingIds([startTerminal.boundShapeId])
				}
				this.app.updateShapes([change], true)
			}
		}
		this.app.select(id)
		this.shape = this.app.getShapeById(id)
		this.startPreciseTimeout()
	}
	onExit = () => {
		this.clearPreciseTimeout()
	}
	onPointerMove = () => {
		if (!this.shape) return
		if (this.app.inputs.isDragging) {
			const util = this.app.getShapeUtil(this.shape)
			const handles = util.handles?.(this.shape)
			if (!handles) {
				this.app.bailToMark('creating')
				throw Error('No handles found')
			}
			if (!this.didTimeout) {
				const util2 = this.app.getShapeUtil(TLArrowUtil)
				const shape = this.app.getShapeById(this.shape.id)
				if (!shape) return
				const handles2 = util2.handles(shape)
				if (handles2) {
					const { x: x3, y: y3 } = this.app.getPointInShapeSpace(
						shape,
						this.app.inputs.originPagePoint
					)
					const change = util2.onHandleChange?.(shape, {
						handle: {
							...handles2[0],
							x: x3,
							y: y3,
						},
						isPrecise: false,
					})
					if (change) {
						this.app.updateShapes([change], true)
					}
				}
			}
			this.app.setSelectedTool('select.dragging_handle', {
				shape: this.shape,
				handle: handles.find((h3) => h3.id === 'end'),
				isCreating: true,
				onInteractionEnd: 'arrow',
			})
		}
	}
	onPointerUp = () => {
		this.cancel()
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.cancel()
	}
	onInterrupt = () => {
		this.cancel()
	}
	cancel() {
		this.app.bailToMark('creating')
		this.app.setHintingIds([])
		this.parent.transition('idle', {})
	}
}
__publicField(Pointing, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLArrowTool/TLArrowTool.ts
var TLArrowTool = class extends StateNode {
	shapeType = 'arrow'
	styles = ['color', 'opacity', 'dash', 'size', 'arrowheadStart', 'arrowheadEnd', 'font', 'fill']
}
__publicField(TLArrowTool, 'id', 'arrow')
__publicField(TLArrowTool, 'initial', 'idle')
__publicField(TLArrowTool, 'children', () => [Idle, Pointing])

// ../packages/editor/src/lib/app/statechart/TLDrawTool/TLDrawTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLDrawTool/children/Drawing.ts
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLDrawUtil/TLDrawUtil.tsx
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLDrawUtil/getPath.ts
init_define_process()
var PEN_EASING = (t4) => t4 * 0.65 + SIN((t4 * PI) / 2) * 0.35
var simulatePressureSettings = (strokeWidth) => {
	return {
		size: 1 + strokeWidth,
		thinning: 0.5,
		streamline: 0.62 + ((1 + strokeWidth) / 8) * 0.06,
		smoothing: 0.62,
		easing: EASINGS.easeOutSine,
		simulatePressure: true,
	}
}
var realPressureSettings = (strokeWidth) => {
	return {
		size: 1 + strokeWidth * 1.2,
		thinning: 0.62,
		streamline: 0.62,
		smoothing: 0.62,
		simulatePressure: false,
		easing: PEN_EASING,
	}
}
var solidSettings = (strokeWidth) => {
	return {
		size: 1 + strokeWidth,
		thinning: 0,
		streamline: 0.62 + ((1 + strokeWidth) / 8) * 0.06,
		smoothing: 0.62,
		simulatePressure: false,
		easing: EASINGS.linear,
	}
}
function getFreehandOptions(shape, strokeWidth, forceComplete, forceSolid) {
	return {
		...(forceSolid
			? solidSettings(strokeWidth)
			: shape.props.dash === 'draw'
			? shape.props.isPen
				? realPressureSettings(strokeWidth)
				: simulatePressureSettings(strokeWidth)
			: solidSettings(strokeWidth)),
		last: shape.props.isComplete || forceComplete,
	}
}
function getPointsFromSegments(segments) {
	const points2 = []
	for (const segment of segments) {
		if (segment.type === 'free' || segment.points.length < 2) {
			points2.push(...segment.points.map(Vec2d.Cast))
		} else {
			const pointsToInterpolate = Math.max(
				4,
				Math.floor(Vec2d.Dist(segment.points[0], segment.points[1]) / 16)
			)
			points2.push(
				...Vec2d.PointsBetween(segment.points[0], segment.points[1], pointsToInterpolate)
			)
		}
	}
	return points2
}
function getDrawShapeStrokeDashArray(shape, strokeWidth) {
	return {
		draw: 'none',
		solid: `none`,
		dotted: `0.1 ${strokeWidth * 2}`,
		dashed: `${strokeWidth * 2} ${strokeWidth * 2}`,
	}[shape.props.dash]
}

// ../packages/editor/src/lib/app/shapeutils/TLDrawUtil/TLDrawUtil.tsx
var import_jsx_runtime14 = __toESM(require_jsx_runtime())
var TLDrawUtil = class extends TLShapeUtil {
	hideResizeHandles = (shape) => this.getIsDot(shape)
	hideRotateHandle = (shape) => this.getIsDot(shape)
	hideSelectionBoundsBg = (shape) => this.getIsDot(shape)
	hideSelectionBoundsFg = (shape) => this.getIsDot(shape)
	defaultProps() {
		return {
			segments: [],
			color: 'black',
			fill: 'none',
			dash: 'draw',
			size: 'm',
			opacity: '1',
			isComplete: false,
			isClosed: false,
			isPen: false,
		}
	}
	isClosed = (shape) => shape.props.isClosed
	getIsDot(shape) {
		return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2
	}
	getBounds(shape) {
		return Box2d.FromPoints(this.outline(shape))
	}
	getOutline(shape) {
		return getPointsFromSegments(shape.props.segments)
	}
	getCenter(shape) {
		return this.bounds(shape).center
	}
	hitTestPoint(shape, point2) {
		const outline = this.outline(shape)
		const zoomLevel = this.app.zoomLevel
		const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel
		if (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {
			if (shape.props.segments[0].points.some((pt) => Vec2d.Dist(point2, pt) < offsetDist * 1.5)) {
				return true
			}
		}
		if (this.isClosed(shape)) {
			return pointInPolygon(point2, outline)
		}
		if (this.bounds(shape).containsPoint(point2)) {
			for (let i3 = 0; i3 < outline.length; i3++) {
				const C2 = outline[i3]
				const D3 = outline[(i3 + 1) % outline.length]
				if (Vec2d.DistanceToLineSegment(C2, D3, point2) < offsetDist) return true
			}
		}
		return false
	}
	hitTestLineSegment(shape, A2, B) {
		const outline = this.outline(shape)
		if (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {
			const zoomLevel = this.app.zoomLevel
			const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel
			if (
				shape.props.segments[0].points.some(
					(pt) => Vec2d.DistanceToLineSegment(A2, B, pt) < offsetDist * 1.5
				)
			) {
				return true
			}
		}
		if (this.isClosed(shape)) {
			for (let i3 = 0; i3 < outline.length; i3++) {
				const C2 = outline[i3]
				const D3 = outline[(i3 + 1) % outline.length]
				if (linesIntersect(A2, B, C2, D3)) return true
			}
		} else {
			for (let i3 = 0; i3 < outline.length - 1; i3++) {
				const C2 = outline[i3]
				const D3 = outline[i3 + 1]
				if (linesIntersect(A2, B, C2, D3)) return true
			}
		}
		return false
	}
	render(shape) {
		const forceSolid = useForceSolid()
		const strokeWidth = this.app.getStrokeWidth(shape.props.size)
		const allPointsFromSegments = getPointsFromSegments(shape.props.segments)
		const showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'
		let sw = strokeWidth
		if (
			!forceSolid &&
			!shape.props.isPen &&
			shape.props.dash === 'draw' &&
			allPointsFromSegments.length === 1
		) {
			sw += rng(shape.id)() * (strokeWidth / 6)
		}
		const options = getFreehandOptions(shape, sw, showAsComplete, forceSolid)
		const strokePoints = getStrokePoints(allPointsFromSegments, options)
		const solidStrokePath =
			strokePoints.length > 1
				? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed)
				: getDot(allPointsFromSegments[0], sw)
		if ((!forceSolid && shape.props.dash === 'draw') || strokePoints.length < 2) {
			setStrokePointRadii(strokePoints, options)
			const strokeOutlinePoints = getStrokeOutlinePoints(strokePoints, options)
			return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(SVGContainer, {
				id: shape.id,
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ShapeFill, {
						fill: shape.props.isClosed ? shape.props.fill : 'none',
						color: shape.props.color,
						d: solidStrokePath,
					}),
					/* @__PURE__ */ (0, import_jsx_runtime14.jsx)('path', {
						d: getSvgPathFromStroke(strokeOutlinePoints, true),
						strokeLinecap: 'round',
						fill: 'currentColor',
					}),
				],
			})
		}
		return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(SVGContainer, {
			id: shape.id,
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ShapeFill, {
					color: shape.props.color,
					fill: shape.props.isClosed ? shape.props.fill : 'none',
					d: solidStrokePath,
				}),
				/* @__PURE__ */ (0, import_jsx_runtime14.jsx)('path', {
					d: solidStrokePath,
					strokeLinecap: 'round',
					fill: 'none',
					stroke: 'currentColor',
					strokeWidth,
					strokeDasharray: getDrawShapeStrokeDashArray(shape, strokeWidth),
					strokeDashoffset: '0',
				}),
			],
		})
	}
	indicator(shape) {
		const forceSolid = useForceSolid()
		const strokeWidth = this.app.getStrokeWidth(shape.props.size)
		const allPointsFromSegments = getPointsFromSegments(shape.props.segments)
		let sw = strokeWidth
		if (
			!forceSolid &&
			!shape.props.isPen &&
			shape.props.dash === 'draw' &&
			allPointsFromSegments.length === 1
		) {
			sw += rng(shape.id)() * (strokeWidth / 6)
		}
		const showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'
		const options = getFreehandOptions(shape, sw, showAsComplete, true)
		const strokePoints = getStrokePoints(allPointsFromSegments, options)
		const solidStrokePath =
			strokePoints.length > 1
				? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed)
				: getDot(allPointsFromSegments[0], sw)
		return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)('path', { d: solidStrokePath })
	}
	toSvg(shape, _font, colors) {
		const { color } = shape.props
		const strokeWidth = this.app.getStrokeWidth(shape.props.size)
		const allPointsFromSegments = getPointsFromSegments(shape.props.segments)
		const showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'
		let sw = strokeWidth
		if (!shape.props.isPen && shape.props.dash === 'draw' && allPointsFromSegments.length === 1) {
			sw += rng(shape.id)() * (strokeWidth / 6)
		}
		const options = getFreehandOptions(shape, sw, showAsComplete, false)
		const strokePoints = getStrokePoints(allPointsFromSegments, options)
		const solidStrokePath =
			strokePoints.length > 1
				? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed)
				: getDot(allPointsFromSegments[0], sw)
		let foregroundPath
		if (shape.props.dash === 'draw' || strokePoints.length < 2) {
			setStrokePointRadii(strokePoints, options)
			const strokeOutlinePoints = getStrokeOutlinePoints(strokePoints, options)
			const p3 = document.createElementNS('http://www.w3.org/2000/svg', 'path')
			p3.setAttribute('d', getSvgPathFromStroke(strokeOutlinePoints, true))
			p3.setAttribute('fill', colors.fill[color])
			p3.setAttribute('stroke-linecap', 'round')
			foregroundPath = p3
		} else {
			const p3 = document.createElementNS('http://www.w3.org/2000/svg', 'path')
			p3.setAttribute('d', solidStrokePath)
			p3.setAttribute('stroke', colors.fill[color])
			p3.setAttribute('fill', 'none')
			p3.setAttribute('stroke-linecap', 'round')
			p3.setAttribute('stroke-width', strokeWidth.toString())
			p3.setAttribute('stroke-dasharray', getDrawShapeStrokeDashArray(shape, strokeWidth))
			p3.setAttribute('stroke-dashoffset', '0')
			foregroundPath = p3
		}
		const fillPath = getShapeFillSvg({
			fill: shape.props.isClosed ? shape.props.fill : 'none',
			d: solidStrokePath,
			color: shape.props.color,
			colors,
		})
		if (fillPath) {
			const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
			g3.appendChild(fillPath)
			g3.appendChild(foregroundPath)
			return g3
		}
		return foregroundPath
	}
	onResize = (shape, info) => {
		const { scaleX, scaleY } = info
		const newSegments = []
		for (const segment of shape.props.segments) {
			newSegments.push({
				...segment,
				points: segment.points.map(({ x: x3, y: y3, z: z2 }) => {
					return {
						x: scaleX * x3,
						y: scaleY * y3,
						z: z2,
					}
				}),
			})
		}
		return {
			props: {
				segments: newSegments,
			},
		}
	}
	expandSelectionOutlinePx(shape) {
		const multiplier = shape.props.dash === 'draw' ? 1.6 : 1
		return (this.app.getStrokeWidth(shape.props.size) * multiplier) / 2
	}
}
__publicField(TLDrawUtil, 'type', 'draw')
function getDot(point2, sw) {
	const r3 = (sw + 1) * 0.5
	return `M ${point2.x} ${point2.y} m -${r3}, 0 a ${r3},${r3} 0 1,0 ${
		r3 * 2
	},0 a ${r3},${r3} 0 1,0 -${r3 * 2},0`
}

// ../packages/editor/src/lib/app/statechart/TLDrawTool/children/Drawing.ts
var Drawing = class extends StateNode {
	info = {}
	initialShape
	util = this.app.getShapeUtil(TLDrawUtil)
	isPen = false
	segmentMode = 'free'
	didJustShiftClickToExtendPreviousShapeLine = false
	pagePointWhereCurrentSegmentChanged = {}
	pagePointWhereNextSegmentChanged = null
	lastRecordedPoint = {}
	mergeNextPoint = false
	currentLineLength = 0
	canDraw = false
	onEnter = (info) => {
		this.info = info
		this.canDraw = !this.app.isMenuOpen
		this.lastRecordedPoint = this.app.inputs.currentPagePoint.clone()
		if (this.canDraw) {
			this.startShape()
		}
	}
	onPointerMove = () => {
		const {
			app: { inputs },
		} = this
		if (this.isPen !== inputs.isPen) {
			this.cancel()
		}
		if (!this.canDraw && inputs.isDragging) {
			this.startShape()
			this.canDraw = true
		}
		if (this.canDraw) {
			if (inputs.isPen) {
				if (Vec2d.Dist(inputs.currentPagePoint, this.lastRecordedPoint) >= 1 / this.app.zoomLevel) {
					this.lastRecordedPoint = inputs.currentPagePoint.clone()
					this.mergeNextPoint = false
				} else {
					this.mergeNextPoint = true
				}
			} else {
				this.mergeNextPoint = false
			}
			this.updateShapes()
		}
	}
	onKeyDown = (info) => {
		if (info.key === 'Shift') {
			switch (this.segmentMode) {
				case 'free': {
					this.segmentMode = 'starting_straight'
					this.pagePointWhereNextSegmentChanged = this.app.inputs.currentPagePoint.clone()
					break
				}
				case 'starting_free': {
					this.segmentMode = 'starting_straight'
				}
			}
		}
		this.updateShapes()
	}
	onKeyUp = (info) => {
		if (info.key === 'Shift') {
			this.app.snaps.clear()
			switch (this.segmentMode) {
				case 'straight': {
					this.segmentMode = 'starting_free'
					this.pagePointWhereNextSegmentChanged = this.app.inputs.currentPagePoint.clone()
					break
				}
				case 'starting_straight': {
					this.pagePointWhereNextSegmentChanged = null
					this.segmentMode = 'free'
					break
				}
			}
		}
		this.updateShapes()
	}
	onExit = () => {
		this.app.snaps.clear()
		this.pagePointWhereCurrentSegmentChanged = this.app.inputs.currentPagePoint.clone()
	}
	getIsClosed(segments, size) {
		const strokeWidth = this.app.getStrokeWidth(size)
		const firstPoint = segments[0].points[0]
		const lastSegment = segments[segments.length - 1]
		const lastPoint = lastSegment.points[lastSegment.points.length - 1]
		return (
			this.currentLineLength > strokeWidth * 4 &&
			Vec2d.Dist(firstPoint, lastPoint) < strokeWidth * 2
		)
	}
	startShape() {
		const {
			inputs: { originPagePoint, isPen },
		} = this.app
		this.app.mark('draw create start')
		this.isPen = isPen
		const pressure = this.isPen ? this.info.point.z * 1.25 : 0.5
		this.segmentMode = this.app.inputs.shiftKey ? 'straight' : 'free'
		this.didJustShiftClickToExtendPreviousShapeLine = false
		this.lastRecordedPoint = originPagePoint.clone()
		if (this.initialShape) {
			const shape = this.app.getShapeById(this.initialShape.id)
			if (shape && this.segmentMode === 'straight') {
				this.didJustShiftClickToExtendPreviousShapeLine = true
				const prevSegment = last(shape.props.segments)
				if (!prevSegment) throw Error('Expected a previous segment!')
				const prevPoint = last(prevSegment.points)
				if (!prevPoint) throw Error('Expected a previous point!')
				const { x: x3, y: y3 } = this.app.getPointInShapeSpace(shape, originPagePoint).toFixed()
				const pressure2 = this.isPen ? this.info.point.z * 1.25 : 0.5
				const newSegment = {
					type: this.segmentMode,
					points: [
						{
							x: prevPoint.x,
							y: prevPoint.y,
							z: +pressure2.toFixed(2),
						},
						{
							x: x3,
							y: y3,
							z: +pressure2.toFixed(2),
						},
					],
				}
				const prevPointPageSpace = Matrix2d.applyToPoint(
					this.app.getPageTransformById(shape.id),
					prevPoint
				)
				this.pagePointWhereCurrentSegmentChanged = prevPointPageSpace
				this.pagePointWhereNextSegmentChanged = null
				const segments = [...shape.props.segments, newSegment]
				this.currentLineLength = this.getLineLength(segments)
				this.app.updateShapes([
					{
						id: shape.id,
						type: 'draw',
						props: {
							segments,
							isClosed: this.getIsClosed(segments, shape.props.size),
						},
					},
				])
				return
			}
		}
		this.pagePointWhereCurrentSegmentChanged = originPagePoint.clone()
		const id = createShapeId()
		this.app.createShapes([
			{
				id,
				type: 'draw',
				x: originPagePoint.x,
				y: originPagePoint.y,
				props: {
					isPen: this.isPen,
					segments: [
						{
							type: this.segmentMode,
							points: [
								{
									x: 0,
									y: 0,
									z: +pressure.toFixed(2),
								},
							],
						},
					],
				},
			},
		])
		this.currentLineLength = 0
		this.initialShape = this.app.getShapeById(id)
	}
	updateShapes() {
		const { inputs } = this.app
		const { initialShape } = this
		if (!initialShape) return
		const {
			id,
			props: { size },
		} = initialShape
		const shape = this.app.getShapeById(id)
		if (!shape) return
		const { segments } = shape.props
		const {
			x: x3,
			y: y3,
			z: z2,
		} = this.app.getPointInShapeSpace(shape, inputs.currentPagePoint).toFixed()
		const newPoint = { x: x3, y: y3, z: this.isPen ? +(z2 * 1.25).toFixed(2) : 0.5 }
		switch (this.segmentMode) {
			case 'starting_straight': {
				const { pagePointWhereNextSegmentChanged } = this
				if (pagePointWhereNextSegmentChanged === null) {
					throw Error('We should have a point where the segment changed')
				}
				const hasMovedFarEnough =
					Vec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE
				if (hasMovedFarEnough) {
					this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone()
					this.pagePointWhereNextSegmentChanged = null
					this.segmentMode = 'straight'
					const prevSegment = last(segments)
					if (!prevSegment) throw Error('Expected a previous segment!')
					const prevLastPoint = last(prevSegment.points)
					if (!prevLastPoint) throw Error('Expected a previous last point!')
					let newSegment
					const newLastPoint = this.app
						.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged)
						.toFixed()
						.toJson()
					if (prevSegment.type === 'straight') {
						this.currentLineLength += Vec2d.Dist(prevLastPoint, newLastPoint)
						newSegment = {
							type: 'straight',
							points: [{ ...prevLastPoint }, newLastPoint],
						}
						const transform = this.app.getPageTransform(shape)
						this.pagePointWhereCurrentSegmentChanged = Matrix2d.applyToPoint(
							transform,
							prevLastPoint
						)
					} else {
						newSegment = {
							type: 'straight',
							points: [newLastPoint, newPoint],
						}
					}
					this.app.updateShapes(
						[
							{
								id,
								type: 'draw',
								props: {
									segments: [...segments, newSegment],
									isClosed: this.getIsClosed(segments, size),
								},
							},
						],
						true
					)
				}
				break
			}
			case 'starting_free': {
				const { pagePointWhereNextSegmentChanged } = this
				if (pagePointWhereNextSegmentChanged === null) {
					throw Error('We should have a point where the segment changed')
				}
				const hasMovedFarEnough =
					Vec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE
				if (hasMovedFarEnough) {
					this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone()
					this.pagePointWhereNextSegmentChanged = null
					this.segmentMode = 'free'
					const newSegments = segments.slice()
					const prevStraightSegment = newSegments[newSegments.length - 1]
					const prevPoint = last(prevStraightSegment.points)
					if (!prevPoint) {
						throw Error('No previous point!')
					}
					const newFreeSegment = {
						type: 'free',
						points: [
							...Vec2d.PointsBetween(prevPoint, newPoint, 6).map((p3) => p3.toFixed().toJson()),
						],
					}
					this.currentLineLength = this.getLineLength(segments)
					this.app.updateShapes(
						[
							{
								id,
								type: 'draw',
								props: {
									segments: [...newSegments, newFreeSegment],
									isClosed: this.getIsClosed(segments, size),
								},
							},
						],
						true
					)
				}
				break
			}
			case 'straight': {
				const newSegments = segments.slice()
				const newSegment = newSegments[newSegments.length - 1]
				const { pagePointWhereCurrentSegmentChanged } = this
				const { currentPagePoint, ctrlKey } = this.app.inputs
				if (!pagePointWhereCurrentSegmentChanged)
					throw Error('We should have a point where the segment changed')
				let pagePoint
				let shouldSnapToAngle = false
				if (this.didJustShiftClickToExtendPreviousShapeLine) {
					if (this.app.inputs.isDragging) {
						shouldSnapToAngle = !ctrlKey
						this.didJustShiftClickToExtendPreviousShapeLine = false
					} else {
					}
				} else {
					shouldSnapToAngle = !ctrlKey
				}
				let newPoint2 = this.app.getPointInShapeSpace(shape, currentPagePoint).toFixed().toJson()
				let didSnap = false
				let snapSegment = void 0
				const shouldSnap = this.app.userDocumentSettings.isSnapMode ? !ctrlKey : ctrlKey
				if (shouldSnap) {
					if (newSegments.length > 2) {
						let nearestPoint = void 0
						let minDistance = 8 / this.app.zoomLevel
						for (let i3 = 0, n3 = segments.length - 2; i3 < n3; i3++) {
							const segment = segments[i3]
							if (!segment) break
							if (segment.type === 'free') continue
							const first = segment.points[0]
							const lastPoint = last(segment.points)
							if (!(first && lastPoint)) continue
							const nearestPointOnSegment = Vec2d.NearestPointOnLineSegment(
								first,
								lastPoint,
								newPoint2
							)
							const distance = Vec2d.Dist(nearestPointOnSegment, newPoint2)
							if (distance < minDistance) {
								nearestPoint = nearestPointOnSegment.toFixed().toJson()
								minDistance = distance
								snapSegment = segment
								break
							}
						}
						if (nearestPoint) {
							didSnap = true
							newPoint2 = nearestPoint
						}
					}
				}
				if (didSnap && snapSegment) {
					const transform = this.app.getPageTransform(shape)
					const first = snapSegment.points[0]
					const lastPoint = last(snapSegment.points)
					if (!lastPoint) throw Error('Expected a last point!')
					const A2 = Matrix2d.applyToPoint(transform, first)
					const B = Matrix2d.applyToPoint(transform, lastPoint)
					const snappedPoint = Matrix2d.applyToPoint(transform, newPoint2)
					this.app.snaps.setLines([
						{
							id: uniqueId(),
							type: 'points',
							points: [A2, snappedPoint, B],
						},
					])
				} else {
					this.app.snaps.clear()
					if (shouldSnapToAngle) {
						const currentAngle = Vec2d.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint)
						const snappedAngle = snapAngle(currentAngle, 24)
						const angleDiff = snappedAngle - currentAngle
						pagePoint = Vec2d.RotWith(
							currentPagePoint,
							pagePointWhereCurrentSegmentChanged,
							angleDiff
						)
					} else {
						pagePoint = currentPagePoint
					}
					newPoint2 = this.app.getPointInShapeSpace(shape, pagePoint).toFixed().toJson()
				}
				this.currentLineLength += Vec2d.Dist(newSegment.points[0], newPoint2)
				newSegments[newSegments.length - 1] = {
					...newSegment,
					type: 'straight',
					points: [newSegment.points[0], newPoint2],
				}
				this.app.updateShapes(
					[
						{
							id,
							type: 'draw',
							props: {
								segments: newSegments,
								isClosed: this.getIsClosed(segments, size),
							},
						},
					],
					true
				)
				break
			}
			case 'free': {
				const newSegments = segments.slice()
				const newSegment = newSegments[newSegments.length - 1]
				const newPoints = [...newSegment.points]
				if (newPoints.length && this.mergeNextPoint) {
					const { z: z3 } = newPoints[newPoints.length - 1]
					newPoints[newPoints.length - 1] = {
						x: newPoint.x,
						y: newPoint.y,
						z: z3 ? Math.max(z3, newPoint.z) : newPoint.z,
					}
				} else {
					this.currentLineLength += Vec2d.Dist(newPoints[newPoints.length - 1], newPoint)
					newPoints.push(newPoint)
				}
				newSegments[newSegments.length - 1] = {
					...newSegment,
					points: newPoints,
				}
				this.app.updateShapes(
					[
						{
							id,
							type: 'draw',
							props: {
								segments: newSegments,
								isClosed: this.getIsClosed(segments, size),
							},
						},
					],
					true
				)
				if (newPoints.length > 500) {
					this.app.updateShapes([{ id, type: 'draw', props: { isComplete: true } }])
					const { currentPagePoint } = this.app.inputs
					const newShapeId = this.app.createShapeId()
					this.app.createShapes([
						{
							id: newShapeId,
							type: 'draw',
							x: currentPagePoint.x,
							y: currentPagePoint.y,
							props: {
								isPen: this.isPen,
								segments: [
									{
										type: 'free',
										points: [{ x: 0, y: 0, z: this.isPen ? +(z2 * 1.25).toFixed() : 0.5 }],
									},
								],
							},
						},
					])
					this.initialShape = structuredClone(this.app.getShapeById(newShapeId))
					this.mergeNextPoint = false
					this.lastRecordedPoint = this.app.inputs.currentPagePoint.clone()
					this.currentLineLength = 0
				}
				break
			}
		}
	}
	getLineLength(segments) {
		let length = 0
		for (const segment of segments) {
			for (let i3 = 0; i3 < segment.points.length - 1; i3++) {
				const A2 = segment.points[i3]
				const B = segment.points[i3 + 1]
				length += Vec2d.Sub(B, A2).len2()
			}
		}
		return Math.sqrt(length)
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	onInterrupt = () => {
		if (this.app.inputs.isDragging) {
			return
		}
		this.app.bail()
		this.cancel()
	}
	complete() {
		if (!this.canDraw) {
			this.cancel()
			return
		}
		const { initialShape } = this
		if (!initialShape) return
		this.app.updateShapes([
			{ id: initialShape.id, type: initialShape.type, props: { isComplete: true } },
		])
		this.parent.transition('idle', {})
	}
	cancel() {
		this.parent.transition('idle', this.info)
	}
}
__publicField(Drawing, 'id', 'drawing')

// ../packages/editor/src/lib/app/statechart/TLDrawTool/children/Idle.ts
init_define_process()
var Idle2 = class extends StateNode {
	onPointerDown = (info) => {
		this.parent.transition('drawing', info)
	}
	onEnter = () => {
		this.app.setCursor({ type: 'cross' })
	}
	onCancel = () => {
		this.app.setSelectedTool('select')
	}
}
__publicField(Idle2, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLDrawTool/TLDrawTool.ts
var TLDrawTool = class extends StateNode {
	styles = ['color', 'opacity', 'dash', 'fill', 'size']
	onExit = () => {
		const drawingState = this.children['drawing']
		drawingState.initialShape = void 0
	}
}
__publicField(TLDrawTool, 'id', 'draw')
__publicField(TLDrawTool, 'initial', 'idle')
__publicField(TLDrawTool, 'children', () => [Idle2, Drawing])

// ../packages/editor/src/lib/app/statechart/TLEraserTool/TLEraserTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLEraserTool/children/Erasing.ts
init_define_process()

// ../packages/editor/src/lib/app/managers/ScribbleManager.ts
init_define_process()
var ScribbleManager = class {
	// Scribble properties
	state
	points
	size
	color
	opacity
	delay
	timeoutMs = 0
	delayRemaining = 0
	// Callbacks
	onUpdate
	onComplete
	// Internal state
	prev = null
	next = null
	constructor(opts) {
		const { size = 20, color = 'accent', opacity = 0.8, delay = 0, onComplete, onUpdate } = opts
		this.onUpdate = onUpdate
		this.onComplete = onComplete
		this.size = size
		this.color = color
		this.delay = delay
		this.opacity = opacity
		this.points = []
		this.state = 'starting'
		this.prev = null
		this.next = null
		this.delayRemaining = this.delay
		this.resume()
	}
	resume = () => {
		this.state = 'active'
	}
	pause = () => {
		this.state = 'starting'
	}
	/**
	 * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
	 *
	 * @public
	 */
	stop = () => {
		this.delayRemaining = Math.min(this.delayRemaining, 200)
		this.state = 'stopping'
	}
	/**
	 * Set the scribble's next point.
	 *
	 * @param point - The point to add.
	 * @public
	 */
	addPoint = (x3, y3) => {
		const { prev } = this
		const point2 = { x: x3, y: y3, z: 0.5 }
		if (prev && Vec2d.Dist(prev, point2) < 1) return
		this.next = point2
	}
	/**
	 * Get the current TLScribble object from the scribble manager.
	 *
	 * @public
	 */
	getScribble() {
		return {
			state: this.state,
			size: this.size,
			color: this.color,
			opacity: this.opacity,
			delay: this.delay,
			points: [...this.points],
		}
	}
	updateScribble() {
		this.onUpdate(this.getScribble())
	}
	tick = (elapsed) => {
		this.timeoutMs += elapsed
		if (this.delayRemaining > 0) {
			this.delayRemaining = Math.max(0, this.delayRemaining - elapsed)
		}
		if (this.timeoutMs >= 16) {
			this.timeoutMs = 0
		}
		const { timeoutMs, state, prev, next, points: points2 } = this
		switch (state) {
			case 'active': {
				if (next && next !== prev) {
					this.prev = next
					points2.push(next)
					if (this.delayRemaining === 0) {
						if (points2.length > 8) {
							points2.shift()
						}
					}
					this.updateScribble()
				} else {
					if (timeoutMs === 0) {
						if (points2.length > 1) {
							points2.shift()
							this.updateScribble()
						} else {
							this.delayRemaining = this.delay
						}
					}
				}
				break
			}
			case 'stopping': {
				if (this.delayRemaining === 0) {
					if (timeoutMs === 0) {
						if (points2.length === 1) {
							this.state = 'paused'
							this.onComplete()
							return
						}
						this.size *= 0.9
						points2.shift()
						this.updateScribble()
					}
				}
				break
			}
			case 'paused': {
				break
			}
		}
	}
}

// ../packages/editor/src/lib/app/statechart/TLEraserTool/children/Erasing.ts
var Erasing = class extends StateNode {
	info = {}
	scribble = {}
	markId = ''
	excludedShapeIds = /* @__PURE__ */ new Set()
	onEnter = (info) => {
		this.markId = this.app.mark('erase scribble begin')
		this.info = info
		const { originPagePoint } = this.app.inputs
		this.excludedShapeIds = new Set(
			this.app.shapesArray
				.filter(
					(shape) =>
						(shape.type === 'frame' || shape.type === 'group') &&
						this.app.isPointInShape(originPagePoint, shape)
				)
				.map((shape) => shape.id)
		)
		this.startScribble()
		this.update()
	}
	startScribble = () => {
		if (this.scribble.tick) {
			this.app.off('tick', this.scribble?.tick)
		}
		this.scribble = new ScribbleManager({
			onUpdate: this.onScribbleUpdate,
			onComplete: this.onScribbleComplete,
			color: 'muted-1',
			size: 12,
		})
		this.app.on('tick', this.scribble.tick)
	}
	pushPointToScribble = () => {
		const { x: x3, y: y3 } = this.app.inputs.currentPagePoint
		this.scribble.addPoint(x3, y3)
	}
	onScribbleUpdate = (scribble) => {
		this.app.setScribble(scribble)
	}
	onScribbleComplete = () => {
		this.app.off('tick', this.scribble.tick)
		this.app.setScribble(null)
	}
	onExit = () => {
		this.scribble.stop()
	}
	onPointerMove = () => {
		this.update()
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	update() {
		const {
			shapesArray,
			erasingIdsSet,
			inputs: { currentPagePoint, previousPagePoint },
		} = this.app
		const { excludedShapeIds } = this
		this.pushPointToScribble()
		const erasing = new Set(erasingIdsSet)
		for (const shape of shapesArray) {
			if (shape.type === 'group') continue
			const pageMask = this.app.getPageMaskById(shape.id)
			if (pageMask && !pointInPolygon(currentPagePoint, pageMask)) {
				continue
			}
			const util = this.app.getShapeUtil(shape)
			const A2 = this.app.getPointInShapeSpace(shape, previousPagePoint)
			const B = this.app.getPointInShapeSpace(shape, currentPagePoint)
			if (util.hitTestLineSegment(shape, A2, B)) {
				erasing.add(this.app.getOutermostSelectableShape(shape).id)
			}
		}
		this.app.setErasingIds([...erasing].filter((id) => !excludedShapeIds.has(id)))
	}
	complete() {
		this.app.deleteShapes(this.app.pageState.erasingIds)
		this.app.setErasingIds([])
		this.parent.transition('idle', {})
	}
	cancel() {
		this.app.setErasingIds([])
		this.app.bailToMark(this.markId)
		this.parent.transition('idle', this.info)
	}
}
__publicField(Erasing, 'id', 'erasing')

// ../packages/editor/src/lib/app/statechart/TLEraserTool/children/Idle.ts
init_define_process()
var Idle3 = class extends StateNode {
	onPointerDown = (info) => {
		this.parent.transition('pointing', info)
	}
}
__publicField(Idle3, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLEraserTool/children/Pointing.ts
init_define_process()
var Pointing2 = class extends StateNode {
	onEnter = () => {
		const { inputs } = this.app
		const erasing = /* @__PURE__ */ new Set()
		const initialSize = erasing.size
		for (const shape of [...this.app.sortedShapesArray].reverse()) {
			if (this.app.isPointInShape(inputs.currentPagePoint, shape)) {
				if (shape.type === 'group') continue
				const hitShape = this.app.getOutermostSelectableShape(shape)
				if (hitShape.type === 'frame' && erasing.size > initialSize) break
				erasing.add(hitShape.id)
			}
		}
		this.app.setErasingIds([...erasing])
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			this.parent.transition('erasing', info)
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	onInterrupt = () => {
		this.cancel()
	}
	complete() {
		const { erasingIds } = this.app
		if (erasingIds.length) {
			this.app.mark('erase end')
			this.app.deleteShapes(erasingIds)
		}
		this.app.setErasingIds([])
		this.parent.transition('idle', {})
	}
	cancel() {
		this.app.setErasingIds([])
		this.parent.transition('idle', {})
	}
}
__publicField(Pointing2, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLEraserTool/TLEraserTool.ts
var TLEraserTool = class extends StateNode {
	onEnter = () => {
		this.app.setCursor({ type: 'cross' })
	}
}
__publicField(TLEraserTool, 'id', 'eraser')
__publicField(TLEraserTool, 'initial', 'idle')
__publicField(TLEraserTool, 'children', () => [Idle3, Pointing2, Erasing])

// ../packages/editor/src/lib/app/statechart/TLFrameTool/TLFrameTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLBoxTool/TLBoxTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLBoxTool/children/Idle.ts
init_define_process()
var Idle4 = class extends StateNode {
	onPointerDown = (info) => {
		this.parent.transition('pointing', info)
	}
	onEnter = () => {
		this.app.setCursor({ type: 'cross' })
	}
	onCancel = () => {
		this.app.setSelectedTool('select')
	}
}
__publicField(Idle4, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLBoxTool/children/Pointing.ts
init_define_process()
var Pointing3 = class extends StateNode {
	markId = 'creating'
	wasFocusedOnEnter = false
	onEnter = () => {
		const { isMenuOpen } = this.app
		this.wasFocusedOnEnter = !isMenuOpen
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			const { originPagePoint } = this.app.inputs
			const shapeType = this.parent.shapeType
			const id = createShapeId()
			this.app.mark(this.markId)
			this.app.createShapes([
				{
					id,
					type: shapeType,
					x: originPagePoint.x,
					y: originPagePoint.y,
					props: {
						w: 1,
						h: 1,
					},
				},
			])
			this.app.setSelectedIds([id])
			this.app.setSelectedTool('select.resizing', {
				...info,
				target: 'selection',
				handle: 'bottom_right',
				isCreating: true,
				creationCursorOffset: { x: 1, y: 1 },
				onInteractionEnd: this.parent.id,
			})
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	onInterrupt = () => {
		this.cancel()
	}
	complete() {
		const { originPagePoint } = this.app.inputs
		if (!this.wasFocusedOnEnter) {
			return
		}
		this.app.mark(this.markId)
		const shapeType = this.parent.shapeType
		const id = createShapeId()
		this.app.mark(this.markId)
		this.app.createShapes([
			{
				id,
				type: shapeType,
				x: originPagePoint.x,
				y: originPagePoint.y,
			},
		])
		const shape = this.app.getShapeById(id)
		const { w: w3, h: h3 } = this.app.getShapeUtil(shape).defaultProps()
		const delta = this.app.getDeltaInParentSpace(shape, new Vec2d(w3 / 2, h3 / 2))
		this.app.updateShapes([
			{
				id,
				type: shapeType,
				x: shape.x - delta.x,
				y: shape.y - delta.y,
			},
		])
		this.app.setSelectedIds([id])
		if (this.app.instanceState.isToolLocked) {
			this.parent.transition('idle', {})
		} else {
			this.app.setSelectedTool('select.idle')
		}
	}
	cancel() {
		this.parent.transition('idle', {})
	}
}
__publicField(Pointing3, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLBoxTool/TLBoxTool.ts
var TLBoxTool = class extends StateNode {
	styles = ['opacity']
}
__publicField(TLBoxTool, 'id', 'box')
__publicField(TLBoxTool, 'initial', 'idle')
__publicField(TLBoxTool, 'children', () => [Idle4, Pointing3])

// ../packages/editor/src/lib/app/statechart/TLFrameTool/TLFrameTool.ts
var TLFrameTool = class extends TLBoxTool {
	shapeType = 'frame'
	styles = ['opacity']
}
__publicField(TLFrameTool, 'id', 'frame')
__publicField(TLFrameTool, 'initial', 'idle')

// ../packages/editor/src/lib/app/statechart/TLGeoTool/TLGeoTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLGeoTool/children/Idle.ts
init_define_process()
var Idle5 = class extends StateNode {
	onPointerDown = (info) => {
		this.parent.transition('pointing', info)
	}
	onEnter = () => {
		this.app.setCursor({ type: 'cross' })
	}
	onKeyUp = (info) => {
		if (info.key === 'Enter') {
			const shape = this.app.onlySelectedShape
			if (shape && shape.type === 'geo') {
				this.app.mark('editing shape')
				this.app.setEditingId(shape.id)
				this.app.setSelectedTool('select.editing_shape', {
					...info,
					target: 'shape',
					shape,
				})
			}
		}
	}
	onCancel = () => {
		this.app.setSelectedTool('select')
	}
}
__publicField(Idle5, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLGeoTool/children/Pointing.ts
init_define_process()
var Pointing4 = class extends StateNode {
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			const { originPagePoint } = this.app.inputs
			const id = createShapeId()
			this.app.mark('creating')
			this.app.createShapes([
				{
					id,
					type: 'geo',
					x: originPagePoint.x,
					y: originPagePoint.y,
					props: {
						w: 1,
						h: 1,
						geo: this.app.instanceState.propsForNextShape.geo,
					},
				},
			])
			this.app.select(id)
			this.app.setSelectedTool('select.resizing', {
				...info,
				target: 'selection',
				handle: 'bottom_right',
				isCreating: true,
				creationCursorOffset: { x: 1, y: 1 },
				onInteractionEnd: 'geo',
			})
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	onInterrupt = () => {
		this.cancel()
	}
	complete() {
		const { originPagePoint } = this.app.inputs
		const id = createShapeId()
		this.app.mark('creating')
		this.app.createShapes([
			{
				id,
				type: 'geo',
				x: originPagePoint.x,
				y: originPagePoint.y,
				props: {
					geo: this.app.instanceState.propsForNextShape.geo,
					w: 1,
					h: 1,
				},
			},
		])
		const shape = this.app.getShapeById(id)
		if (!shape) return
		const bounds =
			shape.props.geo === 'star' ? getStarBounds(5, 200, 200) : new Box2d(0, 0, 200, 200)
		const delta = this.app.getDeltaInParentSpace(shape, bounds.center)
		this.app.select(id)
		this.app.updateShapes([
			{
				id: shape.id,
				type: 'geo',
				x: shape.x - delta.x,
				y: shape.y - delta.y,
				props: {
					geo: this.app.instanceState.propsForNextShape.geo,
					w: bounds.width,
					h: bounds.height,
				},
			},
		])
		if (this.app.instanceState.isToolLocked) {
			this.parent.transition('idle', {})
		} else {
			this.app.setSelectedTool('select', {})
		}
	}
	cancel() {
		this.parent.transition('idle', {})
	}
}
__publicField(Pointing4, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLGeoTool/TLGeoTool.ts
var TLGeoTool = class extends StateNode {
	styles = ['color', 'opacity', 'dash', 'fill', 'size', 'geo', 'font', 'align']
}
__publicField(TLGeoTool, 'id', 'geo')
__publicField(TLGeoTool, 'initial', 'idle')
__publicField(TLGeoTool, 'children', () => [Idle5, Pointing4])

// ../packages/editor/src/lib/app/statechart/TLHandTool/TLHandTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLHandTool/children/Dragging.ts
init_define_process()
var Dragging = class extends StateNode {
	onEnter = () => {
		this.update()
	}
	onPointerMove = () => {
		this.update()
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	update() {
		const { currentScreenPoint, previousScreenPoint } = this.app.inputs
		const delta = Vec2d.Sub(currentScreenPoint, previousScreenPoint)
		if (Math.abs(delta.x) > 0 || Math.abs(delta.y) > 0) {
			this.app.pan(delta.x, delta.y)
		}
	}
	complete() {
		this.app.slideCamera({
			speed: Math.min(2, this.app.inputs.pointerVelocity.len()),
			direction: this.app.inputs.pointerVelocity,
			friction: HAND_TOOL_FRICTION,
		})
		this.parent.transition('idle', {})
	}
}
__publicField(Dragging, 'id', 'dragging')

// ../packages/editor/src/lib/app/statechart/TLHandTool/children/Idle.ts
init_define_process()
var Idle6 = class extends StateNode {
	onEnter = () => {
		this.app.setCursor({ type: 'grab' })
	}
	onPointerDown = (info) => {
		this.parent.transition('pointing', info)
	}
	onCancel = () => {
		this.app.setSelectedTool('select')
	}
}
__publicField(Idle6, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLHandTool/children/Pointing.ts
init_define_process()
var Pointing5 = class extends StateNode {
	onEnter = () => {
		this.app.stopCameraAnimation()
		this.app.setCursor({ type: 'grabbing' })
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			this.parent.transition('dragging', info)
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onInterrupt = () => {
		this.complete()
	}
	complete() {
		this.parent.transition('idle', {})
	}
}
__publicField(Pointing5, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLHandTool/TLHandTool.ts
var TLHandTool = class extends StateNode {
	styles = []
	onDoubleClick = (info) => {
		if (info.phase === 'settle') {
			const { currentScreenPoint } = this.app.inputs
			this.app.zoomIn(currentScreenPoint, { duration: 220, easing: EASINGS.easeOutQuint })
		}
	}
	onTripleClick = (info) => {
		if (info.phase === 'settle') {
			const { currentScreenPoint } = this.app.inputs
			this.app.zoomOut(currentScreenPoint, { duration: 320, easing: EASINGS.easeOutQuint })
		}
	}
	onQuadrupleClick = (info) => {
		if (info.phase === 'settle') {
			const {
				zoomLevel,
				inputs: { currentScreenPoint },
			} = this.app
			if (zoomLevel === 1) {
				this.app.zoomToFit({ duration: 400, easing: EASINGS.easeOutQuint })
			} else {
				this.app.resetZoom(currentScreenPoint, { duration: 320, easing: EASINGS.easeOutQuint })
			}
		}
	}
}
__publicField(TLHandTool, 'id', 'hand')
__publicField(TLHandTool, 'initial', 'idle')
__publicField(TLHandTool, 'children', () => [Idle6, Pointing5, Dragging])

// ../packages/editor/src/lib/app/statechart/TLLaserTool/TLLaserTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLLaserTool/children/Idle.ts
init_define_process()
var Idle7 = class extends StateNode {
	onPointerDown = (info) => {
		this.parent.transition('lasering', info)
	}
}
__publicField(Idle7, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLLaserTool/children/Lasering.ts
init_define_process()
var Lasering = class extends StateNode {
	scribble = {}
	onEnter = () => {
		this.startScribble()
		this.pushPointToScribble()
	}
	onExit = () => {
		this.app.setErasingIds([])
		this.scribble.stop()
	}
	onPointerMove = () => {
		this.pushPointToScribble()
	}
	onPointerUp = () => {
		this.complete()
	}
	startScribble = () => {
		if (this.scribble.tick) {
			this.app.off('tick', this.scribble?.tick)
		}
		this.scribble = new ScribbleManager({
			onUpdate: this.onScribbleUpdate,
			onComplete: this.onScribbleComplete,
			color: 'laser',
			opacity: 0.7,
			size: 4,
			delay: 1200,
		})
		this.app.on('tick', this.scribble.tick)
	}
	pushPointToScribble = () => {
		const { x: x3, y: y3 } = this.app.inputs.currentPagePoint
		this.scribble.addPoint(x3, y3)
	}
	onScribbleUpdate = (scribble) => {
		this.app.setScribble(scribble)
	}
	onScribbleComplete = () => {
		this.app.off('tick', this.scribble.tick)
		this.app.setScribble(null)
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	complete() {
		this.parent.transition('idle', {})
	}
	cancel() {
		this.parent.transition('idle', {})
	}
}
__publicField(Lasering, 'id', 'lasering')

// ../packages/editor/src/lib/app/statechart/TLLaserTool/TLLaserTool.ts
var TLLaserTool = class extends StateNode {
	onEnter = () => {
		this.app.setCursor({ type: 'cross' })
	}
}
__publicField(TLLaserTool, 'id', 'laser')
__publicField(TLLaserTool, 'initial', 'idle')
__publicField(TLLaserTool, 'children', () => [Idle7, Lasering])

// ../packages/editor/src/lib/app/statechart/TLLineTool/TLLineTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLLineTool/children/Idle.ts
init_define_process()
var Idle8 = class extends StateNode {
	shapeId = ''
	onEnter = (info) => {
		this.shapeId = info.shapeId
		this.app.setCursor({ type: 'cross' })
	}
	onPointerDown = () => {
		this.parent.transition('pointing', { shapeId: this.shapeId })
	}
	onCancel = () => {
		this.app.setSelectedTool('select')
	}
}
__publicField(Idle8, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLLineTool/children/Pointing.ts
init_define_process()
var Pointing6 = class extends StateNode {
	shape = {}
	markPointId = ''
	onEnter = (info) => {
		const { inputs } = this.app
		const { currentPagePoint } = inputs
		this.markPointId = this.app.mark('creating')
		let shapeExists = false
		if (info.shapeId) {
			const shape = this.app.getShapeById(info.shapeId)
			if (shape) {
				shapeExists = true
				this.shape = shape
			}
		}
		if (inputs.shiftKey && shapeExists) {
			const handles = this.app.getShapeUtil(this.shape).handles(this.shape)
			const vertexHandles = handles.filter((h3) => h3.type === 'vertex').sort(sortByIndex)
			const endHandle = vertexHandles[vertexHandles.length - 1]
			const shapePagePoint = Matrix2d.applyToPoint(
				this.app.getParentTransform(this.shape),
				new Vec2d(this.shape.x, this.shape.y)
			)
			let nextEndHandleIndex, nextEndHandleId, nextEndHandle
			if (vertexHandles.length === 2 && vertexHandles[1].x === 1 && vertexHandles[1].y === 1) {
				nextEndHandleIndex = vertexHandles[1].index
				nextEndHandleId = vertexHandles[1].id
				nextEndHandle = {
					...vertexHandles[1],
					x: currentPagePoint.x - shapePagePoint.x,
					y: currentPagePoint.y - shapePagePoint.y,
				}
			} else {
				nextEndHandleIndex = getIndexAbove(endHandle.index)
				nextEndHandleId = 'handle:' + nextEndHandleIndex
				nextEndHandle = {
					x: currentPagePoint.x - shapePagePoint.x,
					y: currentPagePoint.y - shapePagePoint.y,
					index: nextEndHandleIndex,
					canBind: false,
					type: 'vertex',
					id: nextEndHandleId,
				}
			}
			const nextHandles = structuredClone(this.shape.props.handles)
			nextHandles[nextEndHandle.id] = nextEndHandle
			this.app.updateShapes([
				{
					id: this.shape.id,
					type: this.shape.type,
					props: {
						handles: nextHandles,
					},
				},
			])
		} else {
			const id = createShapeId()
			this.app.createShapes([
				{
					id,
					type: this.parent.shapeType,
					x: currentPagePoint.x,
					y: currentPagePoint.y,
				},
			])
			this.app.select(id)
			this.shape = this.app.getShapeById(id)
		}
	}
	onPointerMove = () => {
		if (!this.shape) return
		if (this.app.inputs.isDragging) {
			const util = this.app.getShapeUtil(this.shape)
			const handles = util.handles?.(this.shape)
			if (!handles) {
				this.app.bailToMark('creating')
				throw Error('No handles found')
			}
			this.app.setSelectedTool('select.dragging_handle', {
				shape: this.shape,
				isCreating: true,
				handle: last(handles),
				onInteractionEnd: 'line',
			})
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	onInterrupt = () => {
		this.parent.transition('idle', {})
		this.app.bailToMark('creating')
		this.app.snaps.clear()
	}
	complete() {
		this.parent.transition('idle', { shapeId: this.shape.id })
		this.app.snaps.clear()
	}
	cancel() {
		this.app.bailToMark(this.markPointId)
		this.parent.transition('idle', { shapeId: this.shape.id })
		this.app.snaps.clear()
	}
}
__publicField(Pointing6, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLLineTool/TLLineTool.ts
var TLLineTool = class extends StateNode {
	shapeType = 'line'
	styles = ['color', 'opacity', 'dash', 'size', 'spline']
}
__publicField(TLLineTool, 'id', 'line')
__publicField(TLLineTool, 'initial', 'idle')
__publicField(TLLineTool, 'children', () => [Idle8, Pointing6])

// ../packages/editor/src/lib/app/statechart/TLNoteTool/TLNoteTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLNoteTool/children/Idle.ts
init_define_process()
var Idle9 = class extends StateNode {
	onPointerDown = (info) => {
		this.parent.transition('pointing', info)
	}
	onEnter = () => {
		this.app.setCursor({ type: 'cross' })
	}
	onCancel = () => {
		this.app.setSelectedTool('select')
	}
}
__publicField(Idle9, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLNoteTool/children/Pointing.ts
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLNoteUtil/TLNoteUtil.tsx
init_define_process()

// ../packages/editor/src/lib/utils/legacy.ts
init_define_process()
function getLegacyOffsetX(align, padding, spans, totalWidth) {
	if ((align === 'start-legacy' || align === 'end-legacy') && spans.length !== 0) {
		const spansBounds = Box2d.From(spans[0].box)
		for (const { box } of spans) {
			spansBounds.union(box)
		}
		if (align === 'start-legacy') {
			return (totalWidth - 2 * padding - spansBounds.width) / 2
		} else if (align === 'end-legacy') {
			return -(totalWidth - 2 * padding - spansBounds.width) / 2
		}
	}
}
function isLegacyAlign(align) {
	return align === 'start-legacy' || align === 'middle-legacy' || align === 'end-legacy'
}

// ../packages/editor/src/lib/app/shapeutils/shared/HyperlinkButton.tsx
init_define_process()
var import_classnames = __toESM(require_classnames())
var import_jsx_runtime15 = __toESM(require_jsx_runtime())
var LINK_ICON =
	"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E"
function HyperlinkButton({ url, zoomLevel }) {
	return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)('a', {
		className: (0, import_classnames.default)('tl-hyperlink-button', {
			'tl-hyperlink-button__hidden': zoomLevel < 0.5,
		}),
		href: url,
		target: '_blank',
		rel: 'noopener noreferrer',
		onPointerDown: stopEventPropagation,
		onPointerUp: stopEventPropagation,
		title: url,
		draggable: false,
		children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)('div', {
			className: 'tl-hyperlink-button__icon',
			style: {
				mask: `url("${LINK_ICON}") center 100% / 100% no-repeat`,
				WebkitMask: `url("${LINK_ICON}") center 100% / 100% no-repeat`,
			},
		}),
	})
}

// ../packages/editor/src/lib/app/shapeutils/shared/TextLabel.tsx
init_define_process()
var import_react13 = __toESM(require_react())
var import_jsx_runtime16 = __toESM(require_jsx_runtime())
var TextLabel = import_react13.default.memo(function TextLabel2({
	id,
	type,
	text,
	size,
	labelColor,
	font,
	align,
	verticalAlign,
	wrap: wrap2,
}) {
	const {
		rInput,
		isEmpty,
		isEditing,
		isEditableFromHover,
		handleFocus,
		handleChange,
		handleKeyDown,
		handleBlur,
	} = useEditableText(id, type, text)
	const isInteractive = isEditing || isEditableFromHover
	const finalText = TextHelpers.normalizeTextForDom(text)
	const hasText = finalText.trim().length > 0
	const legacyAlign = isLegacyAlign(align)
	return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)('div', {
		className: 'tl-text-label',
		'data-font': font,
		'data-align': align,
		'data-hastext': !isEmpty,
		'data-isediting': isEditing,
		'data-textwrap': !!wrap2,
		style:
			hasText || isInteractive
				? {
						justifyContent: align === 'middle' || legacyAlign ? 'center' : align,
						alignItems: verticalAlign === 'middle' ? 'center' : verticalAlign,
				  }
				: void 0,
		children: /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)('div', {
			className: 'tl-text-label__inner',
			style: {
				fontSize: LABEL_FONT_SIZES[size],
				lineHeight: LABEL_FONT_SIZES[size] * TEXT_PROPS.lineHeight + 'px',
				minHeight: isEmpty ? LABEL_FONT_SIZES[size] * TEXT_PROPS.lineHeight + 32 : 0,
				minWidth: isEmpty ? 33 : 0,
				color: labelColor,
			},
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime16.jsx)('div', {
					className: 'tl-text tl-text-content',
					dir: 'ltr',
					children: finalText,
				}),
				isInteractive
					? // Consider replacing with content-editable
					  /* @__PURE__ */ (0, import_jsx_runtime16.jsx)('textarea', {
							ref: rInput,
							className: 'tl-text tl-text-input',
							name: 'text',
							tabIndex: -1,
							autoComplete: 'false',
							autoCapitalize: 'false',
							autoCorrect: 'false',
							autoSave: 'false',
							autoFocus: isEditing,
							placeholder: '',
							spellCheck: 'true',
							wrap: 'off',
							dir: 'auto',
							datatype: 'wysiwyg',
							defaultValue: text,
							onFocus: handleFocus,
							onChange: handleChange,
							onKeyDown: handleKeyDown,
							onBlur: handleBlur,
							onContextMenu: stopEventPropagation,
					  })
					: null,
			],
		}),
	})
})

// ../packages/editor/src/lib/app/shapeutils/TLNoteUtil/TLNoteUtil.tsx
var import_jsx_runtime17 = __toESM(require_jsx_runtime())
var NOTE_SIZE = 200
var TLNoteUtil = class extends TLShapeUtil {
	canEdit = () => true
	hideResizeHandles = () => true
	hideSelectionBoundsBg = () => true
	hideSelectionBoundsFg = () => true
	defaultProps() {
		return {
			opacity: '1',
			color: 'black',
			size: 'm',
			text: '',
			font: 'draw',
			align: 'middle',
			growY: 0,
			url: '',
		}
	}
	getHeight(shape) {
		return NOTE_SIZE + shape.props.growY
	}
	getBounds(shape) {
		const height = this.getHeight(shape)
		return new Box2d(0, 0, NOTE_SIZE, height)
	}
	getOutline(shape) {
		return this.bounds(shape).corners
	}
	getCenter(_shape) {
		return new Vec2d(NOTE_SIZE / 2, this.getHeight(_shape) / 2)
	}
	render(shape) {
		const {
			id,
			type,
			props: { color, font, size, align, text },
		} = shape
		const adjustedColor = color === 'black' ? 'yellow' : color
		return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, {
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime17.jsx)('div', {
					style: {
						position: 'absolute',
						width: NOTE_SIZE,
						height: this.getHeight(shape),
					},
					children: /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)('div', {
						className: 'tl-note__container tl-hitarea-fill',
						style: {
							color: `var(--palette-${adjustedColor})`,
							backgroundColor: `var(--palette-${adjustedColor})`,
						},
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime17.jsx)('div', { className: 'tl-note__scrim' }),
							/* @__PURE__ */ (0, import_jsx_runtime17.jsx)(TextLabel, {
								id,
								type,
								font,
								size,
								align,
								verticalAlign: 'middle',
								text,
								labelColor: 'inherit',
								wrap: true,
							}),
						],
					}),
				}),
				'url' in shape.props &&
					shape.props.url &&
					/* @__PURE__ */ (0, import_jsx_runtime17.jsx)(HyperlinkButton, {
						url: shape.props.url,
						zoomLevel: this.app.zoomLevel,
					}),
			],
		})
	}
	indicator(shape) {
		return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)('rect', {
			rx: '7',
			width: toDomPrecision(NOTE_SIZE),
			height: toDomPrecision(this.getHeight(shape)),
		})
	}
	toSvg(shape, font, colors) {
		const bounds = this.bounds(shape)
		const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		const adjustedColor = shape.props.color === 'black' ? 'yellow' : shape.props.color
		const rect1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
		rect1.setAttribute('rx', '10')
		rect1.setAttribute('width', NOTE_SIZE.toString())
		rect1.setAttribute('height', bounds.height.toString())
		rect1.setAttribute('fill', colors.fill[adjustedColor])
		rect1.setAttribute('stroke', colors.fill[adjustedColor])
		rect1.setAttribute('stroke-width', '1')
		g3.appendChild(rect1)
		const rect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
		rect2.setAttribute('rx', '10')
		rect2.setAttribute('width', NOTE_SIZE.toString())
		rect2.setAttribute('height', bounds.height.toString())
		rect2.setAttribute('fill', colors.background)
		rect2.setAttribute('opacity', '.28')
		g3.appendChild(rect2)
		const PADDING = 17
		const opts = {
			fontSize: LABEL_FONT_SIZES[shape.props.size],
			fontFamily: font,
			textAlign: shape.props.align,
			verticalTextAlign: 'middle',
			width: bounds.width - PADDING * 2,
			height: bounds.height - PADDING * 2,
			padding: 0,
			lineHeight: TEXT_PROPS.lineHeight,
			fontStyle: 'normal',
			fontWeight: 'normal',
			overflow: 'wrap',
			offsetX: 0,
		}
		const spans = this.app.textMeasure.measureTextSpans(shape.props.text, opts)
		opts.width = bounds.width
		const offsetX = getLegacyOffsetX(shape.props.align, PADDING, spans, bounds.width)
		if (offsetX) {
			opts.offsetX = offsetX
		}
		opts.padding = PADDING
		const textElm = createTextSvgElementFromSpans(this.app, spans, opts)
		textElm.setAttribute('fill', colors.text)
		textElm.setAttribute('transform', `translate(0 ${PADDING})`)
		g3.appendChild(textElm)
		return g3
	}
	onBeforeCreate = (next) => {
		return getGrowY(this.app, next, next.props.growY)
	}
	onBeforeUpdate = (prev, next) => {
		if (
			prev.props.text === next.props.text &&
			prev.props.font === next.props.font &&
			prev.props.size === next.props.size
		) {
			return
		}
		return getGrowY(this.app, next, prev.props.growY)
	}
	onEditEnd = (shape) => {
		const {
			id,
			type,
			props: { text },
		} = shape
		if (text.trimEnd() !== shape.props.text) {
			this.app.updateShapes([
				{
					id,
					type,
					props: {
						text: text.trimEnd(),
					},
				},
			])
		}
	}
}
__publicField(TLNoteUtil, 'type', 'note')
function getGrowY(app, shape, prevGrowY = 0) {
	const PADDING = 17
	const nextTextSize = app.textMeasure.measureText(shape.props.text, {
		...TEXT_PROPS,
		fontFamily: FONT_FAMILIES[shape.props.font],
		fontSize: LABEL_FONT_SIZES[shape.props.size],
		width: NOTE_SIZE - PADDING * 2 + 'px',
	})
	const nextHeight = nextTextSize.h + PADDING * 2
	let growY = null
	if (nextHeight > NOTE_SIZE) {
		growY = nextHeight - NOTE_SIZE
	} else {
		if (prevGrowY) {
			growY = 0
		}
	}
	if (growY !== null) {
		return {
			...shape,
			props: {
				...shape.props,
				growY,
			},
		}
	}
}

// ../packages/editor/src/lib/app/statechart/TLNoteTool/children/Pointing.ts
var Pointing7 = class extends StateNode {
	dragged = false
	info = {}
	wasFocusedOnEnter = false
	markPointId = 'creating'
	onEnter = () => {
		this.wasFocusedOnEnter = !this.app.isMenuOpen
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			this.app.mark(this.markPointId)
			const shape = this.createShape()
			if (!shape) return
			this.app.setSelectedTool('select.translating', {
				...info,
				target: 'shape',
				shape,
				isCreating: true,
				editAfterComplete: true,
				onInteractionEnd: 'note',
			})
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onInterrupt = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	complete() {
		if (!this.wasFocusedOnEnter) {
			return
		}
		this.app.mark(this.markPointId)
		const shape = this.createShape()
		if (this.app.instanceState.isToolLocked) {
			this.parent.transition('idle', {})
		} else {
			if (!shape) return
			this.app.setEditingId(shape.id)
			this.app.setSelectedTool('select.editing_shape', {
				...this.info,
				target: 'shape',
				shape,
			})
		}
	}
	cancel() {
		this.app.bailToMark(this.markPointId)
		this.parent.transition('idle', this.info)
	}
	createShape() {
		const {
			inputs: { originPagePoint },
		} = this.app
		const id = this.app.createShapeId()
		this.app.createShapes(
			[
				{
					id,
					type: 'note',
					x: originPagePoint.x,
					y: originPagePoint.y,
				},
			],
			true
		)
		const util = this.app.getShapeUtil(TLNoteUtil)
		const shape = this.app.getShapeById(id)
		const bounds = util.bounds(shape)
		this.app.updateShapes([
			{
				id,
				type: 'note',
				x: shape.x - bounds.width / 2,
				y: shape.y - bounds.height / 2,
			},
		])
		return this.app.getShapeById(id)
	}
}
__publicField(Pointing7, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLNoteTool/TLNoteTool.ts
var TLNoteTool = class extends StateNode {
	styles = ['color', 'opacity', 'size', 'align', 'font']
}
__publicField(TLNoteTool, 'id', 'note')
__publicField(TLNoteTool, 'initial', 'idle')
__publicField(TLNoteTool, 'children', () => [Idle9, Pointing7])

// ../packages/editor/src/lib/app/statechart/TLSelectTool/TLSelectTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Brushing.ts
init_define_process()
var Brushing = class extends StateNode {
	info = {}
	brush = new Box2d()
	initialSelectedIds = []
	// The shape that the brush started on
	initialStartShape = null
	onEnter = (info) => {
		const { altKey: altKey2, currentPagePoint } = this.app.inputs
		if (altKey2) {
			this.parent.transition('scribble_brushing', info)
			return
		}
		this.info = info
		this.initialSelectedIds = this.app.selectedIds.slice()
		this.initialStartShape = this.app.getShapesAtPoint(currentPagePoint)[0]
		this.onPointerMove()
	}
	onExit = () => {
		this.initialSelectedIds = []
		this.app.setBrush(null)
	}
	onPointerMove = () => {
		this.hitTestShapes()
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onCancel = (info) => {
		this.app.setSelectedIds(this.initialSelectedIds, true)
		this.parent.transition('idle', info)
	}
	onKeyDown = (info) => {
		if (this.app.inputs.altKey) {
			this.parent.transition('scribble_brushing', info)
		} else {
			this.hitTestShapes()
		}
	}
	onKeyUp = () => {
		this.hitTestShapes()
	}
	complete() {
		this.parent.transition('idle', {})
	}
	hitTestShapes() {
		const {
			currentPageId,
			shapesArray,
			inputs: { originPagePoint, currentPagePoint, shiftKey, ctrlKey },
		} = this.app
		this.brush.setTo(Box2d.FromPoints([originPagePoint, currentPagePoint]))
		const results = new Set(shiftKey ? this.initialSelectedIds : [])
		let A2, B, shape, util, pageBounds, pageTransform, localCorners
		const { corners } = this.brush
		testAllShapes: for (let i3 = 0, n3 = shapesArray.length; i3 < n3; i3++) {
			shape = shapesArray[i3]
			if (shape.type === 'group') continue testAllShapes
			if (results.has(shape.id)) continue testAllShapes
			pageBounds = this.app.getPageBounds(shape)
			if (!pageBounds) continue testAllShapes
			if (this.brush.contains(pageBounds)) {
				this.handleHit(shape, currentPagePoint, currentPageId, results, corners)
				continue testAllShapes
			}
			if (ctrlKey || shape.type === 'frame') {
				continue testAllShapes
			}
			if (this.brush.collides(pageBounds)) {
				util = this.app.getShapeUtil(shape)
				pageTransform = this.app.getPageTransform(shape)
				if (!pageTransform) {
					continue testAllShapes
				}
				localCorners = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), corners)
				hitTestBrushEdges: for (let i4 = 0; i4 < localCorners.length; i4++) {
					A2 = localCorners[i4]
					B = localCorners[(i4 + 1) % localCorners.length]
					if (util.hitTestLineSegment(shape, A2, B)) {
						this.handleHit(shape, currentPagePoint, currentPageId, results, corners)
						break hitTestBrushEdges
					}
				}
			}
		}
		this.app.setBrush({ ...this.brush.toJson() })
		this.app.setSelectedIds(Array.from(results), true)
	}
	onInterrupt = () => {
		this.app.setBrush(null)
	}
	handleHit(shape, currentPagePoint, currentPageId, results, corners) {
		if (shape.parentId === currentPageId) {
			results.add(shape.id)
			return
		}
		const selectedShape = this.app.getOutermostSelectableShape(shape)
		const pageMask = this.app.getPageMaskById(selectedShape.id)
		if (
			pageMask &&
			polygonsIntersect(pageMask, corners) !== null &&
			!pointInPolygon(currentPagePoint, pageMask)
		) {
			return
		}
		results.add(selectedShape.id)
	}
}
__publicField(Brushing, 'id', 'brushing')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/Crop.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/Idle.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/crop_helpers.ts
init_define_process()
function getTranslateCroppedImageChange(app, shape, delta) {
	if (!shape) {
		throw Error('Needs to translate a cropped shape!')
	}
	const { crop: oldCrop } = shape.props
	if (!oldCrop) {
		return
	}
	const flatten = app.inputs.shiftKey ? (Math.abs(delta.x) < Math.abs(delta.y) ? 'x' : 'y') : null
	if (flatten === 'x') {
		delta.x = 0
	} else if (flatten === 'y') {
		delta.y = 0
	}
	delta.rot(-shape.rotation)
	const w3 = (1 / (oldCrop.bottomRight.x - oldCrop.topLeft.x)) * shape.props.w
	const h3 = (1 / (oldCrop.bottomRight.y - oldCrop.topLeft.y)) * shape.props.h
	const yCrop = oldCrop.bottomRight.y - oldCrop.topLeft.y
	const xCrop = oldCrop.bottomRight.x - oldCrop.topLeft.x
	const newCrop = deepCopy(oldCrop)
	newCrop.topLeft.x = Math.min(1 - xCrop, Math.max(0, newCrop.topLeft.x - delta.x / w3))
	newCrop.topLeft.y = Math.min(1 - yCrop, Math.max(0, newCrop.topLeft.y - delta.y / h3))
	newCrop.bottomRight.x = newCrop.topLeft.x + xCrop
	newCrop.bottomRight.y = newCrop.topLeft.y + yCrop
	const partial = {
		id: shape.id,
		type: shape.type,
		props: {
			crop: newCrop,
		},
	}
	return partial
}

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/Idle.ts
var Idle10 = class extends StateNode {
	onEnter = () => {
		this.app.setCursor({ type: 'default' })
		const { onlySelectedShape } = this.app
		this.app.on('change-history', this.cleanupCroppingState)
		this.app.mark('crop')
		if (onlySelectedShape) {
			this.app.setCroppingId(onlySelectedShape.id)
		}
	}
	onExit = () => {
		this.app.setCursor({ type: 'default' })
		this.app.off('change-history', this.cleanupCroppingState)
	}
	onCancel = () => {
		this.app.setCroppingId(null)
		this.app.setSelectedTool('select.idle', {})
	}
	onPointerDown = (info) => {
		if (this.app.isMenuOpen) return
		if (info.ctrlKey) {
			this.app.setCroppingId(null)
			this.app.setSelectedTool('select.brushing', info)
			return
		}
		switch (info.target) {
			case 'canvas': {
				this.cancel()
				break
			}
			case 'shape': {
				if (info.shape.id === this.app.croppingId) {
					this.app.setSelectedTool('select.crop.pointing_crop', info)
					return
				} else {
					if (this.app.getShapeUtil(info.shape)?.canCrop(info.shape)) {
						this.app.setCroppingId(info.shape.id)
						this.app.setSelectedIds([info.shape.id])
						this.app.setSelectedTool('select.crop.pointing_crop', info)
					} else {
						this.cancel()
					}
				}
				break
			}
			case 'selection': {
				switch (info.handle) {
					case 'mobile_rotate':
					case 'top_left_rotate':
					case 'top_right_rotate':
					case 'bottom_left_rotate':
					case 'bottom_right_rotate': {
						this.app.setSelectedTool('select.pointing_rotate_handle', {
							...info,
							onInteractionEnd: 'select.crop',
						})
						break
					}
					case 'top':
					case 'right':
					case 'bottom':
					case 'left': {
						this.app.setSelectedTool('select.pointing_crop_handle', {
							...info,
							onInteractionEnd: 'select.crop',
						})
						break
					}
					case 'top_left':
					case 'top_right':
					case 'bottom_left':
					case 'bottom_right': {
						this.app.setSelectedTool('select.pointing_crop_handle', {
							...info,
							onInteractionEnd: 'select.crop',
						})
						break
					}
					default: {
						this.cancel()
					}
				}
				break
			}
		}
	}
	onDoubleClick = (info) => {
		if (info.phase !== 'up') return
		if (!this.app.croppingId) return
		const shape = this.app.getShapeById(this.app.croppingId)
		if (!shape) return
		const util = this.app.getShapeUtil(shape)
		if (!util) return
		if (info.target === 'selection') {
			util.onDoubleClickEdge?.(shape)
		}
	}
	onKeyDown = () => {
		this.nudgeCroppingImage(false)
	}
	onKeyRepeat = () => {
		this.nudgeCroppingImage(true)
	}
	onKeyUp = (info) => {
		switch (info.code) {
			case 'Enter': {
				this.app.setCroppingId(null)
				this.app.setSelectedTool('select.idle', {})
				break
			}
		}
	}
	cancel() {
		this.app.setCroppingId(null)
		this.app.setSelectedTool('select.idle', {})
	}
	cleanupCroppingState = () => {
		if (!this.app.croppingId) {
			this.app.setSelectedTool('select.idle', {})
		}
	}
	nudgeCroppingImage(ephemeral = false) {
		const {
			app: {
				inputs: { keys },
			},
		} = this
		const shiftKey = keys.has('Shift')
		const delta = new Vec2d(0, 0)
		if (keys.has('ArrowLeft')) delta.x += 1
		if (keys.has('ArrowRight')) delta.x -= 1
		if (keys.has('ArrowUp')) delta.y += 1
		if (keys.has('ArrowDown')) delta.y -= 1
		if (delta.equals(new Vec2d(0, 0))) return
		if (shiftKey) delta.mul(10)
		const shape = this.app.getShapeById(this.app.croppingId)
		if (!shape) return
		const partial = getTranslateCroppedImageChange(this.app, shape, delta)
		if (partial) {
			if (!ephemeral) {
				this.app.mark('translate crop')
			}
			this.app.updateShapes([partial])
		}
	}
}
__publicField(Idle10, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/PointingCrop.ts
init_define_process()
var PointingCrop = class extends StateNode {
	onCancel = () => {
		this.app.setSelectedTool('select.crop.idle', {})
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			this.app.setSelectedTool('select.crop.translating_crop', info)
		}
	}
	onPointerUp = (info) => {
		this.app.setSelectedTool('select.crop.idle', info)
	}
}
__publicField(PointingCrop, 'id', 'pointing_crop')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/TranslatingCrop.ts
init_define_process()
var TranslatingCrop = class extends StateNode {
	info = {}
	markId = 'translating crop'
	snapshot = {}
	onEnter = (info) => {
		this.info = info
		this.snapshot = this.createSnapshot()
		this.app.mark(this.markId)
		this.app.setCursor({ type: 'move' })
		this.updateShapes()
	}
	onExit = () => {
		this.app.setCursor({ type: 'default' })
	}
	onPointerMove = () => {
		this.updateShapes()
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onKeyDown = (info) => {
		switch (info.key) {
			case 'Alt':
			case 'Shift': {
				this.updateShapes()
				return
			}
		}
	}
	onKeyUp = (info) => {
		switch (info.key) {
			case 'Enter': {
				this.complete()
				return
			}
			case 'Alt':
			case 'Shift': {
				this.updateShapes()
			}
		}
	}
	complete() {
		this.updateShapes()
		this.app.setSelectedTool('select.crop.idle', this.info)
	}
	cancel() {
		this.app.bailToMark(this.markId)
		this.app.setSelectedTool('select.crop.idle', this.info)
	}
	createSnapshot() {
		const shape = this.app.onlySelectedShape
		return { shape }
	}
	updateShapes() {
		const shape = this.snapshot.shape
		if (!shape) return
		const { originPagePoint, currentPagePoint } = this.app.inputs
		const delta = currentPagePoint.clone().sub(originPagePoint)
		const partial = getTranslateCroppedImageChange(this.app, shape, delta)
		if (partial) {
			this.app.updateShapes([partial], true)
		}
	}
}
__publicField(TranslatingCrop, 'id', 'translating_crop')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/Crop.ts
var Crop = class extends StateNode {}
__publicField(Crop, 'id', 'crop')
__publicField(Crop, 'initial', 'idle')
__publicField(Crop, 'children', () => [Idle10, TranslatingCrop, PointingCrop])

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Cropping.ts
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLImageUtil/TLImageUtil.tsx
init_define_process()
var import_react14 = __toESM(require_react())

// ../packages/editor/src/lib/components/DefaultSpinner.tsx
init_define_process()
var import_jsx_runtime18 = __toESM(require_jsx_runtime())
var DefaultSpinner = () => {
	return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)('svg', {
		width: 16,
		height: 16,
		viewBox: '0 0 16 16',
		children: /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)('g', {
			strokeWidth: 2,
			fill: 'none',
			fillRule: 'evenodd',
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime18.jsx)('circle', {
					strokeOpacity: 0.25,
					cx: 8,
					cy: 8,
					r: 7,
					stroke: 'black',
				}),
				/* @__PURE__ */ (0, import_jsx_runtime18.jsx)('path', {
					strokeLinecap: 'round',
					d: 'M15 8c0-4.5-4.5-7-7-7',
					stroke: 'black',
					children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)('animateTransform', {
						attributeName: 'transform',
						type: 'rotate',
						from: '0 8 8',
						to: '360 8 8',
						dur: '1s',
						repeatCount: 'indefinite',
					}),
				}),
			],
		}),
	})
}

// ../packages/editor/src/lib/hooks/useIsCropping.ts
init_define_process()
function useIsCropping(shapeId) {
	const app = useApp()
	return useValue('isCropping', () => app.croppingId === shapeId, [app, shapeId])
}

// ../packages/editor/src/lib/app/shapeutils/TLImageUtil/TLImageUtil.tsx
var import_jsx_runtime19 = __toESM(require_jsx_runtime())
var loadImage = async (url) => {
	return new Promise((resolve, reject) => {
		const image = new Image()
		image.onload = () => resolve(image)
		image.onerror = () => reject(new Error('Failed to load image'))
		image.crossOrigin = 'anonymous'
		image.src = url
	})
}
var getStateFrame = async (url) => {
	const image = await loadImage(url)
	const canvas = document.createElement('canvas')
	canvas.width = image.width
	canvas.height = image.height
	const ctx = canvas.getContext('2d')
	if (!ctx) return
	ctx.drawImage(image, 0, 0)
	return canvas.toDataURL()
}
async function getDataURIFromURL(url) {
	const response = await fetch(url)
	const blob = await response.blob()
	return new Promise((resolve, reject) => {
		const reader = new FileReader()
		reader.onloadend = () => resolve(reader.result)
		reader.onerror = reject
		reader.readAsDataURL(blob)
	})
}
var TLImageUtil = class extends TLBoxUtil {
	isAspectRatioLocked = () => true
	canCrop = () => true
	defaultProps() {
		return {
			opacity: '1',
			w: 100,
			h: 100,
			assetId: null,
			playing: true,
			url: '',
			crop: null,
		}
	}
	render(shape) {
		const containerStyle = getContainerStyle(shape)
		const isCropping = useIsCropping(shape.id)
		const prefersReducedMotion = usePrefersReducedMotion()
		const [staticFrameSrc, setStaticFrameSrc] = (0, import_react14.useState)('')
		const { w: w3, h: h3 } = shape.props
		const asset = shape.props.assetId ? this.app.getAssetById(shape.props.assetId) : void 0
		if (asset?.type === 'bookmark') {
			throw Error("Bookmark assets can't be rendered as images")
		}
		const isSelected = useValue(
			'onlySelectedShape',
			() => shape.id === this.app.onlySelectedShape?.id,
			[this.app]
		)
		const showCropPreview =
			isSelected &&
			isCropping &&
			this.app.isInAny('select.crop', 'select.cropping', 'select.pointing_crop_handle')
		const reduceMotion =
			prefersReducedMotion &&
			(asset?.props.mimeType?.includes('video') || asset?.props.mimeType?.includes('gif'))
		;(0, import_react14.useEffect)(() => {
			if (asset?.props.src && 'mimeType' in asset.props && asset?.props.mimeType === 'image/gif') {
				let cancelled = false
				const run = async () => {
					const newStaticFrame = await getStateFrame(asset.props.src)
					if (cancelled) return
					if (newStaticFrame) {
						setStaticFrameSrc(newStaticFrame)
					}
				}
				run()
				return () => {
					cancelled = true
				}
			}
		}, [prefersReducedMotion, asset?.props])
		return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, {
			children: [
				asset?.props.src &&
					showCropPreview &&
					/* @__PURE__ */ (0, import_jsx_runtime19.jsx)('div', {
						style: containerStyle,
						children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)('div', {
							className: `tl-image tl-image-${shape.id}-crop`,
							style: {
								opacity: 0.1,
								backgroundImage: `url(${
									!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
								})`,
							},
							draggable: false,
						}),
					}),
				/* @__PURE__ */ (0, import_jsx_runtime19.jsx)(HTMLContainer, {
					id: shape.id,
					style: { overflow: 'hidden' },
					children: /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)('div', {
						className: 'tl-image-container',
						style: containerStyle,
						children: [
							asset?.props.src
								? /* @__PURE__ */ (0, import_jsx_runtime19.jsx)('div', {
										className: `tl-image tl-image-${shape.id}`,
										style: {
											backgroundImage: `url(${
												!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src
											})`,
										},
										draggable: false,
								  })
								: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)('g', {
										transform: `translate(${(w3 - 38) / 2}, ${(h3 - 38) / 2})`,
										children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(DefaultSpinner, {}),
								  }),
							asset?.props.isAnimated &&
								!shape.props.playing &&
								/* @__PURE__ */ (0, import_jsx_runtime19.jsx)('div', {
									className: 'tl-image__tg',
									children: 'GIF',
								}),
						],
					}),
				}),
				'url' in shape.props &&
					shape.props.url &&
					/* @__PURE__ */ (0, import_jsx_runtime19.jsx)(HyperlinkButton, {
						url: shape.props.url,
						zoomLevel: this.app.zoomLevel,
					}),
			],
		})
	}
	indicator(shape) {
		const isCropping = useIsCropping(shape.id)
		if (isCropping) {
			return null
		}
		return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)('rect', {
			width: toDomPrecision(shape.props.w),
			height: toDomPrecision(shape.props.h),
		})
	}
	async toSvg(shape) {
		const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		const asset = shape.props.assetId ? this.app.getAssetById(shape.props.assetId) : null
		let src = asset?.props.src || ''
		if (src && src.startsWith('http')) {
			src = (await getDataURIFromURL(src)) || ''
		}
		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src)
		const containerStyle = getContainerStyle(shape)
		const crop = shape.props.crop
		if (containerStyle && crop) {
			const { transform, width, height } = containerStyle
			const points2 = [
				new Vec2d(crop.topLeft.x * width, crop.topLeft.y * height),
				new Vec2d(crop.bottomRight.x * width, crop.topLeft.y * height),
				new Vec2d(crop.bottomRight.x * width, crop.bottomRight.y * height),
				new Vec2d(crop.topLeft.x * width, crop.bottomRight.y * height),
			]
			const innerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')
			innerElement.style.clipPath = `polygon(${points2
				.map((p3) => `${p3.x}px ${p3.y}px`)
				.join(',')})`
			image.setAttribute('width', width.toString())
			image.setAttribute('height', height.toString())
			image.style.transform = transform
			innerElement.appendChild(image)
			g3.appendChild(innerElement)
		} else {
			image.setAttribute('width', shape.props.w.toString())
			image.setAttribute('height', shape.props.h.toString())
			g3.appendChild(image)
		}
		return g3
	}
	onDoubleClick = (shape) => {
		const asset = shape.props.assetId ? this.app.getAssetById(shape.props.assetId) : void 0
		if (!asset) return
		const canPlay =
			asset.props.src && 'mimeType' in asset.props && asset.props.mimeType === 'image/gif'
		if (!canPlay) return
		this.app.updateShapes([
			{
				type: 'image',
				id: shape.id,
				props: {
					playing: !shape.props.playing,
				},
			},
		])
	}
	onDoubleClickEdge = (shape) => {
		const props = shape.props
		if (!props) return
		if (this.app.croppingId !== shape.id) {
			return
		}
		const crop = deepCopy(props.crop) || {
			topLeft: { x: 0, y: 0 },
			bottomRight: { x: 1, y: 1 },
		}
		const w3 = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
		const h3 = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
		const pointDelta = new Vec2d(crop.topLeft.x * w3, crop.topLeft.y * h3).rot(shape.rotation)
		const partial = {
			id: shape.id,
			type: shape.type,
			x: shape.x - pointDelta.x,
			y: shape.y - pointDelta.y,
			props: {
				crop: {
					topLeft: { x: 0, y: 0 },
					bottomRight: { x: 1, y: 1 },
				},
				w: w3,
				h: h3,
			},
		}
		this.app.updateShapes([partial])
	}
}
__publicField(TLImageUtil, 'type', 'image')
function getContainerStyle(shape) {
	const crop = shape.props.crop
	const topLeft = crop?.topLeft
	if (!topLeft) return
	const w3 = (1 / (crop.bottomRight.x - crop.topLeft.x)) * shape.props.w
	const h3 = (1 / (crop.bottomRight.y - crop.topLeft.y)) * shape.props.h
	const offsetX = -topLeft.x * w3
	const offsetY = -topLeft.y * h3
	return {
		transform: `translate(${offsetX}px, ${offsetY}px)`,
		width: w3,
		height: h3,
	}
}

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingResizeHandle.ts
init_define_process()
var CursorTypeMap = {
	bottom: 'ns-resize',
	top: 'ns-resize',
	left: 'ew-resize',
	right: 'ew-resize',
	bottom_left: 'nesw-resize',
	bottom_right: 'nwse-resize',
	top_left: 'nwse-resize',
	top_right: 'nesw-resize',
	bottom_left_rotate: 'swne-rotate',
	bottom_right_rotate: 'senw-rotate',
	top_left_rotate: 'nwse-rotate',
	top_right_rotate: 'nesw-rotate',
	mobile_rotate: 'grabbing',
}
var PointingResizeHandle = class extends StateNode {
	info = {}
	updateCursor() {
		const selected = this.app.selectedShapes
		const cursorType = CursorTypeMap[this.info.handle]
		this.app.setCursor({
			type: cursorType,
			rotation: selected.length === 1 ? selected[0].rotation : 0,
		})
	}
	onEnter = (info) => {
		this.info = info
		this.updateCursor()
	}
	onPointerMove = () => {
		const isDragging = this.app.inputs.isDragging
		if (isDragging) {
			this.parent.transition('resizing', this.info)
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	// override onPinchStart: TLEventHandlers['onPinchStart'] = (info) => {
	// 	this.parent.transition('pinching', info)
	// }
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.cancel()
	}
	onInterrupt = () => {
		this.cancel()
	}
	complete() {
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, {})
		} else {
			this.parent.transition('idle', {})
		}
	}
	cancel() {
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, {})
		} else {
			this.parent.transition('idle', {})
		}
	}
}
__publicField(PointingResizeHandle, 'id', 'pointing_resize_handle')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Cropping.ts
var Cropping = class extends StateNode {
	info = {}
	markId = ''
	snapshot = {}
	onEnter = (info) => {
		this.info = info
		this.markId = this.app.mark('cropping')
		this.snapshot = this.createSnapshot()
		this.updateShapes()
	}
	onPointerMove = () => {
		this.updateShapes()
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	updateCursor() {
		const selectedShape = this.app.selectedShapes[0]
		if (!selectedShape) return
		const cursorType = CursorTypeMap[this.info.handle]
		this.app.setCursor({
			type: cursorType,
			rotation: selectedShape.rotation,
		})
	}
	getDefaultCrop = () => ({
		topLeft: { x: 0, y: 0 },
		bottomRight: { x: 1, y: 1 },
	})
	updateShapes() {
		const { shape, cursorHandleOffset } = this.snapshot
		if (!shape) return
		const util = this.app.getShapeUtil(TLImageUtil)
		if (!util) return
		const props = shape.props
		const currentPagePoint = this.app.inputs.currentPagePoint.clone().sub(cursorHandleOffset)
		const originPagePoint = this.app.inputs.originPagePoint.clone().sub(cursorHandleOffset)
		const change = currentPagePoint.clone().sub(originPagePoint).rot(-shape.rotation)
		const crop = props.crop ?? this.getDefaultCrop()
		const newCrop = deepCopy(crop)
		const newPoint = new Vec2d(shape.x, shape.y)
		const pointDelta = new Vec2d(0, 0)
		const w3 = (1 / (crop.bottomRight.x - crop.topLeft.x)) * props.w
		const h3 = (1 / (crop.bottomRight.y - crop.topLeft.y)) * props.h
		let hasCropChanged = false
		switch (this.info.handle) {
			case 'top':
			case 'top_left':
			case 'top_right': {
				if (h3 < MIN_CROP_SIZE) break
				hasCropChanged = true
				newCrop.topLeft.y = newCrop.topLeft.y + change.y / h3
				const heightAfterCrop = h3 * (newCrop.bottomRight.y - newCrop.topLeft.y)
				if (heightAfterCrop < MIN_CROP_SIZE) {
					newCrop.topLeft.y = newCrop.bottomRight.y - MIN_CROP_SIZE / h3
					pointDelta.y = (newCrop.topLeft.y - crop.topLeft.y) * h3
				} else {
					if (newCrop.topLeft.y <= 0) {
						newCrop.topLeft.y = 0
						pointDelta.y = (newCrop.topLeft.y - crop.topLeft.y) * h3
					} else {
						pointDelta.y = change.y
					}
				}
				break
			}
			case 'bottom':
			case 'bottom_left':
			case 'bottom_right': {
				if (h3 < MIN_CROP_SIZE) break
				hasCropChanged = true
				newCrop.bottomRight.y = Math.min(1, newCrop.bottomRight.y + change.y / h3)
				const heightAfterCrop = h3 * (newCrop.bottomRight.y - newCrop.topLeft.y)
				if (heightAfterCrop < MIN_CROP_SIZE) {
					newCrop.bottomRight.y = newCrop.topLeft.y + MIN_CROP_SIZE / h3
				}
				break
			}
		}
		switch (this.info.handle) {
			case 'left':
			case 'top_left':
			case 'bottom_left': {
				if (w3 < MIN_CROP_SIZE) break
				hasCropChanged = true
				newCrop.topLeft.x = newCrop.topLeft.x + change.x / w3
				const widthAfterCrop = w3 * (newCrop.bottomRight.x - newCrop.topLeft.x)
				if (widthAfterCrop < MIN_CROP_SIZE) {
					newCrop.topLeft.x = newCrop.bottomRight.x - MIN_CROP_SIZE / w3
					pointDelta.x = (newCrop.topLeft.x - crop.topLeft.x) * w3
				} else {
					if (newCrop.topLeft.x <= 0) {
						newCrop.topLeft.x = 0
						pointDelta.x = (newCrop.topLeft.x - crop.topLeft.x) * w3
					} else {
						pointDelta.x = change.x
					}
				}
				break
			}
			case 'right':
			case 'top_right':
			case 'bottom_right': {
				if (w3 < MIN_CROP_SIZE) break
				hasCropChanged = true
				newCrop.bottomRight.x = Math.min(1, newCrop.bottomRight.x + change.x / w3)
				const widthAfterCrop = w3 * (newCrop.bottomRight.x - newCrop.topLeft.x)
				if (widthAfterCrop < MIN_CROP_SIZE) {
					newCrop.bottomRight.x = newCrop.topLeft.x + MIN_CROP_SIZE / w3
				}
				break
			}
		}
		if (!hasCropChanged) return
		newPoint.add(pointDelta.rot(shape.rotation))
		const partial = {
			id: shape.id,
			type: shape.type,
			x: newPoint.x,
			y: newPoint.y,
			props: {
				crop: newCrop,
				w: (newCrop.bottomRight.x - newCrop.topLeft.x) * w3,
				h: (newCrop.bottomRight.y - newCrop.topLeft.y) * h3,
			},
		}
		this.app.updateShapes([partial], true)
		this.updateCursor()
	}
	complete() {
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, this.info)
		} else {
			this.app.setCroppingId(null)
			this.parent.transition('idle', {})
		}
	}
	cancel() {
		this.app.bailToMark(this.markId)
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, this.info)
		} else {
			this.app.setCroppingId(null)
			this.parent.transition('idle', {})
		}
	}
	createSnapshot() {
		const {
			selectionRotation,
			inputs: { originPagePoint },
		} = this.app
		const shape = this.app.onlySelectedShape
		const selectionBounds = this.app.selectionBounds
		const dragHandlePoint = Vec2d.RotWith(
			selectionBounds.getHandlePoint(this.info.handle),
			selectionBounds.point,
			selectionRotation
		)
		const cursorHandleOffset = Vec2d.Sub(originPagePoint, dragHandlePoint)
		return {
			shape,
			cursorHandleOffset,
		}
	}
}
__publicField(Cropping, 'id', 'cropping')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/DraggingHandle.ts
init_define_process()
var DraggingHandle = class extends StateNode {
	shapeId = ''
	initialHandle = {}
	initialAdjacentHandle = null
	markId = ''
	initialPageTransform
	initialPageRotation
	info = {}
	isPrecise = false
	isPreciseId = null
	pointingId = null
	onEnter = (info) => {
		const { shape, isCreating, handle } = info
		this.info = info
		this.shapeId = shape.id
		this.markId = isCreating ? 'creating' : this.app.mark('dragging handle')
		this.initialHandle = deepCopy(handle)
		this.initialPageTransform = this.app.getPageTransform(shape)
		this.initialPageRotation = this.app.getPageRotation(shape)
		this.app.setCursor({ type: isCreating ? 'cross' : 'grabbing', rotation: 0 })
		const handles = this.app.getShapeUtil(shape).handles(shape).sort(sortByIndex)
		const index2 = handles.findIndex((h3) => h3.id === info.handle.id)
		this.initialAdjacentHandle = null
		for (let i3 = index2 + 1; i3 < handles.length; i3++) {
			const handle2 = handles[i3]
			if (handle2.type === 'vertex' && handle2.id !== 'middle' && handle2.id !== info.handle.id) {
				this.initialAdjacentHandle = handle2
				break
			}
		}
		if (!this.initialAdjacentHandle) {
			for (let i3 = handles.length - 1; i3 >= 0; i3--) {
				const handle2 = handles[i3]
				if (handle2.type === 'vertex' && handle2.id !== 'middle' && handle2.id !== info.handle.id) {
					this.initialAdjacentHandle = handle2
					break
				}
			}
		}
		const initialTerminal = shape.props[info.handle.id]
		this.isPrecise = false
		if (initialTerminal?.type === 'binding') {
			this.app.setHintingIds([initialTerminal.boundShapeId])
			this.isPrecise = !Vec2d.Equals(initialTerminal.normalizedAnchor, { x: 0.5, y: 0.5 })
			if (this.isPrecise) {
				this.isPreciseId = initialTerminal.boundShapeId
			} else {
				this.resetExactTimeout()
			}
		}
		this.update()
	}
	exactTimeout = -1
	resetExactTimeout() {
		if (this.exactTimeout !== -1) {
			this.clearExactTimeout()
		}
		this.exactTimeout = setTimeout(() => {
			if (this.isActive && !this.isPrecise) {
				this.isPrecise = true
				this.isPreciseId = this.pointingId
				this.update()
			}
			this.exactTimeout = -1
		}, 750)
	}
	clearExactTimeout() {
		if (this.exactTimeout !== -1) {
			clearTimeout(this.exactTimeout)
			this.exactTimeout = -1
		}
	}
	onPointerMove = () => {
		this.update()
	}
	onKeyDown = () => {
		this.update()
	}
	onKeyUp = () => {
		this.update()
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onExit = () => {
		this.app.setHintingIds([])
		this.app.snaps.clear()
		this.app.setCursor({ type: 'default' })
	}
	complete() {
		this.app.snaps.clear()
		const { onInteractionEnd } = this.info
		if (this.app.instanceState.isToolLocked && onInteractionEnd) {
			this.app.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId })
			return
		}
		this.parent.transition('idle', {})
	}
	cancel() {
		this.app.bailToMark(this.markId)
		this.app.snaps.clear()
		const { onInteractionEnd } = this.info
		if (onInteractionEnd) {
			this.app.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId })
			return
		}
		this.parent.transition('idle', {})
	}
	update() {
		const { currentPagePoint, originPagePoint, shiftKey } = this.app.inputs
		const shape = this.app.getShapeById(this.shapeId)
		if (!shape) return
		let point2 = Vec2d.Add(
			Vec2d.Rot(Vec2d.Sub(currentPagePoint, originPagePoint), -this.initialPageRotation),
			this.initialHandle
		)
		if (shiftKey && this.initialHandle.id !== 'middle') {
			const { initialAdjacentHandle } = this
			if (initialAdjacentHandle) {
				const angle = Vec2d.Angle(initialAdjacentHandle, point2)
				const snappedAngle = snapAngle(angle, 24)
				const angleDifference = snappedAngle - angle
				point2 = Vec2d.RotWith(point2, initialAdjacentHandle, angleDifference)
			}
		}
		this.app.snaps.clear()
		const { ctrlKey } = this.app.inputs
		const shouldSnap = this.app.userDocumentSettings.isSnapMode ? !ctrlKey : ctrlKey
		if (shouldSnap && shape.type === 'line') {
			const pagePoint = Matrix2d.applyToPoint(this.app.getPageTransformById(shape.id), point2)
			const snapData = this.app.snaps.snapLineHandleTranslate({
				lineId: shape.id,
				handleId: this.initialHandle.id,
				handlePoint: pagePoint,
			})
			const { nudge } = snapData
			if (nudge.x || nudge.y) {
				const shapeSpaceNudge = this.app.getDeltaInShapeSpace(shape, nudge)
				point2 = Vec2d.Add(point2, shapeSpaceNudge)
			}
		}
		const util = this.app.getShapeUtil(shape)
		const changes = util.onHandleChange?.(shape, {
			handle: {
				...this.initialHandle,
				x: point2.x,
				y: point2.y,
			},
			isPrecise: this.isPrecise || this.app.inputs.altKey,
		})
		const next = { ...shape, ...changes }
		if (this.initialHandle.canBind) {
			const bindingAfter = next.props[this.initialHandle.id]
			if (bindingAfter?.type === 'binding') {
				if (this.app.hintingIds[0] !== bindingAfter.boundShapeId) {
					this.app.setHintingIds([bindingAfter.boundShapeId])
					this.pointingId = bindingAfter.boundShapeId
					this.isPrecise = this.app.inputs.pointerVelocity.len() < 0.5 || this.app.inputs.altKey
					this.isPreciseId = this.isPrecise ? bindingAfter.boundShapeId : null
					this.resetExactTimeout()
				}
			} else {
				if (this.app.hintingIds.length > 0) {
					this.app.setHintingIds([])
					this.pointingId = null
					this.isPrecise = false
					this.isPreciseId = null
					this.resetExactTimeout()
				}
			}
		}
		if (changes) {
			this.app.updateShapes([next], true)
		}
	}
}
__publicField(DraggingHandle, 'id', 'dragging_handle')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/EditingShape.ts
init_define_process()
var EditingShape = class extends StateNode {
	onPointerEnter = (info) => {
		switch (info.target) {
			case 'shape': {
				const { selectedIds, focusLayerId } = this.app
				const hoveringShape = this.app.getOutermostSelectableShape(
					info.shape,
					(parent) => !selectedIds.includes(parent.id)
				)
				if (hoveringShape.id !== focusLayerId) {
					this.app.setHoveredId(hoveringShape.id)
				}
				break
			}
		}
	}
	onPointerLeave = (info) => {
		switch (info.target) {
			case 'shape': {
				this.app.setHoveredId(null)
				break
			}
		}
	}
	onExit = () => {
		if (!this.app.pageState.editingId) return
		const { editingId } = this.app.pageState
		if (!editingId) return
		this.app.setEditingId(null)
		const shape = this.app.getShapeById(editingId)
		const util = this.app.getShapeUtil(shape)
		util.onEditEnd?.(shape)
	}
	onPointerDown = (info) => {
		switch (info.target) {
			case 'shape': {
				const { shape } = info
				const { editingId } = this.app.pageState
				if (editingId) {
					if (shape.id === editingId) {
						return
					}
					const editingShape = this.app.getShapeById(editingId)
					if (editingShape) {
						const editingShapeUtil = this.app.getShapeUtil(editingShape)
						editingShapeUtil.onEditEnd?.(editingShape)
						const util = this.app.getShapeUtil(shape)
						if (shape.type === editingShape.type && util.canEdit?.(shape)) {
							this.app.setEditingId(shape.id)
							this.app.setHoveredId(shape.id)
							this.app.setSelectedIds([shape.id])
							return
						}
					}
				}
			}
		}
		this.parent.transition('idle', info)
		this.parent.current.value?.onPointerDown?.(info)
	}
	onComplete = (info) => {
		this.parent.transition('idle', info)
	}
	onCancel = (info) => {
		this.parent.transition('idle', info)
	}
}
__publicField(EditingShape, 'id', 'editing_shape')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Idle.ts
init_define_process()
var Idle11 = class extends StateNode {
	onPointerEnter = (info) => {
		switch (info.target) {
			case 'canvas': {
				break
			}
			case 'shape': {
				const { selectedIds, focusLayerId } = this.app
				const hoveringShape = this.app.getOutermostSelectableShape(
					info.shape,
					(parent) => !selectedIds.includes(parent.id)
				)
				if (hoveringShape.id !== focusLayerId) {
					this.app.setHoveredId(hoveringShape.id)
				}
				if (debugFlags.debugCursors.value) {
					if (hoveringShape.type !== 'geo') break
					const cursorType = hoveringShape.props.text
					try {
						this.app.setCursor({ type: cursorType })
					} catch (e2) {
						console.error(`Cursor type not recognized: '${cursorType}'`)
						this.app.setCursor({ type: 'default' })
					}
				}
				break
			}
		}
	}
	onPointerLeave = (info) => {
		switch (info.target) {
			case 'shape': {
				this.app.setHoveredId(null)
				break
			}
		}
	}
	onPointerDown = (info) => {
		if (this.app.isMenuOpen) return
		const shouldEnterCropMode = this.shouldEnterCropMode(info, true)
		if (info.ctrlKey && !shouldEnterCropMode) {
			this.parent.transition('brushing', info)
			return
		}
		switch (info.target) {
			case 'canvas': {
				this.parent.transition('pointing_canvas', info)
				break
			}
			case 'shape': {
				this.parent.transition('pointing_shape', info)
				break
			}
			case 'handle': {
				if (this.app.isReadOnly) break
				if (this.app.inputs.altKey) {
					this.parent.transition('pointing_shape', info)
				} else {
					this.parent.transition('pointing_handle', info)
				}
				break
			}
			case 'selection': {
				switch (info.handle) {
					case 'mobile_rotate':
					case 'top_left_rotate':
					case 'top_right_rotate':
					case 'bottom_left_rotate':
					case 'bottom_right_rotate': {
						this.parent.transition('pointing_rotate_handle', info)
						break
					}
					case 'top':
					case 'right':
					case 'bottom':
					case 'left': {
						if (shouldEnterCropMode) {
							this.parent.transition('pointing_crop_handle', info)
						} else {
							this.parent.transition('pointing_resize_handle', info)
						}
						break
					}
					case 'top_left':
					case 'top_right':
					case 'bottom_left':
					case 'bottom_right': {
						if (shouldEnterCropMode) {
							this.parent.transition('pointing_crop_handle', info)
						} else {
							this.parent.transition('pointing_resize_handle', info)
						}
						break
					}
					default: {
						this.parent.transition('pointing_selection', info)
					}
				}
				break
			}
		}
	}
	onDoubleClick = (info) => {
		if (info.phase !== 'up') return
		switch (info.target) {
			case 'canvas': {
				if (this.app.isReadOnly) break
				this.createTextShapeAtPoint(info)
				break
			}
			case 'selection': {
				if (this.app.isReadOnly) break
				const { onlySelectedShape } = this.app
				if (onlySelectedShape) {
					const util = this.app.getShapeUtil(onlySelectedShape)
					if (
						info.handle === 'right' ||
						info.handle === 'left' ||
						info.handle === 'top' ||
						info.handle === 'bottom'
					) {
						const change = util.onDoubleClickEdge?.(onlySelectedShape)
						if (change) {
							this.app.mark('double click edge')
							this.app.updateShapes([change])
							return
						}
					}
					if (util.canCrop(onlySelectedShape)) {
						this.parent.transition('crop', info)
						return
					}
					if (util.canEdit(onlySelectedShape)) {
						this.startEditingShape(onlySelectedShape, info)
					}
				}
				break
			}
			case 'shape': {
				const { shape } = info
				const util = this.app.getShapeUtil(shape)
				if (shape.type !== 'video' && shape.type !== 'embed' && this.app.isReadOnly) break
				if (util.onDoubleClick) {
					const change = util.onDoubleClick?.(shape)
					if (change) {
						this.app.updateShapes([change])
						return
					} else if (util.canCrop(shape)) {
						this.app.mark('select and crop')
						this.app.select(info.shape?.id)
						this.parent.transition('crop', info)
						return
					}
				}
				if (util.canEdit(shape)) {
					this.startEditingShape(shape, info)
				} else {
					this.createTextShapeAtPoint(info)
				}
				break
			}
			case 'handle': {
				if (this.app.isReadOnly) break
				const { shape, handle } = info
				const util = this.app.getShapeUtil(shape)
				const changes = util.onDoubleClickHandle?.(shape, handle)
				if (changes) {
					this.app.updateShapes([changes])
				} else {
					if (util.canEdit(shape)) {
						this.startEditingShape(shape, info)
					}
				}
			}
		}
	}
	onRightClick = (info) => {
		switch (info.target) {
			case 'canvas': {
				this.app.selectNone()
				break
			}
			case 'shape': {
				const { selectedIds } = this.app.pageState
				const { shape } = info
				const targetShape = this.app.getOutermostSelectableShape(
					shape,
					(parent) => !this.app.isSelected(parent.id)
				)
				if (!selectedIds.includes(targetShape.id)) {
					this.app.mark('selecting shape')
					this.app.setSelectedIds([targetShape.id])
				}
				break
			}
		}
	}
	onEnter = () => {
		this.app.setHoveredId(null)
		this.app.setCursor({ type: 'default' })
	}
	onCancel = () => {
		if (this.app.focusLayerId !== this.app.currentPageId && this.app.selectedIds.length > 0) {
			this.app.popFocusLayer()
		} else {
			this.app.mark('clearing selection')
			this.app.selectNone()
		}
	}
	onKeyDown = (info) => {
		switch (info.code) {
			case 'ArrowLeft':
			case 'ArrowRight':
			case 'ArrowUp':
			case 'ArrowDown': {
				this.nudgeSelectedShapes(false)
				break
			}
		}
	}
	onKeyRepeat = (info) => {
		switch (info.code) {
			case 'ArrowLeft':
			case 'ArrowRight':
			case 'ArrowUp':
			case 'ArrowDown': {
				this.nudgeSelectedShapes(true)
				break
			}
		}
	}
	onKeyUp = (info) => {
		if (this.app.isReadOnly) {
			switch (info.code) {
				case 'Enter': {
					if (this.shouldStartEditingShape() && this.app.onlySelectedShape) {
						this.startEditingShape(this.app.onlySelectedShape, {
							...info,
							target: 'shape',
							shape: this.app.onlySelectedShape,
						})
						return
					}
					break
				}
			}
		} else {
			switch (info.code) {
				case 'Enter': {
					const { selectedShapes } = this.app
					if (selectedShapes.every((shape) => shape.type === 'group')) {
						this.app.setSelectedIds(
							selectedShapes.flatMap((shape) => this.app.getSortedChildIds(shape.id))
						)
						return
					}
					if (this.shouldStartEditingShape() && this.app.onlySelectedShape) {
						this.startEditingShape(this.app.onlySelectedShape, {
							...info,
							target: 'shape',
							shape: this.app.onlySelectedShape,
						})
						return
					}
					if (this.shouldEnterCropMode(info, false)) {
						this.parent.transition('crop', info)
					}
					break
				}
			}
		}
	}
	shouldStartEditingShape() {
		const { onlySelectedShape } = this.app
		if (!onlySelectedShape) return false
		const util = this.app.getShapeUtil(onlySelectedShape)
		return util.canEdit(onlySelectedShape)
	}
	shouldEnterCropMode(info, withCtrlKey) {
		const singleShape = this.app.onlySelectedShape
		if (!singleShape) return false
		const shapeUtil = this.app.getShapeUtil(singleShape)
		if (withCtrlKey) {
			return shapeUtil.canCrop(singleShape) && info.ctrlKey
		} else {
			return shapeUtil.canCrop(singleShape)
		}
	}
	startEditingShape(shape, info) {
		this.app.mark('editing shape')
		this.app.setEditingId(shape.id)
		this.parent.transition('editing_shape', info)
	}
	createTextShapeAtPoint(info) {
		this.app.mark('creating text shape')
		const id = createShapeId()
		const { x: x3, y: y3 } = this.app.inputs.currentPagePoint
		this.app.createShapes([
			{
				id,
				type: 'text',
				x: x3,
				y: y3,
				props: {
					text: '',
					autoSize: true,
				},
			},
		])
		const shape = this.app.getShapeById(id)
		if (!shape) return
		const bounds = this.app.getBounds(shape)
		this.app.updateShapes([
			{
				id,
				type: 'text',
				x: shape.x - bounds.width / 2,
				y: shape.y - bounds.height / 2,
			},
		])
		this.app.setEditingId(id)
		this.app.select(id)
		this.parent.transition('editing_shape', info)
	}
	nudgeSelectedShapes(ephemeral = false) {
		const {
			app: {
				inputs: { keys },
			},
		} = this
		const shiftKey = keys.has('Shift')
		const delta = new Vec2d(0, 0)
		if (keys.has('ArrowLeft')) delta.x -= 1
		if (keys.has('ArrowRight')) delta.x += 1
		if (keys.has('ArrowUp')) delta.y -= 1
		if (keys.has('ArrowDown')) delta.y += 1
		if (delta.equals(new Vec2d(0, 0))) return
		if (!ephemeral) this.app.mark('nudge shapes')
		this.app.nudgeShapes(this.app.selectedIds, delta, shiftKey)
	}
}
__publicField(Idle11, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingCanvas.ts
init_define_process()
var PointingCanvas = class extends StateNode {
	onEnter = () => {
		const { inputs } = this.app
		if (!inputs.shiftKey) {
			if (this.app.selectedIds.length > 0) {
				this.app.mark('selecting none')
				this.app.selectNone()
			}
		}
	}
	_clickWasInsideFocusedGroup() {
		const { focusLayerId, inputs } = this.app
		if (!isShapeId(focusLayerId)) {
			return false
		}
		const groupShape = this.app.getShapeById(focusLayerId)
		if (!groupShape) {
			return false
		}
		const clickPoint = this.app.getPointInShapeSpace(groupShape, inputs.currentPagePoint)
		const util = this.app.getShapeUtil(groupShape)
		return util.hitTestPoint(groupShape, clickPoint)
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			this.parent.transition('brushing', info)
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onInterrupt = () => {
		this.parent.transition('idle', {})
	}
	complete() {
		const { shiftKey } = this.app.inputs
		if (!shiftKey) {
			this.app.selectNone()
			if (!this._clickWasInsideFocusedGroup()) {
				this.app.setFocusLayer(null)
			}
		}
		this.parent.transition('idle', {})
	}
}
__publicField(PointingCanvas, 'id', 'pointing_canvas')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingCropHandle.ts
init_define_process()
var PointingCropHandle = class extends StateNode {
	info = {}
	updateCursor(shape) {
		const cursorType = CursorTypeMap[this.info.handle]
		this.app.setCursor({
			type: cursorType,
			rotation: shape.rotation,
		})
	}
	onEnter = (info) => {
		this.info = info
		const selectedShape = this.app.selectedShapes[0]
		if (!selectedShape) return
		this.updateCursor(selectedShape)
		this.app.setCroppingId(selectedShape.id)
	}
	onPointerMove = () => {
		const isDragging = this.app.inputs.isDragging
		if (isDragging) {
			this.parent.transition('cropping', {
				...this.info,
				onInteractionEnd: this.info.onInteractionEnd,
			})
		}
	}
	onPointerUp = () => {
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, this.info)
		} else {
			this.app.setCroppingId(null)
			this.parent.transition('idle', {})
		}
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.cancel()
	}
	onInterrupt = () => {
		this.cancel()
	}
	cancel() {
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, this.info)
		} else {
			this.app.setCroppingId(null)
			this.parent.transition('idle', {})
		}
	}
}
__publicField(PointingCropHandle, 'id', 'pointing_crop_handle')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingHandle.ts
init_define_process()
var PointingHandle = class extends StateNode {
	info = {}
	onEnter = (info) => {
		this.info = info
		const initialTerminal = info.shape.props[info.handle.id]
		if (initialTerminal?.type === 'binding') {
			this.app.setHintingIds([initialTerminal.boundShapeId])
		}
		this.app.setCursor({ type: 'grabbing' })
	}
	onExit = () => {
		this.app.setHintingIds([])
		this.app.setCursor({ type: 'default' })
	}
	onPointerUp = () => {
		this.parent.transition('idle', this.info)
	}
	onPointerMove = () => {
		if (this.app.inputs.isDragging) {
			this.parent.transition('dragging_handle', this.info)
		}
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.cancel()
	}
	onInterrupt = () => {
		this.cancel()
	}
	cancel() {
		this.parent.transition('idle', {})
	}
}
__publicField(PointingHandle, 'id', 'pointing_handle')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingRotateHandle.ts
init_define_process()
var PointingRotateHandle = class extends StateNode {
	info = {}
	updateCursor() {
		const { selectionRotation } = this.app
		this.app.setCursor({
			type: CursorTypeMap[this.info.handle],
			rotation: selectionRotation,
		})
	}
	onEnter = (info) => {
		this.info = info
		this.updateCursor()
	}
	onPointerMove = () => {
		const { isDragging } = this.app.inputs
		if (isDragging) {
			this.parent.transition('rotating', this.info)
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.cancel()
	}
	onInterrupt = () => {
		this.cancel()
	}
	complete() {
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, {})
		} else {
			this.parent.transition('idle', {})
		}
	}
	cancel() {
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, {})
		} else {
			this.parent.transition('idle', {})
		}
	}
}
__publicField(PointingRotateHandle, 'id', 'pointing_rotate_handle')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingSelection.ts
init_define_process()
var PointingSelection = class extends StateNode {
	info = {}
	onEnter = (info) => {
		this.info = info
	}
	onPointerUp = (info) => {
		this.app.selectNone()
		this.parent.transition('idle', info)
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			if (this.app.isReadOnly) return
			this.parent.transition('translating', info)
		}
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.cancel()
	}
	onInterrupt = () => {
		this.cancel()
	}
	cancel() {
		this.parent.transition('idle', {})
	}
}
__publicField(PointingSelection, 'id', 'pointing_selection')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingShape.ts
init_define_process()
var PointingShape = class extends StateNode {
	eventTargetShape = {}
	selectingShape = {}
	didSelectOnEnter = false
	onEnter = (info) => {
		this.eventTargetShape = info.shape
		this.selectingShape = this.app.getOutermostSelectableShape(info.shape)
		const util = this.app.getShapeUtil(info.shape)
		if (util.onClick || this.selectingShape.id === this.app.focusLayerId) {
			this.didSelectOnEnter = false
			return
		}
		const isSelected = this.app.isWithinSelection(this.selectingShape.id)
		const isBehindSelectionBounds =
			this.app.selectedIds.length > 1 && // only on 2+ selected shapes!
			this.app.selectionBounds?.containsPoint(this.app.inputs.currentPagePoint)
		this.didSelectOnEnter =
			!isSelected && this.selectingShape.id !== this.app.focusLayerId && !isBehindSelectionBounds
		if (this.didSelectOnEnter) {
			const { inputs, selectedIds } = this.app
			const parent = this.app.getParentShape(info.shape)
			if (parent && parent.type === 'group') {
				this.app.cancelDoubleClick()
			}
			if (inputs.shiftKey && !inputs.altKey) {
				if (!selectedIds.includes(this.selectingShape.id)) {
					this.app.mark('shift selecting shape')
					this.app.setSelectedIds([...selectedIds, this.selectingShape.id])
				}
			} else {
				this.app.mark('selecting shape')
				this.app.setSelectedIds([this.selectingShape.id])
			}
		}
	}
	onPointerUp = (info) => {
		const { shape } = info
		if (shape) {
			const util = this.app.getShapeUtil(shape)
			if (util.onClick) {
				const change = util.onClick?.(shape)
				if (change) {
					this.app.updateShapes([change])
					this.parent.transition('idle', info)
					return
				}
			}
		}
		if (!this.didSelectOnEnter && this.selectingShape.id !== this.app.focusLayerId) {
			this.app.mark('selecting shape (pointer up)')
			const targetShape = this.app.getOutermostSelectableShape(
				this.eventTargetShape,
				// if a group is selected, we want to stop before reaching that group
				// so we can drill down into the group
				(parent) => !this.app.isSelected(parent.id)
			)
			if (this.app.selectedIds.includes(targetShape.id)) {
				this.app.setSelectedIds(
					this.app.inputs.shiftKey
						? this.app.selectedIds.filter((id) => id !== this.selectingShape.id)
						: [this.selectingShape.id]
				)
			} else if (this.app.inputs.shiftKey) {
				const ancestors = this.app.getAncestors(targetShape)
				this.app.setSelectedIds([
					...this.app.selectedIds.filter((id) => !ancestors.find((a3) => a3.id === id)),
					targetShape.id,
				])
			} else {
				this.app.setSelectedIds([targetShape.id])
			}
		} else if (this.selectingShape.id === this.app.focusLayerId) {
			if (this.app.selectedIds.length > 0) {
				this.app.setSelectedIds([])
			} else {
				this.app.popFocusLayer()
			}
		}
		this.parent.transition('idle', info)
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			if (this.app.isReadOnly) return
			this.parent.transition('translating', info)
		}
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.cancel()
	}
	onInterrupt = () => {
		this.cancel()
	}
	cancel() {
		this.parent.transition('idle', {})
	}
}
__publicField(PointingShape, 'id', 'pointing_shape')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Resizing.ts
init_define_process()
var Resizing = class extends StateNode {
	info = {}
	markId = ''
	// we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
	// so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
	// so we allow passing a further offset into this state to negate such issues
	creationCursorOffset = { x: 0, y: 0 }
	editAfterComplete = false
	snapshot = {}
	onEnter = (info) => {
		const {
			isCreating = false,
			editAfterComplete = false,
			creationCursorOffset = { x: 0, y: 0 },
		} = info
		this.info = info
		this.editAfterComplete = editAfterComplete
		this.creationCursorOffset = creationCursorOffset
		if (info.isCreating) {
			this.app.setCursor({ type: 'cross', rotation: 0 })
		}
		this.snapshot = this._createSnapshot()
		this.markId = isCreating ? 'creating' : this.app.mark('starting resizing')
		this.handleResizeStart()
		this.updateShapes()
	}
	onPointerMove = () => {
		this.updateShapes()
	}
	onKeyDown = () => {
		this.updateShapes()
	}
	onKeyUp = () => {
		this.updateShapes()
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	cancel() {
		this.app.bailToMark(this.markId)
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, {})
		} else {
			this.parent.transition('idle', {})
		}
	}
	complete() {
		this.handleResizeEnd()
		if (this.editAfterComplete && this.app.onlySelectedShape) {
			this.app.setEditingId(this.app.onlySelectedShape.id)
			this.app.setSelectedTool('select')
			this.app.root.current.value.transition('editing_shape', {})
			return
		}
		if (this.app.instanceState.isToolLocked && this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, {})
			return
		}
		this.parent.transition('idle', {})
	}
	handleResizeStart() {
		const { shapeSnapshots } = this.snapshot
		const changes = []
		shapeSnapshots.forEach(({ shape }) => {
			const util = this.app.getShapeUtil(shape)
			const change = util.onResizeStart?.(shape)
			if (change) {
				changes.push(change)
			}
		})
		if (changes.length > 0) {
			this.app.updateShapes(changes)
		}
	}
	handleResizeEnd() {
		const { shapeSnapshots } = this.snapshot
		const changes = []
		shapeSnapshots.forEach(({ shape }) => {
			const current = this.app.getShapeById(shape.id)
			const util = this.app.getShapeUtil(shape)
			const change = util.onResizeEnd?.(shape, current)
			if (change) {
				changes.push(change)
			}
		})
		if (changes.length > 0) {
			this.app.updateShapes(changes)
		}
	}
	updateShapes() {
		const { altKey: altKey2, shiftKey } = this.app.inputs
		const {
			shapeSnapshots,
			selectionBounds,
			cursorHandleOffset,
			selectedIds,
			selectionRotation,
			canShapesDeform,
		} = this.snapshot
		const isAspectRatioLocked = shiftKey || !canShapesDeform
		const { ctrlKey } = this.app.inputs
		const currentPagePoint = this.app.inputs.currentPagePoint
			.clone()
			.sub(cursorHandleOffset)
			.sub(this.creationCursorOffset)
		const originPagePoint = this.app.inputs.originPagePoint.clone().sub(cursorHandleOffset)
		if (this.app.isGridMode && !ctrlKey) {
			currentPagePoint.snapToGrid(this.app.gridSize)
		}
		const dragHandle = this.info.handle
		const scaleOriginHandle = rotateSelectionHandle2(dragHandle, Math.PI)
		this.app.snaps.clear()
		const shouldSnap = this.app.userDocumentSettings.isSnapMode ? !ctrlKey : ctrlKey
		if (shouldSnap && selectionRotation % TAU === 0) {
			const { nudge } = this.app.snaps.snapResize({
				dragDelta: Vec2d.Sub(currentPagePoint, originPagePoint),
				initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
				handle: rotateSelectionHandle2(dragHandle, selectionRotation),
				isAspectRatioLocked,
				isResizingFromCenter: altKey2,
			})
			currentPagePoint.add(nudge)
		}
		const scaleOriginPage = Vec2d.RotWith(
			altKey2 ? selectionBounds.center : selectionBounds.getHandlePoint(scaleOriginHandle),
			selectionBounds.point,
			selectionRotation
		)
		const distanceFromScaleOriginNow = Vec2d.Sub(currentPagePoint, scaleOriginPage).rot(
			-selectionRotation
		)
		const distanceFromScaleOriginAtStart = Vec2d.Sub(originPagePoint, scaleOriginPage).rot(
			-selectionRotation
		)
		const scale = Vec2d.DivV(distanceFromScaleOriginNow, distanceFromScaleOriginAtStart)
		if (!Number.isFinite(scale.x)) scale.x = 1
		if (!Number.isFinite(scale.y)) scale.y = 1
		const isXLocked = dragHandle === 'top' || dragHandle === 'bottom'
		const isYLocked = dragHandle === 'left' || dragHandle === 'right'
		if (isAspectRatioLocked) {
			if (isYLocked) {
				scale.y = Math.abs(scale.x)
			} else if (isXLocked) {
				scale.x = Math.abs(scale.y)
			} else if (Math.abs(scale.x) > Math.abs(scale.y)) {
				scale.y = Math.abs(scale.x) * (scale.y < 0 ? -1 : 1)
			} else {
				scale.x = Math.abs(scale.y) * (scale.x < 0 ? -1 : 1)
			}
		} else {
			if (isXLocked) {
				scale.x = 1
			}
			if (isYLocked) {
				scale.y = 1
			}
		}
		if (!this.info.isCreating) {
			this.updateCursor({
				dragHandle,
				isFlippedX: scale.x < 0,
				isFlippedY: scale.y < 0,
				rotation: selectionRotation,
			})
		}
		for (const id of shapeSnapshots.keys()) {
			const snapshot = shapeSnapshots.get(id)
			this.app.resizeShape(id, scale, {
				initialBounds: snapshot.bounds,
				dragHandle,
				initialPageTransform: snapshot.pageTransform,
				initialShape: snapshot.shape,
				mode: selectedIds.length === 1 && id === selectedIds[0] ? 'resize_bounds' : 'scale_shape',
				scaleOrigin: scaleOriginPage,
				scaleAxisRotation: selectionRotation,
			})
		}
	}
	// ---
	updateCursor({ dragHandle, isFlippedX, isFlippedY, rotation }) {
		const nextCursor = { ...this.app.cursor }
		switch (dragHandle) {
			case 'top_left':
			case 'bottom_right': {
				nextCursor.type = 'nwse-resize'
				if (isFlippedX !== isFlippedY) {
					nextCursor.type = 'nesw-resize'
				}
				break
			}
			case 'top_right':
			case 'bottom_left': {
				nextCursor.type = 'nesw-resize'
				if (isFlippedX !== isFlippedY) {
					nextCursor.type = 'nwse-resize'
				}
				break
			}
		}
		nextCursor.rotation = rotation
		this.app.setCursor(nextCursor)
	}
	onExit = () => {
		this.app.snaps.clear()
	}
	_createSnapshot = () => {
		const {
			selectedIds,
			selectionRotation,
			inputs: { originPagePoint },
		} = this.app
		const selectionBounds = this.app.selectionBounds
		const dragHandlePoint = Vec2d.RotWith(
			selectionBounds.getHandlePoint(this.info.handle),
			selectionBounds.point,
			selectionRotation
		)
		const cursorHandleOffset = Vec2d.Sub(originPagePoint, dragHandlePoint)
		const shapeSnapshots = /* @__PURE__ */ new Map()
		selectedIds.forEach((id) => {
			const shape = this.app.getShapeById(id)
			if (shape) {
				shapeSnapshots.set(shape.id, this._createShapeSnapshot(shape))
				if (shape.type === 'frame' && selectedIds.length === 1) return
				this.app.visitDescendants(shape.id, (descendantId) => {
					const descendent = this.app.getShapeById(descendantId)
					if (descendent) {
						shapeSnapshots.set(descendent.id, this._createShapeSnapshot(descendent))
						if (descendent.type === 'frame') {
							return false
						}
					}
				})
			}
		})
		const canShapesDeform = ![...shapeSnapshots.values()].some(
			(shape) =>
				!areAnglesCompatible(shape.pageRotation, selectionRotation) || shape.isAspectRatioLocked
		)
		return {
			shapeSnapshots,
			selectionBounds,
			cursorHandleOffset,
			selectionRotation,
			selectedIds,
			canShapesDeform,
			initialSelectionPageBounds: this.app.selectedPageBounds,
		}
	}
	_createShapeSnapshot = (shape) => {
		const pageTransform = this.app.getPageTransform(shape)
		const util = this.app.getShapeUtil(shape)
		return {
			shape,
			bounds: util.bounds(shape),
			pageTransform,
			pageRotation: Matrix2d.Decompose(pageTransform).rotation,
			isAspectRatioLocked: util.isAspectRatioLocked(shape),
		}
	}
}
__publicField(Resizing, 'id', 'resizing')
var ORDERED_SELECTION_HANDLES = [
	'top',
	'top_right',
	'right',
	'bottom_right',
	'bottom',
	'bottom_left',
	'left',
	'top_left',
]
function rotateSelectionHandle2(handle, rotation) {
	rotation = rotation % PI2
	const numSteps = Math.round(rotation / (PI / 4))
	const currentIndex = ORDERED_SELECTION_HANDLES.indexOf(handle)
	return ORDERED_SELECTION_HANDLES[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES.length]
}

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Rotating.ts
init_define_process()
var Rotating = class extends StateNode {
	snapshot = {}
	info = {}
	markId = ''
	onEnter = (info) => {
		this.info = info
		this.markId = this.app.mark('rotate start')
		this.snapshot = getRotationSnapshot({ app: this.app })
		this.handleStart()
	}
	onExit = () => {
		this.app.setCursor({ type: 'none' })
		this.snapshot = {}
	}
	onPointerMove = () => {
		this.update()
	}
	onKeyDown = () => {
		this.update()
	}
	onKeyUp = () => {
		this.update()
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	// ---
	update = () => {
		const newSelectionRotation = this._getRotationFromPointerPosition({
			snapToNearestDegree: false,
		})
		applyRotationToSnapshotShapes({
			app: this.app,
			delta: newSelectionRotation,
			snapshot: this.snapshot,
			stage: 'update',
		})
		this.app.setCursor({
			type: CursorTypeMap[this.info.handle],
			rotation: newSelectionRotation + this.snapshot.initialSelectionRotation,
		})
	}
	cancel = () => {
		this.app.bailToMark(this.markId)
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, this.info)
		} else {
			this.parent.transition('idle', this.info)
		}
	}
	complete = () => {
		applyRotationToSnapshotShapes({
			app: this.app,
			delta: this._getRotationFromPointerPosition({ snapToNearestDegree: true }),
			snapshot: this.snapshot,
			stage: 'end',
		})
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd, this.info)
		} else {
			this.parent.transition('idle', this.info)
		}
	}
	handleStart() {
		const newSelectionRotation = this._getRotationFromPointerPosition({
			snapToNearestDegree: false,
		})
		applyRotationToSnapshotShapes({
			app: this.app,
			delta: this._getRotationFromPointerPosition({ snapToNearestDegree: false }),
			snapshot: this.snapshot,
			stage: 'start',
		})
		this.app.setCursor({
			type: CursorTypeMap[this.info.handle],
			rotation: newSelectionRotation + this.snapshot.initialSelectionRotation,
		})
	}
	_getRotationFromPointerPosition({ snapToNearestDegree }) {
		const {
			selectionPageCenter,
			inputs: { shiftKey, currentPagePoint },
		} = this.app
		const { initialCursorAngle, initialSelectionRotation } = this.snapshot
		const preSnapRotationDelta = selectionPageCenter.angle(currentPagePoint) - initialCursorAngle
		let newSelectionRotation = initialSelectionRotation + preSnapRotationDelta
		if (shiftKey) {
			newSelectionRotation = snapAngle(newSelectionRotation, 24)
		} else if (snapToNearestDegree) {
			newSelectionRotation = Math.round(newSelectionRotation / EPSILON) * EPSILON
			if (this.app.isCoarsePointer) {
				const snappedToRightAngle = snapAngle(newSelectionRotation, 4)
				const angleToRightAngle = angleDelta(newSelectionRotation, snappedToRightAngle)
				if (Math.abs(angleToRightAngle) < degreesToRadians(5)) {
					newSelectionRotation = snappedToRightAngle
				}
			}
		}
		return newSelectionRotation - initialSelectionRotation
	}
}
__publicField(Rotating, 'id', 'rotating')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/ScribbleBrushing.ts
init_define_process()
var ScribbleBrushing = class extends StateNode {
	hits = /* @__PURE__ */ new Set()
	size = 0
	scribble = {}
	initialSelectedIds = /* @__PURE__ */ new Set()
	newlySelectedIds = /* @__PURE__ */ new Set()
	onEnter = () => {
		this.initialSelectedIds = new Set(this.app.inputs.shiftKey ? this.app.selectedIds : [])
		this.newlySelectedIds = /* @__PURE__ */ new Set()
		this.size = 0
		this.hits.clear()
		this.startScribble()
		this.updateBrushSelection()
		requestAnimationFrame(() => {
			this.app.setBrush(null)
		})
	}
	onExit = () => {
		this.app.setErasingIds([])
		this.scribble.stop()
	}
	onPointerMove = () => {
		this.updateBrushSelection()
	}
	onPointerUp = () => {
		this.complete()
	}
	onKeyDown = () => {
		this.updateBrushSelection()
	}
	onKeyUp = () => {
		if (!this.app.inputs.altKey) {
			this.parent.transition('brushing', {})
		} else {
			this.updateBrushSelection()
		}
	}
	startScribble = () => {
		if (this.scribble.tick) {
			this.app.off('tick', this.scribble?.tick)
		}
		this.scribble = new ScribbleManager({
			onUpdate: this.onScribbleUpdate,
			onComplete: this.onScribbleComplete,
			color: 'selection-stroke',
			opacity: 0.32,
			size: 12,
		})
		this.app.on('tick', this.scribble.tick)
	}
	pushPointToScribble = () => {
		const { x: x3, y: y3 } = this.app.inputs.currentPagePoint
		this.scribble.addPoint(x3, y3)
	}
	onScribbleUpdate = (scribble) => {
		this.app.setScribble(scribble)
	}
	onScribbleComplete = () => {
		this.app.off('tick', this.scribble.tick)
		this.app.setScribble(null)
	}
	updateBrushSelection() {
		const {
			shapesArray,
			inputs: { originPagePoint, previousPagePoint, currentPagePoint },
		} = this.app
		this.pushPointToScribble()
		const shapes = shapesArray
		let shape, util
		for (let i3 = 0, n3 = shapes.length; i3 < n3; i3++) {
			shape = shapes[i3]
			util = this.app.getShapeUtil(shape)
			if (
				shape.type === 'group' ||
				this.newlySelectedIds.has(shape.id) ||
				(shape.type === 'frame' &&
					util.hitTestPoint(shape, this.app.getPointInShapeSpace(shape, originPagePoint)))
			) {
				continue
			}
			if (
				util.hitTestLineSegment(
					shape,
					this.app.getPointInShapeSpace(shape, previousPagePoint),
					this.app.getPointInShapeSpace(shape, currentPagePoint)
				)
			) {
				const outermostShape = this.app.getOutermostSelectableShape(shape)
				const pageMask = this.app.getPageMaskById(outermostShape.id)
				if (pageMask) {
					const intersection = intersectLineSegmentPolyline(
						previousPagePoint,
						currentPagePoint,
						pageMask
					)
					if (intersection !== null) {
						const isInMask = pointInPolygon(currentPagePoint, pageMask)
						if (!isInMask) continue
					}
				}
				this.newlySelectedIds.add(outermostShape.id)
			}
		}
		this.app.setSelectedIds(
			[.../* @__PURE__ */ new Set([...this.newlySelectedIds, ...this.initialSelectedIds])],
			true
		)
	}
	onCancel = () => {
		this.cancel()
	}
	onComplete = () => {
		this.complete()
	}
	complete() {
		this.parent.transition('idle', {})
	}
	cancel() {
		this.app.setSelectedIds([...this.initialSelectedIds], true)
		this.parent.transition('idle', {})
	}
}
__publicField(ScribbleBrushing, 'id', 'scribble_brushing')

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Translating.ts
init_define_process()

// ../packages/editor/src/lib/app/managers/DragAndDropManager.ts
init_define_process()
var LAG_DURATION = 100
var DragAndDropManager = class {
	constructor(app) {
		this.app = app
		app.disposables.add(this.dispose)
	}
	prevDroppingShapeId = null
	currDroppingShapeId = null
	droppingNodeTimer = null
	updateDroppingNode(movingShapes, cb) {
		if (this.droppingNodeTimer === null) {
			const { currentPagePoint } = this.app.inputs
			this.currDroppingShapeId =
				this.app.getDroppingShape(currentPagePoint, movingShapes)?.id ?? null
			this.setDragTimer(movingShapes, LAG_DURATION * 10, cb)
		} else if (this.app.inputs.pointerVelocity.len() > 0.5) {
			clearInterval(this.droppingNodeTimer)
			this.setDragTimer(movingShapes, LAG_DURATION, cb)
		}
	}
	setDragTimer(movingShapes, duration, cb) {
		this.droppingNodeTimer = setTimeout(() => {
			this.app.batch(() => {
				this.handleDrag(movingShapes, cb)
			})
			this.droppingNodeTimer = null
		}, duration)
	}
	handleDrag(movingShapes, cb) {
		const { currentPagePoint } = this.app.inputs
		movingShapes = compact(movingShapes.map((shape) => this.app.getShapeById(shape.id)))
		const currDroppingShapeId =
			this.app.getDroppingShape(currentPagePoint, movingShapes)?.id ?? null
		if (currDroppingShapeId !== this.currDroppingShapeId) {
			this.prevDroppingShapeId = this.currDroppingShapeId
			this.currDroppingShapeId = currDroppingShapeId
		}
		const { prevDroppingShapeId } = this
		if (currDroppingShapeId === prevDroppingShapeId) {
			return
		}
		const prevDroppingShape = prevDroppingShapeId && this.app.getShapeById(prevDroppingShapeId)
		const nextDroppingShape = currDroppingShapeId && this.app.getShapeById(currDroppingShapeId)
		this.prevDroppingShapeId = this.currDroppingShapeId
		if (prevDroppingShape) {
			this.app.getShapeUtil(prevDroppingShape).onDragShapesOut?.(prevDroppingShape, movingShapes)
		}
		if (nextDroppingShape) {
			const res = this.app
				.getShapeUtil(nextDroppingShape)
				.onDragShapesOver?.(nextDroppingShape, movingShapes)
			if (res && res.shouldHint) {
				this.app.setHintingIds([nextDroppingShape.id])
			}
		} else {
			this.app.setHintingIds([])
		}
		cb?.()
	}
	dropShapes(shapes) {
		const { currDroppingShapeId } = this
		this.handleDrag(shapes)
		if (currDroppingShapeId) {
			const shape = this.app.getShapeById(currDroppingShapeId)
			if (!shape) return
			this.app.getShapeUtil(shape).onDropShapesOver?.(shape, shapes)
		}
	}
	clear() {
		this.prevDroppingShapeId = null
		this.currDroppingShapeId = null
		if (this.droppingNodeTimer !== null) {
			clearInterval(this.droppingNodeTimer)
		}
		this.droppingNodeTimer = null
		this.app.setHintingIds([])
	}
	dispose = () => {
		this.clear()
	}
}

// ../packages/editor/src/lib/app/statechart/TLSelectTool/children/Translating.ts
var Translating = class extends StateNode {
	info = {}
	selectionSnapshot = {}
	snapshot = {}
	markId = ''
	isCloning = false
	isCreating = false
	editAfterComplete = false
	dragAndDropManager = new DragAndDropManager(this.app)
	onEnter = (info) => {
		const { isCreating = false, editAfterComplete = false } = info
		this.info = info
		this.isCreating = isCreating
		this.editAfterComplete = editAfterComplete
		this.markId = isCreating ? 'creating' : this.app.mark('translating')
		this.handleEnter(info)
		this.app.on('tick', this.updateParent)
	}
	updateParent = () => {
		const { snapshot } = this
		this.dragAndDropManager.updateDroppingNode(snapshot.movingShapes, this.updateParentTransforms)
	}
	onExit = () => {
		this.app.off('tick', this.updateParent)
		this.selectionSnapshot = {}
		this.snapshot = {}
		this.app.snaps.clear()
		this.app.setCursor({ type: 'default' })
		this.dragAndDropManager.clear()
	}
	onPointerMove = () => {
		this.updateShapes()
	}
	onKeyDown = () => {
		if (this.app.inputs.altKey && !this.isCloning) {
			this.startCloning()
			return
		}
		this.updateShapes()
	}
	onKeyUp = () => {
		if (!this.app.inputs.altKey && this.isCloning) {
			this.stopCloning()
			return
		}
		this.updateShapes()
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	reset() {
		this.app.bailToMark(this.markId)
	}
	startCloning() {
		if (this.isCreating) return
		this.isCloning = true
		this.reset()
		this.markId = this.app.mark('translating')
		this.app.duplicateShapes()
		this.snapshot = getTranslatingSnapshot(this.app)
		this.handleStart()
		this.updateShapes()
	}
	stopCloning() {
		this.isCloning = false
		this.snapshot = this.selectionSnapshot
		this.reset()
		this.markId = this.app.mark('translating')
		this.updateShapes()
	}
	complete() {
		this.updateShapes()
		this.dragAndDropManager.dropShapes(this.snapshot.movingShapes)
		this.handleEnd()
		if (this.app.instanceState.isToolLocked && this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd)
		} else {
			if (this.editAfterComplete) {
				const onlySelected = this.app.onlySelectedShape
				if (onlySelected) {
					this.app.setEditingId(onlySelected.id)
					this.app.setSelectedTool('select')
					this.app.root.current.value.transition('editing_shape', {})
				}
			} else {
				this.parent.transition('idle', {})
			}
		}
	}
	cancel() {
		this.reset()
		if (this.info.onInteractionEnd) {
			this.app.setSelectedTool(this.info.onInteractionEnd)
		} else {
			this.parent.transition('idle', this.info)
		}
	}
	handleEnter(info) {
		this.isCloning = false
		this.info = info
		this.app.setCursor({ type: 'move' })
		this.selectionSnapshot = getTranslatingSnapshot(this.app)
		if (!this.isCreating) {
			if (this.app.inputs.altKey) {
				this.startCloning()
				return
			}
		}
		this.snapshot = this.selectionSnapshot
		this.handleStart()
		this.updateShapes()
	}
	handleStart() {
		const { movingShapes } = this.snapshot
		const changes = []
		movingShapes.forEach((shape) => {
			const util = this.app.getShapeUtil(shape)
			const change = util.onTranslateStart?.(shape)
			if (change) {
				changes.push(change)
			}
		})
		if (changes.length > 0) {
			this.app.updateShapes(changes)
		}
	}
	handleEnd() {
		const { movingShapes } = this.snapshot
		const changes = []
		movingShapes.forEach((shape) => {
			const current = this.app.getShapeById(shape.id)
			const util = this.app.getShapeUtil(shape)
			const change = util.onTranslateEnd?.(shape, current)
			if (change) {
				changes.push(change)
			}
		})
		if (changes.length > 0) {
			this.app.updateShapes(changes)
		}
	}
	handleChange() {
		const { movingShapes } = this.snapshot
		const changes = []
		movingShapes.forEach((shape) => {
			const current = this.app.getShapeById(shape.id)
			const util = this.app.getShapeUtil(shape)
			const change = util.onTranslate?.(shape, current)
			if (change) {
				changes.push(change)
			}
		})
		if (changes.length > 0) {
			this.app.updateShapes(changes)
		}
	}
	updateShapes() {
		const { snapshot } = this
		this.dragAndDropManager.updateDroppingNode(snapshot.movingShapes, this.updateParentTransforms)
		moveShapesToPoint({
			app: this.app,
			shapeSnapshots: snapshot.shapeSnapshots,
			averagePagePoint: snapshot.averagePagePoint,
			initialSelectionPageBounds: snapshot.initialPageBounds,
			initialSelectionSnapPoints: snapshot.initialSnapPoints,
		})
		this.handleChange()
	}
	updateParentTransforms = () => {
		const {
			app,
			snapshot: { shapeSnapshots },
		} = this
		const movingShapes = []
		shapeSnapshots.forEach((shapeSnapshot) => {
			const shape = app.getShapeById(shapeSnapshot.shape.id)
			if (!shape) return null
			movingShapes.push(shape)
			const parentTransform = PageRecordType.isId(shape.parentId)
				? null
				: Matrix2d.Inverse(app.getPageTransformById(shape.parentId))
			shapeSnapshot.parentTransform = parentTransform
		})
	}
}
__publicField(Translating, 'id', 'translating')
function getTranslatingSnapshot(app) {
	const movingShapes = []
	const pagePoints = []
	const shapeSnapshots = compact(
		app.selectedIds.map((id) => {
			const shape = app.getShapeById(id)
			if (!shape) return null
			movingShapes.push(shape)
			const pagePoint = app.getPagePointById(id)
			if (!pagePoint) return null
			pagePoints.push(pagePoint)
			const parentTransform = PageRecordType.isId(shape.parentId)
				? null
				: Matrix2d.Inverse(app.getPageTransformById(shape.parentId))
			return {
				shape,
				pagePoint,
				parentTransform,
			}
		})
	)
	return {
		averagePagePoint: Vec2d.Average(pagePoints),
		movingShapes,
		shapeSnapshots,
		initialPageBounds: app.selectedPageBounds,
		initialSnapPoints:
			app.selectedIds.length === 1
				? app.snaps.snapPointsCache.get(app.selectedIds[0])
				: app.selectedPageBounds
				? app.selectedPageBounds.snapPoints.map((p3, i3) => ({
						id: 'selection:' + i3,
						x: p3.x,
						y: p3.y,
				  }))
				: [],
	}
}
function moveShapesToPoint({
	app,
	shapeSnapshots: snapshots,
	averagePagePoint,
	initialSelectionPageBounds,
	initialSelectionSnapPoints,
}) {
	const { inputs, isGridMode, gridSize } = app
	const delta = Vec2d.Sub(inputs.currentPagePoint, inputs.originPagePoint)
	const flatten = app.inputs.shiftKey ? (Math.abs(delta.x) < Math.abs(delta.y) ? 'x' : 'y') : null
	if (flatten === 'x') {
		delta.x = 0
	} else if (flatten === 'y') {
		delta.y = 0
	}
	app.snaps.clear()
	const shouldSnap =
		(app.userDocumentSettings.isSnapMode ? !inputs.ctrlKey : inputs.ctrlKey) &&
		app.inputs.pointerVelocity.len() < 0.5
	if (shouldSnap) {
		const { nudge } = app.snaps.snapTranslate({
			dragDelta: delta,
			initialSelectionPageBounds,
			lockedAxis: flatten,
			initialSelectionSnapPoints,
		})
		delta.add(nudge)
	}
	const averageSnappedPoint = Vec2d.Add(averagePagePoint, delta)
	if (isGridMode && !inputs.ctrlKey) {
		averageSnappedPoint.snapToGrid(gridSize)
	}
	const averageSnap = Vec2d.Sub(averageSnappedPoint, averagePagePoint)
	app.updateShapes(
		compact(
			snapshots.map(({ shape, pagePoint, parentTransform }) => {
				const newPagePoint = Vec2d.Add(pagePoint, averageSnap)
				const newLocalPoint = parentTransform
					? Matrix2d.applyToPoint(parentTransform, newPagePoint)
					: newPagePoint
				return {
					id: shape.id,
					type: shape.type,
					x: newLocalPoint.x,
					y: newLocalPoint.y,
				}
			})
		),
		true
	)
}

// ../packages/editor/src/lib/app/statechart/TLSelectTool/TLSelectTool.ts
var TLSelectTool = class extends StateNode {
	styles = ['color', 'opacity', 'dash', 'fill', 'size']
	onExit = () => {
		if (this.app.pageState.editingId) {
			this.app.setEditingId(null)
		}
	}
}
__publicField(TLSelectTool, 'id', 'select')
__publicField(TLSelectTool, 'initial', 'idle')
__publicField(TLSelectTool, 'children', () => [
	Crop,
	Cropping,
	Idle11,
	PointingCanvas,
	PointingShape,
	Translating,
	Brushing,
	ScribbleBrushing,
	PointingCropHandle,
	PointingSelection,
	PointingResizeHandle,
	EditingShape,
	Resizing,
	Rotating,
	PointingRotateHandle,
	PointingHandle,
	DraggingHandle,
])

// ../packages/editor/src/lib/app/statechart/TLTextTool/TLTextTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLTextTool/children/Idle.ts
init_define_process()
var Idle12 = class extends StateNode {
	onPointerEnter = (info) => {
		switch (info.target) {
			case 'canvas': {
				break
			}
			case 'shape': {
				const { selectedIds, focusLayerId } = this.app
				const hoveringShape = this.app.getOutermostSelectableShape(
					info.shape,
					(parent) => !selectedIds.includes(parent.id)
				)
				if (hoveringShape.id !== focusLayerId) {
					if (hoveringShape.type === 'text') {
						this.app.setHoveredId(hoveringShape.id)
					}
				}
				break
			}
		}
	}
	onPointerLeave = (info) => {
		switch (info.target) {
			case 'shape': {
				this.app.setHoveredId(null)
				break
			}
		}
	}
	onPointerDown = (info) => {
		const { hoveredId } = this.app
		if (hoveredId) {
			const shape = this.app.getShapeById(hoveredId)
			if (shape.type === 'text') {
				requestAnimationFrame(() => {
					this.app.setSelectedIds([shape.id])
					this.app.setEditingId(shape.id)
					this.app.setSelectedTool('select.editing_shape', {
						...info,
						target: 'shape',
						shape,
					})
				})
				return
			}
		}
		this.parent.transition('pointing', info)
	}
	onEnter = () => {
		this.app.setCursor({ type: 'cross' })
	}
	onKeyDown = (info) => {
		if (info.key === 'Enter') {
			const shape = this.app.selectedShapes[0]
			if (shape && shape.type === 'geo') {
				this.app.setSelectedTool('select')
				this.app.setEditingId(shape.id)
				this.app.root.current.value.transition('editing_shape', {
					...info,
					target: 'shape',
					shape,
				})
			}
		}
	}
	onCancel = () => {
		this.app.setSelectedTool('select')
	}
}
__publicField(Idle12, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLTextTool/children/Pointing.ts
init_define_process()
var Pointing8 = class extends StateNode {
	shape
	onExit = () => {
		this.app.setHintingIds([])
	}
	onPointerMove = (info) => {
		if (this.app.inputs.isDragging) {
			const {
				inputs: { originPagePoint },
			} = this.app
			const id = createShapeId()
			this.app.mark('creating')
			this.app.createShapes([
				{
					id,
					type: 'text',
					x: originPagePoint.x,
					y: originPagePoint.y,
					props: {
						text: '',
						autoSize: false,
						w: 20,
					},
				},
			])
			this.app.select(id)
			this.shape = this.app.getShapeById(id)
			if (!this.shape) return
			this.app.setSelectedTool('select.resizing', {
				...info,
				target: 'selection',
				handle: 'right',
				isCreating: true,
				creationCursorOffset: { x: 1, y: 1 },
				editAfterComplete: true,
				onInteractionEnd: 'text',
			})
		}
	}
	onPointerUp = () => {
		this.complete()
	}
	onComplete = () => {
		this.cancel()
	}
	onCancel = () => {
		this.cancel()
	}
	onInterrupt = () => {
		this.cancel()
	}
	complete() {
		this.app.mark('creating text shape')
		const id = createShapeId()
		const { x: x3, y: y3 } = this.app.inputs.currentPagePoint
		this.app.createShapes(
			[
				{
					id,
					type: 'text',
					x: x3,
					y: y3,
					props: {
						text: '',
						autoSize: true,
					},
				},
			],
			true
		)
		this.app.setEditingId(id)
		this.app.setSelectedTool('select')
		this.app.root.current.value?.transition('editing_shape', {})
	}
	cancel() {
		this.parent.transition('idle', {})
		this.app.bailToMark('creating')
	}
}
__publicField(Pointing8, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLTextTool/TLTextTool.ts
var TLTextTool = class extends StateNode {
	styles = ['color', 'opacity', 'font', 'align', 'size']
}
__publicField(TLTextTool, 'id', 'text')
__publicField(TLTextTool, 'initial', 'idle')
__publicField(TLTextTool, 'children', () => [Idle12, Pointing8])

// ../packages/editor/src/lib/app/statechart/TLZoomTool/TLZoomTool.ts
init_define_process()

// ../packages/editor/src/lib/app/statechart/TLZoomTool/children/Idle.ts
init_define_process()
var Idle13 = class extends StateNode {
	info = {}
	onEnter = (info) => {
		this.info = info
	}
	onPointerDown = () => {
		this.parent.transition('pointing', this.info)
	}
}
__publicField(Idle13, 'id', 'idle')

// ../packages/editor/src/lib/app/statechart/TLZoomTool/children/Pointing.ts
init_define_process()
var Pointing9 = class extends StateNode {
	info = {}
	onEnter = (info) => {
		this.info = info
	}
	onPointerUp = () => {
		this.complete()
	}
	onPointerMove = () => {
		if (this.app.inputs.isDragging) {
			this.parent.transition('zoom_brushing', this.info)
		}
	}
	onCancel = () => {
		this.cancel()
	}
	complete() {
		const { currentScreenPoint } = this.app.inputs
		if (this.app.inputs.altKey) {
			this.app.zoomOut(currentScreenPoint, { duration: 220 })
		} else {
			this.app.zoomIn(currentScreenPoint, { duration: 220 })
		}
		this.parent.transition('idle', this.info)
	}
	cancel() {
		this.parent.transition('idle', this.info)
	}
}
__publicField(Pointing9, 'id', 'pointing')

// ../packages/editor/src/lib/app/statechart/TLZoomTool/children/ZoomBrushing.ts
init_define_process()
var ZoomBrushing = class extends StateNode {
	info = {}
	zoomBrush = new Box2d()
	onEnter = (info) => {
		this.info = info
		this.update()
	}
	onExit = () => {
		this.app.setZoomBrush(null)
	}
	onPointerMove = () => {
		this.update()
	}
	onPointerUp = () => {
		this.complete()
	}
	onCancel = () => {
		this.cancel()
	}
	update() {
		const {
			inputs: { originPagePoint, currentPagePoint },
		} = this.app
		this.zoomBrush.setTo(Box2d.FromPoints([originPagePoint, currentPagePoint]))
		this.app.setZoomBrush(this.zoomBrush.toJson())
	}
	cancel() {
		this.parent.transition('idle', this.info)
	}
	complete() {
		const { zoomBrush } = this
		const threshold = 8 / this.app.zoomLevel
		if (zoomBrush.width < threshold && zoomBrush.height < threshold) {
			const point2 = this.app.inputs.currentScreenPoint
			if (this.app.inputs.altKey) {
				this.app.zoomOut(point2, { duration: 220 })
			} else {
				this.app.zoomIn(point2, { duration: 220 })
			}
		} else {
			const zoomLevel = this.app.inputs.altKey ? this.app.zoomLevel / 2 : void 0
			this.app.zoomToBounds(
				zoomBrush.x,
				zoomBrush.y,
				zoomBrush.width,
				zoomBrush.height,
				zoomLevel,
				{ duration: 220 }
			)
		}
		this.parent.transition('idle', this.info)
	}
}
__publicField(ZoomBrushing, 'id', 'zoom_brushing')

// ../packages/editor/src/lib/app/statechart/TLZoomTool/TLZoomTool.ts
var TLZoomTool = class extends StateNode {
	info = {}
	onEnter = (info) => {
		this.info = info
		this.updateCursor()
	}
	updateCursor() {
		if (this.app.inputs.altKey) {
			this.app.setCursor({ type: 'zoom-out' })
		} else {
			this.app.setCursor({ type: 'zoom-in' })
		}
	}
	onExit = () => {
		this.app.setZoomBrush(null)
		this.app.setCursor({ type: 'default' })
	}
	onKeyDown = () => {
		this.updateCursor()
	}
	onKeyUp = (info) => {
		this.updateCursor()
		if (info.code === 'KeyZ') {
			this.complete()
		}
	}
	onInterrupt = () => {
		this.complete()
	}
	complete() {
		if (this.info.onInteractionEnd && this.info.onInteractionEnd !== 'select') {
			this.app.setSelectedTool(this.info.onInteractionEnd, this.info)
		} else {
			this.parent.transition('select', {})
		}
	}
}
__publicField(TLZoomTool, 'id', 'zoom')
__publicField(TLZoomTool, 'initial', 'idle')
__publicField(TLZoomTool, 'children', () => [Idle13, ZoomBrushing, Pointing9])

// ../packages/editor/src/lib/app/statechart/RootState.ts
var RootState = class extends StateNode {
	onKeyDown = (info) => {
		switch (info.code) {
			case 'KeyZ': {
				if (!(info.shiftKey || info.ctrlKey)) {
					const currentTool = this.current.value
					if (currentTool && currentTool.current.value?.id === 'idle') {
						this.app.setSelectedTool('zoom', { ...info, onInteractionEnd: currentTool.id })
					}
				}
				break
			}
		}
	}
}
__publicField(RootState, 'id', 'root')
__publicField(RootState, 'initial', 'select')
__publicField(RootState, 'children', () => [
	TLSelectTool,
	TLHandTool,
	TLEraserTool,
	TLDrawTool,
	TLTextTool,
	TLLineTool,
	TLArrowTool,
	TLGeoTool,
	TLNoteTool,
	TLFrameTool,
	TLZoomTool,
	TLLaserTool,
])

// ../packages/editor/src/lib/app/App.ts
function isShapeWithHandles(shape) {
	return shape.type === 'arrow' || shape.type === 'line' || shape.type === 'draw'
}
var _App = class extends import_eventemitter3.EventEmitter {
	constructor({ config, store, getContainer }) {
		super()
		this.config = config
		if (store.schema !== this.config.storeSchema) {
			throw new Error('Store schema does not match schema given to App')
		}
		this.store = store
		this.user = new UserPreferencesManager(this)
		this.getContainer = getContainer ?? (() => document.body)
		this.textMeasure = new TextManager(this)
		this.shapeUtils = Object.fromEntries(
			Object.entries(this.config.shapeUtils).map(([type, Util]) => [type, new Util(this, type)])
		)
		if (typeof window !== 'undefined' && 'navigator' in window) {
			this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
			this.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i)
			this.isChromeForIos = /crios.*safari/i.test(navigator.userAgent)
		} else {
			this.isSafari = false
			this.isIos = false
			this.isChromeForIos = false
		}
		this.colors = new Map(_App.styles.color.map((c3) => [c3.id, `var(--palette-${c3.id})`]))
		this.root = new RootState(this)
		if (this.root.children) {
			this.config.tools.forEach((Ctor) => {
				this.root.children[Ctor.id] = new Ctor(this)
			})
		}
		this.store.onBeforeDelete = (record) => {
			if (record.typeName === 'shape') {
				this._shapeWillBeDeleted(record)
			} else if (record.typeName === 'page') {
				this._pageWillBeDeleted(record)
			}
		}
		this.store.onAfterChange = (prev, next) => {
			this._updateDepth++
			if (this._updateDepth > 1e3) {
				console.error('[onAfterChange] Maximum update depth exceeded, bailing out.')
			}
			if (prev.typeName === 'shape' && next.typeName === 'shape') {
				this._shapeDidChange(prev, next)
			} else if (
				prev.typeName === 'instance_page_state' &&
				next.typeName === 'instance_page_state'
			) {
				this._tabStateDidChange(prev, next)
			}
			this._updateDepth--
		}
		this.store.onAfterCreate = (record) => {
			if (record.typeName === 'shape' && this.isShapeOfType(record, TLArrowUtil)) {
				this._arrowDidUpdate(record)
			}
		}
		this._shapeIds = shapeIdsInCurrentPage(this.store, () => this.currentPageId)
		this._parentIdsToChildIds = parentsToChildrenWithIndexes(this.store)
		this.disposables.add(
			this.store.listen((changes) => {
				this.emit('change', changes)
			})
		)
		const container = this.getContainer()
		const focusin = () => {
			this._isFocused.set(true)
		}
		const focusout = () => {
			this._isFocused.set(false)
		}
		container.addEventListener('focusin', focusin)
		container.addEventListener('focus', focusin)
		container.addEventListener('focusout', focusout)
		container.addEventListener('blur', focusout)
		this.disposables.add(() => {
			container.removeEventListener('focusin', focusin)
			container.removeEventListener('focus', focusin)
			container.removeEventListener('focusout', focusout)
			container.removeEventListener('blur', focusout)
		})
		this.store.ensureStoreIsUsable()
		this.setInstancePageState(
			{
				editingId: null,
				hoveredId: null,
				erasingIds: [],
			},
			true
		)
		this.root.enter(void 0, 'initial')
		if (this.instanceState.followingUserId) {
			this.stopFollowingUser()
		}
		this.updateCullingBounds()
		requestAnimationFrame(() => {
			this._tickManager.start()
		})
	}
	/**
	 * The editor's store
	 *
	 * @public
	 */
	store
	/**
	 * The editor's config
	 *
	 * @public
	 */
	config
	/**
	 * The root state of the statechart.
	 *
	 * @public
	 */
	root
	/**
	 * A cache of shape ids in the current page.
	 *
	 * @internal
	 */
	_shapeIds
	/**
	 * A set of functions to call when the app is disposed.
	 *
	 * @public
	 */
	disposables = /* @__PURE__ */ new Set()
	/** @internal */
	_dprManager = new DprManager(this)
	/** @internal */
	_cameraManager = new CameraManager(this)
	/** @internal */
	_activeAreaManager = new ActiveAreaManager(this)
	/** @internal */
	_tickManager = new TickManager(this)
	/** @internal */
	_updateDepth = 0
	/**
	 * A manager for the app's snapping feature.
	 *
	 * @public
	 */
	snaps = new SnapManager(this)
	/**
	 * @internal
	 */
	user
	/**
	 * Whether the editor is running in Safari.
	 *
	 * @public
	 */
	isSafari
	/**
	 * Whether the editor is running on iOS.
	 *
	 * @public
	 */
	isIos
	/**
	 * Whether the editor is running on iOS.
	 *
	 * @public
	 */
	isChromeForIos
	// Flags
	_canMoveCamera = atom('can move camera', true)
	/**
	 * Set whether the editor's camera can move.
	 *
	 * @example
	 *
	 * ```ts
	 * app.canMoveCamera = false
	 * ```
	 *
	 * @param canMove - Whether the camera can move.
	 * @public
	 */
	get canMoveCamera() {
		return this._canMoveCamera.value
	}
	set canMoveCamera(canMove) {
		this._canMoveCamera.set(canMove)
	}
	_isFocused = atom('_isFocused', false)
	/**
	 * Whether or not the editor is focused.
	 *
	 * @public
	 */
	get isFocused() {
		return this._isFocused.value
	}
	/**
	 * The current HTML element containing the editor.
	 *
	 * @example
	 *
	 * ```ts
	 * const container = app.getContainer()
	 * ```
	 *
	 * @public
	 */
	getContainer
	/**
	 * The editor's instanceId (defined in its store.props).
	 *
	 * @example
	 *
	 * ```ts
	 * const instanceId = app.instanceId
	 * ```
	 *
	 * @public
	 */
	get instanceId() {
		return this.store.props.instanceId
	}
	/** @internal */
	annotateError(error, { origin, willCrashApp, tags, extras }) {
		const defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp)
		annotateError(error, {
			tags: { ...defaultAnnotations.tags, ...tags },
			extras: { ...defaultAnnotations.extras, ...extras },
		})
		if (willCrashApp) {
			this.store.markAsPossiblyCorrupted()
		}
	}
	/** @internal */
	createErrorAnnotations(origin, willCrashApp) {
		try {
			return {
				tags: {
					origin,
					willCrashApp,
				},
				extras: {
					activeStateNode: this.root.path.value,
					selectedShapes: this.selectedShapes,
					editingShape: this.editingId ? this.getShapeById(this.editingId) : void 0,
					inputs: this.inputs,
				},
			}
		} catch {
			return {
				tags: {
					origin,
					willCrashApp,
				},
				extras: {},
			}
		}
	}
	/** @internal */
	_crashingError = null
	/**
	 * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
	 * we're in a transaction that's about to be rolled back due to the same error we're currently
	 * reporting.
	 *
	 * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
	 *
	 * @internal
	 */
	get crashingError() {
		return this._crashingError
	}
	/** @internal */
	crash(error) {
		this._crashingError = error
		this.store.markAsPossiblyCorrupted()
		this.emit('crash', { error })
	}
	get devicePixelRatio() {
		return this._dprManager.dpr.value
	}
	_openMenus = atom('open-menus', [])
	get openMenus() {
		return this._openMenus.value
	}
	/**
	 * Add an open menu.
	 *
	 * ```ts
	 * app.addOpenMenu('menu-id')
	 * ```
	 * @public
	 */
	addOpenMenu = (id) => {
		const menus = new Set(this.openMenus)
		if (!menus.has(id)) {
			menus.add(id)
			this._openMenus.set([...menus])
		}
		return this
	}
	/**
	 * Delete an open menu.
	 *
	 * ```ts
	 * app.deleteOpenMenu('menu-id')
	 * ```
	 * @public
	 */
	deleteOpenMenu = (id) => {
		const menus = new Set(this.openMenus)
		if (menus.has(id)) {
			menus.delete(id)
			this._openMenus.set([...menus])
		}
		return this
	}
	get isMenuOpen() {
		return this.openMenus.length > 0
	}
	/** @internal */
	_isCoarsePointer = atom('isCoarsePointer', false)
	/**
	 * Whether the user is using a "coarse" pointer, such as on a touch screen.
	 *
	 * @public
	 */
	get isCoarsePointer() {
		return this._isCoarsePointer.value
	}
	set isCoarsePointer(v3) {
		this._isCoarsePointer.set(v3)
	}
	/** @internal */
	_isChangingStyle = atom('isChangingStyle', false)
	/** @internal */
	_isChangingStyleTimeout = -1
	/**
	 * Whether the user is currently changing the style of a shape. This may cause the UI to change.
	 *
	 * @example
	 *
	 * ```ts
	 * app.isChangingStyle = true
	 * ```
	 *
	 * @public
	 */
	get isChangingStyle() {
		return this._isChangingStyle.value
	}
	set isChangingStyle(v3) {
		this._isChangingStyle.set(v3)
		clearTimeout(this._isChangingStyleTimeout)
		if (v3) {
			this._isChangingStyleTimeout = setTimeout(() => (this.isChangingStyle = false), 2e3)
		}
	}
	get _pageTransformCache() {
		return this.store.createComputedCache('pageTransformCache', (shape) => {
			if (PageRecordType.isId(shape.parentId)) {
				return this.getTransform(shape)
			}
			const parent = this._pageTransformCache.get(shape.parentId)
			return Matrix2d.Compose(parent, this.getTransform(shape))
		})
	}
	get _pageBoundsCache() {
		return this.store.createComputedCache('pageBoundsCache', (shape) => {
			const pageTransform = this._pageTransformCache.get(shape.id)
			if (!pageTransform) return new Box2d()
			const result = Box2d.FromPoints(
				Matrix2d.applyToPoints(pageTransform, this.getShapeUtil(shape).outline(shape))
			)
			return result
		})
	}
	get _pageMaskCache() {
		return this.store.createComputedCache('pageMaskCache', (shape) => {
			if (PageRecordType.isId(shape.parentId)) {
				return void 0
			}
			const frameAncestors = this.getAncestorsById(shape.id).filter((s3) => s3.type === 'frame')
			if (frameAncestors.length === 0) return void 0
			const pageMask = frameAncestors
				.map((s3) =>
					// Apply the frame transform to the frame outline to get the frame outline in page space
					Matrix2d.applyToPoints(this._pageTransformCache.get(s3.id), this.getOutline(s3))
				)
				.reduce((acc, b3) => (b3 && acc ? intersectPolygonPolygon(acc, b3) ?? void 0 : void 0))
			return pageMask
		})
	}
	/**
	 * Get the page mask for a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * const pageMask = app.getPageMaskById(shape.id)
	 * ```
	 *
	 * @param id - The id of the shape to get the page mask for.
	 * @returns The page mask for the shape.
	 * @public
	 */
	getPageMaskById(id) {
		return this._pageMaskCache.get(id)
	}
	get _clipPathCache() {
		return this.store.createComputedCache('clipPathCache', (shape) => {
			const pageMask = this._pageMaskCache.get(shape.id)
			if (!pageMask) return void 0
			const pageTransform = this._pageTransformCache.get(shape.id)
			if (!pageTransform) return void 0
			if (pageMask.length === 0) {
				return `polygon(0px 0px, 0px 0px, 0px 0px)`
			}
			const localMask = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), pageMask)
			return `polygon(${localMask.map((p3) => `${p3.x}px ${p3.y}px`).join(',')})`
		})
	}
	/**
	 * Get the clip path for a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * const clipPath = app.getClipPathById(shape.id)
	 * ```
	 *
	 * @param id - The shape id.
	 * @returns The clip path or undefined.
	 * @public
	 */
	getClipPathById(id) {
		return this._clipPathCache.get(id)
	}
	/**
	 * A cache of parents to children.
	 *
	 * @internal
	 */
	_parentIdsToChildIds
	/**
	 * Dispose the app.
	 *
	 * @public
	 */
	dispose() {
		this.disposables.forEach((dispose) => dispose())
		this.disposables.clear()
	}
	/**
	 * A manager for the app's history.
	 *
	 * @readonly
	 */
	history = new HistoryManager(
		this,
		() => this._complete(),
		(error) => {
			this.annotateError(error, { origin: 'history.batch', willCrashApp: true })
			this.crash(error)
		}
	)
	/**
	 * Undo to the last mark.
	 *
	 * @example
	 *
	 * ```ts
	 * app.undo()
	 * ```
	 *
	 * @public
	 */
	undo() {
		return this.history.undo()
	}
	get canUndo() {
		return this.history.numUndos > 0
	}
	/**
	 * Redo to the next mark.
	 *
	 * @example
	 *
	 * ```ts
	 * app.redo()
	 * ```
	 *
	 * @public
	 */
	redo() {
		this.history.redo()
		return this
	}
	get canRedo() {
		return this.history.numRedos > 0
	}
	/**
	 * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
	 * any redos.
	 *
	 * @example
	 *
	 * ```ts
	 * app.mark()
	 * app.mark('flip shapes')
	 * ```
	 *
	 * @param reason - The reason for the mark.
	 * @param onUndo - Whether to stop at the mark when undoing.
	 * @param onRedo - Whether to stop at the mark when redoing.
	 * @public
	 */
	mark(reason, onUndo, onRedo) {
		return this.history.mark(reason, onUndo, onRedo)
	}
	/**
	 * Clear all marks in the undo stack back to the next mark.
	 *
	 * @example
	 *
	 * ```ts
	 * app.bail()
	 * ```
	 *
	 * @public
	 */
	bail() {
		this.history.bail()
		return this
	}
	/**
	 * Clear all marks in the undo stack back to the mark with the provided mark id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.bailToMark('creating')
	 * ```
	 *
	 * @public
	 */
	bailToMark(id) {
		this.history.bailToMark(id)
		return this
	}
	/**
	 * Run a function in a batch, which will be undone/redone as a single action.
	 *
	 * @example
	 *
	 * ```ts
	 * app.batch(() => {
	 * 	app.selectAll()
	 * 	app.deleteShapes()
	 * 	app.createShapes(myShapes)
	 * 	app.selectNone()
	 * })
	 *
	 * app.undo() // will undo all of the above
	 * ```
	 *
	 * @public
	 */
	batch(fn) {
		this.history.batch(fn)
		return this
	}
	/**
	 * A map of shape utility classes (TLShapeUtils) by shape type.
	 *
	 * @public
	 */
	shapeUtils
	getShapeUtil({ type }) {
		return this.shapeUtils[type]
	}
	/**
	 * A cache of children for each parent.
	 *
	 * @internal
	 */
	_childIdsCache = new WeakMapCache()
	/**
	 * Get an array of all the children of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getSortedChildIds('frame1')
	 * ```
	 *
	 * @param parentId - The id of the parent shape.
	 * @public
	 */
	getSortedChildIds(parentId) {
		const withIndices = this._parentIdsToChildIds.value[parentId]
		if (!withIndices) return EMPTY_ARRAY
		return this._childIdsCache.get(withIndices, () => withIndices.map(([id]) => id))
	}
	/**
	 * Run a visitor function for all descendants of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.visitDescendants('frame1', myCallback)
	 * ```
	 *
	 * @param parentId - The id of the parent shape.
	 * @param visitor - The visitor function.
	 * @public
	 */
	visitDescendants(parentId, visitor) {
		const children = this.getSortedChildIds(parentId)
		for (const id of children) {
			if (visitor(id) === false) continue
			this.visitDescendants(id, visitor)
		}
	}
	get erasingIds() {
		return this.pageState.erasingIds
	}
	get hintingIds() {
		return this.pageState.hintingIds
	}
	get erasingIdsSet() {
		return new Set(this.erasingIds)
	}
	/**
	 * Get all the current props among the users selected shapes
	 *
	 * @internal
	 */
	_extractSharedProps(shape, sharedProps) {
		if (shape.type === 'group') {
			const childIds = this._parentIdsToChildIds.value[shape.id]
			if (!childIds) return
			for (let i3 = 0, n3 = childIds.length; i3 < n3; i3++) {
				this._extractSharedProps(this.getShapeById(childIds[i3][0]), sharedProps)
			}
		} else {
			const props = Object.entries(shape.props)
			let prop
			for (let i3 = 0, n3 = props.length; i3 < n3; i3++) {
				prop = props[i3]
				if (BLACKLISTED_PROPS.has(prop[0])) continue
				switch (sharedProps[prop[0]]) {
					case void 0: {
						sharedProps[prop[0]] = prop[1]
						break
					}
					case null:
					case prop[1]: {
						continue
					}
					default: {
						sharedProps[prop[0]] = null
					}
				}
			}
		}
	}
	/**
	 * A derived object containing all current props among the user's selected shapes.
	 *
	 * @internal
	 */
	_selectionSharedProps = computed('_selectionSharedProps', () => {
		const { selectedShapes } = this
		const sharedProps = {}
		for (let i3 = 0, n3 = selectedShapes.length; i3 < n3; i3++) {
			this._extractSharedProps(selectedShapes[i3], sharedProps)
		}
		return sharedProps
	})
	/** @internal */
	_prevProps = {}
	get props() {
		let next
		if (this.isIn('select') && this.selectedIds.length > 0) {
			next = this._selectionSharedProps.value
		} else {
			const currentState = this.root.current.value
			if (currentState.styles.length === 0) {
				next = null
			} else {
				const { propsForNextShape } = this.instanceState
				next = Object.fromEntries(
					currentState.styles.map((k2) => {
						return [k2, propsForNextShape[k2]]
					})
				)
			}
		}
		if (JSON.stringify(this._prevProps) === JSON.stringify(next)) {
			return this._prevProps
		}
		this._prevProps = next
		return next
	}
	/**
	 * An array of all of the shapes on the current page.
	 *
	 * @public
	 */
	get shapeIds() {
		return this._shapeIds.value
	}
	/**
	 * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes can have.
	 *
	 * @internal
	 */
	_invalidParents = /* @__PURE__ */ new Set()
	/** @internal */
	_complete() {
		const { lastUpdatedPageId, lastUsedTabId } = this.userDocumentSettings
		if (lastUsedTabId !== this.instanceId || lastUpdatedPageId !== this.currentPageId) {
			this.store.put([
				{
					...this.userDocumentSettings,
					lastUsedTabId: this.instanceId,
					lastUpdatedPageId: this.currentPageId,
				},
			])
		}
		for (const parentId of this._invalidParents) {
			this._invalidParents.delete(parentId)
			const parent = this.getShapeById(parentId)
			if (!parent) continue
			const util = this.getShapeUtil(parent)
			const changes = util.onChildrenChange?.(parent)
			if (changes?.length) {
				this.updateShapes(changes, true)
			}
		}
		this.emit('update')
	}
	get _arrowBindingsIndex() {
		return arrowBindingsIndex(this.store)
	}
	/** GetArrowsBoundTo */
	getArrowsBoundTo(shapeId) {
		return this._arrowBindingsIndex.value[shapeId] || EMPTY_ARRAY
	}
	/** @internal */
	_reparentArrow(arrowId) {
		const arrow2 = this.getShapeById(arrowId)
		if (!arrow2) return
		const { start, end } = arrow2.props
		const startShape = start.type === 'binding' ? this.getShapeById(start.boundShapeId) : void 0
		const endShape = end.type === 'binding' ? this.getShapeById(end.boundShapeId) : void 0
		const parentPageId = this.getParentPageId(arrow2)
		if (!parentPageId) return
		let nextParentId
		if (startShape && endShape) {
			nextParentId = this.findCommonAncestor([startShape, endShape]) ?? parentPageId
		} else if (startShape || endShape) {
			nextParentId = parentPageId
		} else {
			return
		}
		if (nextParentId && nextParentId !== arrow2.parentId) {
			this.reparentShapesById([arrowId], nextParentId)
		}
		const reparentedArrow = this.getShapeById(arrowId)
		if (!reparentedArrow) throw Error('no reparented arrow')
		const startSibling = this.getNearestSiblingShape(reparentedArrow, startShape)
		const endSibling = this.getNearestSiblingShape(reparentedArrow, endShape)
		let highestSibling
		if (startSibling && endSibling) {
			highestSibling = startSibling.index > endSibling.index ? startSibling : endSibling
		} else if (startSibling && !endSibling) {
			highestSibling = startSibling
		} else if (endSibling && !startSibling) {
			highestSibling = endSibling
		} else {
			return
		}
		let finalIndex
		const higherSiblings = this.getSortedChildIds(highestSibling.parentId)
			.map((id) => this.getShapeById(id))
			.filter((sibling) => sibling.index > highestSibling.index)
		if (higherSiblings.length) {
			const nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== 'arrow')
			if (
				// ...then, if we're above the last shape we want to be above...
				reparentedArrow.index > highestSibling.index && // ...but below the next non-arrow sibling...
				(!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)
			) {
				return
			}
			finalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index)
		} else {
			finalIndex = getIndexAbove(highestSibling.index)
		}
		if (finalIndex !== reparentedArrow.index) {
			this.updateShapes([{ id: arrowId, type: 'arrow', index: finalIndex }])
		}
	}
	/** @internal */
	_unbindArrowTerminal(arrow2, handleId) {
		const { x: x3, y: y3 } = getArrowTerminalsInArrowSpace(this, arrow2)[handleId]
		this.store.put([
			{ ...arrow2, props: { ...arrow2.props, [handleId]: { type: 'point', x: x3, y: y3 } } },
		])
	}
	get _allPageStates() {
		return this.store.query.records('instance_page_state')
	}
	/** @internal */
	_shapeWillBeDeleted(deletedShape) {
		if (deletedShape.parentId && isShapeId(deletedShape.parentId)) {
			this._invalidParents.add(deletedShape.parentId)
		}
		const bindings = this._arrowBindingsIndex.value[deletedShape.id]
		if (bindings?.length) {
			for (const { arrowId, handleId } of bindings) {
				const arrow2 = this.getShapeById(arrowId)
				if (!arrow2) continue
				this._unbindArrowTerminal(arrow2, handleId)
			}
		}
		const pageStates = this._allPageStates.value
		const deletedIds = /* @__PURE__ */ new Set([deletedShape.id])
		const updates = compact(
			pageStates.map((pageState) => {
				return this._cleanupInstancePageState(pageState, deletedIds)
			})
		)
		if (updates.length) {
			this.store.put(updates)
		}
	}
	/** @internal */
	_arrowDidUpdate(arrow2) {
		for (const handle of ['start', 'end']) {
			const terminal = arrow2.props[handle]
			if (terminal.type !== 'binding') continue
			const boundShape = this.getShapeById(terminal.boundShapeId)
			const isShapeInSamePageAsArrow =
				this.getParentPageId(arrow2) === this.getParentPageId(boundShape)
			if (!boundShape || !isShapeInSamePageAsArrow) {
				this._unbindArrowTerminal(arrow2, handle)
			}
		}
		this._reparentArrow(arrow2.id)
	}
	/** @internal */
	_cleanupInstancePageState(prevPageState, shapesNoLongerInPage) {
		let nextPageState = null
		const selectedIds = prevPageState.selectedIds.filter((id) => !shapesNoLongerInPage.has(id))
		if (selectedIds.length !== prevPageState.selectedIds.length) {
			if (!nextPageState) nextPageState = { ...prevPageState }
			nextPageState.selectedIds = selectedIds
		}
		const erasingIds = prevPageState.erasingIds.filter((id) => !shapesNoLongerInPage.has(id))
		if (erasingIds.length !== prevPageState.erasingIds.length) {
			if (!nextPageState) nextPageState = { ...prevPageState }
			nextPageState.erasingIds = erasingIds
		}
		if (prevPageState.hoveredId && shapesNoLongerInPage.has(prevPageState.hoveredId)) {
			if (!nextPageState) nextPageState = { ...prevPageState }
			nextPageState.hoveredId = null
		}
		if (prevPageState.editingId && shapesNoLongerInPage.has(prevPageState.editingId)) {
			if (!nextPageState) nextPageState = { ...prevPageState }
			nextPageState.editingId = null
		}
		const hintingIds = prevPageState.hintingIds.filter((id) => !shapesNoLongerInPage.has(id))
		if (hintingIds.length !== prevPageState.hintingIds.length) {
			if (!nextPageState) nextPageState = { ...prevPageState }
			nextPageState.hintingIds = hintingIds
		}
		if (prevPageState.focusLayerId && shapesNoLongerInPage.has(prevPageState.focusLayerId)) {
			if (!nextPageState) nextPageState = { ...prevPageState }
			nextPageState.focusLayerId = null
		}
		return nextPageState
	}
	/** @internal */
	_shapeDidChange(prev, next) {
		if (this.isShapeOfType(next, TLArrowUtil)) {
			this._arrowDidUpdate(next)
		}
		if (prev.parentId !== next.parentId) {
			const reparentBoundArrows = (id) => {
				const boundArrows = this._arrowBindingsIndex.value[id]
				if (boundArrows?.length) {
					for (const arrow2 of boundArrows) {
						this._reparentArrow(arrow2.arrowId)
					}
				}
			}
			reparentBoundArrows(next.id)
			this.visitDescendants(next.id, reparentBoundArrows)
		}
		if (prev.parentId !== next.parentId && PageRecordType.isId(next.parentId)) {
			const allMovingIds = /* @__PURE__ */ new Set([prev.id])
			this.visitDescendants(prev.id, (id) => {
				allMovingIds.add(id)
			})
			for (const instancePageState of this.store.query.records('instance_page_state').value) {
				if (instancePageState.pageId === next.parentId) continue
				const nextPageState = this._cleanupInstancePageState(instancePageState, allMovingIds)
				if (nextPageState) {
					this.store.put([nextPageState])
				}
			}
		}
		if (prev.parentId && isShapeId(prev.parentId)) {
			this._invalidParents.add(prev.parentId)
		}
		if (next.parentId !== prev.parentId && isShapeId(next.parentId)) {
			this._invalidParents.add(next.parentId)
		}
	}
	/** @internal */
	_tabStateDidChange(prev, next) {
		if (prev?.selectedIds !== next?.selectedIds) {
			const filtered = next.selectedIds.filter((id) => {
				let parentId = this.getShapeById(id)?.parentId
				while (isShapeId(parentId)) {
					if (next.selectedIds.includes(parentId)) {
						return false
					}
					parentId = this.getShapeById(parentId)?.parentId
				}
				return true
			})
			const nextFocusLayerId =
				filtered.length === 0
					? next?.focusLayerId
					: this.findCommonAncestor(
							compact(filtered.map((id) => this.getShapeById(id))),
							(shape) => shape.type === 'group'
					  )
			if (filtered.length !== next.selectedIds.length || nextFocusLayerId != next.focusLayerId) {
				this.store.put([{ ...next, selectedIds: filtered, focusLayerId: nextFocusLayerId ?? null }])
			}
		}
	}
	/** @internal */
	_pageWillBeDeleted(page) {
		const instanceStates = this.store.query.exec('instance', { currentPageId: { eq: page.id } })
		if (!instanceStates.length) return
		const backupPageId = this.pages.find((p3) => p3.id !== page.id)?.id
		if (!backupPageId) return
		this.store.put(instanceStates.map((state) => ({ ...state, currentPageId: backupPageId })))
	}
	get documentSettings() {
		return this.store.get(TLDOCUMENT_ID)
	}
	get gridSize() {
		return this.documentSettings.gridSize
	}
	get isSnapMode() {
		return this.userDocumentSettings.isSnapMode
	}
	setSnapMode(isSnapMode) {
		if (isSnapMode !== this.isSnapMode) {
			this.updateUserDocumentSettings({ isSnapMode }, true)
		}
		return this
	}
	get isDarkMode() {
		return this.user.isDarkMode
	}
	setDarkMode(isDarkMode) {
		if (isDarkMode !== this.isDarkMode) {
			this.user.updateUserPreferences({ isDarkMode })
		}
		return this
	}
	get isFocusMode() {
		return this.instanceState.isFocusMode
	}
	setFocusMode(isFocusMode) {
		if (isFocusMode !== this.isFocusMode) {
			this.updateInstanceState({ isFocusMode }, true)
		}
		return this
	}
	get isToolLocked() {
		return this.instanceState.isToolLocked
	}
	setToolLocked(isToolLocked) {
		if (isToolLocked !== this.isToolLocked) {
			this.updateInstanceState({ isToolLocked }, true)
		}
		return this
	}
	get _userDocumentSettings() {
		return this.store.query.record('user_document')
	}
	get userDocumentSettings() {
		return this._userDocumentSettings.value
	}
	get isGridMode() {
		return this.userDocumentSettings.isGridMode
	}
	setGridMode(isGridMode) {
		if (isGridMode !== this.isGridMode) {
			this.updateUserDocumentSettings({ isGridMode }, true)
		}
		return this
	}
	_isReadOnly = atom('isReadOnly', false)
	/** @internal */
	setReadOnly(isReadOnly) {
		this._isReadOnly.set(isReadOnly)
		if (isReadOnly) {
			this.setSelectedTool('hand')
		}
		return this
	}
	get isReadOnly() {
		return this._isReadOnly.value
	}
	/** @internal */
	_isPenMode = atom('isPenMode', false)
	/** @internal */
	_touchEventsRemainingBeforeExitingPenMode = 0
	get isPenMode() {
		return this._isPenMode.value
	}
	setPenMode(isPenMode) {
		if (isPenMode) this._touchEventsRemainingBeforeExitingPenMode = 3
		if (isPenMode !== this.isPenMode) {
			this._isPenMode.set(isPenMode)
		}
		return this
	}
	// User / User App State
	/** The current tab state */
	get instanceState() {
		return this.store.get(this.instanceId)
	}
	get cursor() {
		return this.instanceState.cursor
	}
	get brush() {
		return this.instanceState.brush
	}
	get zoomBrush() {
		return this.instanceState.zoomBrush
	}
	get scribble() {
		return this.instanceState.scribble
	}
	get _pageState() {
		return this.store.query.record(
			'instance_page_state',
			() => {
				return {
					pageId: { eq: this.currentPageId },
					instanceId: { eq: this.instanceId },
				}
			},
			'app._pageState'
		)
	}
	/**
	 * The current page state.
	 *
	 * @public
	 */
	get pageState() {
		return this._pageState.value
	}
	get camera() {
		return this.store.get(this.pageState.cameraId)
	}
	get zoomLevel() {
		return this.camera.z
	}
	get selectedIds() {
		return this.pageState.selectedIds
	}
	get selectedIdsSet() {
		return new Set(this.selectedIds)
	}
	get _pages() {
		return this.store.query.records('page')
	}
	get pages() {
		return this._pages.value.sort(sortByIndex)
	}
	/**
	 * The current page.
	 *
	 * @public
	 */
	get currentPage() {
		return this.getPageById(this.currentPageId)
	}
	/**
	 * The current page id.
	 *
	 * @public
	 */
	get currentPageId() {
		return this.instanceState.currentPageId
	}
	/**
	 * Get a page by its ID.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPageById(myPage.id)
	 * ```
	 *
	 * @public
	 */
	getPageById(id) {
		return this.store.get(id)
	}
	get _pageStates() {
		return this.store.query.records('instance_page_state', () => ({
			instanceId: { eq: this.instanceId },
		}))
	}
	/**
	 * Get a page state by its id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPageStateByPageId('page1')
	 * ```
	 *
	 * @public
	 */
	getPageStateByPageId(id) {
		return this._pageStates.value.find((p3) => p3.pageId === id)
	}
	/**
	 * Get a page by its ID.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPageById(myPage.id)
	 * ```
	 *
	 * @public
	 */
	getPageInfoById(id) {
		return this.store.get(id)
	}
	/** Get shapes on a page. */
	getShapesInPage(pageId) {
		const result = this.store.query.exec('shape', { parentId: { eq: pageId } })
		return this.getShapesAndDescendantsInOrder(result.map((s3) => s3.id))
	}
	/* --------------------- Shapes --------------------- */
	/**
	 * Get the local transform for a shape as a matrix model. This transform reflects both its
	 * translation (x, y) from from either its parent's top left corner, if the shape's parent is
	 * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
	 * shape's rotation.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getTransform(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the local transform for.
	 * @public
	 */
	getTransform(shape) {
		const util = this.getShapeUtil(shape)
		return util.transform(shape)
	}
	/**
	 * Get the local transform of a shape's parent as a matrix model.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getParentTransform(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the parent transform for.
	 * @public
	 */
	getParentTransform(shape) {
		if (PageRecordType.isId(shape.parentId)) {
			return Matrix2d.Identity()
		}
		return this._pageTransformCache.get(shape.parentId) ?? Matrix2d.Identity()
	}
	/**
	 * Get the page transform (or absolute transform) of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPageTransform(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the page transform for.
	 * @public
	 */
	getPageTransform(shape) {
		return this.getPageTransformById(shape.id)
	}
	/**
	 * Get the page transform (or absolute transform) of a shape by its id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPageTransformById(myShape)
	 * ```
	 *
	 * @param id - The if of the shape to get the page transform for.
	 * @public
	 */
	getPageTransformById(id) {
		return this._pageTransformCache.get(id)
	}
	/**
	 * Get the page point (or absolute point) of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPagePoint(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the page point for.
	 * @public
	 */
	getPagePointById(id) {
		const pageTransform = this.getPageTransformById(id)
		if (!pageTransform) return
		return Matrix2d.applyToPoint(pageTransform, new Vec2d())
	}
	/**
	 * Get the page point (or absolute point) of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPagePoint(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the page point for.
	 * @public
	 */
	getPageCenter(shape) {
		const pageTransform = this.getPageTransformById(shape.id)
		if (!pageTransform) return null
		const util = this.getShapeUtil(shape)
		const center = util.center(shape)
		return Matrix2d.applyToPoint(pageTransform, center)
	}
	/**
	 * Get the page point (or absolute point) of a shape by its id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPagePoint(myShape)
	 * ```
	 *
	 * @param id - The shape id to get the page point for.
	 * @public
	 */
	getPageCenterById(id) {
		const shape = this.getShapeById(id)
		return this.getPageCenter(shape)
	}
	/**
	 * Get the page rotation (or absolute rotation) of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPageRotation(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the page rotation for.
	 * @public
	 */
	getPageRotation(shape) {
		return this.getPageRotationById(shape.id)
	}
	/**
	 * Get the page rotation (or absolute rotation) of a shape by its id.
	 *
	 * @param id - The id of the shape to get the page rotation for.
	 */
	getPageRotationById(id) {
		const pageTransform = this.getPageTransformById(id)
		if (pageTransform) {
			return Matrix2d.Decompose(pageTransform).rotation
		}
		return 0
	}
	/**
	 * Get the local bounds of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getBounds(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the bounds for.
	 * @public
	 */
	getBounds(shape) {
		return this.getShapeUtil(shape).bounds(shape)
	}
	/**
	 * Get the local bounds of a shape by its id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getBoundsById(myShape)
	 * ```
	 *
	 * @param id - The id of the shape to get the bounds for.
	 * @public
	 */
	getBoundsById(id) {
		const shape = this.getShapeById(id)
		if (!shape) return void 0
		return this.getBounds(shape)
	}
	/**
	 * Get the page (or absolute) bounds of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPageBounds(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the bounds for.
	 * @public
	 */
	getPageBounds(shape) {
		return this.getPageBoundsById(shape.id)
	}
	/**
	 * Get the page (or absolute) bounds of a shape by its id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPageBoundsById(myShape)
	 * ```
	 *
	 * @param id - The id of the shape to get the page bounds for.
	 * @public
	 */
	getPageBoundsById(id) {
		return this._pageBoundsCache.get(id)
	}
	/**
	 * Get the page (or absolute) bounds of a shape, incorporating any masks. For example, if the
	 * shape were the child of a frame and was half way out of the frame, the bounds would be the half
	 * of the shape that was in the frame.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getMaskedPageBounds(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the masked bounds for.
	 * @public
	 */
	getMaskedPageBounds(shape) {
		return this.getMaskedPageBoundsById(shape.id)
	}
	/**
	 * Get the page (or absolute) bounds of a shape by its id, incorporating any masks. For example,
	 * if the shape were the child of a frame and was half way out of the frame, the bounds would be
	 * the half of the shape that was in the frame.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getMaskedPageBoundsById(myShape)
	 * ```
	 *
	 * @param id - The id of the shape to get the masked page bounds for.
	 * @public
	 */
	getMaskedPageBoundsById(id) {
		const pageBounds = this._pageBoundsCache.get(id)
		if (!pageBounds) return
		const pageMask = this._pageMaskCache.get(id)
		if (pageMask) {
			const intersection = intersectPolygonPolygon(pageMask, pageBounds.corners)
			if (!intersection) return
			return Box2d.FromPoints(intersection)
		}
		return pageBounds
	}
	/**
	 * Get the local outline of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getOutline(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the outline for.
	 * @public
	 */
	getOutline(shape) {
		return this.getShapeUtil(shape).outline(shape)
	}
	/**
	 * Get the local outline of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getOutlineById(myShape)
	 * ```
	 *
	 * @param id - The shape id to get the outline for.
	 * @public
	 */
	getOutlineById(id) {
		return this.getOutline(this.getShapeById(id))
	}
	/**
	 * Get the ancestors of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * const ancestors = app.getAncestors(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the ancestors for.
	 * @public
	 */
	getAncestors(shape, acc = []) {
		const parentId = shape.parentId
		if (PageRecordType.isId(parentId)) {
			acc.reverse()
			return acc
		}
		const parent = this.store.get(parentId)
		acc.push(parent)
		return this.getAncestors(parent, acc)
	}
	/**
	 * Get the ancestors of a shape by its id.
	 *
	 * @example
	 *
	 * ```ts
	 * const ancestors = app.getAncestorsById(myShape)
	 * ```
	 *
	 * @param id - The id of the shape to get the ancestors for.
	 * @public
	 */
	getAncestorsById(id, acc = []) {
		const shape = this.getShapeById(id)
		return this.getAncestors(shape, acc)
	}
	/**
	 * Find the first ancestor matching the given predicate
	 *
	 * @example
	 *
	 * ```ts
	 * const ancestor = app.findAncestor(myShape)
	 * ```
	 *
	 * @param shape - The shape to check the ancestors for.
	 * @public
	 */
	findAncestor(shape, predicate) {
		const parentId = shape.parentId
		if (PageRecordType.isId(parentId)) {
			return void 0
		}
		const parent = this.getShapeById(parentId)
		if (parent) {
			if (predicate(parent)) {
				return parent
			}
			return this.findAncestor(parent, predicate)
		}
		return void 0
	}
	/** Returns true if the the given shape has the given ancestor */
	hasAncestor(shape, ancestorId) {
		if (!shape) return false
		if (shape.parentId === ancestorId) return true
		return this.hasAncestor(this.getParentShape(shape), ancestorId)
	}
	/**
	 * Get the common ancestor of two or more shapes that matches a predicate.
	 *
	 * @param shapes - The shapes to check.
	 * @param predicate - The predicate to match.
	 */
	findCommonAncestor(shapes, predicate) {
		if (shapes.length === 0) {
			return
		}
		if (shapes.length === 1) {
			const parentId = shapes[0].parentId
			if (PageRecordType.isId(parentId)) {
				return
			}
			return predicate ? this.findAncestor(shapes[0], predicate)?.id : parentId
		}
		const [nodeA, ...others] = shapes
		let ancestor = this.getParentShape(nodeA)
		while (ancestor) {
			if (predicate && !predicate(ancestor)) {
				ancestor = this.getParentShape(ancestor)
				continue
			}
			if (others.every((shape) => this.hasAncestor(shape, ancestor.id))) {
				return ancestor.id
			}
			ancestor = this.getParentShape(ancestor)
		}
		return void 0
	}
	/**
	 * Check whether a shape is within the bounds of the current viewport.
	 *
	 * @param id - The id of the shape to check.
	 * @public
	 */
	isShapeInViewport(id) {
		const pageBounds = this.getPageBoundsById(id)
		if (!pageBounds) return false
		return this.viewportPageBounds.includes(pageBounds)
	}
	get renderingShapes() {
		const { currentPageId, cullingBounds, cullingBoundsExpanded, erasingIdsSet, editingId } = this
		const renderingShapes = []
		const getShapeToDisplay = (id, parentOpacity, isAncestorErasing) => {
			const shape = this.getShapeById(id)
			if (!shape) return
			let opacity = +shape.props.opacity * parentOpacity
			let isShapeErasing = false
			if (!isAncestorErasing && erasingIdsSet.has(id)) {
				isShapeErasing = true
				opacity *= 0.32
			}
			const bounds = this.getMaskedPageBoundsById(id)
			const isInViewport = bounds ? cullingBounds.includes(bounds) : false
			const isCulled = bounds ? editingId !== id && !cullingBoundsExpanded.includes(bounds) : true
			renderingShapes.push({ id, index: renderingShapes.length, opacity, isCulled, isInViewport })
			this.getSortedChildIds(id).forEach((id2) => {
				getShapeToDisplay(id2, opacity, isAncestorErasing || isShapeErasing)
			})
		}
		this.getSortedChildIds(currentPageId).forEach((shapeId) => getShapeToDisplay(shapeId, 1, false))
		return renderingShapes.sort(sortById)
	}
	get allShapesCommonBounds() {
		let commonBounds = null
		this.shapeIds.forEach((shapeId) => {
			const bounds = this.getMaskedPageBoundsById(shapeId)
			if (bounds) {
				if (commonBounds) {
					commonBounds.expand(bounds)
				} else {
					commonBounds = bounds.clone()
				}
			}
		})
		return commonBounds
	}
	/**
	 * Get the corners of a shape in page space.
	 *
	 * @example
	 *
	 * ```ts
	 * const corners = app.getPageCorners(myShape)
	 * ```
	 *
	 * @param shape - The shape to get the corners for.
	 * @public
	 */
	getPageCorners(shape) {
		const ancestors = this.getAncestors(shape)
		const corners = this.getBounds(shape).corners
		const transform = Matrix2d.Compose(
			...ancestors.flatMap((s3) => [Matrix2d.Translate(s3.x, s3.y), Matrix2d.Rotate(s3.rotation)]),
			Matrix2d.Translate(shape.x, shape.y),
			Matrix2d.Rotate(shape.rotation, 0, 0)
		)
		return Matrix2d.applyToPoints(transform, corners)
	}
	/**
	 * Test whether a point (in page space) will will a shape. This method takes into account masks,
	 * such as when a shape is the child of a frame and is partially clipped by the frame.
	 *
	 * @example
	 *
	 * ```ts
	 * app.isPointInShape({ x: 100, y: 100 }, myShape)
	 * ```
	 *
	 * @param point - The page point to test.
	 * @param shape - The shape to test against.
	 * @public
	 */
	isPointInShape(point2, shape) {
		const util = this.getShapeUtil(shape)
		const pageMask = this._pageMaskCache.get(shape.id)
		if (pageMask) {
			const hit = pointInPolygon(point2, pageMask)
			if (!hit) return false
		}
		return util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point2))
	}
	/**
	 * Get the shapes, if any, at a given page point.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getShapesAtPoint({ x: 100, y: 100 })
	 * ```
	 *
	 * @param point - The page point to test.
	 * @public
	 */
	getShapesAtPoint(point2) {
		return this.shapesArray.filter((shape) => {
			const pageMask = this._pageMaskCache.get(shape.id)
			if (pageMask) {
				return pointInPolygon(point2, pageMask)
			}
			return this.getShapeUtil(shape).hitTestPoint(shape, this.getPointInShapeSpace(shape, point2))
		})
	}
	/**
	 * Convert a point in page space to a point in the local space of a shape. For example, if a
	 * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
	 * `{ x: 10, y: 10 }` in the shape's local space.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPointInShapeSpace(myShape, { x: 100, y: 100 })
	 * ```
	 *
	 * @param shape - The shape to get the point in the local space of.
	 * @param point - The page point to get in the local space of the shape.
	 * @public
	 */
	getPointInShapeSpace(shape, point2) {
		return Matrix2d.applyToPoint(Matrix2d.Inverse(this.getPageTransform(shape)), point2)
	}
	/**
	 * Convert a delta in page space to a point in the local space of a shape. For example, if a
	 * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
	 * `{ x: 10, y: 10 }` in the shape's local space.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })
	 * ```
	 *
	 * @param shape - The shape to get the point in the local space of.
	 * @param point - The page point to get in the local space of the shape.
	 * @public
	 */
	getPointInParentSpace(shapeId, point2) {
		const shape = this.getShapeById(shapeId)
		if (!shape) {
			return new Vec2d(0, 0)
		}
		if (PageRecordType.isId(shape.parentId)) return Vec2d.From(point2)
		const parentTransform = this.getPageTransformById(shape.parentId)
		if (!parentTransform) return Vec2d.From(point2)
		return Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), point2)
	}
	/**
	 * Convert a delta in page space to a delta in the local space of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })
	 * ```
	 *
	 * @param shape - The shape to get the delta in the local space of.
	 * @param delta - The page delta to convert.
	 * @public
	 */
	getDeltaInShapeSpace(shape, delta) {
		const pageTransform = this.getPageTransform(shape)
		if (!pageTransform) return Vec2d.From(delta)
		return Vec2d.Rot(delta, -Matrix2d.Decompose(pageTransform).rotation)
	}
	/**
	 * Convert a delta in page space to a delta in the parent space of a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getDeltaInParentSpace(myShape, { x: 100, y: 100 })
	 * ```
	 *
	 * @param shape - The shape to get the delta in the parent space of.
	 * @param delta - The page delta to convert.
	 * @public
	 */
	getDeltaInParentSpace(shape, delta) {
		if (PageRecordType.isId(shape.parentId)) return Vec2d.From(delta)
		const parent = this.getShapeById(shape.parentId)
		if (!parent) return Vec2d.From(delta)
		return this.getDeltaInShapeSpace(parent, delta)
	}
	/**
	 * For a given set of ids, get a map containing the ids of their parents and the children of those
	 * parents.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getParentsMappedToChildren(['id1', 'id2', 'id3'])
	 * ```
	 *
	 * @param ids - The ids to get the parents and children of.
	 * @public
	 */
	getParentsMappedToChildren(ids) {
		const shapes = ids.map((id) => this.store.get(id))
		const parents = /* @__PURE__ */ new Map()
		shapes.forEach((shape) => {
			if (!parents.has(shape.parentId)) {
				parents.set(shape.parentId, /* @__PURE__ */ new Set())
			}
			parents.get(shape.parentId)?.add(shape)
		})
		return parents
	}
	/* -------------------- Viewport -------------------- */
	/**
	 * Update the viewport. The viewport will measure the size and screen position of its container
	 * element. This should be done whenever the container's position on the screen changes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.updateViewportScreenBounds()
	 * ```
	 *
	 * @param center - Whether to preserve the viewport page center as the viewport changes.
	 *   (optional)
	 * @public
	 */
	updateViewportScreenBounds(center = false) {
		const container = this.getContainer()
		if (!container) return this
		const rect = container.getBoundingClientRect()
		const screenBounds = new Box2d(0, 0, Math.max(rect.width, 1), Math.max(rect.height, 1))
		const boundsAreEqual = screenBounds.equals(this.viewportScreenBounds)
		const { _willSetInitialBounds } = this
		if (boundsAreEqual) {
			this._willSetInitialBounds = false
		} else {
			if (_willSetInitialBounds) {
				this._willSetInitialBounds = false
				this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)
			} else {
				const { zoomLevel } = this
				if (center) {
					const before = this.viewportPageCenter
					this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)
					const after = this.viewportPageCenter
					if (!this.instanceState.followingUserId) {
						this.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel)
					}
				} else {
					const before = this.screenToPage(0, 0)
					this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)
					const after = this.screenToPage(0, 0)
					if (!this.instanceState.followingUserId) {
						this.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel)
					}
				}
			}
		}
		this._cameraManager.tick()
		this.updateCullingBounds()
		const { editingId } = this
		if (editingId) {
			this.panZoomIntoView([editingId])
		}
		return this
	}
	get viewportScreenBounds() {
		const { x: x3, y: y3, w: w3, h: h3 } = this.instanceState.screenBounds
		return new Box2d(x3, y3, w3, h3)
	}
	get viewportScreenCenter() {
		return this.viewportScreenBounds.center
	}
	get viewportPageBounds() {
		const { x: x3, y: y3, w: w3, h: h3 } = this.viewportScreenBounds
		const tl = this.screenToPage(x3, y3)
		const br = this.screenToPage(x3 + w3, y3 + h3)
		return new Box2d(tl.x, tl.y, br.x - tl.x, br.y - tl.y)
	}
	get cullingBounds() {
		return this._cullingBounds.value
	}
	/** @internal */
	_cullingBounds = atom('culling viewport', new Box2d())
	get cullingBoundsExpanded() {
		return this._cullingBoundsExpanded.value
	}
	/** @internal */
	_cullingBoundsExpanded = atom('culling viewport expanded', new Box2d())
	/**
	 * Update the culling bounds. This should be called when the viewport has stopped changing, such
	 * as at the end of a pan, zoom, or animation.
	 *
	 * @example
	 *
	 * ```ts
	 * app.updateCullingBounds()
	 * ```
	 *
	 * @internal
	 */
	updateCullingBounds() {
		const { viewportPageBounds } = this
		if (viewportPageBounds.equals(this._cullingBounds.__unsafe__getWithoutCapture())) return this
		this._cullingBounds.set(viewportPageBounds.clone())
		this._cullingBoundsExpanded.set(viewportPageBounds.clone().expandBy(100 / this.zoomLevel))
		return this
	}
	get viewportPageCenter() {
		return this.viewportPageBounds.center
	}
	/**
	 * Convert a point in screen space to a point in page space.
	 *
	 * @example
	 *
	 * ```ts
	 * app.screenToPage(100, 100)
	 * ```
	 *
	 * @param x - The x coordinate of the point in screen space.
	 * @param y - The y coordinate of the point in screen space.
	 * @param camera - The camera to use. Defaults to the current camera.
	 * @public
	 */
	screenToPage(x3, y3, z2 = 0.5, camera = this.camera) {
		const { screenBounds } = this.store.unsafeGetWithoutCapture(this.instanceId)
		const { x: cx, y: cy, z: cz = 1 } = camera
		return {
			x: (x3 - screenBounds.x) / cz - cx,
			y: (y3 - screenBounds.y) / cz - cy,
			z: z2,
		}
	}
	/**
	 * Convert a point in page space to a point in screen space.
	 *
	 * @example
	 *
	 * ```ts
	 * app.pageToScreen(100, 100)
	 * ```
	 *
	 * @param x - The x coordinate of the point in screen space.
	 * @param y - The y coordinate of the point in screen space.
	 * @param camera - The camera to use. Defaults to the current camera.
	 * @public
	 */
	pageToScreen(x3, y3, z2 = 0.5, camera = this.camera) {
		const { x: cx, y: cy, z: cz = 1 } = camera
		return {
			x: x3 + cx * cz,
			y: y3 + cy * cz,
			z: z2,
		}
	}
	/* Focus Layers */
	get focusLayerId() {
		return this.pageState.focusLayerId ?? this.currentPageId
	}
	get focusLayerShape() {
		const id = this.pageState.focusLayerId
		if (!id) {
			return
		}
		return this.getShapeById(id)
	}
	popFocusLayer() {
		const current = this.pageState.focusLayerId
		const focusedShape = current && this.getShapeById(current)
		if (focusedShape) {
			const match = this.findAncestor(focusedShape, (s3) => s3.type === 'group')
			this.setFocusLayer(match?.id ?? null)
			this.select(focusedShape.id)
		} else {
			this.setFocusLayer(null)
			this.selectNone()
		}
		return this
	}
	/**
	 * Set the focus layer to the given shape id.
	 *
	 * @param next - The next focus layer id or null to reset the focus layer to the page
	 * @public
	 */
	setFocusLayer(next) {
		this._setFocusLayer(next)
		return this
	}
	/** @internal */
	_setFocusLayer = this.history.createCommand(
		'setFocusLayer',
		(next) => {
			if (next === null && !this.canUndo) {
				return
			}
			const prev = this.pageState.focusLayerId
			return { data: { prev, next }, preservesRedoStack: true, squashing: true }
		},
		{
			do: ({ next }) => {
				this.store.update(this.pageState.id, (s3) => ({ ...s3, focusLayerId: next }))
			},
			undo: ({ prev }) => {
				this.store.update(this.pageState.id, (s3) => ({ ...s3, focusLayerId: prev }))
			},
			squash({ prev }, { next }) {
				return { prev, next }
			},
		}
	)
	/**
	 * Set the hinted shape ids.
	 *
	 * @param ids - The ids to set as hinted.
	 * @public
	 */
	setHintingIds(ids) {
		this.store.update(this.pageState.id, (s3) => ({ ...s3, hintingIds: dedupe(ids) }))
		return this
	}
	/**
	 * The current editing shape's id.
	 *
	 * @public
	 */
	get editingId() {
		return this.pageState.editingId
	}
	/**
	 * The current cropping shape's id.
	 *
	 * @public
	 */
	get croppingId() {
		return this.pageState.croppingId
	}
	get editingShape() {
		if (!this.editingId) return null
		return this.getShapeById(this.editingId) ?? null
	}
	/**
	 * Set the current editing id.
	 *
	 * @param id - The id of the shape to edit or null to clear the editing id.
	 * @public
	 */
	setEditingId(id) {
		if (!id) {
			this.setInstancePageState({ editingId: null })
		} else {
			if (id !== this.editingId) {
				const shape = this.getShapeById(id)
				const util = this.getShapeUtil(shape)
				if (shape && util.canEdit(shape)) {
					this.setInstancePageState({ editingId: id, hoveredId: null }, false)
					const { viewportPageBounds } = this
					const localEditingBounds = util.getEditingBounds(shape)
					const pageTransform = this.getPageTransformById(id)
					const pageEditingBounds = Box2d.FromPoints(
						Matrix2d.applyToPoints(pageTransform, localEditingBounds.corners)
					)
					if (!viewportPageBounds.contains(pageEditingBounds)) {
						if (
							pageEditingBounds.width > viewportPageBounds.width ||
							pageEditingBounds.height > viewportPageBounds.height
						) {
							this.zoomToBounds(
								pageEditingBounds.minX,
								pageEditingBounds.minY,
								pageEditingBounds.width,
								pageEditingBounds.height
							)
						} else {
							this.centerOnPoint(pageEditingBounds.midX, pageEditingBounds.midY)
						}
					}
				}
			}
		}
		return this
	}
	setCroppingId(id) {
		if (id !== this.croppingId) {
			if (!id) {
				this.setInstancePageState({ croppingId: null })
				if (this.isInAny('select.crop', 'select.pointing_crop_handle', 'select.cropping')) {
					this.setSelectedTool('select.idle')
				}
			} else {
				const shape = this.getShapeById(id)
				const util = this.getShapeUtil(shape)
				if (shape && util.canCrop(shape)) {
					this.setInstancePageState({ croppingId: id, hoveredId: null })
				}
			}
		}
		return this
	}
	getParentIdForNewShapeAtPoint(point2, shapeType) {
		const shapes = this.sortedShapesArray
		for (let i3 = shapes.length - 1; i3 >= 0; i3--) {
			const shape = shapes[i3]
			const util = this.getShapeUtil(shape)
			if (!util.canReceiveNewChildrenOfType(shapeType)) continue
			const maskedPageBounds = this.getMaskedPageBoundsById(shape.id)
			if (
				maskedPageBounds &&
				maskedPageBounds.containsPoint(point2) &&
				util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point2))
			) {
				return shape.id
			}
		}
		return this.focusLayerId
	}
	getDroppingShape(point2, droppingShapes = []) {
		const shapes = this.sortedShapesArray
		for (let i3 = shapes.length - 1; i3 >= 0; i3--) {
			const shape = shapes[i3]
			if (droppingShapes.find((s3) => s3.id === shape.id || this.hasAncestor(shape, s3.id)))
				continue
			const util = this.getShapeUtil(shape)
			if (!util.canDropShapes(shape, droppingShapes)) continue
			const maskedPageBounds = this.getMaskedPageBoundsById(shape.id)
			if (
				maskedPageBounds &&
				maskedPageBounds.containsPoint(point2) &&
				util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point2))
			) {
				return shape
			}
		}
		return void 0
	}
	// This returns the node that should be selected when you click on this one, assuming there is nothing
	// already selected. It will not return anything higher than or including the current focus layer.
	getOutermostSelectableShape(shape, filter2) {
		let match = shape
		let node = shape
		while (node) {
			if (
				node.type === 'group' &&
				this.focusLayerId !== node.id &&
				!this.hasAncestor(this.focusLayerShape, node.id) &&
				(filter2?.(node) ?? true)
			) {
				match = node
			} else if (this.focusLayerId === node.id) {
				break
			}
			node = this.getParentShape(node)
		}
		return match
	}
	get selectedPageBounds() {
		const {
			pageState: { selectedIds },
		} = this
		if (selectedIds.length === 0) return null
		return Box2d.Common(compact(selectedIds.map((id) => this.getPageBoundsById(id))))
	}
	get selectionRotation() {
		const { selectedIds } = this
		if (selectedIds.length === 0) {
			return 0
		}
		if (selectedIds.length === 1) {
			return this.getPageRotationById(this.selectedIds[0])
		}
		const allRotations = selectedIds.map((id) => this.getPageRotationById(id) % (Math.PI / 2))
		if (allRotations.every((rotation) => Math.abs(rotation - allRotations[0]) < Math.PI / 180)) {
			return this.getPageRotationById(selectedIds[0])
		}
		return 0
	}
	get selectionBounds() {
		const { selectedIds } = this
		if (selectedIds.length === 0) {
			return void 0
		}
		const { selectionRotation } = this
		if (selectionRotation === 0) {
			return this.selectedPageBounds
		}
		if (selectedIds.length === 1) {
			const bounds = this.getBounds(this.getShapeById(selectedIds[0])).clone()
			bounds.point = Matrix2d.applyToPoint(this.getPageTransformById(selectedIds[0]), bounds.point)
			return bounds
		}
		const allPoints = this.selectedIds
			.flatMap((id) => {
				const pageTransform = this.getPageTransformById(id)
				if (!pageTransform) return []
				return this.getOutlineById(id).map((point2) => Matrix2d.applyToPoint(pageTransform, point2))
			})
			.map((p3) => Vec2d.Rot(p3, -selectionRotation))
		const box = Box2d.FromPoints(allPoints)
		box.point = box.point.rot(selectionRotation)
		return box
	}
	get selectionPageCenter() {
		const { selectionBounds, selectionRotation } = this
		if (!selectionBounds) return null
		return Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)
	}
	get shapesArray() {
		return Array.from(this.shapeIds).map((id) => this.store.get(id))
	}
	get sortedShapesArray() {
		const shapes = new Set(this.shapesArray.sort(sortByIndex))
		const results = []
		function pushShapeWithDescendants(shape) {
			results.push(shape)
			shapes.delete(shape)
			shapes.forEach((otherShape) => {
				if (otherShape.parentId === shape.id) {
					pushShapeWithDescendants(otherShape)
				}
			})
		}
		shapes.forEach((shape) => {
			const parent = this.getShapeById(shape.parentId)
			if (!isShape(parent)) {
				pushShapeWithDescendants(shape)
			}
		})
		return results
	}
	get selectedShapes() {
		const { selectedIds } = this.pageState
		return compact(selectedIds.map((id) => this.store.get(id)))
	}
	get onlySelectedShape() {
		const { selectedShapes } = this
		return selectedShapes.length === 1 ? selectedShapes[0] : null
	}
	/**
	 * Get whether a shape matches the type of a TLShapeUtil.
	 *
	 * @example
	 *
	 * ```ts
	 * const isArrowShape = isShapeOfType(someShape, TLArrowUtil)
	 * ```
	 *
	 * @param util - the TLShapeUtil constructor to test against
	 * @param shape - the shape to test
	 *
	 * @public
	 */
	isShapeOfType(shape, util) {
		return shape.type === util.type
	}
	/**
	 * Get a shape by its id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getShapeById('box1')
	 * ```
	 *
	 * @param id - The id of the shape to get.
	 * @public
	 */
	getShapeById(id) {
		if (!isShapeId(id)) return void 0
		return this.store.get(id)
	}
	/**
	 * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
	 * the page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getParentShape(myShape)
	 * ```
	 *
	 * @public
	 */
	getParentShape(shape) {
		if (shape === void 0 || !isShapeId(shape.parentId)) return void 0
		return this.store.get(shape.parentId)
	}
	/**
	 * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
	 * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
	 * undefined
	 */
	getNearestSiblingShape(siblingShape, targetShape) {
		if (!targetShape) {
			return void 0
		}
		if (targetShape.parentId === siblingShape.parentId) {
			return targetShape
		}
		const ancestor = this.findAncestor(
			targetShape,
			(ancestor2) => ancestor2.parentId === siblingShape.parentId
		)
		return ancestor
	}
	/** Get the id of the containing page for a given shape. */
	getParentPageId(shape) {
		if (shape === void 0) return void 0
		if (PageRecordType.isId(shape.parentId)) {
			return shape.parentId
		} else {
			return this.getParentPageId(this.getShapeById(shape.parentId))
		}
	}
	/**
	 * Get whether the given shape is the descendant of the given page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.isShapeInPage(myShape)
	 * app.isShapeInPage(myShape, 'page1')
	 * ```
	 *
	 * @param shape - The shape to check.
	 * @param pageId - The id of the page to check against. Defaults to the current page.
	 * @public
	 */
	isShapeInPage(shape, pageId = this.currentPageId) {
		let shapeIsInPage = false
		if (shape.parentId === pageId) {
			shapeIsInPage = true
		} else {
			let parent = this.getShapeById(shape.parentId)
			isInPageSearch: while (parent) {
				if (parent.parentId === pageId) {
					shapeIsInPage = true
					break isInPageSearch
				}
				parent = this.getShapeById(parent.parentId)
			}
		}
		return shapeIsInPage
	}
	/* --------------------- Styles --------------------- */
	/**
	 * A mapping of color ids to CSS color values.
	 *
	 * @internal
	 */
	colors
	/**
	 * A mapping of size ids to size values.
	 *
	 * @internal
	 */
	sizes = {
		s: 2,
		m: 3.5,
		l: 5,
		xl: 10,
	}
	/**
	 * Get the CSS color value for a given color id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getCssColor('red')
	 * ```
	 *
	 * @param id - The id of the color to get.
	 * @public
	 */
	getCssColor(id) {
		return this.colors.get(id)
	}
	/**
	 * Get the stroke width value for a given size id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getStrokeWidth('m')
	 * ```
	 *
	 * @param id - The id of the size to get.
	 * @public
	 */
	getStrokeWidth(id) {
		return this.sizes[id]
	}
	/* ------------------- Statechart ------------------- */
	/**
	 * The id of the current selected tool.
	 *
	 * @public
	 */
	get currentToolId() {
		const activeTool = this.root.current.value
		let activeToolId = activeTool?.id
		if (activeToolId === 'select' || activeToolId === 'zoom') {
			const currentChildState = activeTool?.current.value
			activeToolId = currentChildState?.info?.onInteractionEnd ?? 'select'
		}
		return activeToolId ?? 'select'
	}
	/**
	 * Set the selected tool.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setSelectedTool('hand')
	 * app.setSelectedTool('hand', { date: Date.now() })
	 * ```
	 *
	 * @param id - The id of the tool to select.
	 * @param info - Arbitrary data to pass along into the transition.
	 * @public
	 */
	setSelectedTool(id, info = {}) {
		this.root.transition(id, info)
		return this
	}
	/**
	 * Get a descendant by its path.
	 *
	 * @example
	 *
	 * ```ts
	 * state.getStateDescendant('select')
	 * state.getStateDescendant('select.brushing')
	 * ```
	 *
	 * @param path - The descendant's path of state ids, separated by periods.
	 * @public
	 */
	getStateDescendant(path) {
		const ids = path.split('.').reverse()
		let state = this.root
		while (ids.length > 0) {
			const id = ids.pop()
			if (!id) return state
			const childState = state.children?.[id]
			if (!childState) return void 0
			state = childState
		}
		return state
	}
	/**
	 * Get whether a certain tool (or other state node) is currently active.
	 *
	 * @example
	 *
	 * ```ts
	 * app.isIn('select')
	 * app.isIn('select.brushing')
	 * ```
	 *
	 * @param path - The path of active states, separated by periods.
	 * @public
	 */
	isIn(path) {
		const ids = path.split('.').reverse()
		let state = this.root
		while (ids.length > 0) {
			const id = ids.pop()
			if (!id) return true
			const current = state.current.value
			if (current?.id === id) {
				if (ids.length === 0) return true
				state = current
				continue
			} else return false
		}
		return false
	}
	/**
	 * Get whether the state node is in any of the given active paths.
	 *
	 * @example
	 *
	 * ```ts
	 * state.isInAny('select', 'erase')
	 * state.isInAny('select.brushing', 'erase.idle')
	 * ```
	 *
	 * @public
	 */
	isInAny(...paths) {
		return paths.some((path) => this.isIn(path))
	}
	/* --------------------- Inputs --------------------- */
	/**
	 * The app's current input state.
	 *
	 * @public
	 */
	inputs = {
		/** The most recent pointer down's position in page space. */
		originPagePoint: new Vec2d(),
		/** The most recent pointer down's position in screen space. */
		originScreenPoint: new Vec2d(),
		/** The previous pointer position in page space. */
		previousPagePoint: new Vec2d(),
		/** The previous pointer position in screen space. */
		previousScreenPoint: new Vec2d(),
		/** The most recent pointer position in page space. */
		currentPagePoint: new Vec2d(),
		/** The most recent pointer position in screen space. */
		currentScreenPoint: new Vec2d(),
		/** A set containing the currently pressed keys. */
		keys: /* @__PURE__ */ new Set(),
		/** A set containing the currently pressed buttons. */
		buttons: /* @__PURE__ */ new Set(),
		/** Whether the input is from a pe. */
		isPen: false,
		/** Whether the shift key is currently pressed. */
		shiftKey: false,
		/** Whether the control or command key is currently pressed. */
		ctrlKey: false,
		/** Whether the alt or option key is currently pressed. */
		altKey: false,
		/** Whether the user is dragging. */
		isDragging: false,
		/** Whether the user is pointing. */
		isPointing: false,
		/** Whether the user is pinching. */
		isPinching: false,
		/** Whether the user is editing. */
		isEditing: false,
		/** Whether the user is panning. */
		isPanning: false,
		/** Veclocity of mouse pointer, in pixels per millisecond */
		pointerVelocity: new Vec2d(),
	}
	/**
	 * Update the input points from a pointer or pinch event.
	 *
	 * @param info - The event info.
	 * @internal
	 */
	_updateInputsFromEvent(info) {
		const { previousScreenPoint, previousPagePoint, currentScreenPoint, currentPagePoint } =
			this.inputs
		const { screenBounds } = this.store.unsafeGetWithoutCapture(this.instanceId)
		const { x: sx, y: sy, z: sz } = info.point
		const { x: cx, y: cy, z: cz } = this.camera
		previousScreenPoint.setTo(currentScreenPoint)
		previousPagePoint.setTo(currentPagePoint)
		const px = (sx - screenBounds.x) / cz - cx
		const py = (sy - screenBounds.y) / cz - cy
		currentScreenPoint.set(sx, sy)
		currentPagePoint.set(px, py, sz ?? 0.5)
		this.inputs.isPen = info.type === 'pointer' && info.isPen
		if (info.name === 'pointer_down') {
			this.inputs.pointerVelocity = new Vec2d()
		}
		this.store.put([
			{
				id: TLPOINTER_ID,
				typeName: 'pointer',
				x: currentPagePoint.x,
				y: currentPagePoint.y,
				lastActivityTimestamp: Date.now(),
			},
		])
	}
	/* --------------------- Events --------------------- */
	/**
	 * A manager for recording multiple click events.
	 *
	 * @internal
	 */
	_clickManager = new ClickManager(this)
	/**
	 * Prevent a double click event from firing the next time the user clicks
	 *
	 * @public
	 */
	cancelDoubleClick() {
		this._clickManager.cancelDoubleClickTimeout()
	}
	/**
	 * The previous cursor. Used for restoring the cursor after pan events.
	 *
	 * @internal
	 */
	_prevCursor = 'default'
	/** @internal */
	_shiftKeyTimeout = -1
	/** @internal */
	_setShiftKeyTimeout = () => {
		this.inputs.shiftKey = false
		this.dispatch({
			type: 'keyboard',
			name: 'key_up',
			key: 'Shift',
			shiftKey: this.inputs.shiftKey,
			ctrlKey: this.inputs.ctrlKey,
			altKey: this.inputs.altKey,
			code: 'ShiftLeft',
		})
	}
	/** @internal */
	_altKeyTimeout = -1
	/** @internal */
	_setAltKeyTimeout = () => {
		this.inputs.altKey = false
		this.dispatch({
			type: 'keyboard',
			name: 'key_up',
			key: 'Alt',
			shiftKey: this.inputs.shiftKey,
			ctrlKey: this.inputs.ctrlKey,
			altKey: this.inputs.altKey,
			code: 'AltLeft',
		})
	}
	/** @internal */
	_ctrlKeyTimeout = -1
	/** @internal */
	_setCtrlKeyTimeout = () => {
		this.inputs.ctrlKey = false
		this.dispatch({
			type: 'keyboard',
			name: 'key_up',
			key: 'Ctrl',
			shiftKey: this.inputs.shiftKey,
			ctrlKey: this.inputs.ctrlKey,
			altKey: this.inputs.altKey,
			code: 'CtrlLeft',
		})
	}
	/** @internal */
	_restoreToolId = 'select'
	/** @internal */
	_pinchStart = 1
	/** @internal */
	_didPinch = false
	/** @internal */
	_selectedIdsAtPointerDown = []
	/** @internal */
	capturedPointerId = null
	/**
	 * Dispatch an event to the app.
	 *
	 * @example
	 *
	 * ```ts
	 * app.dispatch(myPointerEvent)
	 * ```
	 *
	 * @param info - The event info.
	 * @public
	 */
	dispatch = (info) => {
		if (this.crashingError) return this
		const { inputs } = this
		const { type } = info
		this.batch(() => {
			if (info.type === 'misc') {
				if (info.name === 'cancel' || info.name === 'complete') {
					this.inputs.isDragging = false
					if (this.inputs.isPanning) {
						this.inputs.isPanning = false
						this.setCursor({
							type: this._prevCursor,
						})
					}
				}
				this.root.handleEvent(info)
				return
			}
			if (info.shiftKey) {
				clearInterval(this._shiftKeyTimeout)
				this._shiftKeyTimeout = -1
				inputs.shiftKey = true
			} else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {
				this._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150)
			}
			if (info.altKey) {
				clearInterval(this._altKeyTimeout)
				this._altKeyTimeout = -1
				inputs.altKey = true
			} else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {
				this._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150)
			}
			if (info.ctrlKey) {
				clearInterval(this._ctrlKeyTimeout)
				this._ctrlKeyTimeout = -1
				inputs.ctrlKey = true
			} else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {
				this._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150)
			}
			const { originPagePoint, originScreenPoint, currentPagePoint, currentScreenPoint } = inputs
			if (!inputs.isPointing) {
				inputs.isDragging = false
			}
			switch (type) {
				case 'pinch': {
					if (!this.canMoveCamera) return
					this._updateInputsFromEvent(info)
					switch (info.name) {
						case 'pinch_start': {
							if (inputs.isPinching) return
							if (!inputs.isEditing) {
								this._pinchStart = this.camera.z
								if (!this._selectedIdsAtPointerDown.length) {
									this._selectedIdsAtPointerDown = this.selectedIds.slice()
								}
								this._didPinch = true
								inputs.isPinching = true
								this.interrupt()
							}
							return
						}
						case 'pinch': {
							if (!inputs.isPinching) return
							const {
								point: { x: x3, y: y3, z: z2 = 1 },
								delta: { x: dx, y: dy },
							} = info
							const {
								camera: { x: cx, y: cy, z: cz },
							} = this
							const zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z2))
							this.setCamera(
								cx + dx / cz - x3 / cz + x3 / zoom,
								cy + dy / cz - y3 / cz + y3 / zoom,
								zoom
							)
							return
						}
						case 'pinch_end': {
							if (!inputs.isPinching) return this
							inputs.isPinching = false
							const { _selectedIdsAtPointerDown } = this
							this.setSelectedIds(this._selectedIdsAtPointerDown, true)
							this._selectedIdsAtPointerDown = []
							const {
								camera: { x: cx, y: cy, z: cz },
							} = this
							let zoom
							if (cz > 0.9 && cz < 1.05) {
								zoom = 1
							} else if (cz > 0.49 && cz < 0.505) {
								zoom = 0.5
							}
							if (cz > this._pinchStart - 0.1 && cz < this._pinchStart + 0.05) {
								zoom = this._pinchStart
							}
							if (zoom !== void 0) {
								const { x: x3, y: y3 } = this.viewportScreenCenter
								this.animateCamera(
									cx + (x3 / zoom - x3) - (x3 / cz - x3),
									cy + (y3 / zoom - y3) - (y3 / cz - y3),
									zoom,
									{ duration: 100 }
								)
							}
							if (this._didPinch) {
								this._didPinch = false
								requestAnimationFrame(() => {
									if (!this._didPinch) {
										this.setSelectedIds(_selectedIdsAtPointerDown, true)
									}
								})
							}
							return
						}
					}
				}
				case 'wheel': {
					if (!this.canMoveCamera) return
					if (this.isMenuOpen) {
					} else {
						if (inputs.ctrlKey) {
							const { x: x3, y: y3 } = this.inputs.currentScreenPoint
							const { x: cx, y: cy, z: cz } = this.camera
							const zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, cz + (info.delta.z ?? 0) * cz))
							this.setCamera(
								cx + (x3 / zoom - x3) - (x3 / cz - x3),
								cy + (y3 / zoom - y3) - (y3 / cz - y3),
								zoom
							)
							return
						}
						this.pan(info.delta.x, info.delta.y)
						if (
							!inputs.isDragging &&
							inputs.isPointing &&
							originPagePoint.dist(currentPagePoint) >
								(this.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / this.zoomLevel
						) {
							inputs.isDragging = true
						}
					}
					break
				}
				case 'pointer': {
					if (inputs.isPinching) return
					this._updateInputsFromEvent(info)
					const { isPen } = info
					switch (info.name) {
						case 'pointer_down': {
							this._selectedIdsAtPointerDown = this.selectedIds.slice()
							if (info.button === 0) {
								this.capturedPointerId = info.pointerId
							}
							inputs.buttons.add(info.button)
							inputs.isPointing = true
							inputs.isDragging = false
							if (this.isPenMode) {
								if (!isPen) {
									this._touchEventsRemainingBeforeExitingPenMode--
									if (this._touchEventsRemainingBeforeExitingPenMode === 0) {
										this.setPenMode(false)
									} else {
										return
									}
								} else {
									this._touchEventsRemainingBeforeExitingPenMode = 3
								}
							} else {
								if (isPen) {
									this.setPenMode(true)
								}
							}
							if (info.button === 5) {
								this._restoreToolId = this.currentToolId
								this.complete()
								this.setSelectedTool('eraser')
							} else if (info.button === 1) {
								if (!this.inputs.isPanning) {
									this._prevCursor = this.instanceState.cursor.type
								}
								this.inputs.isPanning = true
							}
							if (this.inputs.isPanning) {
								this.stopCameraAnimation()
								this.setCursor({
									type: 'grabbing',
								})
								return this
							}
							originScreenPoint.setTo(currentScreenPoint)
							originPagePoint.setTo(currentPagePoint)
							break
						}
						case 'pointer_move': {
							if (!isPen && this.isPenMode) {
								return
							}
							if (this.inputs.isPanning && this.inputs.isPointing) {
								const { currentScreenPoint: currentScreenPoint2, previousScreenPoint } = this.inputs
								const delta = Vec2d.Sub(currentScreenPoint2, previousScreenPoint)
								this.pan(delta.x, delta.y)
								return
							}
							if (
								!inputs.isDragging &&
								inputs.isPointing &&
								originPagePoint.dist(currentPagePoint) >
									(this.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / this.zoomLevel
							) {
								inputs.isDragging = true
							}
							break
						}
						case 'pointer_up': {
							inputs.buttons.delete(info.button)
							inputs.isPointing = false
							inputs.isDragging = false
							if (this.isMenuOpen) {
								return
							}
							if (!isPen && this.isPenMode) {
								return
							}
							if (this.capturedPointerId === info.pointerId) {
								this.capturedPointerId = null
								info.button = 0
							}
							if (inputs.isPanning) {
								if (info.button === 1) {
									if (!this.inputs.keys.has(' ')) {
										inputs.isPanning = false
										this.slideCamera({
											speed: Math.min(2, this.inputs.pointerVelocity.len()),
											direction: this.inputs.pointerVelocity,
											friction: HAND_TOOL_FRICTION,
										})
										this.setCursor({
											type: this._prevCursor,
										})
									} else {
										this.slideCamera({
											speed: Math.min(2, this.inputs.pointerVelocity.len()),
											direction: this.inputs.pointerVelocity,
											friction: HAND_TOOL_FRICTION,
										})
										this.setCursor({
											type: 'grab',
										})
									}
								} else if (info.button === 0) {
									this.slideCamera({
										speed: Math.min(2, this.inputs.pointerVelocity.len()),
										direction: this.inputs.pointerVelocity,
										friction: HAND_TOOL_FRICTION,
									})
									this.setCursor({
										type: 'grab',
									})
								}
							} else {
								if (info.button === 5) {
									this.complete()
									this.setSelectedTool(this._restoreToolId)
								}
							}
							break
						}
					}
					break
				}
				case 'keyboard': {
					switch (info.name) {
						case 'key_down': {
							inputs.keys.add(info.code)
							if (!info.ctrlKey && info.code === 'Space') {
								if (!this.inputs.isPanning) {
									this._prevCursor = this.instanceState.cursor.type
								}
								this.inputs.isPanning = true
								this.setCursor({
									type: this.inputs.isPointing ? 'grabbing' : 'grab',
								})
							}
							break
						}
						case 'key_up': {
							inputs.keys.delete(info.code)
							if (info.code === 'Space' && !this.inputs.buttons.has(1)) {
								this.inputs.isPanning = false
								this.setCursor({
									type: this._prevCursor,
								})
							}
							break
						}
						case 'key_repeat': {
							break
						}
					}
					break
				}
			}
			if (info.type === 'pointer') {
				if (info.button === 1) {
					info.name = 'middle_click'
				} else if (info.button === 2) {
					info.name = 'right_click'
				}
				if (info.isPen === this.isPenMode) {
					switch (info.name) {
						case 'pointer_down': {
							const otherEvent = this._clickManager.transformPointerDownEvent(info)
							if (info.name !== otherEvent.name) {
								this.root.handleEvent(info)
								this.emit('event', info)
								this.root.handleEvent(otherEvent)
								this.emit('event', otherEvent)
								return
							}
							break
						}
						case 'pointer_up': {
							const otherEvent = this._clickManager.transformPointerUpEvent(info)
							if (info.name !== otherEvent.name) {
								this.root.handleEvent(info)
								this.emit('event', info)
								this.root.handleEvent(otherEvent)
								this.emit('event', otherEvent)
								return
							}
							break
						}
						case 'pointer_move': {
							this._clickManager.handleMove()
							break
						}
					}
				}
			}
			this.root.handleEvent(info)
			this.emit('event', info)
		})
		return this
	}
	replaceStoreContentsWithRecordsForOtherDocument(records) {
		transact(() => {
			this.store.clear()
			const [shapes, nonShapes] = partition(records, (record) => record.typeName === 'shape')
			this.store.put(nonShapes, 'initialize')
			this.store.ensureStoreIsUsable()
			this.store.put(shapes, 'initialize')
			this.history.clear()
			this.updateViewportScreenBounds()
			this.updateCullingBounds()
			const bounds = this.allShapesCommonBounds
			if (bounds) {
				this.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height, 1)
			}
		})
	}
	getContent(ids = this.selectedIds) {
		if (!ids) return
		if (ids.length === 0) return
		const pageTransforms = {}
		let shapes = dedupe(
			ids
				.map((id) => this.getShapeById(id))
				.sort(sortByIndex)
				.flatMap((shape) => {
					const allShapes = [shape]
					this.visitDescendants(shape.id, (descendant) => {
						allShapes.push(this.getShapeById(descendant))
					})
					return allShapes
				})
		)
		shapes = shapes.map((shape) => {
			pageTransforms[shape.id] = this.getPageTransformById(shape.id)
			shape = structuredClone(shape)
			if (this.isShapeOfType(shape, TLArrowUtil)) {
				const startBindingId =
					shape.props.start.type === 'binding' ? shape.props.start.boundShapeId : void 0
				const endBindingId =
					shape.props.end.type === 'binding' ? shape.props.end.boundShapeId : void 0
				const info = this.getShapeUtil(TLArrowUtil).getArrowInfo(shape)
				if (shape.props.start.type === 'binding') {
					if (!shapes.some((s3) => s3.id === startBindingId)) {
						if (info?.isValid) {
							const { x: x3, y: y3 } = info.start.point
							shape.props.start = {
								type: 'point',
								x: x3,
								y: y3,
							}
						} else {
							const { start } = getArrowTerminalsInArrowSpace(this, shape)
							shape.props.start = {
								type: 'point',
								x: start.x,
								y: start.y,
							}
						}
					}
				}
				if (shape.props.end.type === 'binding') {
					if (!shapes.some((s3) => s3.id === endBindingId)) {
						if (info?.isValid) {
							const { x: x3, y: y3 } = info.end.point
							shape.props.end = {
								type: 'point',
								x: x3,
								y: y3,
							}
						} else {
							const { end } = getArrowTerminalsInArrowSpace(this, shape)
							shape.props.end = {
								type: 'point',
								x: end.x,
								y: end.y,
							}
						}
					}
				}
				const infoAfter = getIsArrowStraight(shape)
					? getStraightArrowInfo(this, shape)
					: getCurvedArrowInfo(this, shape)
				if (info?.isValid && infoAfter?.isValid && !getIsArrowStraight(shape)) {
					const mpA = Vec2d.Med(info.start.handle, info.end.handle)
					const distA = Vec2d.Dist(info.middle, mpA)
					const distB = Vec2d.Dist(infoAfter.middle, mpA)
					if (shape.props.bend < 0) {
						shape.props.bend += distB - distA
					} else {
						shape.props.bend -= distB - distA
					}
				}
				return shape
			}
			return shape
		})
		const rootShapeIds = []
		shapes.forEach((shape) => {
			if (shapes.find((s3) => s3.id === shape.parentId) === void 0) {
				const pagePoint = this.getPagePointById(shape.id)
				const pageRotation = this.getPageRotationById(shape.id)
				shape.x = pagePoint.x
				shape.y = pagePoint.y
				shape.rotation = pageRotation
				shape.parentId = this.currentPageId
				rootShapeIds.push(shape.id)
			}
		})
		const assetsSet = /* @__PURE__ */ new Set()
		shapes.forEach((shape) => {
			if ('assetId' in shape.props) {
				if (shape.props.assetId !== null) {
					assetsSet.add(shape.props.assetId)
				}
			}
		})
		return {
			shapes,
			rootShapeIds,
			schema: this.store.schema.serialize(),
			assets: compact(Array.from(assetsSet).map((id) => this.getAssetById(id))),
		}
	}
	/* --------------------- Commands --------------------- */
	putContent(content, options = {}) {
		if (this.isReadOnly) return this
		if (!content.schema) {
			throw Error('Could not put content: content is missing a schema.')
		}
		const { select = false, preserveIds = false, preservePosition = false } = options
		let { point: point2 = void 0 } = options
		const { currentPageId } = this
		const { assets, shapes, rootShapeIds } = content
		const idMap = new Map(shapes.map((shape) => [shape.id, createShapeId()]))
		let pasteParentId = this.currentPageId
		let lowestDepth = Infinity
		let lowestAncestors = []
		for (const shape of this.selectedShapes) {
			if (lowestDepth === 0) break
			const ancestors = this.getAncestors(shape)
			if (shape.type === 'frame') ancestors.push(shape)
			const depth = shape.type === 'frame' ? ancestors.length + 1 : ancestors.length
			if (depth < lowestDepth) {
				lowestDepth = depth
				lowestAncestors = ancestors
				pasteParentId = shape.type === 'frame' ? shape.id : shape.parentId
			} else if (depth === lowestDepth) {
				if (lowestAncestors.length !== ancestors.length) {
					throw Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`)
				}
				if (lowestAncestors.length === 0) {
					pasteParentId = currentPageId
					break
				} else {
					pasteParentId = currentPageId
					for (let i3 = 0; i3 < lowestAncestors.length; i3++) {
						if (ancestors[i3] !== lowestAncestors[i3]) break
						pasteParentId = ancestors[i3].id
					}
				}
			}
		}
		let isDuplicating = false
		if (!PageRecordType.isId(pasteParentId)) {
			const parent = this.getShapeById(pasteParentId)
			if (parent) {
				if (!this.viewportPageBounds.includes(this.getPageBounds(parent))) {
					pasteParentId = currentPageId
				} else {
					if (rootShapeIds.length === 1) {
						const rootShape = shapes.find((s3) => s3.id === rootShapeIds[0])
						if (
							this.isShapeOfType(parent, TLFrameUtil) &&
							this.isShapeOfType(rootShape, TLFrameUtil) &&
							rootShape.props.w === parent?.props.w &&
							rootShape.props.h === parent?.props.h
						) {
							isDuplicating = true
						}
					}
				}
			} else {
				pasteParentId = currentPageId
			}
		}
		if (!isDuplicating) {
			isDuplicating = idMap.has(pasteParentId)
		}
		if (isDuplicating) {
			pasteParentId = this.getShapeById(pasteParentId).parentId
		}
		let index2 = this.getHighestIndexForParent(pasteParentId)
		const rootShapes = []
		const newShapes = shapes.map((shape) => {
			let newShape
			if (preserveIds) {
				newShape = deepCopy(shape)
				idMap.set(shape.id, shape.id)
			} else {
				const id = idMap.get(shape.id)
				newShape = deepCopy({ ...shape, id })
			}
			if (rootShapeIds.includes(shape.id)) {
				newShape.parentId = currentPageId
				rootShapes.push(newShape)
			}
			if (idMap.has(newShape.parentId)) {
				newShape.parentId = idMap.get(shape.parentId)
			} else {
				rootShapeIds.push(newShape.id)
				newShape.index = index2
				index2 = getIndexAbove(index2)
			}
			if (this.isShapeOfType(newShape, TLArrowUtil)) {
				if (newShape.props.start.type === 'binding') {
					const mappedId = idMap.get(newShape.props.start.boundShapeId)
					newShape.props.start = mappedId
						? { ...newShape.props.start, boundShapeId: mappedId }
						: // this shouldn't happen, if you copy an arrow but not it's bound shape it should
						  // convert the binding to a point at the time of copying
						  { type: 'point', x: 0, y: 0 }
				}
				if (newShape.props.end.type === 'binding') {
					const mappedId = idMap.get(newShape.props.end.boundShapeId)
					newShape.props.end = mappedId
						? { ...newShape.props.end, boundShapeId: mappedId }
						: // this shouldn't happen, if you copy an arrow but not it's bound shape it should
						  // convert the binding to a point at the time of copying
						  { type: 'point', x: 0, y: 0 }
				}
			}
			return newShape
		})
		if (newShapes.length + this.shapeIds.size > MAX_SHAPES_PER_PAGE) {
			alertMaxShapes(this)
			return this
		}
		let assetsToCreate = []
		if (assets) {
			for (let i3 = 0; i3 < assets.length; i3++) {
				const asset = assets[i3]
				const result = this.store.schema.migratePersistedRecord(asset, content.schema)
				if (result.type === 'success') {
					assets[i3] = result.value
				} else {
					throw Error(
						`Could not put content: could not migrate content for asset:
${JSON.stringify(asset, null, 2)}`
					)
				}
			}
			const assetsToUpdate = []
			assetsToCreate = assets
				.filter((asset) => !this.store.has(asset.id))
				.map((asset) => {
					if (asset.type === 'image' || asset.type === 'video') {
						if (asset.props.src && asset.props.src?.startsWith('data:image')) {
							assetsToUpdate.push(structuredClone(asset))
							asset.props.src = null
						} else {
							assetsToUpdate.push(structuredClone(asset))
						}
					}
					return asset
				})
			Promise.allSettled(
				assetsToUpdate.map(async (asset) => {
					const file = await dataUrlToFile(
						asset.props.src,
						asset.props.name,
						asset.props.mimeType ?? 'image/png'
					)
					const newAsset = await this.onCreateAssetFromFile(file)
					return [asset, newAsset]
				})
			).then((assets2) => {
				this.updateAssets(
					compact(
						assets2.map((result) =>
							result.status === 'fulfilled'
								? { ...result.value[1], id: result.value[0].id }
								: void 0
						)
					)
				)
			})
		}
		for (let i3 = 0; i3 < newShapes.length; i3++) {
			const shape = newShapes[i3]
			const result = this.store.schema.migratePersistedRecord(shape, content.schema)
			if (result.type === 'success') {
				newShapes[i3] = result.value
			} else {
				throw Error(
					`Could not put content: could not migrate content for shape:
${JSON.stringify(shape, null, 2)}`
				)
			}
		}
		this.batch(() => {
			if (assetsToCreate.length > 0) {
				this.createAssets(assetsToCreate)
			}
			this.createShapes(newShapes, select)
			if (pasteParentId !== currentPageId) {
				this.reparentShapesById(
					rootShapes.map((s3) => s3.id),
					pasteParentId
				)
			}
			const newCreatedShapes = newShapes.map((s3) => this.getShapeById(s3.id))
			const bounds = Box2d.Common(newCreatedShapes.map((s3) => this.getPageBounds(s3)))
			if (point2 === void 0) {
				if (!PageRecordType.isId(pasteParentId)) {
					const shape = this.getShapeById(pasteParentId)
					const util = this.getShapeUtil(shape)
					point2 = util.center(shape)
				} else {
					const { viewportPageBounds } = this
					if (preservePosition || viewportPageBounds.includes(Box2d.From(bounds))) {
						point2 = bounds.center
					} else {
						point2 = viewportPageBounds.center
					}
				}
			}
			if (rootShapes.length === 1) {
				const onlyRoot = rootShapes[0]
				if (onlyRoot.type === 'frame') {
					while (
						this.getShapesAtPoint(point2).some(
							(shape) =>
								this.isShapeOfType(shape, TLFrameUtil) &&
								shape.props.w === onlyRoot.props.w &&
								shape.props.h === onlyRoot.props.h
						)
					) {
						point2.x += bounds.w + 16
					}
				}
			}
			this.updateShapes(
				rootShapes.map((s3) => {
					const delta = {
						x: (s3.x ?? 0) - (bounds.x + bounds.w / 2),
						y: (s3.y ?? 0) - (bounds.y + bounds.h / 2),
					}
					return { id: s3.id, type: s3.type, x: point2.x + delta.x, y: point2.y + delta.y }
				})
			)
		})
		return this
	}
	/* --------------------- Shapes --------------------- */
	/**
	 * Get a unique id for a shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.createShapeId()
	 * app.createShapeId('box1')
	 * ```
	 *
	 * @param id - The id to use.
	 * @public
	 */
	createShapeId(id) {
		return id ? createCustomShapeId(id) : createShapeId()
	}
	getHighestIndexForParent(parentId) {
		const children = this._parentIdsToChildIds.value[parentId]
		if (!children || children.length === 0) {
			return 'a1'
		}
		return getIndexAbove(children[children.length - 1][1])
	}
	/**
	 * Create shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.createShapes([{ id: 'box1', type: 'box' }])
	 * ```
	 *
	 * @param partials - The shape partials to create.
	 * @param select - Whether to select the created shapes. Defaults to false.
	 * @public
	 */
	createShapes(partials, select = false) {
		this._createShapes(partials, select)
		return this
	}
	/** @internal */
	_createShapes = this.history.createCommand(
		'createShapes',
		(partials, select = false) => {
			if (this.isReadOnly) return null
			if (partials.length <= 0) return null
			const { shapeIds, selectedIds } = this
			const prevSelectedIds = select ? selectedIds : void 0
			const maxShapesReached = partials.length + shapeIds.size > MAX_SHAPES_PER_PAGE
			if (maxShapesReached) {
				alertMaxShapes(this)
			}
			const partialsToCreate = maxShapesReached
				? partials.slice(0, MAX_SHAPES_PER_PAGE - shapeIds.size)
				: partials
			if (partialsToCreate.length === 0) return null
			return {
				data: {
					currentPageId: this.currentPageId,
					createdIds: partials.map((p3) => p3.id),
					prevSelectedIds,
					partials: partialsToCreate,
					select,
				},
			}
		},
		{
			do: ({ createdIds, partials, select }) => {
				const { focusLayerId } = this
				partials = partials.map((partial) => {
					if (
						// No parentId provided
						!partial.parentId || // A parentId is proved but the parent is neither a) in the store
						// or b) among the other creating shape partials
						(!this.store.get(partial.parentId) &&
							!partials.find((p3) => p3.id === partial.parentId))
					) {
						partial = { ...partial }
						const parentId = this.getParentIdForNewShapeAtPoint(
							{ x: partial.x ?? 0, y: partial.y ?? 0 },
							partial.type
						)
						partial.parentId = parentId
						if (isShapeId(parentId)) {
							const point2 = this.getPointInShapeSpace(this.getShapeById(parentId), {
								x: partial.x ?? 0,
								y: partial.y ?? 0,
							})
							partial.x = point2.x
							partial.y = point2.y
							partial.rotation = -this.getPageRotationById(parentId) + (partial.rotation ?? 0)
						}
						return partial
					}
					return partial
				})
				const parentIndices = /* @__PURE__ */ new Map()
				const shapeRecordsToCreate = []
				for (const partial of partials) {
					const util = this.getShapeUtil(partial)
					let index2 = partial.index
					if (!index2) {
						const parentId = partial.parentId ?? focusLayerId
						if (!parentIndices.has(parentId)) {
							parentIndices.set(parentId, this.getHighestIndexForParent(parentId))
						}
						index2 = parentIndices.get(parentId)
						parentIndices.set(parentId, getIndexAbove(index2))
					}
					const initialProps = util.defaultProps()
					const { propsForNextShape } = this.instanceState
					for (const key in initialProps) {
						if (key in propsForNextShape) {
							if (key === 'url') continue
							initialProps[key] = propsForNextShape[key]
						}
					}
					let shapeRecordToCreate = this.config.TLShape.create({
						...partial,
						index: index2,
						parentId: partial.parentId ?? focusLayerId,
						props: 'props' in partial ? { ...initialProps, ...partial.props } : initialProps,
					})
					if (shapeRecordToCreate.index === void 0) {
						throw Error('no index!')
					}
					const next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate)
					if (next) {
						shapeRecordToCreate = next
					}
					shapeRecordsToCreate.push(shapeRecordToCreate)
				}
				this.store.put(shapeRecordsToCreate)
				if (select) {
					this.store.update(this.pageState.id, (state) => ({
						...state,
						selectedIds: createdIds,
					}))
				}
			},
			undo: ({ createdIds, prevSelectedIds }) => {
				this.store.remove(createdIds)
				if (prevSelectedIds) {
					this.store.update(this.pageState.id, (state) => ({
						...state,
						selectedIds: prevSelectedIds,
					}))
				}
			},
		}
	)
	animatingShapes = /* @__PURE__ */ new Map()
	/**
	 * Animate shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
	 * ```
	 *
	 * @param partials - The shape partials to update.
	 * @public
	 */
	animateShapes(partials, options = {}) {
		const { duration = 500, ease: ease2 = EASINGS.linear } = options
		const animationId = uniqueId()
		let remaining = duration
		let t4
		const animations = []
		partials.forEach((partial) => {
			if (!partial) return
			const result = {
				partial,
				values: [],
			}
			const shape = this.getShapeById(partial.id)
			if (!shape) return
			for (const key of ['x', 'y', 'rotation']) {
				if (partial[key] !== void 0 && shape[key] !== partial[key]) {
					result.values.push({ prop: key, from: shape[key], to: partial[key] })
				}
			}
			animations.push(result)
			this.animatingShapes.set(shape.id, animationId)
		})
		let value
		const handleTick = (elapsed) => {
			remaining -= elapsed
			if (remaining < 0) {
				const { animatingShapes: animatingShapes2 } = this
				const partialsToUpdate = partials.filter(
					(p3) => p3 && animatingShapes2.get(p3.id) === animationId
				)
				if (partialsToUpdate.length) {
					this.updateShapes(partialsToUpdate, false)
				}
				this.removeListener('tick', handleTick)
				return
			}
			t4 = ease2(1 - remaining / duration)
			const { animatingShapes } = this
			try {
				const tPartials = []
				for (let i3 = 0; i3 < animations.length; i3++) {
					value = animations[i3]
					if (animatingShapes.get(value.partial.id) === animationId) {
						tPartials.push({
							id: value.partial.id,
							type: value.partial.type,
							...value.values.reduce((acc, { prop, from, to }) => {
								acc[prop] = from + (to - from) * t4
								return acc
							}, {}),
						})
					}
				}
				this._updateShapes(tPartials, true)
			} catch (e2) {}
		}
		this.addListener('tick', handleTick)
		return this
	}
	/**
	 * Update shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.updateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
	 * ```
	 *
	 * @param partials - The shape partials to update.
	 * @param squashing - Whether the change is ephemeral.
	 * @public
	 */
	updateShapes(partials, squashing = false) {
		if (this.animatingShapes.size > 0) {
			let partial
			for (let i3 = 0; i3 < partials.length; i3++) {
				partial = partials[i3]
				if (partial) {
					this.animatingShapes.delete(partial.id)
				}
			}
		}
		this._updateShapes(partials, squashing)
		return this
	}
	/** @internal */
	_updateShapes = this.history.createCommand(
		'updateShapes',
		(_partials, squashing = false) => {
			if (this.isReadOnly) return null
			const partials = compact(_partials)
			const snapshots = Object.fromEntries(
				compact(partials.map(({ id }) => this.getShapeById(id))).map((shape) => {
					return [shape.id, shape]
				})
			)
			if (partials.length <= 0) return null
			const updated = compact(
				partials.map((partial) => {
					const prev = snapshots[partial.id]
					if (!prev) return null
					let newRecord = null
					for (const [k2, v3] of Object.entries(partial)) {
						switch (k2) {
							case 'id':
							case 'type':
							case 'typeName': {
								continue
							}
							default: {
								if (v3 !== prev[k2]) {
									if (!newRecord) {
										newRecord = { ...prev }
									}
									if (k2 === 'props') {
										newRecord.props = { ...prev.props, ...v3 }
									} else {
										newRecord[k2] = v3
									}
								}
							}
						}
					}
					return newRecord ?? prev
				})
			)
			const updates = Object.fromEntries(updated.map((shape) => [shape.id, shape]))
			return { data: { snapshots, updates }, squashing }
		},
		{
			do: ({ updates }) => {
				const result = Object.values(updates)
				for (let i3 = 0; i3 < result.length; i3++) {
					const shape = result[i3]
					const current = this.store.get(shape.id)
					if (!current) continue
					const next = this.getShapeUtil(shape).onBeforeUpdate?.(current, shape)
					if (next) {
						result[i3] = next
					}
				}
				this.store.put(result)
			},
			undo: ({ snapshots }) => {
				this.store.put(Object.values(snapshots))
			},
			squash(prevData, nextData) {
				return {
					// keep the oldest snapshots
					snapshots: { ...nextData.snapshots, ...prevData.snapshots },
					// keep the newest updates
					updates: { ...prevData.updates, ...nextData.updates },
				}
			},
		}
	)
	/**
	 * Delete shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.deleteShapes()
	 * app.deleteShapes(['box1', 'box2'])
	 * ```
	 *
	 * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.
	 * @public
	 */
	deleteShapes(ids = this.selectedIds) {
		this._deleteShapes(ids)
		return this
	}
	/** @internal */
	_deleteShapes = this.history.createCommand(
		'delete_shapes',
		(ids) => {
			if (this.isReadOnly) return null
			if (ids.length === 0) return null
			const prevSelectedIds = [...this.pageState.selectedIds]
			const allIds = new Set(ids)
			for (const id of ids) {
				this.visitDescendants(id, (childId) => {
					allIds.add(childId)
				})
			}
			const deletedIds = [...allIds]
			const arrowBindings = this._arrowBindingsIndex.value
			const snapshots = compact(
				deletedIds.flatMap((id) => {
					const shape = this.getShapeById(id)
					const bindings = arrowBindings[id]
					if (bindings && bindings.length > 0) {
						return bindings.map(({ arrowId }) => this.getShapeById(arrowId)).concat(shape)
					}
					return shape
				})
			)
			const postSelectedIds = prevSelectedIds.filter((id) => !allIds.has(id))
			return { data: { deletedIds, snapshots, prevSelectedIds, postSelectedIds } }
		},
		{
			do: ({ deletedIds, postSelectedIds }) => {
				this.store.remove(deletedIds)
				this.store.update(this.pageState.id, (state) => ({
					...state,
					selectedIds: postSelectedIds,
				}))
			},
			undo: ({ snapshots, prevSelectedIds }) => {
				this.store.put(snapshots)
				this.store.update(this.pageState.id, (state) => ({
					...state,
					selectedIds: prevSelectedIds,
				}))
			},
		}
	)
	/**
	 * Update user document settings
	 *
	 * @example
	 *
	 * ```ts
	 * app.updateUserDocumentSettings({ isGridMode: true })
	 * ```
	 *
	 * @public
	 */
	updateUserDocumentSettings(partial, ephemeral = false) {
		this._updateUserDocumentSettings(partial, ephemeral)
		return this
	}
	/** @internal */
	_updateUserDocumentSettings = this.history.createCommand(
		'updateUserDocumentSettings',
		(partial, ephemeral = false) => {
			const prev = this.userDocumentSettings
			const next = { ...prev, ...partial }
			return { data: { prev, next }, ephemeral }
		},
		{
			do: ({ next }) => {
				this.store.put([next])
			},
			undo: ({ prev }) => {
				this.store.put([prev])
			},
		}
	)
	/**
	 * Get the editor's locale.
	 * @public
	 */
	get locale() {
		return this.user.locale
	}
	/**
	 * Update the editor's locale. This affects which translations are used when rendering UI elements.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setLocale('fr')
	 * ```
	 */
	setLocale(locale) {
		this.user.updateUserPreferences({ locale })
	}
	/**
	 * Update a page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.updatePage({ id: 'page2', name: 'Page 2' })
	 * ```
	 *
	 * @param partial - The partial of the shape to update.
	 * @public
	 */
	updatePage(partial, squashing = false) {
		this._updatePage(partial, squashing)
		return this
	}
	/** @internal */
	_updatePage = this.history.createCommand(
		'updatePage',
		(partial, squashing = false) => {
			if (this.isReadOnly) return null
			const prev = this.getPageById(partial.id)
			if (!prev) return null
			return { data: { prev, partial }, squashing }
		},
		{
			do: ({ partial }) => {
				this.store.update(partial.id, (page) => ({ ...page, ...partial }))
			},
			undo: ({ prev, partial }) => {
				this.store.update(partial.id, () => prev)
			},
			squash(prevData, nextData) {
				return {
					prev: { ...prevData.prev, ...nextData.prev },
					partial: nextData.partial,
				}
			},
		}
	)
	/**
	 * Create a page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.createPage('New Page')
	 * app.createPage('New Page', 'page1')
	 * ```
	 *
	 * @param id - The new page's id.
	 * @param title - The new page's title.
	 * @public
	 */
	createPage(title, id = PageRecordType.createId(), belowPageIndex) {
		this._createPage(title, id, belowPageIndex)
		return this
	}
	/** @internal */
	_createPage = this.history.createCommand(
		'createPage',
		(title, id = PageRecordType.createId(), belowPageIndex) => {
			if (this.isReadOnly) return null
			if (this.pages.length >= MAX_PAGES) return null
			const pageInfo = this.pages
			const topIndex = belowPageIndex ?? pageInfo[pageInfo.length - 1]?.index ?? 'a1'
			const bottomIndex = pageInfo[pageInfo.findIndex((p3) => p3.index === topIndex) + 1]?.index
			const prevPageState = { ...this.pageState }
			const prevInstanceState = { ...this.instanceState }
			title = getIncrementedName(
				title,
				pageInfo.map((p3) => p3.name)
			)
			const newPage = PageRecordType.create({
				id,
				name: title,
				index:
					bottomIndex && topIndex !== bottomIndex
						? getIndexBetween(topIndex, bottomIndex)
						: getIndexAbove(topIndex),
			})
			const newCamera = CameraRecordType.create({})
			const newTabPageState = InstancePageStateRecordType.create({
				pageId: newPage.id,
				instanceId: this.instanceId,
				cameraId: newCamera.id,
			})
			return {
				data: {
					prevPageState,
					prevTabState: prevInstanceState,
					newPage,
					newTabPageState,
					newCamera,
				},
			}
		},
		{
			do: ({ newPage, newTabPageState, newCamera }) => {
				this.store.put([
					newPage,
					newCamera,
					newTabPageState,
					{ ...this.instanceState, currentPageId: newPage.id },
				])
				this.updateCullingBounds()
			},
			undo: ({ newPage, prevPageState, prevTabState, newTabPageState }) => {
				this.store.put([prevPageState, prevTabState])
				this.store.remove([newTabPageState.id, newPage.id, newTabPageState.cameraId])
				this.updateCullingBounds()
			},
		}
	)
	duplicatePage(id = this.currentPageId, createId = PageRecordType.createId()) {
		if (this.pages.length >= MAX_PAGES) return
		const page = this.getPageById(id)
		if (!page) return
		const camera = { ...this.camera }
		const content = this.getContent(this.getSortedChildIds(page.id))
		this.batch(() => {
			this.createPage(page.name + ' Copy', createId, page.index)
			this.setCurrentPageId(createId)
			this.setCamera(camera.x, camera.y, camera.z)
			if (content) {
				return this.putContent(content)
			}
		})
	}
	/**
	 * Delete a page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.deletePage('page1')
	 * ```
	 *
	 * @param id - The id of the page to delete.
	 * @public
	 */
	deletePage(id) {
		this._deletePage(id)
	}
	/** @internal */
	_deletePage = this.history.createCommand(
		'delete_page',
		(id) => {
			if (this.isReadOnly) return null
			const { pages } = this
			if (pages.length === 1) return null
			const deletedPage = this.getPageById(id)
			const deletedPageStates = this._pageStates.value.filter((s3) => s3.pageId === id)
			if (!deletedPage) return null
			if (id === this.currentPageId) {
				const index2 = pages.findIndex((page) => page.id === id)
				const next = pages[index2 - 1] ?? pages[index2 + 1]
				this.setCurrentPageId(next.id)
			}
			return { data: { id, deletedPage, deletedPageStates } }
		},
		{
			do: ({ deletedPage, deletedPageStates }) => {
				const { pages } = this
				if (pages.length === 1) return
				if (deletedPage.id === this.currentPageId) {
					const index2 = pages.findIndex((page) => page.id === deletedPage.id)
					const next = pages[index2 - 1] ?? pages[index2 + 1]
					this.setCurrentPageId(next.id)
				}
				this.store.remove(deletedPageStates.map((s3) => s3.id))
				this.store.remove([deletedPage.id])
				this.updateCullingBounds()
			},
			undo: ({ deletedPage, deletedPageStates }) => {
				this.store.put([deletedPage])
				this.store.put(deletedPageStates)
				this.updateCullingBounds()
			},
		}
	)
	/**
	 * Update a page state.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setInstancePageState({ id: 'page1', editingId: 'shape:123' })
	 * app.setInstancePageState({ id: 'page1', editingId: 'shape:123' }, true)
	 * ```
	 *
	 * @param partial - The partial of the page state object containing the changes.
	 * @param ephemeral - Whether the command is ephemeral.
	 * @public
	 */
	setInstancePageState(partial, ephemeral = false) {
		this._setInstancePageState(partial, ephemeral)
	}
	/** @internal */
	_setInstancePageState = this.history.createCommand(
		'setInstancePageState',
		(partial, ephemeral = false) => {
			const prev = this.store.get(partial.id ?? this.pageState.id)
			return { data: { prev, partial }, ephemeral }
		},
		{
			do: ({ prev, partial }) => {
				this.store.update(prev.id, (state) => ({ ...state, ...partial }))
			},
			undo: ({ prev }) => {
				this.store.update(prev.id, () => prev)
			},
		}
	)
	/**
	 * Select one or more shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setSelectedIds(['id1'])
	 * app.setSelectedIds(['id1', 'id2'])
	 * ```
	 *
	 * @param ids - The ids to select.
	 * @param squashing - Whether the change should create a new history entry or combine with the
	 *   previous (if the previous is the same type).
	 * @public
	 */
	setSelectedIds(ids, squashing = false) {
		this._setSelectedIds(ids, squashing)
		return this
	}
	/** @internal */
	_setSelectedIds = this.history.createCommand(
		'setSelectedIds',
		(ids, squashing = false) => {
			const prevSelectedIds = this.pageState.selectedIds
			const prevSet = new Set(this.pageState.selectedIds)
			if (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null
			return { data: { ids, prevSelectedIds }, squashing, preservesRedoStack: true }
		},
		{
			do: ({ ids }) => {
				this.store.update(this.pageState.id, (state) => ({ ...state, selectedIds: ids }))
			},
			undo: ({ prevSelectedIds }) => {
				this.store.update(this.pageState.id, () => ({
					...this.pageState,
					selectedIds: prevSelectedIds,
				}))
			},
			squash(prev, next) {
				return { ids: next.ids, prevSelectedIds: prev.prevSelectedIds }
			},
		}
	)
	/**
	 * Determine whether or not a shape is selected
	 *
	 * @example
	 *
	 * ```ts
	 * app.isSelected('id1')
	 * ```
	 *
	 * @param id - The id of the shape to check.
	 * @public
	 */
	isSelected(id) {
		return this.selectedIdsSet.has(id)
	}
	/**
	 * Determine whether a not a shape is within the current selection. A shape is within the
	 * selection if it or any of its parents is selected.
	 *
	 * @param id - The id of the shape to check.
	 * @public
	 */
	isWithinSelection(id) {
		const shape = this.getShapeById(id)
		if (!shape) return false
		if (this.isSelected(id)) return true
		return !!this.findAncestor(shape, (parent) => this.isSelected(parent.id))
	}
	get _assets() {
		return this.store.query.records('asset')
	}
	/** Get all assets in the app. */
	get assets() {
		return this._assets.value
	}
	/**
	 * Create one or more assets.
	 *
	 * @example
	 *
	 * ```ts
	 * app.createAssets([...myAssets])
	 * ```
	 *
	 * @param assets - The assets to create.
	 * @public
	 */
	createAssets(assets) {
		this._createAssets(assets)
		return this
	}
	/** @internal */
	_createAssets = this.history.createCommand(
		'createAssets',
		(assets) => {
			if (this.isReadOnly) return null
			if (assets.length <= 0) return null
			return { data: { assets } }
		},
		{
			do: ({ assets }) => {
				this.store.put(assets)
			},
			undo: ({ assets }) => {
				this.store.remove(assets.map((a3) => a3.id))
			},
		}
	)
	/**
	 * Delete one or more assets.
	 *
	 * @example
	 *
	 * ```ts
	 * app.deleteAssets(['asset1', 'asset2'])
	 * ```
	 *
	 * @param ids - The assets to delete.
	 * @public
	 */
	deleteAssets(ids) {
		this._deleteAssets(ids)
		return this
	}
	/** @internal */
	_deleteAssets = this.history.createCommand(
		'deleteAssets',
		(ids) => {
			if (this.isReadOnly) return
			if (ids.length <= 0) return
			const prev = compact(ids.map((id) => this.store.get(id)))
			return { data: { ids, prev } }
		},
		{
			do: ({ ids }) => {
				this.store.remove(ids)
			},
			undo: ({ prev }) => {
				this.store.put(prev)
			},
		}
	)
	/**
	 * Update one or more assets.
	 *
	 * @example
	 *
	 * ```ts
	 * app.updateAssets([{ id: 'asset1', name: 'New name' }])
	 * ```
	 *
	 * @param assets - The assets to update.
	 * @public
	 */
	updateAssets(assets) {
		this._updateAssets(assets)
		return this
	}
	/** @internal */
	_updateAssets = this.history.createCommand(
		'updateAssets',
		(assets) => {
			if (this.isReadOnly) return
			if (assets.length <= 0) return
			const snapshots = {}
			return { data: { snapshots, assets } }
		},
		{
			do: ({ assets, snapshots }) => {
				this.store.put(
					assets.map((a3) => {
						const asset = this.store.get(a3.id)
						snapshots[a3.id] = asset
						return {
							...asset,
							...a3,
						}
					})
				)
			},
			undo: ({ snapshots }) => {
				this.store.put(Object.values(snapshots))
			},
		}
	)
	/**
	 * Get an asset by its src property.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getAssetBySource('https://example.com/image.png')
	 * ```
	 *
	 * @param src - The source value of the asset.
	 * @public
	 */
	getAssetBySrc(src) {
		return this.assets.find((a3) => a3.props.src === src)
	}
	/**
	 * Get an asset by its id.
	 *
	 * @example
	 *
	 * ```ts
	 * app.getAssetById('asset1')
	 * ```
	 *
	 * @param id - The id of the asset.
	 * @public
	 */
	getAssetById(id) {
		return this.store.get(id)
	}
	/* ------------------- SubCommands ------------------ */
	async getSvg(
		ids = this.selectedIds.length ? this.selectedIds : Object.keys(this.shapeIds),
		opts = {}
	) {
		if (ids.length === 0) return
		if (!window.document) throw Error('No document')
		const {
			scale = 1,
			background = false,
			padding = SVG_PADDING,
			darkMode = this.isDarkMode,
			preserveAspectRatio = false,
		} = opts
		const realContainerEl = this.getContainer()
		const realContainerStyle = getComputedStyle(realContainerEl)
		const fakeContainerEl = document.createElement('div')
		fakeContainerEl.className = `tl-container tl-theme__${darkMode ? 'dark' : 'light'}`
		document.body.appendChild(fakeContainerEl)
		const containerStyle = getComputedStyle(fakeContainerEl)
		const fontsUsedInExport = /* @__PURE__ */ new Map()
		const colors = {
			fill: Object.fromEntries(
				STYLES.color.map((color) => [
					color.id,
					containerStyle.getPropertyValue(`--palette-${color.id}`),
				])
			),
			pattern: Object.fromEntries(
				STYLES.color.map((color) => [
					color.id,
					containerStyle.getPropertyValue(`--palette-${color.id}-pattern`),
				])
			),
			semi: Object.fromEntries(
				STYLES.color.map((color) => [
					color.id,
					containerStyle.getPropertyValue(`--palette-${color.id}-semi`),
				])
			),
			text: containerStyle.getPropertyValue(`--color-text`),
			background: containerStyle.getPropertyValue(`--color-background`),
			solid: containerStyle.getPropertyValue(`--palette-solid`),
		}
		document.body.removeChild(fakeContainerEl)
		const shapes = this.getShapesAndDescendantsInOrder(ids)
		const bbox = Box2d.FromPoints(
			shapes
				.map((shape2) => {
					const pageMask = this.getPageMaskById(shape2.id)
					if (pageMask) {
						return pageMask
					}
					const pageTransform = this.getPageTransform(shape2)
					const pageOutline = Matrix2d.applyToPoints(pageTransform, this.getOutline(shape2))
					return pageOutline
				})
				.flat()
		)
		const isSingleFrameShape = ids.length === 1 && shapes[0].type === 'frame'
		if (!isSingleFrameShape) {
			bbox.expandBy(padding)
		}
		const w3 = bbox.width * scale
		const h3 = bbox.height * scale
		const svg = window.document.createElementNS('http://www.w3.org/2000/svg', 'svg')
		if (preserveAspectRatio) {
			svg.setAttribute('preserveAspectRatio', preserveAspectRatio)
		}
		svg.setAttribute('direction', 'ltr')
		svg.setAttribute('width', w3 + '')
		svg.setAttribute('height', h3 + '')
		svg.setAttribute('viewBox', `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`)
		svg.setAttribute('stroke-linecap', 'round')
		svg.setAttribute('stroke-linejoin', 'round')
		if (background) {
			if (isSingleFrameShape) {
				svg.style.setProperty('background', colors.solid)
			} else {
				svg.style.setProperty('background-color', colors.background)
			}
		} else {
			svg.style.setProperty('background-color', 'transparent')
		}
		const defs = window.document.createElementNS('http://www.w3.org/2000/svg', 'defs')
		for (const element of Array.from(exportPatternSvgDefs(colors.solid))) {
			defs.appendChild(element)
		}
		try {
			document.body.focus?.()
		} catch (e2) {}
		svg.append(defs)
		let shape
		for (let i3 = 0, n3 = shapes.length; i3 < n3; i3++) {
			shape = shapes[i3]
			if (isSingleFrameShape && i3 === 0) continue
			let font
			if ('font' in shape.props) {
				if (shape.props.font) {
					if (fontsUsedInExport.has(shape.props.font)) {
						font = fontsUsedInExport.get(shape.props.font)
					} else {
						font = realContainerStyle.getPropertyValue(`--tl-font-${shape.props.font}`)
						fontsUsedInExport.set(shape.props.font, font)
					}
				}
			}
			const util = this.getShapeUtil(shape)
			let utilSvgElement = await util.toSvg?.(shape, font, colors)
			if (!utilSvgElement) {
				const bounds = this.getPageBounds(shape)
				const elm = window.document.createElementNS('http://www.w3.org/2000/svg', 'rect')
				elm.setAttribute('width', bounds.width + '')
				elm.setAttribute('height', bounds.height + '')
				elm.setAttribute('fill', colors.solid)
				elm.setAttribute('stroke', colors.pattern.grey)
				elm.setAttribute('stroke-width', '1')
				utilSvgElement = elm
			}
			const shapeSvg = utilSvgElement
			let pageTransform = this.getPageTransform(shape).toCssString()
			if ('scale' in shape.props) {
				if (shape.props.scale !== 1) {
					pageTransform = `${pageTransform} scale(${shape.props.scale}, ${shape.props.scale})`
				}
			}
			shapeSvg.setAttribute('transform', pageTransform)
			if ('opacity' in shape.props) shapeSvg.setAttribute('opacity', shape.props.opacity + '')
			const pageMask = this.getPageMaskById(shape.id)
			if (shapeSvg && pageMask) {
				const clipPathEl = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath')
				defs.appendChild(clipPathEl)
				const id = nanoid()
				clipPathEl.id = id
				const mask = document.createElementNS('http://www.w3.org/2000/svg', 'path')
				mask.setAttribute('d', `M${pageMask.map(({ x: x3, y: y3 }) => `${x3},${y3}`).join('L')}Z`)
				clipPathEl.appendChild(mask)
				const outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')
				outerElement.setAttribute('clip-path', `url(#${id})`)
				outerElement.appendChild(shapeSvg)
				svg.appendChild(outerElement)
			} else {
				svg.appendChild(shapeSvg)
			}
		}
		let styles2 = ``
		const style = window.document.createElementNS('http://www.w3.org/2000/svg', 'style')
		const fontInstances = []
		if ('fonts' in document) {
			document.fonts.forEach((font) => fontInstances.push(font))
		}
		for (const font of fontInstances) {
			const fileReader = new FileReader()
			let isUsed = false
			fontsUsedInExport.forEach((fontName) => {
				if (fontName.includes(font.family)) {
					isUsed = true
				}
			})
			if (!isUsed) continue
			const url = font.$$_url
			const fontFaceRule = font.$$_fontface
			if (url) {
				const fontFile = await (await fetch(url)).blob()
				const base64Font = await new Promise((resolve, reject) => {
					fileReader.onload = () => resolve(fileReader.result)
					fileReader.onerror = () => reject(fileReader.error)
					fileReader.readAsDataURL(fontFile)
				})
				const newFontFaceRule = '\n' + fontFaceRule.replaceAll(url, base64Font)
				styles2 += newFontFaceRule
			}
		}
		style.textContent = styles2
		defs.append(style)
		return svg
	}
	/**
	 * Rename a page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.renamePage('page1', 'My Page')
	 * ```
	 *
	 * @param id - The id of the page to rename.
	 * @param name - The new name.
	 * @public
	 */
	renamePage(id, name, squashing = false) {
		if (this.isReadOnly) return this
		this.updatePage({ id, name }, squashing)
		return this
	}
	/**
	 * Move shapes to page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.moveShapesToPage(['box1', 'box2'], 'page1')
	 * ```
	 *
	 * @param ids - The ids of the shapes to move.
	 * @param pageId - The id of the page where the shapes will be moved.
	 * @public
	 */
	moveShapesToPage(ids, pageId) {
		if (ids.length === 0) return this
		if (this.isReadOnly) return this
		const { currentPageId } = this
		if (pageId === currentPageId) return this
		if (!this.store.has(pageId)) return this
		const content = this.getContent(ids)
		if (!content) return this
		if (this.getShapesInPage(pageId).length + content.shapes.length > MAX_SHAPES_PER_PAGE) {
			alertMaxShapes(this, pageId)
			return this
		}
		const fromPageZ = this.camera.z
		this.history.batch(() => {
			this.deleteShapes(ids)
			this.setCurrentPageId(pageId)
			this.setFocusLayer(null)
			this.selectNone()
			this.putContent(content, { select: true, preserveIds: true, preservePosition: true })
			const {
				center: { x: x3, y: y3 },
			} = this.selectionBounds
			this.setCamera(this.camera.x, this.camera.y, fromPageZ)
			this.centerOnPoint(x3, y3)
		})
		return this
	}
	lockShapes(_ids = this.pageState.selectedIds) {
		if (this.isReadOnly) return this
		return this
	}
	/**
	 * Reorder shapes.
	 *
	 * @param operation - The operation to perform.
	 * @param ids - The ids to reorder.
	 * @public
	 */
	reorderShapes(operation, ids) {
		if (this.isReadOnly) return this
		if (ids.length === 0) return this
		const parents = this.getParentsMappedToChildren(ids)
		const changes = []
		switch (operation) {
			case 'toBack': {
				parents.forEach((movingSet, parentId) => {
					const siblings = compact(
						this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
					)
					if (movingSet.size === siblings.length) return
					let below
					let above
					for (const shape of siblings) {
						if (!movingSet.has(shape)) {
							above = shape.index
							break
						}
						movingSet.delete(shape)
						below = shape.index
					}
					if (movingSet.size === 0) return
					const indices = getIndicesBetween(below, above, movingSet.size)
					Array.from(movingSet.values())
						.sort(sortByIndex)
						.forEach((node, i3) =>
							changes.push({ id: node.id, type: node.type, index: indices[i3] })
						)
				})
				break
			}
			case 'toFront': {
				parents.forEach((movingSet, parentId) => {
					const siblings = compact(
						this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
					)
					const len = siblings.length
					if (movingSet.size === len) return
					let below
					let above
					for (let i3 = len - 1; i3 > -1; i3--) {
						const shape = siblings[i3]
						if (!movingSet.has(shape)) {
							below = shape.index
							break
						}
						movingSet.delete(shape)
						above = shape.index
					}
					if (movingSet.size === 0) return
					const indices = getIndicesBetween(below, above, movingSet.size)
					Array.from(movingSet.values())
						.sort(sortByIndex)
						.forEach((node, i3) =>
							changes.push({ id: node.id, type: node.type, index: indices[i3] })
						)
				})
				break
			}
			case 'forward': {
				parents.forEach((movingSet, parentId) => {
					const siblings = compact(
						this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
					)
					const len = siblings.length
					if (movingSet.size === len) return
					const movingIndices = new Set(Array.from(movingSet).map((n3) => siblings.indexOf(n3)))
					let selectIndex = -1
					let isSelecting = false
					let below
					let above
					let count
					for (let i3 = 0; i3 < len; i3++) {
						const isMoving = movingIndices.has(i3)
						if (!isSelecting && isMoving) {
							isSelecting = true
							selectIndex = i3
							above = void 0
						} else if (isSelecting && !isMoving) {
							isSelecting = false
							count = i3 - selectIndex
							below = siblings[i3].index
							above = siblings[i3 + 1]?.index
							const indices = getIndicesBetween(below, above, count)
							for (let k2 = 0; k2 < count; k2++) {
								const node = siblings[selectIndex + k2]
								changes.push({ id: node.id, type: node.type, index: indices[k2] })
							}
						}
					}
				})
				break
			}
			case 'backward': {
				parents.forEach((movingSet, parentId) => {
					const siblings = compact(
						this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
					)
					const len = siblings.length
					if (movingSet.size === len) return
					const movingIndices = new Set(Array.from(movingSet).map((n3) => siblings.indexOf(n3)))
					let selectIndex = -1
					let isSelecting = false
					let count
					for (let i3 = len - 1; i3 > -1; i3--) {
						const isMoving = movingIndices.has(i3)
						if (!isSelecting && isMoving) {
							isSelecting = true
							selectIndex = i3
						} else if (isSelecting && !isMoving) {
							isSelecting = false
							count = selectIndex - i3
							const indices = getIndicesBetween(siblings[i3 - 1]?.index, siblings[i3].index, count)
							for (let k2 = 0; k2 < count; k2++) {
								const node = siblings[i3 + k2 + 1]
								changes.push({ id: node.id, type: node.type, index: indices[k2] })
							}
						}
					}
				})
				break
			}
		}
		this.updateShapes(changes)
		return this
	}
	/**
	 * Send shapes to the back of the page's object list.
	 *
	 * @example
	 *
	 * ```ts
	 * app.sendToBack()
	 * app.sendToBack(['id1', 'id2'])
	 * ```
	 *
	 * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
	 * @public
	 */
	sendToBack(ids = this.pageState.selectedIds) {
		this.reorderShapes('toBack', ids)
		return this
	}
	/**
	 * Send shapes backward in the page's object list.
	 *
	 * @example
	 *
	 * ```ts
	 * app.sendBackward()
	 * app.sendBackward(['id1', 'id2'])
	 * ```
	 *
	 * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
	 * @public
	 */
	sendBackward(ids = this.pageState.selectedIds) {
		this.reorderShapes('backward', ids)
		return this
	}
	/**
	 * Bring shapes forward in the page's object list.
	 *
	 * @example
	 *
	 * ```ts
	 * app.bringForward()
	 * app.bringForward(['id1', 'id2'])
	 * ```
	 *
	 * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
	 * @public
	 */
	bringForward(ids = this.pageState.selectedIds) {
		this.reorderShapes('forward', ids)
		return this
	}
	/**
	 * Bring shapes to the front of the page's object list.
	 *
	 * @example
	 *
	 * ```ts
	 * app.bringToFront()
	 * app.bringToFront(['id1', 'id2'])
	 * ```
	 *
	 * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
	 * @public
	 */
	bringToFront(ids = this.pageState.selectedIds) {
		this.reorderShapes('toFront', ids)
		return this
	}
	/**
	 * Flip shape positions.
	 *
	 * @example
	 *
	 * ```ts
	 * app.flipShapes('horizontal')
	 * app.flipShapes('horizontal', ['box1', 'box2'])
	 * ```
	 *
	 * @param operation - Whether to flip horizontally or vertically.
	 * @param ids - The ids of the shapes to flip. Defaults to selected shapes.
	 * @public
	 */
	flipShapes(operation, ids = this.selectedIds) {
		if (this.isReadOnly) return this
		let shapes = compact(ids.map((id) => this.getShapeById(id)))
		if (!shapes.length) return this
		shapes = compact(
			shapes
				.map((shape) => {
					if (shape.type === 'group') {
						return this.getSortedChildIds(shape.id).map((id) => this.getShapeById(id))
					}
					return shape
				})
				.flat()
		)
		const scaleOriginPage = Box2d.Common(compact(shapes.map((id) => this.getPageBounds(id)))).center
		this.batch(() => {
			for (const shape of shapes) {
				const util = this.getShapeUtil(shape)
				const bounds = util.bounds(shape)
				const initialPageTransform = this.getPageTransformById(shape.id)
				if (!initialPageTransform) continue
				this.resizeShape(
					shape.id,
					{ x: operation === 'horizontal' ? -1 : 1, y: operation === 'vertical' ? -1 : 1 },
					{
						initialBounds: bounds,
						initialPageTransform,
						initialShape: shape,
						mode: 'scale_shape',
						scaleOrigin: scaleOriginPage,
						scaleAxisRotation: 0,
					}
				)
			}
		})
		return this
	}
	/**
	 * Stack shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.stackShapes('horizontal')
	 * app.stackShapes('horizontal', ['box1', 'box2'])
	 * app.stackShapes('horizontal', ['box1', 'box2'], 20)
	 * ```
	 *
	 * @param operation - Whether to stack horizontally or vertically.
	 * @param ids - The ids of the shapes to stack. Defaults to selected shapes.
	 * @param gap - A specific gap to use when stacking.
	 * @public
	 */
	stackShapes(operation, ids = this.pageState.selectedIds, gap) {
		if (this.isReadOnly) return this
		const shapes = compact(ids.map((id) => this.getShapeById(id))).filter((shape) => {
			if (!shape) return false
			if (this.isShapeOfType(shape, TLArrowUtil)) {
				if (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {
					return false
				}
			}
			return true
		})
		const len = shapes.length
		if ((gap === void 0 && len < 3) || len < 2) return this
		const pageBounds = Object.fromEntries(
			shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
		)
		let val
		let min2
		let max
		let dim
		if (operation === 'horizontal') {
			val = 'x'
			min2 = 'minX'
			max = 'maxX'
			dim = 'width'
		} else {
			val = 'y'
			min2 = 'minY'
			max = 'maxY'
			dim = 'height'
		}
		let shapeGap
		if (gap === void 0) {
			const gaps = []
			shapes.sort((a3, b3) => pageBounds[a3.id][min2] - pageBounds[b3.id][min2])
			for (let i3 = 0; i3 < len - 1; i3++) {
				const shape = shapes[i3]
				const nextShape = shapes[i3 + 1]
				const bounds = pageBounds[shape.id]
				const nextBounds = pageBounds[nextShape.id]
				const gap2 = nextBounds[min2] - bounds[max]
				const current = gaps.find((g3) => g3.gap === gap2)
				if (current) {
					current.count++
				} else {
					gaps.push({ gap: gap2, count: 1 })
				}
			}
			let maxCount = 0
			gaps.forEach((g3) => {
				if (g3.count > maxCount) {
					maxCount = g3.count
					shapeGap = g3.gap
				}
			})
			if (maxCount === 1) {
				shapeGap = Math.max(0, gaps.reduce((a3, c3) => a3 + c3.gap * c3.count, 0) / (len - 1))
			}
		} else {
			shapeGap = gap
		}
		const changes = []
		let v3 = pageBounds[shapes[0].id][max]
		shapes.forEach((shape, i3) => {
			if (i3 === 0) return
			const delta = { x: 0, y: 0 }
			delta[val] = v3 + shapeGap - pageBounds[shape.id][val]
			const parent = this.getParentShape(shape)
			const localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta
			const translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)
			changes.push(
				translateStartChanges
					? {
							...translateStartChanges,
							[val]: shape[val] + localDelta[val],
					  }
					: {
							id: shape.id,
							type: shape.type,
							[val]: shape[val] + localDelta[val],
					  }
			)
			v3 += pageBounds[shape.id][dim] + shapeGap
		})
		this.updateShapes(changes)
		return this
	}
	/**
	 * Pack shapes into a grid centered on their current position. Based on potpack
	 * (https://github.com/mapbox/potpack)
	 *
	 * @param ids - The ids of the shapes to pack. Defaults to selected shapes.
	 * @param padding - The padding to apply to the packed shapes.
	 */
	packShapes(ids = this.pageState.selectedIds, padding = 16) {
		if (this.isReadOnly) return this
		if (ids.length < 2) return this
		const shapes = compact(
			ids
				.map((id) => this.getShapeById(id))
				.filter((shape2) => {
					if (!shape2) return false
					if (this.isShapeOfType(shape2, TLArrowUtil)) {
						if (shape2.props.start.type === 'binding' || shape2.props.end.type === 'binding') {
							return false
						}
					}
					return true
				})
		)
		const shapePageBounds = {}
		const nextShapePageBounds = {}
		let shape,
			bounds,
			area = 0
		for (let i3 = 0; i3 < shapes.length; i3++) {
			shape = shapes[i3]
			bounds = this.getPageBounds(shape)
			shapePageBounds[shape.id] = bounds
			nextShapePageBounds[shape.id] = bounds.clone()
			area += bounds.width * bounds.height
		}
		const commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))
		const maxWidth = commonBounds.width
		shapes.sort((a3, b3) => shapePageBounds[b3.id].height - shapePageBounds[a3.id].height)
		const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth)
		const spaces = [new Box2d(commonBounds.x, commonBounds.y, startWidth, Infinity)]
		let width = 0
		let height = 0
		let space
		let last2
		for (let i3 = 0; i3 < shapes.length; i3++) {
			shape = shapes[i3]
			bounds = nextShapePageBounds[shape.id]
			for (let i4 = spaces.length - 1; i4 >= 0; i4--) {
				space = spaces[i4]
				if (bounds.width > space.width || bounds.height > space.height) continue
				bounds.x = space.x
				bounds.y = space.y
				height = Math.max(height, bounds.maxY)
				width = Math.max(width, bounds.maxX)
				if (bounds.width === space.width && bounds.height === space.height) {
					last2 = spaces.pop()
					if (i4 < spaces.length) spaces[i4] = last2
				} else if (bounds.height === space.height) {
					space.x += bounds.width + padding
					space.width -= bounds.width + padding
				} else if (bounds.width === space.width) {
					space.y += bounds.height + padding
					space.height -= bounds.height + padding
				} else {
					spaces.push(
						new Box2d(
							space.x + (bounds.width + padding),
							space.y,
							space.width - (bounds.width + padding),
							bounds.height
						)
					)
					space.y += bounds.height + padding
					space.height -= bounds.height + padding
				}
				break
			}
		}
		const commonAfter = Box2d.Common(Object.values(nextShapePageBounds))
		const centerDelta = Vec2d.Sub(commonBounds.center, commonAfter.center)
		let nextBounds
		const changes = []
		for (let i3 = 0; i3 < shapes.length; i3++) {
			shape = shapes[i3]
			bounds = shapePageBounds[shape.id]
			nextBounds = nextShapePageBounds[shape.id]
			const delta = this.getDeltaInParentSpace(
				shape,
				Vec2d.Sub(nextBounds.point, bounds.point).add(centerDelta)
			)
			const change = {
				id: shape.id,
				type: shape.type,
				x: shape.x + delta.x,
				y: shape.y + delta.y,
			}
			const translateStartChange = this.getShapeUtil(shape).onTranslateStart?.({
				...shape,
				...change,
			})
			if (translateStartChange) {
				changes.push({ ...change, ...translateStartChange })
			} else {
				changes.push(change)
			}
		}
		if (changes.length) {
			this.updateShapes(changes)
		}
		return this
	}
	/**
	 * Align shape positions.
	 *
	 * @example
	 *
	 * ```ts
	 * app.alignShapes('left')
	 * app.alignShapes('left', ['box1', 'box2'])
	 * ```
	 *
	 * @param operation - The align operation to apply.
	 * @param ids - The ids of the shapes to align. Defaults to selected shapes.
	 * @public
	 */
	alignShapes(operation, ids = this.pageState.selectedIds) {
		if (this.isReadOnly) return this
		if (ids.length < 2) return this
		const shapes = compact(ids.map((id) => this.getShapeById(id)))
		const shapePageBounds = Object.fromEntries(
			shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
		)
		const commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))
		const changes = []
		shapes.forEach((shape) => {
			const pageBounds = shapePageBounds[shape.id]
			if (!pageBounds) return
			const delta = { x: 0, y: 0 }
			switch (operation) {
				case 'top': {
					delta.y = commonBounds.minY - pageBounds.minY
					break
				}
				case 'center-vertical': {
					delta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2
					break
				}
				case 'bottom': {
					delta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height
					break
				}
				case 'left': {
					delta.x = commonBounds.minX - pageBounds.minX
					break
				}
				case 'center-horizontal': {
					delta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2
					break
				}
				case 'right': {
					delta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width
					break
				}
			}
			const parent = this.getParentShape(shape)
			const localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta
			const translateChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)
			changes.push(
				translateChanges
					? {
							...translateChanges,
							x: shape.x + localDelta.x,
							y: shape.y + localDelta.y,
					  }
					: {
							id: shape.id,
							type: shape.type,
							x: shape.x + localDelta.x,
							y: shape.y + localDelta.y,
					  }
			)
		})
		this.updateShapes(changes)
		return this
	}
	/**
	 * Distribute shape positions.
	 *
	 * @example
	 *
	 * ```ts
	 * app.distributeShapes('left')
	 * app.distributeShapes('left', ['box1', 'box2'])
	 * ```
	 *
	 * @param operation - Whether to distribute shapes horizontally or vertically.
	 * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.
	 * @public
	 */
	distributeShapes(operation, ids = this.pageState.selectedIds) {
		if (this.isReadOnly) return this
		if (ids.length < 3) return this
		const len = ids.length
		const shapes = compact(ids.map((id) => this.getShapeById(id)))
		const pageBounds = Object.fromEntries(
			shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
		)
		let val
		let min2
		let max
		let mid
		let dim
		if (operation === 'horizontal') {
			val = 'x'
			min2 = 'minX'
			max = 'maxX'
			mid = 'midX'
			dim = 'width'
		} else {
			val = 'y'
			min2 = 'minY'
			max = 'maxY'
			mid = 'midY'
			dim = 'height'
		}
		const changes = []
		const first = shapes.sort((a3, b3) => pageBounds[a3.id][min2] - pageBounds[b3.id][min2])[0]
		const last2 = shapes.sort((a3, b3) => pageBounds[b3.id][max] - pageBounds[a3.id][max])[0]
		const midFirst = pageBounds[first.id][mid]
		const step = (pageBounds[last2.id][mid] - midFirst) / (len - 1)
		const v3 = midFirst + step
		shapes
			.filter((shape) => shape !== first && shape !== last2)
			.sort((a3, b3) => pageBounds[a3.id][mid] - pageBounds[b3.id][mid])
			.forEach((shape, i3) => {
				const delta = { x: 0, y: 0 }
				delta[val] = v3 + step * i3 - pageBounds[shape.id][dim] / 2 - pageBounds[shape.id][val]
				const parent = this.getParentShape(shape)
				const localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta
				const translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)
				changes.push(
					translateStartChanges
						? {
								...translateStartChanges,
								[val]: shape[val] + localDelta[val],
						  }
						: {
								id: shape.id,
								type: shape.type,
								[val]: shape[val] + localDelta[val],
						  }
				)
			})
		this.updateShapes(changes)
		return this
	}
	/** @internal */
	_resizeUnalignedShape(id, scale, options) {
		const { type } = options.initialShape
		const shapeScale = new Vec2d(scale.x, scale.y)
		if (Math.abs(scale.x) > Math.abs(scale.y)) {
			shapeScale.x = Math.sign(scale.x) * Math.abs(scale.y)
		} else {
			shapeScale.y = Math.sign(scale.y) * Math.abs(scale.x)
		}
		this.resizeShape(id, shapeScale, {
			initialShape: options.initialShape,
			initialBounds: options.initialBounds,
		})
		if (Math.sign(scale.x) * Math.sign(scale.y) < 0) {
			let { rotation } = Matrix2d.Decompose(options.initialPageTransform)
			rotation -= 2 * rotation
			this.updateShapes([{ id, type, rotation }], true)
		}
		const preScaleShapePageCenter = Matrix2d.applyToPoint(
			options.initialPageTransform,
			options.initialBounds.center
		)
		const postScaleShapePageCenter = this._scalePagePoint(
			preScaleShapePageCenter,
			options.scaleOrigin,
			scale,
			options.scaleAxisRotation
		)
		const currentPageCenter = this.getPageCenterById(id)
		const currentPagePoint = this.getPagePointById(id)
		if (!currentPageCenter || !currentPagePoint) return this
		const pageDelta = Vec2d.Sub(postScaleShapePageCenter, currentPageCenter)
		const postScaleShapePagePoint = Vec2d.Add(currentPagePoint, pageDelta)
		const { x: x3, y: y3 } = this.getPointInParentSpace(id, postScaleShapePagePoint)
		this.updateShapes([{ id, type, x: x3, y: y3 }], true)
		return this
	}
	/** @internal */
	_scalePagePoint(point2, scaleOrigin, scale, scaleAxisRotation) {
		const relativePoint = Vec2d.RotWith(point2, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin)
		const newRelativePagePoint = Vec2d.MulV(relativePoint, scale)
		const destination = Vec2d.Add(newRelativePagePoint, scaleOrigin).rotWith(
			scaleOrigin,
			scaleAxisRotation
		)
		return destination
	}
	resizeShape(id, scale, options) {
		if (this.isReadOnly) return this
		if (!Number.isFinite(scale.x)) scale = new Vec2d(1, scale.y)
		if (!Number.isFinite(scale.y)) scale = new Vec2d(scale.x, 1)
		const initialShape = options?.initialShape ?? this.getShapeById(id)
		if (!initialShape) return this
		const scaleOrigin = options?.scaleOrigin ?? this.getPageBoundsById(id)?.center
		if (!scaleOrigin) return this
		const pageRotation = this.getPageRotationById(id)
		if (pageRotation == null) return this
		const scaleAxisRotation = options?.scaleAxisRotation ?? pageRotation
		const pageTransform = options?.initialPageTransform ?? this.getPageTransformById(id)
		if (!pageTransform) return this
		const initialBounds = options?.initialBounds ?? this.getBoundsById(id)
		if (!initialBounds) return this
		if (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {
			return this._resizeUnalignedShape(id, scale, {
				...options,
				initialBounds,
				scaleOrigin,
				scaleAxisRotation,
				initialPageTransform: pageTransform,
				initialShape,
			})
		}
		const util = this.getShapeUtil(initialShape)
		if (util.isAspectRatioLocked(initialShape)) {
			if (Math.abs(scale.x) > Math.abs(scale.y)) {
				scale = new Vec2d(scale.x, Math.sign(scale.y) * Math.abs(scale.x))
			} else {
				scale = new Vec2d(Math.sign(scale.x) * Math.abs(scale.y), scale.y)
			}
		}
		if (util.onResize && util.canResize(initialShape)) {
			const newPagePoint = this._scalePagePoint(
				Matrix2d.applyToPoint(pageTransform, new Vec2d(0, 0)),
				scaleOrigin,
				scale,
				scaleAxisRotation
			)
			const newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint)
			const myScale = new Vec2d(scale.x, scale.y)
			const areWidthAndHeightAlignedWithCorrectAxis = approximately(
				(pageRotation - scaleAxisRotation) % Math.PI,
				0
			)
			myScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y
			myScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x
			const initialPagePoint = Matrix2d.applyToPoint(pageTransform, new Vec2d())
			const { x: x3, y: y3 } = this.getPointInParentSpace(initialShape.id, initialPagePoint)
			this.updateShapes(
				[
					{
						id,
						type: initialShape.type,
						x: newLocalPoint.x,
						y: newLocalPoint.y,
						...util.onResize(
							{ ...initialShape, x: x3, y: y3 },
							{
								newPoint: newLocalPoint,
								handle: options?.dragHandle ?? 'bottom_right',
								// don't set isSingle to true for children
								mode: options?.mode ?? 'scale_shape',
								scaleX: myScale.x,
								scaleY: myScale.y,
								initialBounds,
								initialShape,
							}
						),
					},
				],
				true
			)
		} else {
			const initialPageCenter = Matrix2d.applyToPoint(pageTransform, initialBounds.center)
			const newPageCenter = this._scalePagePoint(
				initialPageCenter,
				scaleOrigin,
				scale,
				scaleAxisRotation
			)
			const initialPageCenterInParentSpace = this.getPointInParentSpace(
				initialShape.id,
				initialPageCenter
			)
			const newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter)
			const delta = Vec2d.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace)
			this.updateShapes(
				[
					{
						id,
						type: initialShape.type,
						x: initialShape.x + delta.x,
						y: initialShape.y + delta.y,
					},
				],
				true
			)
		}
		return this
	}
	/**
	 * Stretch shape sizes and positions to fill their common bounding box.
	 *
	 * @example
	 *
	 * ```ts
	 * app.stretchShapes('horizontal')
	 * app.stretchShapes('horizontal', ['box1', 'box2'])
	 * ```
	 *
	 * @param operation - Whether to stretch shapes horizontally or vertically.
	 * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.
	 * @public
	 */
	stretchShapes(operation, ids = this.pageState.selectedIds) {
		if (this.isReadOnly) return this
		if (ids.length < 2) return this
		const shapes = compact(ids.map((id) => this.getShapeById(id)))
		const shapeBounds = Object.fromEntries(shapes.map((shape) => [shape.id, this.getBounds(shape)]))
		const shapePageBounds = Object.fromEntries(
			shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
		)
		const commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))
		const changes = []
		switch (operation) {
			case 'vertical': {
				this.batch(() => {
					for (const shape of shapes) {
						const pageRotation = this.getPageRotation(shape)
						if (pageRotation % PI2) continue
						const bounds = shapeBounds[shape.id]
						const pageBounds = shapePageBounds[shape.id]
						const localOffset = this.getDeltaInParentSpace(
							shape,
							new Vec2d(0, commonBounds.minY - pageBounds.minY)
						)
						const { x: x3, y: y3 } = Vec2d.Add(localOffset, shape)
						this.updateShapes([{ id: shape.id, type: shape.type, x: x3, y: y3 }], true)
						const scale = new Vec2d(1, commonBounds.height / pageBounds.height)
						this.resizeShape(shape.id, scale, {
							initialBounds: bounds,
							scaleOrigin: new Vec2d(pageBounds.center.x, commonBounds.minY),
							scaleAxisRotation: 0,
						})
					}
				})
				break
			}
			case 'horizontal': {
				this.batch(() => {
					for (const shape of shapes) {
						const bounds = shapeBounds[shape.id]
						const pageBounds = shapePageBounds[shape.id]
						const pageRotation = this.getPageRotation(shape)
						if (pageRotation % PI2) continue
						const localOffset = this.getDeltaInParentSpace(
							shape,
							new Vec2d(commonBounds.minX - pageBounds.minX, 0)
						)
						const { x: x3, y: y3 } = Vec2d.Add(localOffset, shape)
						this.updateShapes([{ id: shape.id, type: shape.type, x: x3, y: y3 }], true)
						const scale = new Vec2d(commonBounds.width / pageBounds.width, 1)
						this.resizeShape(shape.id, scale, {
							initialBounds: bounds,
							scaleOrigin: new Vec2d(commonBounds.minX, pageBounds.center.y),
							scaleAxisRotation: 0,
						})
					}
				})
				break
			}
		}
		this.updateShapes(changes)
		return this
	}
	/**
	 * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
	 * rotations.
	 *
	 * @example
	 *
	 * ```ts
	 * app.reparentShapesById(['box1', 'box2'], 'frame1')
	 * ```
	 *
	 * @param ids - The ids of the shapes to reparent.
	 * @param parentId - The id of the new parent shape.
	 * @param insertIndex - The index to insert the children.
	 * @public
	 */
	reparentShapesById(ids, parentId, insertIndex) {
		const changes = []
		const parentTransform = PageRecordType.isId(parentId)
			? Matrix2d.Identity()
			: this.getPageTransformById(parentId)
		const parentPageRotation = parentTransform.decompose().rotation
		let indices = []
		const sibs = compact(this.getSortedChildIds(parentId).map((id2) => this.getShapeById(id2)))
		if (insertIndex) {
			const sibWithInsertIndex = sibs.find((s3) => s3.index === insertIndex)
			if (sibWithInsertIndex) {
				const sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1]
				if (sibAbove) {
					indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)
				} else {
					indices = getIndicesAbove(insertIndex, ids.length)
				}
			} else {
				const sibAbove = sibs.sort(sortByIndex).find((s3) => s3.index > insertIndex)
				if (sibAbove) {
					indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)
				} else {
					indices = getIndicesAbove(insertIndex, ids.length)
				}
			}
		} else {
			const sib = sibs.length && sibs[sibs.length - 1]
			indices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length)
		}
		let id
		for (let i3 = 0; i3 < ids.length; i3++) {
			id = ids[i3]
			const shape = this.getShapeById(id)
			const pagePoint = this.getPagePointById(id)
			if (!shape || !pagePoint) continue
			const newPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), pagePoint)
			const newRotation = this.getPageRotation(shape) - parentPageRotation
			changes.push({
				id: shape.id,
				type: shape.type,
				parentId,
				x: newPoint.x,
				y: newPoint.y,
				rotation: newRotation,
				index: indices[i3],
			})
		}
		this.updateShapes(changes)
		return this
	}
	/**
	 * Select one or more shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.select('id1')
	 * app.select('id1', 'id2')
	 * ```
	 *
	 * @param ids - The ids to select.
	 * @public
	 */
	select(...ids) {
		this.setSelectedIds(ids)
		return this
	}
	/**
	 * Remove a shpae from the existing set of selected shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.deselect(shape.id)
	 * ```
	 *
	 * @public
	 */
	deselect(...ids) {
		const { selectedIds } = this
		if (selectedIds.length > 0 && ids.length > 0) {
			this.setSelectedIds(selectedIds.filter((id) => !ids.includes(id)))
		}
		return this
	}
	/**
	 * Select all direct children of the current page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.selectAll()
	 * ```
	 *
	 * @public
	 */
	selectAll() {
		const ids = this.getSortedChildIds(this.currentPageId)
		if (ids.length <= 0) return this
		this.setSelectedIds(ids)
		return this
	}
	getShapesAndDescendantsInOrder(ids) {
		const idsToInclude = []
		const visitedIds = /* @__PURE__ */ new Set()
		const idsToCheck = [...ids]
		while (idsToCheck.length > 0) {
			const id = idsToCheck.pop()
			if (!id) break
			if (visitedIds.has(id)) continue
			idsToInclude.push(id)
			this.getSortedChildIds(id).forEach((id2) => {
				idsToCheck.push(id2)
			})
		}
		const shapes = idsToInclude
			.map((s3) => this.getShapeById(s3))
			.filter((s3) => s3.type !== 'group')
		const { sortedShapesArray } = this
		shapes.sort((a3, b3) => sortedShapesArray.indexOf(a3) - sortedShapesArray.indexOf(b3))
		return shapes
	}
	/**
	 * Clear the selection.
	 *
	 * @example
	 *
	 * ```ts
	 * app.selectNone()
	 * ```
	 *
	 * @public
	 */
	selectNone() {
		if (this.selectedIds.length > 0) {
			this.setSelectedIds([])
		}
		return this
	}
	/**
	 * Set the current page.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setCurrentPageId('page1')
	 * ```
	 *
	 * @param pageId - The id of the page to set as the current page.
	 * @param options - Options for setting the current page.
	 * @public
	 */
	setCurrentPageId(pageId, { stopFollowing = true } = {}) {
		this._setCurrentPageId(pageId, { stopFollowing })
		return this
	}
	/** @internal */
	_setCurrentPageId = this.history.createCommand(
		'setCurrentPage',
		(pageId, { stopFollowing = true } = {}) => {
			if (!this.store.has(pageId)) {
				console.error("Tried to set the current page id to a page that doesn't exist.")
				return
			}
			if (stopFollowing && this.instanceState.followingUserId) {
				this.stopFollowingUser()
			}
			return {
				data: { toId: pageId, fromId: this.currentPageId },
				squashing: true,
				preservesRedoStack: true,
			}
		},
		{
			do: ({ toId }) => {
				if (!this.getPageStateByPageId(toId)) {
					const camera = CameraRecordType.create({})
					this.store.put([
						camera,
						InstancePageStateRecordType.create({
							pageId: toId,
							instanceId: this.instanceId,
							cameraId: camera.id,
						}),
					])
				}
				this.store.put([{ ...this.instanceState, currentPageId: toId }])
				this.updateCullingBounds()
			},
			undo: ({ fromId }) => {
				this.store.put([{ ...this.instanceState, currentPageId: fromId }])
				this.updateCullingBounds()
			},
			squash: ({ fromId }, { toId }) => {
				return { toId, fromId }
			},
		}
	)
	/** Set the current user tab state */
	updateInstanceState(partial, ephemeral = false, squashing = false) {
		this._updateInstanceState(partial, ephemeral, squashing)
		return this
	}
	/** @internal */
	_updateInstanceState = this.history.createCommand(
		'updateTabState',
		(partial, ephemeral = false, squashing = false) => {
			const prev = this.instanceState
			const next = { ...prev, ...partial }
			return {
				data: { prev, next },
				squashing,
				ephemeral,
			}
		},
		{
			do: ({ next }) => {
				this.store.put([next])
			},
			undo: ({ prev }) => {
				this.store.put([prev])
			},
			squash({ prev }, { next }) {
				return { prev, next }
			},
		}
	)
	get hoveredId() {
		return this.pageState.hoveredId
	}
	get hoveredShape() {
		if (!this.hoveredId) return null
		return this.getShapeById(this.hoveredId) ?? null
	}
	/**
	 * Set the current hovered shape.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setHoveredId('box1')
	 * app.setHoveredId() // Clears the hovered shape.
	 * ```
	 *
	 * @param id - The id of the page to set as the current page
	 * @public
	 */
	setHoveredId(id = null) {
		if (id === this.pageState.hoveredId) return this
		this.setInstancePageState({ hoveredId: id }, true)
		return this
	}
	/**
	 * Set the current erasing shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setErasingIds(['box1', 'box2'])
	 * app.setErasingIds() // Clears the erasing set
	 * ```
	 *
	 * @param ids - The ids of shapes to set as erasing.
	 * @public
	 */
	setErasingIds(ids = []) {
		const erasingIds = this.erasingIdsSet
		if (ids.length === erasingIds.size && ids.every((id) => erasingIds.has(id))) return this
		this.setInstancePageState({ erasingIds: ids }, true)
		return this
	}
	/**
	 * Set the current cursor.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setCursor({ type: 'default' })
	 * app.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })
	 * ```
	 *
	 * @param cursor - A partial of the cursor object.
	 * @public
	 */
	setCursor(cursor) {
		const current = this.cursor
		const next = {
			...current,
			rotation: 0,
			...cursor,
		}
		if (
			!(
				current.type === next.type &&
				current.rotation === next.rotation &&
				current.color === next.color
			)
		) {
			this.updateInstanceState({ cursor: next }, true)
		}
		return this
	}
	/**
	 * Set the current scribble.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setScribble(nextScribble)
	 * app.setScribble() // clears the scribble
	 * ```
	 *
	 * @param scribble - The new scribble object.
	 * @public
	 */
	setScribble(scribble = null) {
		this.updateInstanceState({ scribble }, true)
		return this
	}
	/**
	 * Set the current brush.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setBrush({ x: 0, y: 0, w: 100, h: 100 })
	 * app.setBrush() // Clears the brush
	 * ```
	 *
	 * @param brush - The brush box model to set, or null for no brush model.
	 * @public
	 */
	setBrush(brush = null) {
		if (!brush && !this.brush) return this
		this.updateInstanceState({ brush }, true)
		return this
	}
	/**
	 * Set the current zoom brush.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setZoomBrush({ x: 0, y: 0, w: 100, h: 100 })
	 * app.setZoomBrush() // Clears the zoom
	 * ```
	 *
	 * @param zoomBrush - The zoom box model to set, or null for no zoom model.
	 * @public
	 */
	setZoomBrush(zoomBrush = null) {
		if (!zoomBrush && !this.zoomBrush) return this
		this.updateInstanceState({ zoomBrush }, true)
		return this
	}
	/**
	 * Rotate shapes by a delta in radians.
	 *
	 * @example
	 *
	 * ```ts
	 * app.rotateShapesBy(['box1', 'box2'], Math.PI)
	 * app.rotateShapesBy(['box1', 'box2'], Math.PI / 2)
	 * ```
	 *
	 * @param ids - The ids of the shapes to move.
	 * @param delta - The delta in radians to apply to the selection rotation.
	 */
	rotateShapesBy(ids, delta) {
		if (ids.length <= 0) return this
		const snapshot = getRotationSnapshot({ app: this })
		applyRotationToSnapshotShapes({ delta, snapshot, app: this, stage: 'one-off' })
		return this
	}
	/**
	 * Move shapes by a delta.
	 *
	 * @example
	 *
	 * ```ts
	 * app.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 })
	 * app.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 }, true)
	 * ```
	 *
	 * @param ids - The ids of the shapes to move.
	 * @param direction - The direction in which to move the shapes.
	 * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.
	 */
	nudgeShapes(ids, direction, major = false, ephemeral = false) {
		if (ids.length <= 0) return this
		const step = this.isGridMode
			? major
				? this.gridSize * GRID_INCREMENT
				: this.gridSize
			: major
			? MAJOR_NUDGE_FACTOR
			: MINOR_NUDGE_FACTOR
		const steppedDelta = Vec2d.Mul(direction, step)
		const changes = []
		for (const id of ids) {
			const shape = this.getShapeById(id)
			if (!shape) {
				throw Error(`Could not find a shape with the id ${id}.`)
			}
			const localDelta = this.getDeltaInParentSpace(shape, steppedDelta)
			const translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)
			changes.push(
				translateStartChanges
					? {
							...translateStartChanges,
							x: shape.x + localDelta.x,
							y: shape.y + localDelta.y,
					  }
					: {
							id,
							x: shape.x + localDelta.x,
							y: shape.y + localDelta.y,
							type: shape.type,
					  }
			)
		}
		this.updateShapes(changes, ephemeral)
		return this
	}
	/**
	 * Duplicate shapes.
	 *
	 * @example
	 *
	 * ```ts
	 * app.duplicateShapes()
	 * app.duplicateShapes(['id1', 'id2'])
	 * app.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })
	 * ```
	 *
	 * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected shapes.
	 * @param offset - The offset (in pixels) to apply to the duplicated shapes.
	 * @public
	 */
	duplicateShapes(ids = this.selectedIds, offset) {
		if (ids.length <= 0) return this
		const initialIds = new Set(ids)
		const idsToCreate = []
		const idsToCheck = [...ids]
		while (idsToCheck.length > 0) {
			const id = idsToCheck.pop()
			if (!id) break
			idsToCreate.push(id)
			this.getSortedChildIds(id).forEach((childId) => idsToCheck.push(childId))
		}
		idsToCreate.reverse()
		const idsMap = new Map(idsToCreate.map((id) => [id, this.createShapeId()]))
		const shapesToCreate = compact(
			idsToCreate.map((id) => {
				const shape = this.getShapeById(id)
				if (!shape) {
					return null
				}
				const createId = idsMap.get(id)
				let ox = 0
				let oy = 0
				if (offset && initialIds.has(id)) {
					const parentTransform = this.getParentTransform(shape)
					const vec = new Vec2d(offset.x, offset.y).rot(
						-Matrix2d.Decompose(parentTransform).rotation
					)
					ox = vec.x
					oy = vec.y
				}
				const parentId = shape.parentId ?? this.currentPageId
				const siblings = this.getSortedChildIds(parentId)
				const currentIndex = siblings.indexOf(shape.id)
				const siblingAboveId = siblings[currentIndex + 1]
				const siblingAbove = siblingAboveId ? this.getShapeById(siblingAboveId) : null
				const index2 = siblingAbove
					? getIndexBetween(shape.index, siblingAbove.index)
					: getIndexAbove(shape.index)
				let newShape = deepCopy(shape)
				if (this.isShapeOfType(shape, TLArrowUtil) && this.isShapeOfType(newShape, TLArrowUtil)) {
					const info = this.getShapeUtil(TLArrowUtil).getArrowInfo(shape)
					let newStartShapeId = void 0
					let newEndShapeId = void 0
					if (shape.props.start.type === 'binding') {
						newStartShapeId = idsMap.get(shape.props.start.boundShapeId)
						if (!newStartShapeId) {
							if (info?.isValid) {
								const { x: x3, y: y3 } = info.start.point
								newShape.props.start = {
									type: 'point',
									x: x3,
									y: y3,
								}
							} else {
								const { start } = getArrowTerminalsInArrowSpace(this, shape)
								newShape.props.start = {
									type: 'point',
									x: start.x,
									y: start.y,
								}
							}
						}
					}
					if (shape.props.end.type === 'binding') {
						newEndShapeId = idsMap.get(shape.props.end.boundShapeId)
						if (!newEndShapeId) {
							if (info?.isValid) {
								const { x: x3, y: y3 } = info.end.point
								newShape.props.end = {
									type: 'point',
									x: x3,
									y: y3,
								}
							} else {
								const { end } = getArrowTerminalsInArrowSpace(this, shape)
								newShape.props.start = {
									type: 'point',
									x: end.x,
									y: end.y,
								}
							}
						}
					}
					const infoAfter = getIsArrowStraight(newShape)
						? getStraightArrowInfo(this, newShape)
						: getCurvedArrowInfo(this, newShape)
					if (info?.isValid && infoAfter?.isValid && !getIsArrowStraight(shape)) {
						const mpA = Vec2d.Med(info.start.handle, info.end.handle)
						const distA = Vec2d.Dist(info.middle, mpA)
						const distB = Vec2d.Dist(infoAfter.middle, mpA)
						if (newShape.props.bend < 0) {
							newShape.props.bend += distB - distA
						} else {
							newShape.props.bend -= distB - distA
						}
					}
					if (newShape.props.start.type === 'binding' && newStartShapeId) {
						newShape.props.start.boundShapeId = newStartShapeId
					}
					if (newShape.props.end.type === 'binding' && newEndShapeId) {
						newShape.props.end.boundShapeId = newEndShapeId
					}
				}
				newShape = { ...newShape, id: createId, x: shape.x + ox, y: shape.y + oy, index: index2 }
				return newShape
			})
		)
		shapesToCreate.forEach((shape) => {
			if (isShapeId(shape.parentId)) {
				if (idsMap.has(shape.parentId)) {
					shape.parentId = idsMap.get(shape.parentId)
				}
			}
		})
		this.history.batch(() => {
			const maxShapesReached = shapesToCreate.length + this.shapeIds.size > MAX_SHAPES_PER_PAGE
			if (maxShapesReached) {
				alertMaxShapes(this)
			}
			const newShapes = maxShapesReached
				? shapesToCreate.slice(0, MAX_SHAPES_PER_PAGE - this.shapeIds.size)
				: shapesToCreate
			const ids2 = newShapes.map((s3) => s3.id)
			this.createShapes(newShapes)
			this.setSelectedIds(ids2)
			if (offset !== void 0) {
				const { viewportPageBounds, selectedPageBounds } = this
				if (selectedPageBounds && !viewportPageBounds.contains(selectedPageBounds)) {
					this.centerOnPoint(selectedPageBounds.center.x, selectedPageBounds.center.y, {
						duration: ANIMATION_MEDIUM_MS,
					})
				}
			}
		})
		return this
	}
	/**
	 * Set the current props (generally styles).
	 *
	 * @example
	 *
	 * ```ts
	 * app.setProp('color', 'red')
	 * app.setProp('color', 'red', true)
	 * ```
	 *
	 * @param key - The key to set.
	 * @param value - The value to set.
	 * @param ephemeral - Whether the style is ephemeral. Defaults to false.
	 * @public
	 */
	setProp(key, value, ephemeral = false, squashing = false) {
		const children = []
		const getChildProp = (id) => {
			const childIds = this.getSortedChildIds(id)
			for (const childId of childIds) {
				const childShape = this.getShapeById(childId)
				if (childShape?.type === 'group') {
					getChildProp(childShape.id)
				}
				children.push(childShape)
			}
		}
		this.history.batch(() => {
			this.updateInstanceState(
				{
					propsForNextShape: setPropsForNextShape(this.instanceState.propsForNextShape, {
						[key]: value,
					}),
				},
				ephemeral,
				squashing
			)
			if (this.isIn('select')) {
				const {
					pageState: { selectedIds },
				} = this
				if (selectedIds.length > 0) {
					const shapes = compact(
						selectedIds.map((id) => {
							const shape = this.getShapeById(id)
							if (shape?.type === 'group') {
								const childIds = this.getSortedChildIds(shape.id)
								for (const childId of childIds) {
									const childShape = this.getShapeById(childId)
									if (childShape?.type === 'group') {
										getChildProp(childShape.id)
									}
									children.push(childShape)
								}
								return children
							} else {
								return shape
							}
						})
					)
						.flat()
						.filter((shape) => shape.props[key] !== void 0 && shape?.type !== 'group')
					this.updateShapes(
						shapes.map((shape) => {
							const props = { ...shape.props, [key]: value }
							if (key === 'color' && 'labelColor' in props) {
								props.labelColor = 'black'
							}
							return {
								id: shape.id,
								type: shape.type,
								props,
							}
						}),
						ephemeral
					)
					if (key !== 'color' && key !== 'opacity') {
						const changes = []
						for (const shape of shapes) {
							const currentShape = this.getShapeById(shape.id)
							if (!currentShape) continue
							const util = this.getShapeUtil(currentShape)
							const boundsA = util.bounds(shape)
							const boundsB = util.bounds(currentShape)
							const change = { id: shape.id, type: shape.type }
							let didChange = false
							if (boundsA.width !== boundsB.width) {
								didChange = true
								if (this.isShapeOfType(shape, TLTextUtil)) {
									switch (shape.props.align) {
										case 'middle': {
											change.x = currentShape.x + (boundsA.width - boundsB.width) / 2
											break
										}
										case 'end': {
											change.x = currentShape.x + boundsA.width - boundsB.width
											break
										}
									}
								} else {
									change.x = currentShape.x + (boundsA.width - boundsB.width) / 2
								}
							}
							if (boundsA.height !== boundsB.height) {
								didChange = true
								change.y = currentShape.y + (boundsA.height - boundsB.height) / 2
							}
							if (didChange) {
								changes.push(change)
							}
						}
						if (changes.length) {
							this.updateShapes(changes, ephemeral)
						}
					}
				}
			}
			this.updateInstanceState(
				{
					propsForNextShape: setPropsForNextShape(this.instanceState.propsForNextShape, {
						[key]: value,
					}),
				},
				ephemeral,
				squashing
			)
		})
		return this
	}
	/** @internal */
	_willSetInitialBounds = true
	/** @internal */
	_setCamera(x3, y3, z2 = this.camera.z) {
		const currentCamera = this.camera
		if (currentCamera.x === x3 && currentCamera.y === y3 && currentCamera.z === z2) return this
		const nextCamera = { ...currentCamera, x: x3, y: y3, z: z2 }
		this.batch(() => {
			this.store.put([nextCamera])
			const { currentScreenPoint } = this.inputs
			this.dispatch({
				type: 'pointer',
				target: 'canvas',
				name: 'pointer_move',
				point: currentScreenPoint,
				pointerId: 0,
				ctrlKey: this.inputs.ctrlKey,
				altKey: this.inputs.altKey,
				shiftKey: this.inputs.shiftKey,
				button: 0,
				isPen: this.isPenMode ?? false,
			})
			this._cameraManager.tick()
		})
		return this
	}
	/**
	 * Set the current camera.
	 *
	 * @example
	 *
	 * ```ts
	 * app.setCamera(0, 0)
	 * app.setCamera(0, 0, 1)
	 * ```
	 *
	 * @param x - The camera's x position.
	 * @param y - The camera's y position.
	 * @param z - The camera's z position. Defaults to the current zoom.
	 * @param options - Options for the camera change.
	 * @public
	 */
	setCamera(x3, y3, z2 = this.camera.z, { stopFollowing = true } = {}) {
		this.stopCameraAnimation()
		if (stopFollowing && this.instanceState.followingUserId) {
			this.stopFollowingUser()
		}
		x3 = Number.isNaN(x3) ? 0 : x3
		y3 = Number.isNaN(y3) ? 0 : y3
		z2 = Number.isNaN(z2) ? 1 : z2
		this._setCamera(x3, y3, z2)
		return this
	}
	/**
	 * Animate the camera.
	 *
	 * @example
	 *
	 * ```ts
	 * app.animateCamera(0, 0)
	 * app.animateCamera(0, 0, 1)
	 * app.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })
	 * ```
	 *
	 * @param x - The camera's x position.
	 * @param y - The camera's y position.
	 * @param z - The camera's z position. Defaults to the current zoom.
	 * @param opts - Options for the animation.
	 * @public
	 */
	animateCamera(x3, y3, z2 = this.camera.z, opts = DEFAULT_ANIMATION_OPTIONS) {
		x3 = Number.isNaN(x3) ? 0 : x3
		y3 = Number.isNaN(y3) ? 0 : y3
		z2 = Number.isNaN(z2) ? 1 : z2
		const { width, height } = this.viewportScreenBounds
		const w3 = width / z2
		const h3 = height / z2
		const targetViewport = new Box2d(-x3, -y3, w3, h3)
		return this._animateToViewport(targetViewport, opts)
	}
	/**
	 * Center the camera on a point (in page space).
	 *
	 * @example
	 *
	 * ```ts
	 * app.centerOnPoint(100, 100)
	 * ```
	 *
	 * @param x - The x position of the point.
	 * @param y - The y position of the point.
	 * @param opts - The options for an animation.
	 * @public
	 */
	centerOnPoint(x3, y3, opts) {
		if (!this.canMoveCamera) return this
		const {
			viewportPageBounds: { width: pw, height: ph },
			camera,
		} = this
		if (opts?.duration) {
			this.animateCamera(-(x3 - pw / 2), -(y3 - ph / 2), camera.z, opts)
		} else {
			this.setCamera(-(x3 - pw / 2), -(y3 - ph / 2), camera.z)
		}
		return this
	}
	/**
	 * Move the camera to the nearest content.
	 *
	 * @public
	 */
	zoomToContent() {
		const bounds = this.selectedPageBounds ?? this.allShapesCommonBounds
		if (bounds) {
			this.zoomToBounds(
				bounds.minX,
				bounds.minY,
				bounds.width,
				bounds.height,
				Math.min(1, this.zoomLevel),
				{ duration: 220 }
			)
		}
		return this
	}
	/**
	 * Zoom the camera to fit the current page's content in the viewport.
	 *
	 * @example
	 *
	 * ```ts
	 * app.zoomToFit()
	 * ```
	 *
	 * @public
	 */
	zoomToFit(opts) {
		if (!this.canMoveCamera) return this
		const ids = [...this.shapeIds]
		if (ids.length <= 0) return this
		const pageBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))
		this.zoomToBounds(
			pageBounds.minX,
			pageBounds.minY,
			pageBounds.width,
			pageBounds.height,
			void 0,
			opts
		)
		return this
	}
	/**
	 * Set the zoom back to 100%.
	 *
	 * @example
	 *
	 * ```ts
	 * app.resetZoom()
	 * ```
	 *
	 * @param opts - The options for an animation.
	 * @public
	 */
	resetZoom(point2 = this.viewportScreenCenter, opts) {
		if (!this.canMoveCamera) return this
		const { x: cx, y: cy, z: cz } = this.camera
		const { x: x3, y: y3 } = point2
		if (opts?.duration) {
			this.animateCamera(
				cx + (x3 / 1 - x3) - (x3 / cz - x3),
				cy + (y3 / 1 - y3) - (y3 / cz - y3),
				1,
				opts
			)
		} else {
			this.setCamera(cx + (x3 / 1 - x3) - (x3 / cz - x3), cy + (y3 / 1 - y3) - (y3 / cz - y3), 1)
		}
		return this
	}
	/**
	 * Zoom the camera in.
	 *
	 * @example
	 *
	 * ```ts
	 * app.zoomIn()
	 * app.zoomIn(app.viewportScreenCenter, { duration: 120 })
	 * app.zoomIn(app.inputs.currentScreenPoint, { duration: 120 })
	 * ```
	 *
	 * @param opts - The options for an animation.
	 * @public
	 */
	zoomIn(point2 = this.viewportScreenCenter, opts) {
		if (!this.canMoveCamera) return this
		const { x: cx, y: cy, z: cz } = this.camera
		let zoom = MAX_ZOOM
		for (let i3 = 1; i3 < ZOOMS.length; i3++) {
			const z1 = ZOOMS[i3 - 1]
			const z2 = ZOOMS[i3]
			if (z2 - cz <= (z2 - z1) / 2) continue
			zoom = z2
			break
		}
		const { x: x3, y: y3 } = point2
		if (opts?.duration) {
			this.animateCamera(
				cx + (x3 / zoom - x3) - (x3 / cz - x3),
				cy + (y3 / zoom - y3) - (y3 / cz - y3),
				zoom,
				opts
			)
		} else {
			this.setCamera(
				cx + (x3 / zoom - x3) - (x3 / cz - x3),
				cy + (y3 / zoom - y3) - (y3 / cz - y3),
				zoom
			)
		}
		return this
	}
	/**
	 * Zoom the camera out.
	 *
	 * @example
	 *
	 * ```ts
	 * app.zoomOut()
	 * app.zoomOut(app.viewportScreenCenter, { duration: 120 })
	 * app.zoomOut(app.inputs.currentScreenPoint, { duration: 120 })
	 * ```
	 *
	 * @param opts - The options for an animation.
	 * @public
	 */
	zoomOut(point2 = this.viewportScreenCenter, opts) {
		if (!this.canMoveCamera) return this
		const { x: cx, y: cy, z: cz } = this.camera
		let zoom = MIN_ZOOM
		for (let i3 = ZOOMS.length - 1; i3 > 0; i3--) {
			const z1 = ZOOMS[i3 - 1]
			const z2 = ZOOMS[i3]
			if (z2 - cz >= (z2 - z1) / 2) continue
			zoom = z1
			break
		}
		const { x: x3, y: y3 } = point2
		if (opts?.duration) {
			this.animateCamera(
				cx + (x3 / zoom - x3) - (x3 / cz - x3),
				cy + (y3 / zoom - y3) - (y3 / cz - y3),
				zoom,
				opts
			)
		} else {
			this.setCamera(
				cx + (x3 / zoom - x3) - (x3 / cz - x3),
				cy + (y3 / zoom - y3) - (y3 / cz - y3),
				zoom
			)
		}
		return this
	}
	/**
	 * Zoom the camera to fit the current selection in the viewport.
	 *
	 * @example
	 *
	 * ```ts
	 * app.zoomToSelection()
	 * ```
	 *
	 * @param opts - The options for an animation.
	 * @public
	 */
	zoomToSelection(opts) {
		if (!this.canMoveCamera) return this
		const ids = this.selectedIds
		if (ids.length <= 0) return this
		const selectedBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))
		this.zoomToBounds(
			selectedBounds.minX,
			selectedBounds.minY,
			selectedBounds.width,
			selectedBounds.height,
			Math.max(1, this.camera.z),
			opts
		)
		return this
	}
	/**
	 * Pan or pan/zoom the selected ids into view. This method tries to not change the zoom if
	 * possible.
	 *
	 * @param ids - The ids of the shapes to pan and zoom into view.
	 * @param opts - The options for an animation.
	 * @public
	 */
	panZoomIntoView(ids, opts) {
		if (!this.canMoveCamera) return this
		if (ids.length <= 0) return this
		const selectedBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))
		const { viewportPageBounds } = this
		if (viewportPageBounds.h < selectedBounds.h || viewportPageBounds.w < selectedBounds.w) {
			this.zoomToBounds(
				selectedBounds.minX,
				selectedBounds.minY,
				selectedBounds.width,
				selectedBounds.height,
				this.camera.z,
				opts
			)
			return this
		} else {
			const bufferOffsets = this._activeAreaManager.offsets.value
			const pageTop = viewportPageBounds.y + bufferOffsets.top
			const pageRight = viewportPageBounds.maxY - bufferOffsets.right
			const pageBottom = viewportPageBounds.maxY - bufferOffsets.bottom
			const pageLeft = viewportPageBounds.x + bufferOffsets.left
			const selectedTop = selectedBounds.y
			const selectedRight = selectedBounds.maxX
			const selectedBottom = selectedBounds.maxY
			const selectedLeft = selectedBounds.x
			let offsetX = 0
			let offsetY = 0
			if (pageBottom < selectedBottom) {
				offsetY = pageBottom - selectedBottom
			} else if (pageTop > selectedTop) {
				offsetY = pageTop - selectedTop
			} else {
			}
			if (pageRight < selectedRight) {
				offsetX = pageRight - selectedRight
			} else if (pageLeft > selectedLeft) {
				offsetX = pageLeft - selectedLeft
			} else {
			}
			const { camera } = this
			if (opts?.duration) {
				this.animateCamera(camera.x + offsetX, camera.y + offsetY, camera.z, opts)
			} else {
				this.setCamera(camera.x + offsetX, camera.y + offsetY, camera.z)
			}
		}
		return this
	}
	/**
	 * Zoom the camera to fit a bounding box (in page space).
	 *
	 * @example
	 *
	 * ```ts
	 * app.zoomToBounds(0, 0, 100, 100)
	 * ```
	 *
	 * @param x - The bounding box's x position.
	 * @param y - The bounding box's y position.
	 * @param width - The bounding box's width.
	 * @param height - The bounding box's height.
	 * @param targetZoom - The desired zoom level. Defaults to 0.1.
	 * @public
	 */
	zoomToBounds(x3, y3, width, height, targetZoom, opts) {
		if (!this.canMoveCamera) return this
		const { viewportScreenBounds } = this
		const inset = Math.min(256, viewportScreenBounds.width * 0.28)
		let zoom = clamp(
			Math.min(
				(viewportScreenBounds.width - inset) / width,
				(viewportScreenBounds.height - inset) / height
			),
			MIN_ZOOM,
			MAX_ZOOM
		)
		if (targetZoom !== void 0) {
			zoom = Math.min(targetZoom, zoom)
		}
		if (opts?.duration) {
			this.animateCamera(
				-x3 + (viewportScreenBounds.width - width * zoom) / 2 / zoom,
				-y3 + (viewportScreenBounds.height - height * zoom) / 2 / zoom,
				zoom,
				opts
			)
		} else {
			this.setCamera(
				-x3 + (viewportScreenBounds.width - width * zoom) / 2 / zoom,
				-y3 + (viewportScreenBounds.height - height * zoom) / 2 / zoom,
				zoom
			)
		}
		return this
	}
	/**
	 * Pan the camera.
	 *
	 * @example
	 *
	 * ```ts
	 * app.pan(100, 100)
	 * app.pan(100, 100, { duration: 1000 })
	 * ```
	 *
	 * @param dx - The amount to pan on the x axis.
	 * @param dy - The amount to pan on the y axis.
	 * @param opts - The animation options
	 */
	pan(dx, dy, opts) {
		if (!this.canMoveCamera) return this
		const { camera } = this
		const { x: cx, y: cy, z: cz } = camera
		const d3 = new Vec2d(dx, dy).div(cz)
		if (opts?.duration ?? 0 > 0) {
			return this.animateCamera(cx + d3.x, cy + d3.y, cz, opts)
		} else {
			this.setCamera(cx + d3.x, cy + d3.y, cz)
		}
		return this
	}
	/**
	 * Stop the current camera animation, if any.
	 *
	 * @public
	 */
	stopCameraAnimation() {
		this.emit('stop-camera-animation')
		return this
	}
	/** @internal */
	_viewportAnimation = null
	/** @internal */
	_animateViewport(ms) {
		if (!this._viewportAnimation) return
		const cancel = () => {
			this.removeListener('tick', this._animateViewport)
			this.removeListener('stop-camera-animation', cancel)
			this._viewportAnimation = null
		}
		this.once('stop-camera-animation', cancel)
		this._viewportAnimation.elapsed += ms
		const { elapsed, easing, duration, start, end } = this._viewportAnimation
		if (elapsed > duration) {
			const z3 = this.viewportScreenBounds.width / end.width
			const x4 = -end.x
			const y4 = -end.y
			this._setCamera(x4, y4, z3)
			cancel()
			return
		}
		const remaining = duration - elapsed
		const t4 = easing(1 - remaining / duration)
		const left = start.minX + (end.minX - start.minX) * t4
		const top = start.minY + (end.minY - start.minY) * t4
		const right = start.maxX + (end.maxX - start.maxX) * t4
		const bottom = start.maxY + (end.maxY - start.maxY) * t4
		const easedViewport = new Box2d(left, top, right - left, bottom - top)
		const z2 = this.viewportScreenBounds.width / easedViewport.width
		const x3 = -easedViewport.x
		const y3 = -easedViewport.y
		this._setCamera(x3, y3, z2)
	}
	/** @internal */
	_animateToViewport(targetViewportPage, opts = {}) {
		const { duration = 0, easing = EASINGS.easeInOutCubic } = opts
		const startViewport = this.viewportPageBounds.clone()
		this.stopCameraAnimation()
		if (this.instanceState.followingUserId) {
			this.stopFollowingUser()
		}
		this._viewportAnimation = {
			elapsed: 0,
			duration,
			easing,
			start: startViewport,
			end: targetViewportPage,
		}
		this.addListener('tick', this._animateViewport)
		return this
	}
	slideCamera(opts = {}) {
		if (!this.canMoveCamera) return this
		const { speed, direction, friction, speedThreshold = 0.01 } = opts
		let currentSpeed = speed
		this.stopCameraAnimation()
		const cancel = () => {
			this.removeListener('tick', moveCamera)
			this.removeListener('stop-camera-animation', cancel)
		}
		this.once('stop-camera-animation', cancel)
		const moveCamera = (elapsed) => {
			const { x: cx, y: cy, z: cz } = this.camera
			const movementVec = direction.clone().mul((currentSpeed * elapsed) / cz)
			currentSpeed *= 1 - friction
			if (currentSpeed < speedThreshold) {
				cancel()
			} else {
				this._setCamera(cx + movementVec.x, cy + movementVec.y, cz)
			}
		}
		this.addListener('tick', moveCamera)
		return this
	}
	/**
	 * Start viewport-following a user.
	 *
	 * @param userId - The id of the user to follow.
	 * @public
	 */
	startFollowingUser = (userId) => {
		const leaderPresences = this.store.query.records('instance_presence', () => ({
			userId: { eq: userId },
		}))
		const thisUserId = this.user.id
		if (!thisUserId) {
			console.warn('You should set the userId for the current instance before following a user')
		}
		if (leaderPresences.value.some((p3) => p3.followingUserId === thisUserId)) {
			return
		}
		transact(() => {
			this.stopFollowingUser()
			this.updateInstanceState({
				followingUserId: userId,
			})
		})
		const cancel = () => {
			this.removeListener('frame', moveTowardsUser)
			this.removeListener('stop-following', cancel)
		}
		let isCaughtUp = false
		const moveTowardsUser = () => {
			const leaderPresence = [...leaderPresences.value]
				.sort((a3, b3) => {
					return a3.lastActivityTimestamp - b3.lastActivityTimestamp
				})
				.pop()
			if (!leaderPresence) {
				this.stopFollowingUser()
				return
			}
			const isOnSamePage = leaderPresence.currentPageId === this.currentPageId
			const chaseProportion = isOnSamePage ? FOLLOW_CHASE_PROPORTION : 1
			if (!isOnSamePage) {
				this.setCurrentPageId(leaderPresence.currentPageId, { stopFollowing: false })
			}
			const { center, width, height } = this.viewportPageBounds
			const leaderScreen = Box2d.From(leaderPresence.screenBounds)
			const leaderWidth = leaderScreen.width / leaderPresence.camera.z
			const leaderHeight = leaderScreen.height / leaderPresence.camera.z
			const leaderCenter = new Vec2d(
				leaderWidth / 2 - leaderPresence.camera.x,
				leaderHeight / 2 - leaderPresence.camera.y
			)
			const isFollowingFollower = leaderPresence.followingUserId === thisUserId
			const desiredWidth = width + (leaderWidth - width) * chaseProportion
			const desiredHeight = height + (leaderHeight - height) * chaseProportion
			const ratio = !isFollowingFollower
				? Math.min(width / desiredWidth, height / desiredHeight)
				: height / desiredHeight
			const targetZoom = clamp(this.camera.z * ratio, MIN_ZOOM, MAX_ZOOM)
			const targetWidth = this.viewportScreenBounds.w / targetZoom
			const targetHeight = this.viewportScreenBounds.h / targetZoom
			const displacement = leaderCenter.sub(center)
			const targetCenter = Vec2d.Add(center, Vec2d.Mul(displacement, chaseProportion))
			const distance = Vec2d.Sub(targetCenter, center).len()
			const zoomChange = Math.abs(targetZoom - this.camera.z)
			if (distance < FOLLOW_CHASE_PAN_SNAP && zoomChange < FOLLOW_CHASE_ZOOM_SNAP) {
				isCaughtUp = true
				return
			}
			if (
				isCaughtUp &&
				distance < FOLLOW_CHASE_PAN_UNSNAP &&
				zoomChange < FOLLOW_CHASE_ZOOM_UNSNAP
			) {
				return
			}
			isCaughtUp = false
			this.stopCameraAnimation()
			this.setCamera(
				-(targetCenter.x - targetWidth / 2),
				-(targetCenter.y - targetHeight / 2),
				targetZoom,
				{ stopFollowing: false }
			)
		}
		this.once('stop-following', cancel)
		this.addListener('frame', moveTowardsUser)
		return this
	}
	/**
	 * Stop viewport-following a user.
	 *
	 * @public
	 */
	stopFollowingUser = () => {
		this.updateInstanceState({
			followingUserId: null,
		})
		this.emit('stop-following')
		return this
	}
	animateToShape(shapeId, opts = DEFAULT_ANIMATION_OPTIONS) {
		if (!this.canMoveCamera) return this
		const activeArea = getActiveAreaScreenSpace(this)
		const viewportAspectRatio = activeArea.width / activeArea.height
		const shapePageBounds = this.getPageBoundsById(shapeId)
		if (!shapePageBounds) return this
		const shapeAspectRatio = shapePageBounds.width / shapePageBounds.height
		const targetViewportPage = shapePageBounds.clone()
		const z2 = shapePageBounds.width / activeArea.width
		targetViewportPage.width += (activeArea.left + activeArea.right) * z2
		targetViewportPage.height += (activeArea.top + activeArea.bottom) * z2
		targetViewportPage.x -= activeArea.left * z2
		targetViewportPage.y -= activeArea.top * z2
		if (shapeAspectRatio > viewportAspectRatio) {
			targetViewportPage.height = shapePageBounds.width / viewportAspectRatio
			targetViewportPage.y -= (targetViewportPage.height - shapePageBounds.height) / 2
		} else {
			targetViewportPage.width = shapePageBounds.height * viewportAspectRatio
			targetViewportPage.x -= (targetViewportPage.width - shapePageBounds.width) / 2
		}
		return this._animateToViewport(targetViewportPage, opts)
	}
	/**
	 * Blur the app, cancelling any interaction state.
	 *
	 * @example
	 *
	 * ```ts
	 * app.blur()
	 * ```
	 *
	 * @public
	 */
	blur() {
		this.complete()
		this.getContainer().blur()
		this._isFocused.set(false)
		return this
	}
	/**
	 * Focus the app.
	 *
	 * @example
	 *
	 * ```ts
	 * app.focus()
	 * ```
	 *
	 * @public
	 */
	focus() {
		this.getContainer().focus()
		this._isFocused.set(true)
		return this
	}
	/**
	 * Dispatch a cancel event.
	 *
	 * @example
	 *
	 * ```ts
	 * app.cancel()
	 * ```
	 *
	 * @public
	 */
	cancel() {
		this.dispatch({ type: 'misc', name: 'cancel' })
		return this
	}
	/**
	 * Dispatch an interrupt event.
	 *
	 * @example
	 *
	 * ```ts
	 * app.interrupt()
	 * ```
	 *
	 * @public
	 */
	interrupt() {
		this.dispatch({ type: 'misc', name: 'interrupt' })
		return this
	}
	/**
	 * Dispatch a complete event.
	 *
	 * @example
	 *
	 * ```ts
	 * app.complete()
	 * ```
	 *
	 * @public
	 */
	complete() {
		this.dispatch({ type: 'misc', name: 'complete' })
		return this
	}
	/* -------------------- Callbacks ------------------- */
	/**
	 * A callback fired when a file is converted to an asset. This callback should return the asset
	 * partial.
	 *
	 * @example
	 *
	 * ```ts
	 * app.onCreateAssetFromFile(myFile)
	 * ```
	 *
	 * @param file - The file to upload.
	 * @public
	 */
	async onCreateAssetFromFile(file) {
		return await getMediaAssetFromFile(file)
	}
	/**
	 * A callback fired when a URL is converted to a bookmark. This callback should return the
	 * metadata for the bookmark.
	 *
	 * @example
	 *
	 * ```ts
	 * app.onCreateBookmarkFromUrl(url, id)
	 * ```
	 *
	 * @param url - The url that was created.
	 * @public
	 */
	async onCreateBookmarkFromUrl(url) {
		try {
			const resp = await fetch(url, { method: 'GET', mode: 'no-cors' })
			const html = await resp.text()
			const doc = new DOMParser().parseFromString(html, 'text/html')
			return {
				image: doc.head.querySelector('meta[property="og:image"]')?.getAttribute('content') ?? '',
				title: doc.head.querySelector('meta[property="og:title"]')?.getAttribute('content') ?? '',
				description:
					doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ?? '',
			}
		} catch (error) {
			console.error(error)
			return { image: '', title: '', description: '' }
		}
	}
	/* ---------------- Text Measurement ---------------- */
	/**
	 * A helper for measuring text.
	 *
	 * @public
	 */
	textMeasure
	/* --------------------- Groups --------------------- */
	groupShapes(ids = this.selectedIds, groupId = createShapeId()) {
		if (this.isReadOnly) return this
		if (ids.length <= 1) return this
		const shapes = compact(ids.map((id) => this.getShapeById(id)))
		const sortedShapeIds = shapes.sort(sortByIndex).map((s3) => s3.id)
		const pageBounds = Box2d.Common(compact(shapes.map((id) => this.getPageBounds(id))))
		const { x: x3, y: y3 } = pageBounds.point
		const parentId = this.findCommonAncestor(shapes) ?? this.currentPageId
		if (this.currentToolId !== 'select') return this
		if (!this.isIn('select.idle')) {
			this.cancel()
		}
		const shapesWithRootParent = shapes
			.filter((shape) => shape.parentId === parentId)
			.sort(sortByIndex)
		const highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index
		this.batch(() => {
			this.createShapes([
				{
					id: groupId,
					type: 'group',
					parentId,
					index: highestIndex,
					x: x3,
					y: y3,
					props: {
						opacity: '1',
					},
				},
			])
			this.reparentShapesById(sortedShapeIds, groupId)
			this.select(groupId)
		})
		return this
	}
	ungroupShapes(ids = this.selectedIds) {
		if (this.isReadOnly) return this
		if (ids.length === 0) return this
		if (this.currentToolId !== 'select') return this
		if (!this.isIn('select.idle')) {
			this.cancel()
		}
		const idsToSelect = /* @__PURE__ */ new Set()
		const shapes = compact(ids.map((id) => this.getShapeById(id)))
		const groups = []
		shapes.forEach((shape) => {
			if (this.isShapeOfType(shape, TLGroupUtil)) {
				groups.push(shape)
			} else {
				idsToSelect.add(shape.id)
			}
		})
		if (groups.length === 0) return this
		this.batch(() => {
			let group
			for (let i3 = 0, n3 = groups.length; i3 < n3; i3++) {
				group = groups[i3]
				const childIds = this.getSortedChildIds(group.id)
				for (let j = 0, n4 = childIds.length; j < n4; j++) {
					idsToSelect.add(childIds[j])
				}
				this.reparentShapesById(childIds, group.parentId, group.index)
			}
			this.deleteShapes(groups.map((group2) => group2.id))
			this.select(...idsToSelect)
		})
		return this
	}
}
var App = _App
/* --------------------- Shapes --------------------- */
/**
 * The app's set of styles.
 *
 * @public
 */
__publicField(App, 'styles', STYLES)
__decorateClass([computed], App.prototype, 'openMenus', 1)
__decorateClass([computed], App.prototype, 'isMenuOpen', 1)
__decorateClass([computed], App.prototype, '_pageTransformCache', 1)
__decorateClass([computed], App.prototype, '_pageBoundsCache', 1)
__decorateClass([computed], App.prototype, '_pageMaskCache', 1)
__decorateClass([computed], App.prototype, '_clipPathCache', 1)
__decorateClass([computed], App.prototype, 'canUndo', 1)
__decorateClass([computed], App.prototype, 'canRedo', 1)
__decorateClass([computed], App.prototype, 'erasingIds', 1)
__decorateClass([computed], App.prototype, 'hintingIds', 1)
__decorateClass([computed], App.prototype, 'erasingIdsSet', 1)
__decorateClass([computed], App.prototype, 'props', 1)
__decorateClass([computed], App.prototype, '_arrowBindingsIndex', 1)
__decorateClass([computed], App.prototype, '_allPageStates', 1)
__decorateClass([computed], App.prototype, 'documentSettings', 1)
__decorateClass([computed], App.prototype, '_userDocumentSettings', 1)
__decorateClass([computed], App.prototype, '_pageState', 1)
__decorateClass([computed], App.prototype, 'camera', 1)
__decorateClass([computed], App.prototype, 'zoomLevel', 1)
__decorateClass([computed], App.prototype, 'selectedIds', 1)
__decorateClass([computed], App.prototype, 'selectedIdsSet', 1)
__decorateClass([computed], App.prototype, '_pages', 1)
__decorateClass([computed], App.prototype, 'pages', 1)
__decorateClass([computed], App.prototype, '_pageStates', 1)
__decorateClass([computed], App.prototype, 'renderingShapes', 1)
__decorateClass([computed], App.prototype, 'allShapesCommonBounds', 1)
__decorateClass([computed], App.prototype, 'viewportScreenBounds', 1)
__decorateClass([computed], App.prototype, 'viewportScreenCenter', 1)
__decorateClass([computed], App.prototype, 'viewportPageBounds', 1)
__decorateClass([computed], App.prototype, 'cullingBounds', 1)
__decorateClass([computed], App.prototype, 'cullingBoundsExpanded', 1)
__decorateClass([computed], App.prototype, 'viewportPageCenter', 1)
__decorateClass([computed], App.prototype, 'editingShape', 1)
__decorateClass([computed], App.prototype, 'selectedPageBounds', 1)
__decorateClass([computed], App.prototype, 'selectionRotation', 1)
__decorateClass([computed], App.prototype, 'selectionBounds', 1)
__decorateClass([computed], App.prototype, 'selectionPageCenter', 1)
__decorateClass([computed], App.prototype, 'shapesArray', 1)
__decorateClass([computed], App.prototype, 'sortedShapesArray', 1)
__decorateClass([computed], App.prototype, 'selectedShapes', 1)
__decorateClass([computed], App.prototype, 'onlySelectedShape', 1)
__decorateClass([computed], App.prototype, '_assets', 1)
__decorateClass([computed], App.prototype, 'hoveredId', 1)
__decorateClass([computed], App.prototype, 'hoveredShape', 1)
function alertMaxShapes(app, pageId = app.currentPageId) {
	const name = app.getPageById(pageId).name
	app.emit('max-shapes', { name, pageId, count: MAX_SHAPES_PER_PAGE })
}

// ../packages/editor/src/lib/assetUrls.ts
init_define_process()
var defaultEditorAssetUrls = {
	fonts: {
		draw: '/fonts/Shantell_Sans-Normal-SemiBold.woff2',
		serif: '/fonts/IBMPlexSerif-Medium.woff2',
		sansSerif: '/fonts/IBMPlexSans-Medium.woff2',
		monospace: '/fonts/IBMPlexMono-Medium.woff2',
	},
}

// ../packages/editor/src/lib/components/ErrorBoundary.tsx
init_define_process()
var React9 = __toESM(require_react())
var import_jsx_runtime20 = __toESM(require_jsx_runtime())
var initialState = { error: null }
var ErrorBoundary = class extends React9.Component {
	static getDerivedStateFromError(error) {
		return { error }
	}
	state = initialState
	componentDidCatch(error) {
		this.props.onError?.(error)
	}
	render() {
		const { error } = this.state
		if (error !== null) {
			return this.props.fallback(error)
		}
		return this.props.children
	}
}
function OptionalErrorBoundary({ children, fallback, ...props }) {
	if (fallback === null) {
		return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(import_jsx_runtime20.Fragment, {
			children,
		})
	}
	return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(ErrorBoundary, {
		fallback,
		...props,
		children,
	})
}

// ../packages/editor/src/lib/components/DefaultErrorFallback.tsx
init_define_process()
var import_classnames10 = __toESM(require_classnames())
var import_react34 = __toESM(require_react())

// ../packages/editor/src/lib/utils/hard-reset.ts
init_define_process()

// ../packages/editor/src/lib/utils/runtime.ts
init_define_process()
var runtime = {
	openWindow: (url, target) => window.open(url, target, 'noopener noreferrer'),
	refreshPage: () => window.location.reload(),
	hardReset: async () => await window.__tldraw__hardReset?.(),
}

// ../packages/editor/src/lib/utils/hard-reset.ts
function hardResetApp() {
	runtime.hardReset()
}

// ../packages/editor/src/lib/utils/refresh-page.ts
init_define_process()
function refreshPage() {
	runtime.refreshPage()
}

// ../packages/editor/src/lib/components/Canvas.tsx
init_define_process()
var React19 = __toESM(require_react())

// ../packages/editor/src/lib/hooks/useCanvasEvents.ts
init_define_process()
var import_react15 = __toESM(require_react())
function useCanvasEvents() {
	const app = useApp()
	const events = (0, import_react15.useMemo)(
		function canvasEvents() {
			let lastX, lastY
			function onPointerDown(e2) {
				if (e2.isKilled) return
				if (e2.button !== 0 && e2.button !== 1 && e2.button !== 5) return
				setPointerCapture(e2.currentTarget, e2)
				app.dispatch({
					type: 'pointer',
					target: 'canvas',
					name: 'pointer_down',
					...getPointerInfo(e2, app.getContainer()),
				})
			}
			function onPointerMove(e2) {
				if (e2.isKilled) return
				if (e2.clientX === lastX && e2.clientY === lastY) return
				lastX = e2.clientX
				lastY = e2.clientY
				app.dispatch({
					type: 'pointer',
					target: 'canvas',
					name: 'pointer_move',
					...getPointerInfo(e2, app.getContainer()),
				})
			}
			function onPointerUp(e2) {
				if (e2.isKilled) return
				if (e2.button !== 0 && e2.button !== 1 && e2.button !== 2 && e2.button !== 5) return
				lastX = e2.clientX
				lastY = e2.clientY
				releasePointerCapture(e2.currentTarget, e2)
				app.dispatch({
					type: 'pointer',
					target: 'canvas',
					name: 'pointer_up',
					...getPointerInfo(e2, app.getContainer()),
				})
			}
			function onPointerEnter(e2) {
				if (e2.isKilled) return
				app.dispatch({
					type: 'pointer',
					target: 'canvas',
					name: 'pointer_enter',
					...getPointerInfo(e2, app.getContainer()),
				})
			}
			function onPointerLeave(e2) {
				if (e2.isKilled) return
				app.dispatch({
					type: 'pointer',
					target: 'canvas',
					name: 'pointer_leave',
					...getPointerInfo(e2, app.getContainer()),
				})
			}
			function onTouchStart(e2) {
				e2.isKilled = true
				document.body.click()
				preventDefault(e2)
			}
			function onTouchEnd(e2) {
				e2.isKilled = true
				if (e2.target.tagName !== 'A' && e2.target.tagName !== 'TEXTAREA') {
					preventDefault(e2)
				}
			}
			function onDragOver(e2) {
				preventDefault(e2)
			}
			async function onDrop(e2) {
				preventDefault(e2)
				if (!e2.dataTransfer?.files?.length) return
				const files = Array.from(e2.dataTransfer.files).filter(
					(file) => !file.name.endsWith('.tldr')
				)
				await createShapesFromFiles(app, files, app.screenToPage(e2.clientX, e2.clientY), false)
			}
			return {
				onPointerDown,
				onPointerMove,
				onPointerUp,
				onPointerEnter,
				onPointerLeave,
				onDragOver,
				onDrop,
				onTouchStart,
				onTouchEnd,
			}
		},
		[app]
	)
	return events
}

// ../packages/editor/src/lib/hooks/useCoarsePointer.ts
init_define_process()
var import_react16 = __toESM(require_react())
function useCoarsePointer() {
	const app = useApp()
	;(0, import_react16.useEffect)(() => {
		const mql = window.matchMedia('(pointer: coarse)')
		const handler = () => {
			app.isCoarsePointer = mql.matches
		}
		handler()
		mql.addEventListener('change', handler)
		return () => mql.removeEventListener('change', handler)
	}, [app])
}

// ../packages/editor/src/lib/hooks/useDocumentEvents.ts
init_define_process()
var import_react18 = __toESM(require_react())

// ../packages/editor/src/lib/hooks/useContainer.tsx
init_define_process()
var import_react17 = __toESM(require_react())
var import_jsx_runtime21 = __toESM(require_jsx_runtime())
var ContainerContext = (0, import_react17.createContext)(null)
function ContainerProvider({ container, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(ContainerContext.Provider, {
		value: container,
		children,
	})
}
function useContainer() {
	return assertExists(
		(0, import_react17.useContext)(ContainerContext),
		'useContainer used outside of <Tldraw />'
	)
}

// ../packages/editor/src/lib/hooks/useDocumentEvents.ts
function useDocumentEvents() {
	const app = useApp()
	const container = useContainer()
	const isAppFocused = useValue('isFocused', () => app.isFocused, [app])
	;(0, import_react18.useEffect)(() => {
		if (!isAppFocused) return
		const handleKeyDown = (e2) => {
			if (
				e2.altKey &&
				(app.isIn('zoom') || !app.root.path.value.endsWith('.idle')) &&
				!isFocusingInput()
			) {
				preventDefault(e2)
			}
			if (e2.isKilled) return
			e2.isKilled = true
			switch (e2.key) {
				case '=': {
					if (e2.metaKey || e2.ctrlKey) {
						preventDefault(e2)
						return
					}
					break
				}
				case '-': {
					if (e2.metaKey || e2.ctrlKey) {
						preventDefault(e2)
						return
					}
					break
				}
				case '0': {
					if (e2.metaKey || e2.ctrlKey) {
						preventDefault(e2)
						return
					}
					break
				}
				case 'Tab': {
					if (isFocusingInput() || app.isMenuOpen) {
						return
					}
					break
				}
				case ',': {
					if (!isFocusingInput()) {
						preventDefault(e2)
						if (!app.inputs.keys.has('Comma')) {
							const { x: x3, y: y3, z: z2 } = app.inputs.currentScreenPoint
							const {
								pageState: { hoveredId },
							} = app
							app.inputs.keys.add('Comma')
							const info2 = {
								type: 'pointer',
								name: 'pointer_down',
								point: { x: x3, y: y3, z: z2 },
								shiftKey: e2.shiftKey,
								altKey: e2.altKey,
								ctrlKey: e2.metaKey || e2.ctrlKey,
								pointerId: 0,
								button: 0,
								isPen: app.isPenMode,
								...(hoveredId
									? {
											target: 'shape',
											shape: app.getShapeById(hoveredId),
									  }
									: {
											target: 'canvas',
									  }),
							}
							app.dispatch(info2)
							return
						}
					}
					break
				}
				case 'Escape': {
					if (!app.inputs.keys.has('Escape')) {
						app.inputs.keys.add('Escape')
						app.cancel()
						container.focus()
					}
					return
				}
				default: {
					if (isFocusingInput() || app.isMenuOpen) {
						return
					}
				}
			}
			const info = {
				type: 'keyboard',
				name: app.inputs.keys.has(e2.code) ? 'key_repeat' : 'key_down',
				key: e2.key,
				code: e2.code,
				shiftKey: e2.shiftKey,
				altKey: e2.altKey,
				ctrlKey: e2.metaKey || e2.ctrlKey,
			}
			app.dispatch(info)
		}
		const handleKeyUp = (e2) => {
			if (e2.isKilled) return
			e2.isKilled = true
			if (isFocusingInput() || app.isMenuOpen) {
				return
			}
			if (e2.key === ',') {
				if (document.activeElement?.ELEMENT_NODE) preventDefault(e2)
				if (app.inputs.keys.has(e2.code)) {
					const { x: x3, y: y3, z: z2 } = app.inputs.currentScreenPoint
					const {
						pageState: { hoveredId },
					} = app
					app.inputs.keys.delete(e2.code)
					const info2 = {
						type: 'pointer',
						name: 'pointer_up',
						point: { x: x3, y: y3, z: z2 },
						shiftKey: e2.shiftKey,
						altKey: e2.altKey,
						ctrlKey: e2.metaKey || e2.ctrlKey,
						pointerId: 0,
						button: 0,
						isPen: app.isPenMode,
						...(hoveredId
							? {
									target: 'shape',
									shape: app.getShapeById(hoveredId),
							  }
							: {
									target: 'canvas',
							  }),
					}
					app.dispatch(info2)
					return
				}
			}
			const info = {
				type: 'keyboard',
				name: 'key_up',
				key: e2.key,
				code: e2.code,
				shiftKey: e2.shiftKey,
				altKey: e2.altKey,
				ctrlKey: e2.metaKey || e2.ctrlKey,
			}
			app.dispatch(info)
		}
		function handleTouchStart(e2) {
			if (container.contains(e2.target)) {
				const touchXPosition = e2.touches[0].pageX
				const touchXRadius = e2.touches[0].radiusX || 0
				if (
					touchXPosition - touchXRadius < 10 ||
					touchXPosition + touchXRadius > app.viewportScreenBounds.width - 10
				) {
					if (e2.target?.tagName === 'BUTTON') {
						e2.target?.click()
					}
					preventDefault(e2)
				}
			}
		}
		const handleWheel = (e2) => {
			if (container.contains(e2.target) && (e2.ctrlKey || e2.metaKey)) {
				preventDefault(e2)
			}
		}
		function handleBlur() {
			app.complete()
		}
		function handleFocus() {
			app.updateViewportScreenBounds()
		}
		container.addEventListener('touchstart', handleTouchStart, { passive: false })
		document.addEventListener('wheel', handleWheel, { passive: false })
		document.addEventListener('gesturestart', preventDefault)
		document.addEventListener('gesturechange', preventDefault)
		document.addEventListener('gestureend', preventDefault)
		document.addEventListener('keydown', handleKeyDown)
		document.addEventListener('keyup', handleKeyUp)
		window.addEventListener('blur', handleBlur)
		window.addEventListener('focus', handleFocus)
		return () => {
			container.removeEventListener('touchstart', handleTouchStart)
			document.removeEventListener('wheel', handleWheel)
			document.removeEventListener('gesturestart', preventDefault)
			document.removeEventListener('gesturechange', preventDefault)
			document.removeEventListener('gestureend', preventDefault)
			document.removeEventListener('keydown', handleKeyDown)
			document.removeEventListener('keyup', handleKeyUp)
			window.removeEventListener('blur', handleBlur)
			window.removeEventListener('focus', handleFocus)
		}
	}, [app, container, isAppFocused])
}
var INPUTS = ['input', 'select', 'button', 'textarea']
function isFocusingInput() {
	const { activeElement } = document
	if (
		activeElement &&
		(activeElement.getAttribute('contenteditable') ||
			INPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1)
	) {
		return true
	}
	return false
}

// ../packages/editor/src/lib/hooks/useEditorComponents.tsx
init_define_process()
var import_react23 = __toESM(require_react())

// ../packages/editor/src/lib/components/DefaultBackground.tsx
init_define_process()
var import_jsx_runtime22 = __toESM(require_jsx_runtime())
function DefaultBackground() {
	return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)('div', { className: 'tl-background' })
}

// ../packages/editor/src/lib/components/DefaultBrush.tsx
init_define_process()
var import_react20 = __toESM(require_react())

// ../packages/editor/src/lib/hooks/useTransform.ts
init_define_process()
var import_react19 = __toESM(require_react())
function useTransform(ref, x3, y3, scale, rotate, additionalOffset) {
	;(0, import_react19.useLayoutEffect)(() => {
		const elm = ref.current
		if (!elm) return
		if (x3 === void 0) return
		let trans = `translate(${x3}px, ${y3}px)`
		if (scale !== void 0) {
			trans += ` scale(${scale})`
		}
		if (rotate !== void 0) {
			trans += ` rotate(${rotate}rad)`
		}
		if (additionalOffset) {
			trans += ` translate(${additionalOffset.x}px, ${additionalOffset.y}px)`
		}
		elm.style.transform = trans
	})
}

// ../packages/editor/src/lib/components/DefaultBrush.tsx
var import_jsx_runtime23 = __toESM(require_jsx_runtime())
var DefaultBrush = ({ brush, color, opacity }) => {
	const rSvg = (0, import_react20.useRef)(null)
	useTransform(rSvg, brush.x, brush.y)
	return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)('svg', {
		className: 'tl-overlays__item',
		ref: rSvg,
		children: color
			? /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)('g', {
					className: 'tl-brush',
					opacity,
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime23.jsx)('rect', {
							width: toDomPrecision(Math.max(1, brush.w)),
							height: toDomPrecision(Math.max(1, brush.h)),
							fill: color,
							opacity: 0.75,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime23.jsx)('rect', {
							width: toDomPrecision(Math.max(1, brush.w)),
							height: toDomPrecision(Math.max(1, brush.h)),
							fill: 'none',
							stroke: color,
							opacity: 0.1,
						}),
					],
			  })
			: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)('rect', {
					className: 'tl-brush tl-brush__default',
					width: toDomPrecision(Math.max(1, brush.w)),
					height: toDomPrecision(Math.max(1, brush.h)),
			  }),
	})
}

// ../packages/editor/src/lib/components/DefaultCollaboratorHint.tsx
init_define_process()
var import_classnames2 = __toESM(require_classnames())
var import_react21 = __toESM(require_react())
var import_jsx_runtime24 = __toESM(require_jsx_runtime())
var DefaultCollaboratorHint = ({
	className,
	zoom,
	point: point2,
	color,
	viewport,
	opacity = 1,
}) => {
	const rSvg = (0, import_react21.useRef)(null)
	useTransform(
		rSvg,
		clamp(point2.x, viewport.minX + 5 / zoom, viewport.maxX - 5 / zoom),
		clamp(point2.y, viewport.minY + 5 / zoom, viewport.maxY - 5 / zoom),
		1 / zoom,
		Vec2d.Angle(viewport.center, point2)
	)
	return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)('svg', {
		ref: rSvg,
		className: (0, import_classnames2.default)('tl-overlays__item', className),
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime24.jsx)('use', {
				href: '#cursor_hint',
				color,
				strokeWidth: 3,
				stroke: 'var(--color-background)',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime24.jsx)('use', {
				href: '#cursor_hint',
				color,
				opacity,
			}),
		],
	})
}

// ../packages/editor/src/lib/components/DefaultCursor.tsx
init_define_process()
var import_classnames3 = __toESM(require_classnames())
var import_react22 = __toESM(require_react())
var import_jsx_runtime25 = __toESM(require_jsx_runtime())
var _Cursor = ({ className, zoom, point: point2, color, name }) => {
	const rDiv = (0, import_react22.useRef)(null)
	useTransform(rDiv, point2?.x, point2?.y, 1 / zoom)
	if (!point2) return null
	return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)('div', {
		ref: rDiv,
		className: (0, import_classnames3.default)('tl-overlays__item', className),
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime25.jsx)('svg', {
				className: 'tl-cursor',
				children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)('use', { href: '#cursor', color }),
			}),
			name !== null &&
				name !== '' &&
				/* @__PURE__ */ (0, import_jsx_runtime25.jsx)('div', {
					className: 'tl-nametag',
					style: { backgroundColor: color },
					children: name,
				}),
		],
	})
}
var DefaultCursor = (0, import_react22.memo)(_Cursor)

// ../packages/editor/src/lib/components/DefaultGrid.tsx
init_define_process()
var import_jsx_runtime26 = __toESM(require_jsx_runtime())
var DefaultGrid = ({ x: x3, y: y3, z: z2, size }) => {
	return /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)('svg', {
		className: 'tl-grid',
		version: '1.1',
		xmlns: 'http://www.w3.org/2000/svg',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime26.jsx)('defs', {
				children: GRID_STEPS.map(({ min: min2, mid, step }, i3) => {
					const s3 = step * size * z2
					const xo = 0.5 + x3 * z2
					const yo = 0.5 + y3 * z2
					const gxo = xo > 0 ? xo % s3 : s3 + (xo % s3)
					const gyo = yo > 0 ? yo % s3 : s3 + (yo % s3)
					const opacity = z2 < mid ? modulate(z2, [min2, mid], [0, 1]) : 1
					return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
						'pattern',
						{
							id: `grid-${step}`,
							width: s3,
							height: s3,
							patternUnits: 'userSpaceOnUse',
							children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)('circle', {
								className: 'tl-grid-dot',
								cx: gxo,
								cy: gyo,
								r: 1,
								opacity,
							}),
						},
						`grid-pattern-${i3}`
					)
				}),
			}),
			GRID_STEPS.map(({ step }, i3) =>
				/* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
					'rect',
					{ width: '100%', height: '100%', fill: `url(#grid-${step})` },
					`grid-rect-${i3}`
				)
			),
		],
	})
}

// ../packages/editor/src/lib/components/DefaultHandle.tsx
init_define_process()
var import_classnames4 = __toESM(require_classnames())
var import_jsx_runtime27 = __toESM(require_jsx_runtime())
var DefaultHandle = ({ handle, className }) => {
	return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)('g', {
		className: (0, import_classnames4.default)(
			'tl-handle',
			{ 'tl-handle__hint': handle.type !== 'vertex' },
			className
		),
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime27.jsx)('circle', { className: 'tl-handle__bg' }),
			/* @__PURE__ */ (0, import_jsx_runtime27.jsx)('circle', { className: 'tl-handle__fg' }),
		],
	})
}

// ../packages/editor/src/lib/components/DefaultScribble.tsx
init_define_process()
var import_classnames5 = __toESM(require_classnames())
var import_jsx_runtime28 = __toESM(require_jsx_runtime())
var DefaultScribble = ({ scribble, zoom, color, opacity, className }) => {
	if (!scribble.points.length) return
	const d3 = getSvgPathFromStroke(
		getStroke(scribble.points, {
			size: scribble.size / zoom,
			start: { taper: true, easing: EASINGS.linear },
			last: scribble.state === 'stopping',
			simulatePressure: false,
			streamline: 0.32,
		})
	)
	return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)('svg', {
		className: className
			? (0, import_classnames5.default)('tl-overlays__item', className)
			: className,
		children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)('path', {
			className: 'tl-scribble',
			d: d3,
			fill: color ?? `var(--color-${scribble.color})`,
			opacity: opacity ?? scribble.opacity,
		}),
	})
}

// ../packages/editor/src/lib/components/DefaultShapeErrorFallback.tsx
init_define_process()
var import_jsx_runtime29 = __toESM(require_jsx_runtime())
var DefaultShapeErrorFallback = () => {
	return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)('div', {
		className: 'tl-shape-error-boundary',
	})
}

// ../packages/editor/src/lib/components/DefaultShapeIndicatorErrorFallback.tsx
init_define_process()
var import_jsx_runtime30 = __toESM(require_jsx_runtime())
var DefaultShapeIndicatorErrorFallback = () => {
	return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)('circle', {
		cx: 4,
		cy: 4,
		r: 8,
		strokeWidth: '1',
		stroke: 'red',
	})
}

// ../packages/editor/src/lib/components/DefaultSnapLine.tsx
init_define_process()
var import_classnames6 = __toESM(require_classnames())
var React11 = __toESM(require_react())
var import_jsx_runtime31 = __toESM(require_jsx_runtime())
function PointsSnapLine({ points: points2, zoom }) {
	const l3 = 2.5 / zoom
	const minX = points2.reduce((acc, p3) => Math.min(acc, p3.x), Infinity)
	const maxX = points2.reduce((acc, p3) => Math.max(acc, p3.x), -Infinity)
	const minY = points2.reduce((acc, p3) => Math.min(acc, p3.y), Infinity)
	const maxY = points2.reduce((acc, p3) => Math.max(acc, p3.y), -Infinity)
	const useNWtoSEdireciton = points2.some((p3) => p3.x === minX && p3.y === minY)
	let firstX, firstY, secondX, secondY
	if (useNWtoSEdireciton) {
		firstX = minX
		firstY = minY
		secondX = maxX
		secondY = maxY
	} else {
		firstX = minX
		firstY = maxY
		secondX = maxX
		secondY = minY
	}
	return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)('g', {
		className: 'tl-snap-line',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
				x1: firstX,
				y1: firstY,
				x2: secondX,
				y2: secondY,
			}),
			points2.map((p3, i3) =>
				/* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
					'g',
					{
						transform: `translate(${p3.x},${p3.y})`,
						children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)('path', {
							className: 'tl-snap-point',
							d: `M ${-l3},${-l3} L ${l3},${l3} M ${-l3},${l3} L ${l3},${-l3}`,
						}),
					},
					i3
				)
			),
		],
	})
}
function GapsSnapLine({ gaps, direction, zoom }) {
	const l3 = 3.5 / zoom
	let edgeIntersection = [-Infinity, Infinity]
	let nextEdgeIntersection = null
	const horizontal = direction === 'horizontal'
	for (const gap of gaps) {
		nextEdgeIntersection = rangeIntersection(
			edgeIntersection[0],
			edgeIntersection[1],
			horizontal ? gap.startEdge[0].y : gap.startEdge[0].x,
			horizontal ? gap.startEdge[1].y : gap.startEdge[1].x
		)
		if (nextEdgeIntersection) {
			edgeIntersection = nextEdgeIntersection
		} else {
			continue
		}
		nextEdgeIntersection = rangeIntersection(
			edgeIntersection[0],
			edgeIntersection[1],
			horizontal ? gap.endEdge[0].y : gap.endEdge[0].x,
			horizontal ? gap.endEdge[1].y : gap.endEdge[1].x
		)
		if (nextEdgeIntersection) {
			edgeIntersection = nextEdgeIntersection
		} else {
			continue
		}
	}
	if (edgeIntersection === null) {
		return null
	}
	const midPoint = (edgeIntersection[0] + edgeIntersection[1]) / 2
	return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)('g', {
		className: 'tl-snap-line',
		children: gaps.map(({ startEdge, endEdge }, i3) =>
			/* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
				React11.Fragment,
				{
					children: horizontal
						? // horizontal gap
						  /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, {
								children: [
									/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
										x1: startEdge[0].x,
										y1: midPoint - 2 * l3,
										x2: startEdge[1].x,
										y2: midPoint + 2 * l3,
									}),
									/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
										x1: endEdge[0].x,
										y1: midPoint - 2 * l3,
										x2: endEdge[1].x,
										y2: midPoint + 2 * l3,
									}),
									/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
										x1: startEdge[0].x,
										y1: midPoint,
										x2: endEdge[0].x,
										y2: midPoint,
									}),
									/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
										x1: (startEdge[0].x + endEdge[0].x) / 2,
										y1: midPoint - l3,
										x2: (startEdge[0].x + endEdge[0].x) / 2,
										y2: midPoint + l3,
									}),
								],
						  })
						: // vertical gap
						  /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(import_jsx_runtime31.Fragment, {
								children: [
									/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
										x1: midPoint - 2 * l3,
										y1: startEdge[0].y,
										x2: midPoint + 2 * l3,
										y2: startEdge[1].y,
									}),
									/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
										x1: midPoint - 2 * l3,
										y1: endEdge[0].y,
										x2: midPoint + 2 * l3,
										y2: endEdge[1].y,
									}),
									/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
										x1: midPoint,
										y1: startEdge[0].y,
										x2: midPoint,
										y2: endEdge[0].y,
									}),
									/* @__PURE__ */ (0, import_jsx_runtime31.jsx)('line', {
										x1: midPoint - l3,
										y1: (startEdge[0].y + endEdge[0].y) / 2,
										x2: midPoint + l3,
										y2: (startEdge[0].y + endEdge[0].y) / 2,
									}),
								],
						  }),
				},
				i3
			)
		),
	})
}
var DefaultSnapLine = ({ className, line, zoom }) => {
	return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)('svg', {
		className: (0, import_classnames6.default)('tl-overlays__item', className),
		children:
			line.type === 'points'
				? /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(PointsSnapLine, { ...line, zoom })
				: line.type === 'gaps'
				? /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(GapsSnapLine, { ...line, zoom })
				: null,
	})
}

// ../packages/editor/src/lib/components/DefaultSvgDefs.tsx
init_define_process()
var DefaultSvgDefs = () => {
	return null
}

// ../packages/editor/src/lib/components/ShapeIndicator.tsx
init_define_process()
var import_classnames7 = __toESM(require_classnames())
var React12 = __toESM(require_react())
var import_jsx_runtime32 = __toESM(require_jsx_runtime())
var ShapeWithPropsEquality = class {
	constructor(shape) {
		this.shape = shape
	}
	equals(other) {
		return this.shape?.props === other?.shape?.props
	}
}
var EvenInnererIndicator = ({ shape, util }) => {
	return useStateTracking('Indicator:' + shape.type, () => util.indicator(shape))
}
var InnerIndicator = ({ app, id }) => {
	const shape = useValue('shape', () => new ShapeWithPropsEquality(app.store.get(id)), [app, id])
	const { ShapeIndicatorErrorFallback } = useEditorComponents()
	if (!shape.shape) return null
	return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(OptionalErrorBoundary, {
		fallback: ShapeIndicatorErrorFallback
			? (error) =>
					/* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ShapeIndicatorErrorFallback, { error })
			: null,
		onError: (error) =>
			app.annotateError(error, { origin: 'react.shapeIndicator', willCrashApp: false }),
		children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
			EvenInnererIndicator,
			{
				shape: shape.shape,
				util: app.getShapeUtil(shape.shape),
			},
			shape.shape.id
		),
	})
}
var _ShapeIndicator = ({ id, className, color, opacity }) => {
	const app = useApp()
	const transform = useValue(
		'transform',
		() => {
			const pageTransform = app.getPageTransformById(id)
			if (!pageTransform) return ''
			return pageTransform.toCssString()
		},
		[app, id]
	)
	return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)('svg', {
		className: (0, import_classnames7.default)('tl-overlays__item', className),
		children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)('g', {
			className: 'tl-shape-indicator',
			transform,
			stroke: color ?? 'var(--color-selected)',
			opacity,
			children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(InnerIndicator, { app, id }),
		}),
	})
}
var ShapeIndicator = React12.memo(_ShapeIndicator)

// ../packages/editor/src/lib/hooks/useEditorComponents.tsx
var import_jsx_runtime33 = __toESM(require_jsx_runtime())
var EditorComponentsContext = (0, import_react23.createContext)({})
function EditorComponentsProvider({ overrides, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(EditorComponentsContext.Provider, {
		value: {
			Background: DefaultBackground,
			SvgDefs: DefaultSvgDefs,
			Brush: DefaultBrush,
			ZoomBrush: DefaultBrush,
			CollaboratorBrush: DefaultBrush,
			Cursor: DefaultCursor,
			CollaboratorCursor: DefaultCursor,
			CollaboratorHint: DefaultCollaboratorHint,
			CollaboratorShapeIndicator: ShapeIndicator,
			Grid: DefaultGrid,
			Scribble: DefaultScribble,
			SnapLine: DefaultSnapLine,
			Handle: DefaultHandle,
			CollaboratorScribble: DefaultScribble,
			ErrorFallback: DefaultErrorFallback,
			ShapeErrorFallback: DefaultShapeErrorFallback,
			ShapeIndicatorErrorFallback: DefaultShapeIndicatorErrorFallback,
			Spinner: DefaultSpinner,
			...overrides,
		},
		children,
	})
}
function useEditorComponents() {
	return (0, import_react23.useContext)(EditorComponentsContext)
}

// ../packages/editor/src/lib/hooks/useFixSafariDoubleTapZoomPencilEvents.ts
init_define_process()
var import_react24 = __toESM(require_react())
var IGNORED_TAGS = ['textarea', 'input']
function useFixSafariDoubleTapZoomPencilEvents(ref) {
	const app = useApp()
	;(0, import_react24.useEffect)(() => {
		const elm = ref.current
		if (!elm) return
		const handleEvent = (e2) => {
			if (e2 instanceof PointerEvent && e2.pointerType === 'pen') {
				e2.isKilled = true
				const { target } = e2
				if (
					IGNORED_TAGS.includes(target.tagName?.toLocaleLowerCase()) ||
					app.isIn('select.editing_shape')
				) {
					return
				}
				preventDefault(e2)
			}
		}
		elm.addEventListener('touchstart', handleEvent)
		elm.addEventListener('touchend', handleEvent)
		return () => {
			elm.removeEventListener('touchstart', handleEvent)
			elm.addEventListener('touchend', handleEvent)
		}
	}, [app, ref])
}

// ../packages/editor/src/lib/hooks/useGestureEvents.ts
init_define_process()

// ../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
init_define_process()

// ../node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js
init_define_process()

// ../node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js
init_define_process()

// ../node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js
init_define_process()
function clamp2(v3, min2, max) {
	return Math.max(min2, Math.min(v3, max))
}
var V = {
	toVector(v3, fallback) {
		if (v3 === void 0) v3 = fallback
		return Array.isArray(v3) ? v3 : [v3, v3]
	},
	add(v1, v22) {
		return [v1[0] + v22[0], v1[1] + v22[1]]
	},
	sub(v1, v22) {
		return [v1[0] - v22[0], v1[1] - v22[1]]
	},
	addTo(v1, v22) {
		v1[0] += v22[0]
		v1[1] += v22[1]
	},
	subTo(v1, v22) {
		v1[0] -= v22[0]
		v1[1] -= v22[1]
	},
}
function rubberband(distance, dimension, constant) {
	if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5)
	return (distance * dimension * constant) / (dimension + constant * distance)
}
function rubberbandIfOutOfBounds(position, min2, max, constant = 0.15) {
	if (constant === 0) return clamp2(position, min2, max)
	if (position < min2) return -rubberband(min2 - position, max - min2, constant) + min2
	if (position > max) return +rubberband(position - max, max - min2, constant) + max
	return position
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
	const [[X0, X1], [Y0, Y1]] = bounds
	return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)]
}

// ../node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js
function _toPrimitive(input, hint) {
	if (typeof input !== 'object' || input === null) return input
	var prim = input[Symbol.toPrimitive]
	if (prim !== void 0) {
		var res = prim.call(input, hint || 'default')
		if (typeof res !== 'object') return res
		throw new TypeError('@@toPrimitive must return a primitive value.')
	}
	return (hint === 'string' ? String : Number)(input)
}
function _toPropertyKey(arg) {
	var key = _toPrimitive(arg, 'string')
	return typeof key === 'symbol' ? key : String(key)
}
function _defineProperty(obj, key, value) {
	key = _toPropertyKey(key)
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true,
		})
	} else {
		obj[key] = value
	}
	return obj
}
function ownKeys(object2, enumerableOnly) {
	var keys = Object.keys(object2)
	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object2)
		enumerableOnly &&
			(symbols = symbols.filter(function (sym) {
				return Object.getOwnPropertyDescriptor(object2, sym).enumerable
			})),
			keys.push.apply(keys, symbols)
	}
	return keys
}
function _objectSpread2(target) {
	for (var i3 = 1; i3 < arguments.length; i3++) {
		var source = null != arguments[i3] ? arguments[i3] : {}
		i3 % 2
			? ownKeys(Object(source), true).forEach(function (key) {
					_defineProperty(target, key, source[key])
			  })
			: Object.getOwnPropertyDescriptors
			? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))
			: ownKeys(Object(source)).forEach(function (key) {
					Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key))
			  })
	}
	return target
}
var EVENT_TYPE_MAP = {
	pointer: {
		start: 'down',
		change: 'move',
		end: 'up',
	},
	mouse: {
		start: 'down',
		change: 'move',
		end: 'up',
	},
	touch: {
		start: 'start',
		change: 'move',
		end: 'end',
	},
	gesture: {
		start: 'start',
		change: 'change',
		end: 'end',
	},
}
function capitalize(string2) {
	if (!string2) return ''
	return string2[0].toUpperCase() + string2.slice(1)
}
var actionsWithoutCaptureSupported = ['enter', 'leave']
function hasCapture(capture = false, actionKey) {
	return capture && !actionsWithoutCaptureSupported.includes(actionKey)
}
function toHandlerProp(device, action = '', capture = false) {
	const deviceProps = EVENT_TYPE_MAP[device]
	const actionKey = deviceProps ? deviceProps[action] || action : action
	return (
		'on' +
		capitalize(device) +
		capitalize(actionKey) +
		(hasCapture(capture, actionKey) ? 'Capture' : '')
	)
}
var pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture']
function parseProp(prop) {
	let eventKey = prop.substring(2).toLowerCase()
	const passive = !!~eventKey.indexOf('passive')
	if (passive) eventKey = eventKey.replace('passive', '')
	const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture'
	const capture = !!~eventKey.indexOf(captureKey)
	if (capture) eventKey = eventKey.replace('capture', '')
	return {
		device: eventKey,
		capture,
		passive,
	}
}
function toDomEventType(device, action = '') {
	const deviceProps = EVENT_TYPE_MAP[device]
	const actionKey = deviceProps ? deviceProps[action] || action : action
	return device + actionKey
}
function isTouch(event) {
	return 'touches' in event
}
function getPointerType(event) {
	if (isTouch(event)) return 'touch'
	if ('pointerType' in event) return event.pointerType
	return 'mouse'
}
function getCurrentTargetTouchList(event) {
	return Array.from(event.touches).filter((e2) => {
		var _event$currentTarget, _event$currentTarget$
		return (
			e2.target === event.currentTarget ||
			((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0
				? void 0
				: (_event$currentTarget$ = _event$currentTarget.contains) === null ||
				  _event$currentTarget$ === void 0
				? void 0
				: _event$currentTarget$.call(_event$currentTarget, e2.target))
		)
	})
}
function distanceAngle(P1, P2) {
	try {
		const dx = P2.clientX - P1.clientX
		const dy = P2.clientY - P1.clientY
		const cx = (P2.clientX + P1.clientX) / 2
		const cy = (P2.clientY + P1.clientY) / 2
		const distance = Math.hypot(dx, dy)
		const angle = -(Math.atan2(dx, dy) * 180) / Math.PI
		const origin = [cx, cy]
		return {
			angle,
			distance,
			origin,
		}
	} catch (_unused) {}
	return null
}
function touchIds(event) {
	return getCurrentTargetTouchList(event).map((touch) => touch.identifier)
}
function touchDistanceAngle(event, ids) {
	const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier))
	return distanceAngle(P1, P2)
}
var LINE_HEIGHT = 40
var PAGE_HEIGHT = 800
function wheelValues(event) {
	let { deltaX, deltaY, deltaMode } = event
	if (deltaMode === 1) {
		deltaX *= LINE_HEIGHT
		deltaY *= LINE_HEIGHT
	} else if (deltaMode === 2) {
		deltaX *= PAGE_HEIGHT
		deltaY *= PAGE_HEIGHT
	}
	return [deltaX, deltaY]
}
function getEventDetails(event) {
	const payload = {}
	if ('buttons' in event) payload.buttons = event.buttons
	if ('shiftKey' in event) {
		const { shiftKey, altKey: altKey2, metaKey, ctrlKey } = event
		Object.assign(payload, {
			shiftKey,
			altKey: altKey2,
			metaKey,
			ctrlKey,
		})
	}
	return payload
}
function call(v3, ...args) {
	if (typeof v3 === 'function') {
		return v3(...args)
	} else {
		return v3
	}
}
function noop() {}
function chain(...fns) {
	if (fns.length === 0) return noop
	if (fns.length === 1) return fns[0]
	return function () {
		let result
		for (const fn of fns) {
			result = fn.apply(this, arguments) || result
		}
		return result
	}
}
function assignDefault(value, fallback) {
	return Object.assign({}, fallback, value || {})
}
var BEFORE_LAST_KINEMATICS_DELAY = 32
var Engine = class {
	constructor(ctrl, args, key) {
		this.ctrl = ctrl
		this.args = args
		this.key = key
		if (!this.state) {
			this.state = {}
			this.computeValues([0, 0])
			this.computeInitial()
			if (this.init) this.init()
			this.reset()
		}
	}
	get state() {
		return this.ctrl.state[this.key]
	}
	set state(state) {
		this.ctrl.state[this.key] = state
	}
	get shared() {
		return this.ctrl.state.shared
	}
	get eventStore() {
		return this.ctrl.gestureEventStores[this.key]
	}
	get timeoutStore() {
		return this.ctrl.gestureTimeoutStores[this.key]
	}
	get config() {
		return this.ctrl.config[this.key]
	}
	get sharedConfig() {
		return this.ctrl.config.shared
	}
	get handler() {
		return this.ctrl.handlers[this.key]
	}
	reset() {
		const { state, shared, ingKey, args } = this
		shared[ingKey] = state._active = state.active = state._blocked = state._force = false
		state._step = [false, false]
		state.intentional = false
		state._movement = [0, 0]
		state._distance = [0, 0]
		state._direction = [0, 0]
		state._delta = [0, 0]
		state._bounds = [
			[-Infinity, Infinity],
			[-Infinity, Infinity],
		]
		state.args = args
		state.axis = void 0
		state.memo = void 0
		state.elapsedTime = state.timeDelta = 0
		state.direction = [0, 0]
		state.distance = [0, 0]
		state.overflow = [0, 0]
		state._movementBound = [false, false]
		state.velocity = [0, 0]
		state.movement = [0, 0]
		state.delta = [0, 0]
		state.timeStamp = 0
	}
	start(event) {
		const state = this.state
		const config = this.config
		if (!state._active) {
			this.reset()
			this.computeInitial()
			state._active = true
			state.target = event.target
			state.currentTarget = event.currentTarget
			state.lastOffset = config.from ? call(config.from, state) : state.offset
			state.offset = state.lastOffset
			state.startTime = state.timeStamp = event.timeStamp
		}
	}
	computeValues(values) {
		const state = this.state
		state._values = values
		state.values = this.config.transform(values)
	}
	computeInitial() {
		const state = this.state
		state._initial = state._values
		state.initial = state.values
	}
	compute(event) {
		const { state, config, shared } = this
		state.args = this.args
		let dt = 0
		if (event) {
			state.event = event
			if (config.preventDefault && event.cancelable) state.event.preventDefault()
			state.type = event.type
			shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size
			shared.locked = !!document.pointerLockElement
			Object.assign(shared, getEventDetails(event))
			shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0
			dt = event.timeStamp - state.timeStamp
			state.timeStamp = event.timeStamp
			state.elapsedTime = state.timeStamp - state.startTime
		}
		if (state._active) {
			const _absoluteDelta = state._delta.map(Math.abs)
			V.addTo(state._distance, _absoluteDelta)
		}
		if (this.axisIntent) this.axisIntent(event)
		const [_m0, _m1] = state._movement
		const [t0, t1] = config.threshold
		const { _step, values } = state
		if (config.hasCustomTransform) {
			if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0]
			if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1]
		} else {
			if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0
			if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1
		}
		state.intentional = _step[0] !== false || _step[1] !== false
		if (!state.intentional) return
		const movement = [0, 0]
		if (config.hasCustomTransform) {
			const [v0, v1] = values
			movement[0] = _step[0] !== false ? v0 - _step[0] : 0
			movement[1] = _step[1] !== false ? v1 - _step[1] : 0
		} else {
			movement[0] = _step[0] !== false ? _m0 - _step[0] : 0
			movement[1] = _step[1] !== false ? _m1 - _step[1] : 0
		}
		if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement)
		const previousOffset = state.offset
		const gestureIsActive = (state._active && !state._blocked) || state.active
		if (gestureIsActive) {
			state.first = state._active && !state.active
			state.last = !state._active && state.active
			state.active = shared[this.ingKey] = state._active
			if (event) {
				if (state.first) {
					if ('bounds' in config) state._bounds = call(config.bounds, state)
					if (this.setup) this.setup()
				}
				state.movement = movement
				this.computeOffset()
			}
		}
		const [ox, oy] = state.offset
		const [[x0, x1], [y0, y1]] = state._bounds
		state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0]
		state._movementBound[0] = state.overflow[0]
			? state._movementBound[0] === false
				? state._movement[0]
				: state._movementBound[0]
			: false
		state._movementBound[1] = state.overflow[1]
			? state._movementBound[1] === false
				? state._movement[1]
				: state._movementBound[1]
			: false
		const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0]
		state.offset = computeRubberband(state._bounds, state.offset, rubberband2)
		state.delta = V.sub(state.offset, previousOffset)
		this.computeMovement()
		if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
			state.delta = V.sub(state.offset, previousOffset)
			const absoluteDelta = state.delta.map(Math.abs)
			V.addTo(state.distance, absoluteDelta)
			state.direction = state.delta.map(Math.sign)
			state._direction = state._delta.map(Math.sign)
			if (!state.first && dt > 0) {
				state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt]
				state.timeDelta = dt
			}
		}
	}
	emit() {
		const state = this.state
		const shared = this.shared
		const config = this.config
		if (!state._active) this.clean()
		if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return
		const memo27 = this.handler(
			_objectSpread2(
				_objectSpread2(_objectSpread2({}, shared), state),
				{},
				{
					[this.aliasKey]: state.values,
				}
			)
		)
		if (memo27 !== void 0) state.memo = memo27
	}
	clean() {
		this.eventStore.clean()
		this.timeoutStore.clean()
	}
}
function selectAxis([dx, dy], threshold) {
	const absDx = Math.abs(dx)
	const absDy = Math.abs(dy)
	if (absDx > absDy && absDx > threshold) {
		return 'x'
	}
	if (absDy > absDx && absDy > threshold) {
		return 'y'
	}
	return void 0
}
var CoordinatesEngine = class extends Engine {
	constructor(...args) {
		super(...args)
		_defineProperty(this, 'aliasKey', 'xy')
	}
	reset() {
		super.reset()
		this.state.axis = void 0
	}
	init() {
		this.state.offset = [0, 0]
		this.state.lastOffset = [0, 0]
	}
	computeOffset() {
		this.state.offset = V.add(this.state.lastOffset, this.state.movement)
	}
	computeMovement() {
		this.state.movement = V.sub(this.state.offset, this.state.lastOffset)
	}
	axisIntent(event) {
		const state = this.state
		const config = this.config
		if (!state.axis && event) {
			const threshold =
				typeof config.axisThreshold === 'object'
					? config.axisThreshold[getPointerType(event)]
					: config.axisThreshold
			state.axis = selectAxis(state._movement, threshold)
		}
		state._blocked =
			((config.lockDirection || !!config.axis) && !state.axis) ||
			(!!config.axis && config.axis !== state.axis)
	}
	restrictToAxis(v3) {
		if (this.config.axis || this.config.lockDirection) {
			switch (this.state.axis) {
				case 'x':
					v3[1] = 0
					break
				case 'y':
					v3[0] = 0
					break
			}
		}
	}
}
var identity = (v3) => v3
var DEFAULT_RUBBERBAND = 0.15
var commonConfigResolver = {
	enabled(value = true) {
		return value
	},
	eventOptions(value, _k, config) {
		return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value)
	},
	preventDefault(value = false) {
		return value
	},
	triggerAllEvents(value = false) {
		return value
	},
	rubberband(value = 0) {
		switch (value) {
			case true:
				return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND]
			case false:
				return [0, 0]
			default:
				return V.toVector(value)
		}
	},
	from(value) {
		if (typeof value === 'function') return value
		if (value != null) return V.toVector(value)
	},
	transform(value, _k, config) {
		const transform = value || config.shared.transform
		this.hasCustomTransform = !!transform
		if (define_process_default.env.NODE_ENV === 'development') {
			const originalTransform = transform || identity
			return (v3) => {
				const r3 = originalTransform(v3)
				if (!isFinite(r3[0]) || !isFinite(r3[1])) {
					console.warn(
						`[@use-gesture]: config.transform() must produce a valid result, but it was: [${
							r3[0]
						},${[1]}]`
					)
				}
				return r3
			}
		}
		return transform || identity
	},
	threshold(value) {
		return V.toVector(value, 0)
	},
}
if (define_process_default.env.NODE_ENV === 'development') {
	Object.assign(commonConfigResolver, {
		domTarget(value) {
			if (value !== void 0) {
				throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`)
			}
			return NaN
		},
		lockDirection(value) {
			if (value !== void 0) {
				throw Error(
					`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``
				)
			}
			return NaN
		},
		initial(value) {
			if (value !== void 0) {
				throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`)
			}
			return NaN
		},
	})
}
var DEFAULT_AXIS_THRESHOLD = 0
var coordinatesConfigResolver = _objectSpread2(
	_objectSpread2({}, commonConfigResolver),
	{},
	{
		axis(_v, _k, { axis }) {
			this.lockDirection = axis === 'lock'
			if (!this.lockDirection) return axis
		},
		axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
			return value
		},
		bounds(value = {}) {
			if (typeof value === 'function') {
				return (state) => coordinatesConfigResolver.bounds(value(state))
			}
			if ('current' in value) {
				return () => value.current
			}
			if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {
				return value
			}
			const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value
			return [
				[left, right],
				[top, bottom],
			]
		},
	}
)
var isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement
function supportsTouchEvents() {
	return isBrowser && 'ontouchstart' in window
}
function isTouchScreen() {
	return supportsTouchEvents() || (isBrowser && window.navigator.maxTouchPoints > 1)
}
function supportsPointerEvents() {
	return isBrowser && 'onpointerdown' in window
}
function supportsPointerLock() {
	return isBrowser && 'exitPointerLock' in window.document
}
function supportsGestureEvents() {
	try {
		return 'constructor' in GestureEvent
	} catch (e2) {
		return false
	}
}
var SUPPORT = {
	isBrowser,
	gesture: supportsGestureEvents(),
	touch: isTouchScreen(),
	touchscreen: isTouchScreen(),
	pointer: supportsPointerEvents(),
	pointerLock: supportsPointerLock(),
}
var DEFAULT_PREVENT_SCROLL_DELAY = 250
var DEFAULT_DRAG_DELAY = 180
var DEFAULT_SWIPE_VELOCITY = 0.5
var DEFAULT_SWIPE_DISTANCE = 50
var DEFAULT_SWIPE_DURATION = 250
var DEFAULT_KEYBOARD_DISPLACEMENT = 10
var DEFAULT_DRAG_AXIS_THRESHOLD = {
	mouse: 0,
	touch: 0,
	pen: 8,
}
var dragConfigResolver = _objectSpread2(
	_objectSpread2({}, coordinatesConfigResolver),
	{},
	{
		device(_v, _k, { pointer: { touch = false, lock = false, mouse = false } = {} }) {
			this.pointerLock = lock && SUPPORT.pointerLock
			if (SUPPORT.touch && touch) return 'touch'
			if (this.pointerLock) return 'mouse'
			if (SUPPORT.pointer && !mouse) return 'pointer'
			if (SUPPORT.touch) return 'touch'
			return 'mouse'
		},
		preventScrollAxis(value, _k, { preventScroll }) {
			this.preventScrollDelay =
				typeof preventScroll === 'number'
					? preventScroll
					: preventScroll || (preventScroll === void 0 && value)
					? DEFAULT_PREVENT_SCROLL_DELAY
					: void 0
			if (!SUPPORT.touchscreen || preventScroll === false) return void 0
			return value ? value : preventScroll !== void 0 ? 'y' : void 0
		},
		pointerCapture(_v, _k, { pointer: { capture = true, buttons = 1, keys = true } = {} }) {
			this.pointerButtons = buttons
			this.keys = keys
			return !this.pointerLock && this.device === 'pointer' && capture
		},
		threshold(value, _k, { filterTaps = false, tapsThreshold = 3, axis = void 0 }) {
			const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0)
			this.filterTaps = filterTaps
			this.tapsThreshold = tapsThreshold
			return threshold
		},
		swipe({
			velocity = DEFAULT_SWIPE_VELOCITY,
			distance = DEFAULT_SWIPE_DISTANCE,
			duration = DEFAULT_SWIPE_DURATION,
		} = {}) {
			return {
				velocity: this.transform(V.toVector(velocity)),
				distance: this.transform(V.toVector(distance)),
				duration,
			}
		},
		delay(value = 0) {
			switch (value) {
				case true:
					return DEFAULT_DRAG_DELAY
				case false:
					return 0
				default:
					return value
			}
		},
		axisThreshold(value) {
			if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD
			return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value)
		},
		keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
			return value
		},
	}
)
if (define_process_default.env.NODE_ENV === 'development') {
	Object.assign(dragConfigResolver, {
		useTouch(value) {
			if (value !== void 0) {
				throw Error(
					`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`
				)
			}
			return NaN
		},
		experimental_preventWindowScrollY(value) {
			if (value !== void 0) {
				throw Error(
					`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`
				)
			}
			return NaN
		},
		swipeVelocity(value) {
			if (value !== void 0) {
				throw Error(
					`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`
				)
			}
			return NaN
		},
		swipeDistance(value) {
			if (value !== void 0) {
				throw Error(
					`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`
				)
			}
			return NaN
		},
		swipeDuration(value) {
			if (value !== void 0) {
				throw Error(
					`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`
				)
			}
			return NaN
		},
	})
}
function clampStateInternalMovementToBounds(state) {
	const [ox, oy] = state.overflow
	const [dx, dy] = state._delta
	const [dirx, diry] = state._direction
	if ((ox < 0 && dx > 0 && dirx < 0) || (ox > 0 && dx < 0 && dirx > 0)) {
		state._movement[0] = state._movementBound[0]
	}
	if ((oy < 0 && dy > 0 && diry < 0) || (oy > 0 && dy < 0 && diry > 0)) {
		state._movement[1] = state._movementBound[1]
	}
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30
var PINCH_WHEEL_RATIO = 100
var PinchEngine = class extends Engine {
	constructor(...args) {
		super(...args)
		_defineProperty(this, 'ingKey', 'pinching')
		_defineProperty(this, 'aliasKey', 'da')
	}
	init() {
		this.state.offset = [1, 0]
		this.state.lastOffset = [1, 0]
		this.state._pointerEvents = /* @__PURE__ */ new Map()
	}
	reset() {
		super.reset()
		const state = this.state
		state._touchIds = []
		state.canceled = false
		state.cancel = this.cancel.bind(this)
		state.turns = 0
	}
	computeOffset() {
		const { type, movement, lastOffset } = this.state
		if (type === 'wheel') {
			this.state.offset = V.add(movement, lastOffset)
		} else {
			this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]]
		}
	}
	computeMovement() {
		const { offset, lastOffset } = this.state
		this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]]
	}
	axisIntent() {
		const state = this.state
		const [_m0, _m1] = state._movement
		if (!state.axis) {
			const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1)
			if (axisMovementDifference < 0) state.axis = 'angle'
			else if (axisMovementDifference > 0) state.axis = 'scale'
		}
	}
	restrictToAxis(v3) {
		if (this.config.lockDirection) {
			if (this.state.axis === 'scale') v3[1] = 0
			else if (this.state.axis === 'angle') v3[0] = 0
		}
	}
	cancel() {
		const state = this.state
		if (state.canceled) return
		setTimeout(() => {
			state.canceled = true
			state._active = false
			this.compute()
			this.emit()
		}, 0)
	}
	touchStart(event) {
		this.ctrl.setEventIds(event)
		const state = this.state
		const ctrlTouchIds = this.ctrl.touchIds
		if (state._active) {
			if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return
		}
		if (ctrlTouchIds.size < 2) return
		this.start(event)
		state._touchIds = Array.from(ctrlTouchIds).slice(0, 2)
		const payload = touchDistanceAngle(event, state._touchIds)
		if (!payload) return
		this.pinchStart(event, payload)
	}
	pointerStart(event) {
		if (event.buttons != null && event.buttons % 2 !== 1) return
		this.ctrl.setEventIds(event)
		event.target.setPointerCapture(event.pointerId)
		const state = this.state
		const _pointerEvents = state._pointerEvents
		const ctrlPointerIds = this.ctrl.pointerIds
		if (state._active) {
			if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return
		}
		if (_pointerEvents.size < 2) {
			_pointerEvents.set(event.pointerId, event)
		}
		if (state._pointerEvents.size < 2) return
		this.start(event)
		const payload = distanceAngle(...Array.from(_pointerEvents.values()))
		if (!payload) return
		this.pinchStart(event, payload)
	}
	pinchStart(event, payload) {
		const state = this.state
		state.origin = payload.origin
		this.computeValues([payload.distance, payload.angle])
		this.computeInitial()
		this.compute(event)
		this.emit()
	}
	touchMove(event) {
		if (!this.state._active) return
		const payload = touchDistanceAngle(event, this.state._touchIds)
		if (!payload) return
		this.pinchMove(event, payload)
	}
	pointerMove(event) {
		const _pointerEvents = this.state._pointerEvents
		if (_pointerEvents.has(event.pointerId)) {
			_pointerEvents.set(event.pointerId, event)
		}
		if (!this.state._active) return
		const payload = distanceAngle(...Array.from(_pointerEvents.values()))
		if (!payload) return
		this.pinchMove(event, payload)
	}
	pinchMove(event, payload) {
		const state = this.state
		const prev_a = state._values[1]
		const delta_a = payload.angle - prev_a
		let delta_turns = 0
		if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a)
		this.computeValues([payload.distance, payload.angle - 360 * delta_turns])
		state.origin = payload.origin
		state.turns = delta_turns
		state._movement = [
			state._values[0] / state._initial[0] - 1,
			state._values[1] - state._initial[1],
		]
		this.compute(event)
		this.emit()
	}
	touchEnd(event) {
		this.ctrl.setEventIds(event)
		if (!this.state._active) return
		if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
			this.state._active = false
			this.compute(event)
			this.emit()
		}
	}
	pointerEnd(event) {
		const state = this.state
		this.ctrl.setEventIds(event)
		try {
			event.target.releasePointerCapture(event.pointerId)
		} catch (_unused) {}
		if (state._pointerEvents.has(event.pointerId)) {
			state._pointerEvents.delete(event.pointerId)
		}
		if (!state._active) return
		if (state._pointerEvents.size < 2) {
			state._active = false
			this.compute(event)
			this.emit()
		}
	}
	gestureStart(event) {
		if (event.cancelable) event.preventDefault()
		const state = this.state
		if (state._active) return
		this.start(event)
		this.computeValues([event.scale, event.rotation])
		state.origin = [event.clientX, event.clientY]
		this.compute(event)
		this.emit()
	}
	gestureMove(event) {
		if (event.cancelable) event.preventDefault()
		if (!this.state._active) return
		const state = this.state
		this.computeValues([event.scale, event.rotation])
		state.origin = [event.clientX, event.clientY]
		const _previousMovement = state._movement
		state._movement = [event.scale - 1, event.rotation]
		state._delta = V.sub(state._movement, _previousMovement)
		this.compute(event)
		this.emit()
	}
	gestureEnd(event) {
		if (!this.state._active) return
		this.state._active = false
		this.compute(event)
		this.emit()
	}
	wheel(event) {
		const modifierKey = this.config.modifierKey
		if (modifierKey && !event[modifierKey]) return
		if (!this.state._active) this.wheelStart(event)
		else this.wheelChange(event)
		this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this))
	}
	wheelStart(event) {
		this.start(event)
		this.wheelChange(event)
	}
	wheelChange(event) {
		const isR3f = 'uv' in event
		if (!isR3f) {
			if (event.cancelable) {
				event.preventDefault()
			}
			if (define_process_default.env.NODE_ENV === 'development' && !event.defaultPrevented) {
				console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`)
			}
		}
		const state = this.state
		state._delta = [(-wheelValues(event)[1] / PINCH_WHEEL_RATIO) * state.offset[0], 0]
		V.addTo(state._movement, state._delta)
		clampStateInternalMovementToBounds(state)
		this.state.origin = [event.clientX, event.clientY]
		this.compute(event)
		this.emit()
	}
	wheelEnd() {
		if (!this.state._active) return
		this.state._active = false
		this.compute()
		this.emit()
	}
	bind(bindFunction) {
		const device = this.config.device
		if (!!device) {
			bindFunction(device, 'start', this[device + 'Start'].bind(this))
			bindFunction(device, 'change', this[device + 'Move'].bind(this))
			bindFunction(device, 'end', this[device + 'End'].bind(this))
			bindFunction(device, 'cancel', this[device + 'End'].bind(this))
			bindFunction('lostPointerCapture', '', this[device + 'End'].bind(this))
		}
		if (this.config.pinchOnWheel) {
			bindFunction('wheel', '', this.wheel.bind(this), {
				passive: false,
			})
		}
	}
}
var pinchConfigResolver = _objectSpread2(
	_objectSpread2({}, commonConfigResolver),
	{},
	{
		device(_v, _k, { shared, pointer: { touch = false } = {} }) {
			const sharedConfig = shared
			if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture'
			if (SUPPORT.touch && touch) return 'touch'
			if (SUPPORT.touchscreen) {
				if (SUPPORT.pointer) return 'pointer'
				if (SUPPORT.touch) return 'touch'
			}
		},
		bounds(_v, _k, { scaleBounds = {}, angleBounds = {} }) {
			const _scaleBounds = (state) => {
				const D3 = assignDefault(call(scaleBounds, state), {
					min: -Infinity,
					max: Infinity,
				})
				return [D3.min, D3.max]
			}
			const _angleBounds = (state) => {
				const A2 = assignDefault(call(angleBounds, state), {
					min: -Infinity,
					max: Infinity,
				})
				return [A2.min, A2.max]
			}
			if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function')
				return [_scaleBounds(), _angleBounds()]
			return (state) => [_scaleBounds(state), _angleBounds(state)]
		},
		threshold(value, _k, config) {
			this.lockDirection = config.axis === 'lock'
			const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0)
			return threshold
		},
		modifierKey(value) {
			if (value === void 0) return 'ctrlKey'
			return value
		},
		pinchOnWheel(value = true) {
			return value
		},
	}
)
var moveConfigResolver = _objectSpread2(
	_objectSpread2({}, coordinatesConfigResolver),
	{},
	{
		mouseOnly: (value = true) => value,
	}
)
var WheelEngine = class extends CoordinatesEngine {
	constructor(...args) {
		super(...args)
		_defineProperty(this, 'ingKey', 'wheeling')
	}
	wheel(event) {
		if (!this.state._active) this.start(event)
		this.wheelChange(event)
		this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this))
	}
	wheelChange(event) {
		const state = this.state
		state._delta = wheelValues(event)
		V.addTo(state._movement, state._delta)
		clampStateInternalMovementToBounds(state)
		this.compute(event)
		this.emit()
	}
	wheelEnd() {
		if (!this.state._active) return
		this.state._active = false
		this.compute()
		this.emit()
	}
	bind(bindFunction) {
		bindFunction('wheel', '', this.wheel.bind(this))
	}
}
var wheelConfigResolver = coordinatesConfigResolver
var hoverConfigResolver = _objectSpread2(
	_objectSpread2({}, coordinatesConfigResolver),
	{},
	{
		mouseOnly: (value = true) => value,
	}
)
var EngineMap = /* @__PURE__ */ new Map()
var ConfigResolverMap = /* @__PURE__ */ new Map()
function registerAction(action) {
	EngineMap.set(action.key, action.engine)
	ConfigResolverMap.set(action.key, action.resolver)
}
var pinchAction = {
	key: 'pinch',
	engine: PinchEngine,
	resolver: pinchConfigResolver,
}
var wheelAction = {
	key: 'wheel',
	engine: WheelEngine,
	resolver: wheelConfigResolver,
}

// ../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react25 = __toESM(require_react())

// ../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
init_define_process()
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {}
	var target = {}
	var sourceKeys = Object.keys(source)
	var key, i3
	for (i3 = 0; i3 < sourceKeys.length; i3++) {
		key = sourceKeys[i3]
		if (excluded.indexOf(key) >= 0) continue
		target[key] = source[key]
	}
	return target
}
function _objectWithoutProperties(source, excluded) {
	if (source == null) return {}
	var target = _objectWithoutPropertiesLoose(source, excluded)
	var key, i3
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source)
		for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
			key = sourceSymbolKeys[i3]
			if (excluded.indexOf(key) >= 0) continue
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue
			target[key] = source[key]
		}
	}
	return target
}
var sharedConfigResolver = {
	target(value) {
		if (value) {
			return () => ('current' in value ? value.current : value)
		}
		return void 0
	},
	enabled(value = true) {
		return value
	},
	window(value = SUPPORT.isBrowser ? window : void 0) {
		return value
	},
	eventOptions({ passive = true, capture = false } = {}) {
		return {
			passive,
			capture,
		}
	},
	transform(value) {
		return value
	},
}
var _excluded = ['target', 'eventOptions', 'window', 'enabled', 'transform']
function resolveWith(config = {}, resolvers) {
	const result = {}
	for (const [key, resolver] of Object.entries(resolvers)) {
		switch (typeof resolver) {
			case 'function':
				if (define_process_default.env.NODE_ENV === 'development') {
					const r3 = resolver.call(result, config[key], key, config)
					if (!Number.isNaN(r3)) result[key] = r3
				} else {
					result[key] = resolver.call(result, config[key], key, config)
				}
				break
			case 'object':
				result[key] = resolveWith(config[key], resolver)
				break
			case 'boolean':
				if (resolver) result[key] = config[key]
				break
		}
	}
	return result
}
function parse(newConfig, gestureKey, _config = {}) {
	const _ref = newConfig,
		{ target, eventOptions, window: window3, enabled, transform } = _ref,
		rest = _objectWithoutProperties(_ref, _excluded)
	_config.shared = resolveWith(
		{
			target,
			eventOptions,
			window: window3,
			enabled,
			transform,
		},
		sharedConfigResolver
	)
	if (gestureKey) {
		const resolver = ConfigResolverMap.get(gestureKey)
		_config[gestureKey] = resolveWith(
			_objectSpread2(
				{
					shared: _config.shared,
				},
				rest
			),
			resolver
		)
	} else {
		for (const key in rest) {
			const resolver = ConfigResolverMap.get(key)
			if (resolver) {
				_config[key] = resolveWith(
					_objectSpread2(
						{
							shared: _config.shared,
						},
						rest[key]
					),
					resolver
				)
			} else if (define_process_default.env.NODE_ENV === 'development') {
				if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {
					if (key === 'domTarget') {
						throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`)
					}
					console.warn(
						`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`
					)
				}
			}
		}
	}
	return _config
}
var EventStore = class {
	constructor(ctrl, gestureKey) {
		_defineProperty(this, '_listeners', /* @__PURE__ */ new Set())
		this._ctrl = ctrl
		this._gestureKey = gestureKey
	}
	add(element, device, action, handler, options) {
		const listeners = this._listeners
		const type = toDomEventType(device, action)
		const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}
		const eventOptions = _objectSpread2(_objectSpread2({}, _options), options)
		element.addEventListener(type, handler, eventOptions)
		const remove = () => {
			element.removeEventListener(type, handler, eventOptions)
			listeners.delete(remove)
		}
		listeners.add(remove)
		return remove
	}
	clean() {
		this._listeners.forEach((remove) => remove())
		this._listeners.clear()
	}
}
var TimeoutStore = class {
	constructor() {
		_defineProperty(this, '_timeouts', /* @__PURE__ */ new Map())
	}
	add(key, callback, ms = 140, ...args) {
		this.remove(key)
		this._timeouts.set(key, window.setTimeout(callback, ms, ...args))
	}
	remove(key) {
		const timeout = this._timeouts.get(key)
		if (timeout) window.clearTimeout(timeout)
	}
	clean() {
		this._timeouts.forEach((timeout) => void window.clearTimeout(timeout))
		this._timeouts.clear()
	}
}
var Controller = class {
	constructor(handlers) {
		_defineProperty(this, 'gestures', /* @__PURE__ */ new Set())
		_defineProperty(this, '_targetEventStore', new EventStore(this))
		_defineProperty(this, 'gestureEventStores', {})
		_defineProperty(this, 'gestureTimeoutStores', {})
		_defineProperty(this, 'handlers', {})
		_defineProperty(this, 'config', {})
		_defineProperty(this, 'pointerIds', /* @__PURE__ */ new Set())
		_defineProperty(this, 'touchIds', /* @__PURE__ */ new Set())
		_defineProperty(this, 'state', {
			shared: {
				shiftKey: false,
				metaKey: false,
				ctrlKey: false,
				altKey: false,
			},
		})
		resolveGestures(this, handlers)
	}
	setEventIds(event) {
		if (isTouch(event)) {
			this.touchIds = new Set(touchIds(event))
			return this.touchIds
		} else if ('pointerId' in event) {
			if (event.type === 'pointerup' || event.type === 'pointercancel')
				this.pointerIds.delete(event.pointerId)
			else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId)
			return this.pointerIds
		}
	}
	applyHandlers(handlers, nativeHandlers) {
		this.handlers = handlers
		this.nativeHandlers = nativeHandlers
	}
	applyConfig(config, gestureKey) {
		this.config = parse(config, gestureKey, this.config)
	}
	clean() {
		this._targetEventStore.clean()
		for (const key of this.gestures) {
			this.gestureEventStores[key].clean()
			this.gestureTimeoutStores[key].clean()
		}
	}
	effect() {
		if (this.config.shared.target) this.bind()
		return () => this._targetEventStore.clean()
	}
	bind(...args) {
		const sharedConfig = this.config.shared
		const props = {}
		let target
		if (sharedConfig.target) {
			target = sharedConfig.target()
			if (!target) return
		}
		if (sharedConfig.enabled) {
			for (const gestureKey of this.gestures) {
				const gestureConfig = this.config[gestureKey]
				const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target)
				if (gestureConfig.enabled) {
					const Engine2 = EngineMap.get(gestureKey)
					new Engine2(this, args, gestureKey).bind(bindFunction)
				}
			}
			const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target)
			for (const eventKey in this.nativeHandlers) {
				nativeBindFunction(
					eventKey,
					'',
					(event) =>
						this.nativeHandlers[eventKey](
							_objectSpread2(
								_objectSpread2({}, this.state.shared),
								{},
								{
									event,
									args,
								}
							)
						),
					void 0,
					true
				)
			}
		}
		for (const handlerProp in props) {
			props[handlerProp] = chain(...props[handlerProp])
		}
		if (!target) return props
		for (const handlerProp in props) {
			const { device, capture, passive } = parseProp(handlerProp)
			this._targetEventStore.add(target, device, '', props[handlerProp], {
				capture,
				passive,
			})
		}
	}
}
function setupGesture(ctrl, gestureKey) {
	ctrl.gestures.add(gestureKey)
	ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey)
	ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore()
}
function resolveGestures(ctrl, internalHandlers) {
	if (internalHandlers.drag) setupGesture(ctrl, 'drag')
	if (internalHandlers.wheel) setupGesture(ctrl, 'wheel')
	if (internalHandlers.scroll) setupGesture(ctrl, 'scroll')
	if (internalHandlers.move) setupGesture(ctrl, 'move')
	if (internalHandlers.pinch) setupGesture(ctrl, 'pinch')
	if (internalHandlers.hover) setupGesture(ctrl, 'hover')
}
var bindToProps =
	(props, eventOptions, withPassiveOption) =>
	(device, action, handler, options = {}, isNative = false) => {
		var _options$capture, _options$passive
		const capture =
			(_options$capture = options.capture) !== null && _options$capture !== void 0
				? _options$capture
				: eventOptions.capture
		const passive =
			(_options$passive = options.passive) !== null && _options$passive !== void 0
				? _options$passive
				: eventOptions.passive
		let handlerProp = isNative ? device : toHandlerProp(device, action, capture)
		if (withPassiveOption && passive) handlerProp += 'Passive'
		props[handlerProp] = props[handlerProp] || []
		props[handlerProp].push(handler)
	}
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/
function sortHandlers(_handlers2) {
	const native = {}
	const handlers = {}
	const actions = /* @__PURE__ */ new Set()
	for (let key in _handlers2) {
		if (RE_NOT_NATIVE.test(key)) {
			actions.add(RegExp.lastMatch)
			handlers[key] = _handlers2[key]
		} else {
			native[key] = _handlers2[key]
		}
	}
	return [handlers, native, actions]
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
	if (!actions.has(handlerKey)) return
	if (!EngineMap.has(key)) {
		if (define_process_default.env.NODE_ENV === 'development') {
			console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`)
		}
		return
	}
	const startKey = handlerKey + 'Start'
	const endKey = handlerKey + 'End'
	const fn = (state) => {
		let memo27 = void 0
		if (state.first && startKey in handlers) handlers[startKey](state)
		if (handlerKey in handlers) memo27 = handlers[handlerKey](state)
		if (state.last && endKey in handlers) handlers[endKey](state)
		return memo27
	}
	internalHandlers[key] = fn
	config[key] = config[key] || {}
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
	const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers)
	const internalHandlers = {}
	registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig)
	registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig)
	registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig)
	registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig)
	registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig)
	registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig)
	return {
		handlers: internalHandlers,
		config: mergedConfig,
		nativeHandlers,
	}
}

// ../node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js
init_define_process()

// ../node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js
init_define_process()

// ../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
	const ctrl = import_react25.default.useMemo(() => new Controller(handlers), [])
	ctrl.applyHandlers(handlers, nativeHandlers)
	ctrl.applyConfig(config, gestureKey)
	import_react25.default.useEffect(ctrl.effect.bind(ctrl))
	import_react25.default.useEffect(() => {
		return ctrl.clean.bind(ctrl)
	}, [])
	if (config.target === void 0) {
		return ctrl.bind.bind(ctrl)
	}
	return void 0
}
function createUseGesture(actions) {
	actions.forEach(registerAction)
	return function useGesture2(_handlers2, _config) {
		const { handlers, nativeHandlers, config } = parseMergedHandlers(_handlers2, _config || {})
		return useRecognizers(handlers, config, void 0, nativeHandlers)
	}
}

// ../packages/editor/src/lib/hooks/useGestureEvents.ts
var import_lodash3 = __toESM(require_lodash3())
var React14 = __toESM(require_react())

// ../packages/editor/src/lib/hooks/shared.ts
init_define_process()
var MAX_ZOOM_STEP = 10
var IS_DARWIN = /Mac|iPod|iPhone|iPad/.test(
	typeof window === 'undefined' ? 'node' : window.navigator.platform
)
function normalizeWheel(event) {
	let { deltaY, deltaX } = event
	let deltaZ = 0
	if (event.ctrlKey || event.altKey || event.metaKey) {
		const signY = Math.sign(event.deltaY)
		const absDeltaY = Math.abs(event.deltaY)
		let dy = deltaY
		if (absDeltaY > MAX_ZOOM_STEP) {
			dy = MAX_ZOOM_STEP * signY
		}
		deltaZ = dy / 100
	} else {
		if (event.shiftKey && !IS_DARWIN) {
			deltaX = deltaY
			deltaY = 0
		}
	}
	return { x: -deltaX, y: -deltaY, z: -deltaZ }
}

// ../packages/editor/src/lib/hooks/useGestureEvents.ts
var useGesture = createUseGesture([wheelAction, pinchAction])
var lastWheelTime = void 0
var isWheelEndEvent = (time) => {
	if (lastWheelTime === void 0) {
		lastWheelTime = time
		return false
	}
	if (time - lastWheelTime > 120 && time - lastWheelTime < 160) {
		lastWheelTime = time
		return true
	}
	lastWheelTime = time
	return false
}
function useGestureEvents(ref) {
	const app = useApp()
	const events = React14.useMemo(() => {
		let pinchState = null
		const onWheel = ({ event }) => {
			if (!app.isFocused) {
				return
			}
			pinchState = null
			if (isWheelEndEvent(Date.now())) {
				return
			}
			if (app.editingId) {
				const shape = app.getShapeById(app.editingId)
				if (shape) {
					const util = app.getShapeUtil(shape)
					if (util.canScroll(shape)) {
						const bounds = app.getPageBoundsById(app.editingId)
						if (bounds?.containsPoint(app.inputs.currentPagePoint)) {
							return
						}
					}
				}
			}
			preventDefault(event)
			const delta = normalizeWheel(event)
			if (delta.x === 0 && delta.y === 0) return
			const info = {
				type: 'wheel',
				name: 'wheel',
				delta,
				shiftKey: event.shiftKey,
				altKey: event.altKey,
				ctrlKey: event.metaKey || event.ctrlKey,
			}
			app.dispatch(info)
		}
		let initTouchDistance = 1
		let initZoom = 1
		let currentZoom = 1
		let currentTouchDistance = 0
		const initOrigin = new Vec2d()
		const prevOrigin = new Vec2d()
		const onPinchStart = (gesture) => {
			const elm = ref.current
			pinchState = null
			const { event, origin, da } = gesture
			if (event instanceof WheelEvent) return
			if (!(event.target === elm || elm?.contains(event.target))) return
			prevOrigin.x = origin[0]
			prevOrigin.y = origin[1]
			initOrigin.x = origin[0]
			initOrigin.y = origin[1]
			initTouchDistance = da[0]
			initZoom = app.zoomLevel
			app.dispatch({
				type: 'pinch',
				name: 'pinch_start',
				point: { x: origin[0], y: origin[1], z: app.zoomLevel },
				delta: { x: 0, y: 0 },
				shiftKey: event.shiftKey,
				altKey: event.altKey,
				ctrlKey: event.metaKey || event.ctrlKey,
			})
		}
		const updatePinchState = (0, import_lodash3.default)((type) => {
			if (pinchState === null) {
				const touchDistance = Math.abs(currentTouchDistance - initTouchDistance)
				const originDistance = Vec2d.Dist(initOrigin, prevOrigin)
				if (type === 'gesture' && touchDistance) {
					pinchState = 'zooming'
				} else if (type === 'touch' && touchDistance > 16) {
					pinchState = 'zooming'
				} else if (originDistance > 16) {
					pinchState = 'panning'
				}
			}
		}, 32)
		const onPinch = (gesture) => {
			const elm = ref.current
			const { event, origin, offset, da } = gesture
			if (event instanceof WheelEvent) return
			if (!(event.target === elm || elm?.contains(event.target))) return
			const isGesture = 'touches' in event ? false : true
			currentTouchDistance = da[0]
			if (isGesture || currentTouchDistance > 64) {
				currentZoom = offset[0]
			}
			const dx = origin[0] - prevOrigin.x
			const dy = origin[1] - prevOrigin.y
			prevOrigin.x = origin[0]
			prevOrigin.y = origin[1]
			updatePinchState(isGesture ? 'gesture' : 'touch')
			switch (pinchState) {
				case 'zooming': {
					app.dispatch({
						type: 'pinch',
						name: 'pinch',
						point: { x: origin[0], y: origin[1], z: currentZoom },
						delta: { x: dx, y: dy },
						shiftKey: event.shiftKey,
						altKey: event.altKey,
						ctrlKey: event.metaKey || event.ctrlKey,
					})
					break
				}
				case 'panning': {
					app.dispatch({
						type: 'pinch',
						name: 'pinch',
						point: { x: origin[0], y: origin[1], z: initZoom },
						delta: { x: dx, y: dy },
						shiftKey: event.shiftKey,
						altKey: event.altKey,
						ctrlKey: event.metaKey || event.ctrlKey,
					})
					break
				}
			}
		}
		const onPinchEnd = (gesture) => {
			const elm = ref.current
			const { event, origin, offset } = gesture
			if (event instanceof WheelEvent) return
			if (!(event.target === elm || elm?.contains(event.target))) return
			const scale = offset[0]
			pinchState = null
			requestAnimationFrame(() => {
				app.dispatch({
					type: 'pinch',
					name: 'pinch_end',
					point: { x: origin[0], y: origin[1], z: scale },
					delta: { x: origin[0], y: origin[1] },
					shiftKey: event.shiftKey,
					altKey: event.altKey,
					ctrlKey: event.metaKey || event.ctrlKey,
				})
			})
		}
		return {
			onWheel,
			onPinchStart,
			onPinchEnd,
			onPinch,
		}
	}, [app, ref])
	useGesture(events, {
		target: ref,
		eventOptions: { passive: false },
		pinch: {
			from: () => [app.zoomLevel, 0],
			// Return the camera z to use when pinch starts
			scaleBounds: () => {
				return { from: app.zoomLevel, max: 8, min: 0.05 }
			},
		},
	})
}

// ../packages/editor/src/lib/hooks/useHandleEvents.ts
init_define_process()
var React15 = __toESM(require_react())
function getHandle(app, id, handleId) {
	const shape = app.getShapeById(id)
	const util = app.getShapeUtil(shape)
	const handles = util.handles(shape)
	return { shape, handle: handles.find((h3) => h3.id === handleId) }
}
function useHandleEvents(id, handleId) {
	const app = useApp()
	return React15.useMemo(() => {
		const onPointerDown = (e2) => {
			if (e2.isKilled) return
			const target = loopToHtmlElement(e2.currentTarget)
			setPointerCapture(target, e2)
			const { shape, handle } = getHandle(app, id, handleId)
			if (!handle) return
			app.dispatch({
				type: 'pointer',
				target: 'handle',
				handle,
				shape,
				name: 'pointer_down',
				...getPointerInfo(e2, app.getContainer()),
			})
		}
		let lastX, lastY
		const onPointerMove = (e2) => {
			if (e2.isKilled) return
			if (e2.clientX === lastX && e2.clientY === lastY) return
			lastX = e2.clientX
			lastY = e2.clientY
			const { shape, handle } = getHandle(app, id, handleId)
			if (!handle) return
			app.dispatch({
				type: 'pointer',
				target: 'handle',
				handle,
				shape,
				name: 'pointer_move',
				...getPointerInfo(e2, app.getContainer()),
			})
		}
		const onPointerUp = (e2) => {
			if (e2.isKilled) return
			const target = loopToHtmlElement(e2.currentTarget)
			releasePointerCapture(target, e2)
			const { shape, handle } = getHandle(app, id, handleId)
			if (!handle) return
			app.dispatch({
				type: 'pointer',
				target: 'handle',
				handle,
				shape,
				name: 'pointer_up',
				...getPointerInfo(e2, app.getContainer()),
			})
		}
		const onPointerEnter = (e2) => {
			if (e2.isKilled) return
			const { shape, handle } = getHandle(app, id, handleId)
			if (!handle) return
			app.dispatch({
				type: 'pointer',
				target: 'handle',
				handle,
				shape,
				name: 'pointer_enter',
				...getPointerInfo(e2, app.getContainer()),
			})
		}
		const onPointerLeave = (e2) => {
			if (e2.isKilled) return
			const { shape, handle } = getHandle(app, id, handleId)
			if (!handle) return
			app.dispatch({
				type: 'pointer',
				target: 'handle',
				handle,
				shape,
				name: 'pointer_leave',
				...getPointerInfo(e2, app.getContainer()),
			})
		}
		return {
			onPointerDown,
			onPointerMove,
			onPointerUp,
			onPointerEnter,
			onPointerLeave,
		}
	}, [app, id, handleId])
}

// ../packages/editor/src/lib/hooks/useQuickReactor.ts
init_define_process()
var import_react27 = __toESM(require_react())
function useQuickReactor(name, reactFn, deps = EMPTY_ARRAY) {
	;(0, import_react27.useEffect)(() => {
		const scheduler = new EffectScheduler(name, reactFn)
		scheduler.attach()
		scheduler.execute()
		return () => {
			scheduler.detach()
		}
	}, deps)
}

// ../packages/editor/src/lib/hooks/useScreenBounds.ts
init_define_process()
var import_lodash4 = __toESM(require_lodash3())
var import_react28 = __toESM(require_react())
function useScreenBounds() {
	const app = useApp()
	const container = useContainer()
	;(0, import_react28.useLayoutEffect)(() => {
		const updateBounds = (0, import_lodash4.default)(
			() => {
				app.updateViewportScreenBounds()
			},
			200,
			{ trailing: true }
		)
		const resizeObserver = new ResizeObserver((entries) => {
			if (entries[0].contentRect) {
				updateBounds()
			}
		})
		if (container) {
			resizeObserver.observe(container)
		}
		updateBounds()
		return () => {
			resizeObserver.disconnect()
		}
	}, [app, container])
}

// ../packages/editor/src/lib/components/LiveCollaborators.tsx
init_define_process()

// ../packages/editor/src/lib/hooks/usePeerIds.ts
init_define_process()
var import_lodash5 = __toESM(require_lodash2())
var import_react29 = __toESM(require_react())
function usePeerIds() {
	const app = useApp()
	const $presences = (0, import_react29.useMemo)(() => {
		return app.store.query.records('instance_presence', () => ({ userId: { neq: app.user.id } }))
	}, [app])
	const $userIds = useComputed(
		'userIds',
		() => (0, import_lodash5.default)($presences.value.map((p3) => p3.userId)).sort(),
		{ isEqual: (a3, b3) => a3.join(',') === b3.join?.(',') },
		[$presences]
	)
	return useValue($userIds)
}

// ../packages/editor/src/lib/hooks/usePresence.ts
init_define_process()
var import_react30 = __toESM(require_react())
function usePresence(userId) {
	const app = useApp()
	const $presences = (0, import_react30.useMemo)(() => {
		return app.store.query.records('instance_presence', () => ({
			userId: { eq: userId },
		}))
	}, [app, userId])
	const latestPresence = useValue(
		`latestPresence:${userId}`,
		() => {
			return $presences.value
				.slice()
				.sort((a3, b3) => b3.lastActivityTimestamp - a3.lastActivityTimestamp)[0]
		},
		[]
	)
	return latestPresence ?? null
}

// ../packages/editor/src/lib/components/LiveCollaborators.tsx
var import_jsx_runtime34 = __toESM(require_jsx_runtime())
var LiveCollaborators = track(function Collaborators() {
	const peerIds = usePeerIds()
	return /* @__PURE__ */ (0,
	import_jsx_runtime34.jsx)(import_jsx_runtime34.Fragment, { children: peerIds.map((id) => /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Collaborator, { userId: id }, id)) })
})
var Collaborator = track(function Collaborator2({ userId }) {
	const app = useApp()
	const { viewportPageBounds, zoomLevel } = app
	const {
		CollaboratorBrush,
		CollaboratorScribble,
		CollaboratorCursor,
		CollaboratorHint: CollaboratorHint2,
		CollaboratorShapeIndicator,
	} = useEditorComponents()
	const latestPresence = usePresence(userId)
	if (!latestPresence) return null
	if (latestPresence.currentPageId !== app.currentPageId) return null
	const { brush, scribble, selectedIds, userName, cursor, color } = latestPresence
	const isCursorInViewport = !(
		cursor.x < viewportPageBounds.minX - 12 / zoomLevel ||
		cursor.y < viewportPageBounds.minY - 16 / zoomLevel ||
		cursor.x > viewportPageBounds.maxX - 12 / zoomLevel ||
		cursor.y > viewportPageBounds.maxY - 16 / zoomLevel
	)
	return /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(import_jsx_runtime34.Fragment, {
		children: [
			brush && CollaboratorBrush
				? /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
						CollaboratorBrush,
						{
							className: 'tl-collaborator__brush',
							brush,
							color,
							opacity: 0.1,
						},
						userId + '_brush'
				  )
				: null,
			isCursorInViewport && CollaboratorCursor
				? /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
						CollaboratorCursor,
						{
							className: 'tl-collaborator__cursor',
							point: cursor,
							color,
							zoom: zoomLevel,
							name: userName !== 'New User' ? userName : null,
						},
						userId + '_cursor'
				  )
				: CollaboratorHint2
				? /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
						CollaboratorHint2,
						{
							className: 'tl-collaborator__cursor-hint',
							point: cursor,
							color,
							zoom: zoomLevel,
							viewport: viewportPageBounds,
						},
						userId + '_cursor_hint'
				  )
				: null,
			scribble && CollaboratorScribble
				? /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
						CollaboratorScribble,
						{
							className: 'tl-collaborator__scribble',
							scribble,
							color,
							zoom: zoomLevel,
							opacity: scribble.color === 'laser' ? 0.5 : 0.1,
						},
						userId + '_scribble'
				  )
				: null,
			CollaboratorShapeIndicator &&
				selectedIds.map((shapeId) =>
					/* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
						CollaboratorShapeIndicator,
						{
							className: 'tl-collaborator__shape-indicator',
							id: shapeId,
							color,
							opacity: 0.5,
						},
						userId + '_' + shapeId
					)
				),
		],
	})
})

// ../packages/editor/src/lib/components/SelectionBg.tsx
init_define_process()
var React16 = __toESM(require_react())
var import_jsx_runtime35 = __toESM(require_jsx_runtime())
var SelectionBg = track(function SelectionBg2() {
	const app = useApp()
	const events = React16.useMemo(() => {
		const onPointerDown = (e2) => {
			if (e2.isKilled) return
			setPointerCapture(e2.currentTarget, e2)
			const info = {
				type: 'pointer',
				target: 'selection',
				name: 'pointer_down',
				...getPointerInfo(e2, app.getContainer()),
			}
			app.dispatch(info)
		}
		const onPointerMove = (e2) => {
			if (e2.isKilled) return
			const info = {
				type: 'pointer',
				target: 'selection',
				name: 'pointer_move',
				...getPointerInfo(e2, app.getContainer()),
			}
			app.dispatch(info)
		}
		const onPointerUp = (e2) => {
			if (e2.isKilled) return
			releasePointerCapture(e2.currentTarget, e2)
			const info = {
				type: 'pointer',
				target: 'selection',
				name: 'pointer_up',
				...getPointerInfo(e2, app.getContainer()),
			}
			app.dispatch(info)
		}
		const onPointerEnter = (e2) => {
			if (e2.isKilled) return
			const info = {
				type: 'pointer',
				target: 'selection',
				name: 'pointer_enter',
				...getPointerInfo(e2, app.getContainer()),
			}
			app.dispatch(info)
		}
		const onPointerLeave = (e2) => {
			if (e2.isKilled) return
			const info = {
				type: 'pointer',
				target: 'selection',
				name: 'pointer_leave',
				...getPointerInfo(e2, app.getContainer()),
			}
			app.dispatch(info)
		}
		return {
			onPointerDown,
			onPointerMove,
			onPointerUp,
			onPointerEnter,
			onPointerLeave,
		}
	}, [app])
	const { selectionBounds: bounds, selectedIds } = app
	if (!bounds) return null
	const shouldDisplay = app.isInAny(
		'select.idle',
		'select.brushing',
		'select.scribble_brushing',
		'select.pointing_shape',
		'select.pointing_selection',
		'text.resizing'
	)
	if (selectedIds.length === 1) {
		const shape = app.getShapeById(selectedIds[0])
		if (!shape) {
			return null
		}
		const util = app.getShapeUtil(shape)
		if (util.hideSelectionBoundsBg(shape)) {
			return null
		}
	}
	const transform = Matrix2d.toCssString(
		Matrix2d.Compose(
			Matrix2d.Translate(bounds.minX, bounds.minY),
			Matrix2d.Rotate(app.selectionRotation)
		)
	)
	return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)('div', {
		className: 'tl-selection__bg',
		draggable: false,
		style: {
			transform,
			width: toDomPrecision(Math.max(1, bounds.width)),
			height: toDomPrecision(Math.max(1, bounds.height)),
			pointerEvents: shouldDisplay ? 'all' : 'none',
			opacity: shouldDisplay ? 1 : 0,
		},
		...events,
	})
})

// ../packages/editor/src/lib/components/SelectionFg.tsx
init_define_process()
var import_classnames9 = __toESM(require_classnames())
var import_react32 = __toESM(require_react())

// ../packages/editor/src/lib/hooks/useCursor.ts
init_define_process()
var DEFAULT_SVG = `<path d="m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" fill="white"/><path d="m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" fill="white"/><path d="m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" fill="black"/><path d="m13 10.814v11.188l2.969-2.866.428-.139h4.768z" fill="black"/>`
var POINTER_SVG = `<path d="m13.3315 21.3799c-.284-.359-.629-1.093-1.243-1.984-.348-.504-1.211-1.453-1.468-1.935-.223-.426-.199-.617-.146-.97.094-.628.738-1.117 1.425-1.051.519.049.959.392 1.355.716.239.195.533.574.71.788.163.196.203.277.377.509.23.307.302.459.214.121-.071-.496-.187-1.343-.355-2.092-.128-.568-.159-.657-.281-1.093-.129-.464-.195-.789-.316-1.281-.084-.348-.235-1.059-.276-1.459-.057-.547-.087-1.439.264-1.849.275-.321.906-.418 1.297-.22.512.259.803 1.003.936 1.3.239.534.387 1.151.516 1.961.164 1.031.466 2.462.476 2.763.024-.369-.068-1.146-.004-1.5.058-.321.328-.694.666-.795.286-.085.621-.116.916-.055.313.064.643.288.766.499.362.624.369 1.899.384 1.831.086-.376.071-1.229.284-1.584.14-.234.497-.445.687-.479.294-.052.655-.068.964-.008.249.049.586.345.677.487.218.344.342 1.317.379 1.658.015.141.074-.392.293-.736.406-.639 1.843-.763 1.898.639.025.654.02.624.02 1.064 0 .517-.012.828-.04 1.202-.031.4-.117 1.304-.242 1.742-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.191 1.813-.118.562-.079.566-.102.965-.023.398.121.922.121.922s-.802.104-1.234.035c-.391-.063-.875-.841-1-1.079-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.031-3.139.02 0 0 .185-1.011-.227-1.358-.305-.259-.83-.784-1.144-1.06z" fill="white"/><g stroke="black" stroke-linecap="round" stroke-width=".75"><path d="m13.3315 21.3799c-.284-.359-.629-1.093-1.243-1.984-.348-.504-1.211-1.453-1.468-1.935-.223-.426-.199-.617-.146-.97.094-.628.738-1.117 1.425-1.051.519.049.959.392 1.355.716.239.195.533.574.71.788.163.196.203.277.377.509.23.307.302.459.214.121-.071-.496-.187-1.343-.355-2.092-.128-.568-.159-.657-.281-1.093-.129-.464-.195-.789-.316-1.281-.084-.348-.235-1.059-.276-1.459-.057-.547-.087-1.439.264-1.849.275-.321.906-.418 1.297-.22.512.259.803 1.003.936 1.3.239.534.387 1.151.516 1.961.164 1.031.466 2.462.476 2.763.024-.369-.068-1.146-.004-1.5.058-.321.328-.694.666-.795.286-.085.621-.116.916-.055.313.064.643.288.766.499.362.624.369 1.899.384 1.831.086-.376.071-1.229.284-1.584.14-.234.497-.445.687-.479.294-.052.655-.068.964-.008.249.049.586.345.677.487.218.344.342 1.317.379 1.658.015.141.074-.392.293-.736.406-.639 1.843-.763 1.898.639.025.654.02.624.02 1.064 0 .517-.012.828-.04 1.202-.031.4-.117 1.304-.242 1.742-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.191 1.813-.118.562-.079.566-.102.965-.023.398.121.922.121.922s-.802.104-1.234.035c-.391-.063-.875-.841-1-1.079-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.031-3.139.02 0 0 .185-1.011-.227-1.358-.305-.259-.83-.784-1.144-1.06z" stroke-linejoin="round"/><path d="m21.5664 21.7344v-3.459"/><path d="m19.5508 21.7461-.016-3.473"/><path d="m17.5547 18.3047.021 3.426"/></g>`
var CROSS_SVG = `<path d="m25 16h-6.01v-6h-2.98v6h-6.01v3h6.01v6h2.98v-6h6.01z" fill="white"/><path d="m23.9902 17.0103h-6v-6.01h-.98v6.01h-6v.98h6v6.01h.98v-6.01h6z" fill="%23231f1f"/>`
var MOVE_SVG = `<path d="m19 14h1v1h-1zm1 6h-1v-1h1zm-5-5h-1v-1h1zm0 5h-1v-1h1zm2-10.987-7.985 7.988 5.222 5.221 2.763 2.763 7.984-7.985z" fill="white"/><g fill="black"><path d="m23.5664 16.9971-2.557-2.809v1.829h-4.009-4.001v-1.829l-2.571 2.809 2.572 2.808-.001-1.808h4.001 4.009l-.001 1.808z"/><path d="m17.9873 17h.013v-4.001l1.807.001-2.807-2.571-2.809 2.57h1.809v4.001h.008v4.002l-1.828-.001 2.807 2.577 2.805-2.576h-1.805z"/></g>`
var CORNER_SVG = `<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>`
var EDGE_SVG = `<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>`
var ROTATE_CORNER_SVG = `<g><path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/></g>`
var TEXT_SVG = `<path fill="white" d="M7.94 0a5.25 5.25 0 0 0-3.47 1.17A5.27 5.27 0 0 0 1 0H0v3h1c1.41 0 1.85.7 2 1v3.94H2v3h1v3c-.13.3-.57 1-2 1H0v3h1a5.27 5.27 0 0 0 3.47-1.17c.98.8 2.21 1.21 3.47 1.17h1v-3h-1c-1.41 0-1.85-.7-2-1v-3H7v-3H6V4c.13-.3.57-1 2-1h1V0H7.94z"/><path fill="black" d="M7.94 2V1a4 4 0 0 0-3.47 1.64A4 4 0 0 0 1 1v1c1.3-.17 2.56.6 3 1.84v5.1H3v1h1v4.16c-.45 1.24-1.7 2-3 1.84v1a4.05 4.05 0 0 0 3.47-1.63 4.05 4.05 0 0 0 3.47 1.63v-1A2.82 2.82 0 0 1 5 14.1V9.93h1v-1H5V3.85A2.81 2.81 0 0 1 7.94 2z"/>`
var GRABBING_SVG = `<path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042' fill='white'/><g stroke='black' stroke-width='.75'><path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042z' stroke-linejoin='round'/><path d='m20.5664 19.7344v-3.459' stroke-linecap='round'/><path d='m18.5508 19.7461-.016-3.473' stroke-linecap='round'/><path d='m16.5547 16.3047.021 3.426' stroke-linecap='round'/></g>`
var GRAB_SVG = `<path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" fill="white"/><g stroke="black" stroke-linecap="round" stroke-width=".75"><path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" stroke-linejoin="round"/><path d="m20.5664 21.7344v-3.459"/><path d="m18.5508 21.7461-.016-3.473"/><path d="m16.5547 18.3047.021 3.426"/></g>`
var ZOOM_IN_SVG = `<path d="m20.5 15c0 3.038-2.462 5.5-5.5 5.5s-5.5-2.462-5.5-5.5 2.462-5.5 5.5-5.5 5.5 2.462 5.5 5.5" fill="white"/><path d="m20.5 15c0 3.038-2.462 5.5-5.5 5.5s-5.5-2.462-5.5-5.5 2.462-5.5 5.5-5.5 5.5 2.462 5.5 5.5z" stroke="black"/><g fill="black"><path d="m18 14h-2v-2h-2v2h-2v1.98h2v2.02h2v-2.02h2z"/><path d="m23.5859 25 1.414-1.414-5.449-5.449-1.414 1.414z"/></g>`
var ZOOM_OUT_SVG = `<path d="m20.5 15c0 3.038-2.462 5.5-5.5 5.5s-5.5-2.462-5.5-5.5 2.462-5.5 5.5-5.5 5.5 2.462 5.5 5.5" fill="white"/><path d="m20.5 15c0 3.038-2.462 5.5-5.5 5.5s-5.5-2.462-5.5-5.5 2.462-5.5 5.5-5.5 5.5 2.462 5.5 5.5z" stroke="black"/><g fill="black"><path d="m18 16h-5.98v-1.98h5.98z"/><path d="m23.5859 25 1.414-1.414-5.449-5.449-1.414 1.414z"/></g>`
function getCursorCss(svg, r3, tr, f3, color, hotspotX = 16, hotspotY = 16) {
	const a3 = (-tr - r3) * (PI / 180)
	const s3 = Math.sin(a3)
	const c3 = Math.cos(a3)
	const dx = 1 * c3 - 1 * s3
	const dy = 1 * s3 + 1 * c3
	return (
		`url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${color};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${dx}' dy='${dy}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${
			r3 + tr
		} 16 16)${f3 ? ` scale(-1,-1) translate(0, -32)` : ''}' filter='url(%23shadow)'>` +
		svg.replaceAll(`"`, `'`) +
		`</g></svg>") ${hotspotX} ${hotspotY}, pointer`
	)
}
var CURSORS = {
	none: () => 'none',
	default: (r3, f3, c3) => getCursorCss(DEFAULT_SVG, r3, 0, f3, c3, 12, 8),
	pointer: (r3, f3, c3) => getCursorCss(POINTER_SVG, r3, 0, f3, c3, 14, 10),
	cross: (r3, f3, c3) => getCursorCss(CROSS_SVG, r3, 0, f3, c3),
	move: (r3, f3, c3) => getCursorCss(MOVE_SVG, r3, 0, f3, c3),
	grab: (r3, f3, c3) => getCursorCss(GRAB_SVG, r3, 0, f3, c3),
	grabbing: (r3, f3, c3) => getCursorCss(GRABBING_SVG, r3, 0, f3, c3),
	text: (r3, f3, c3) => getCursorCss(TEXT_SVG, r3, 0, f3, c3, 4, 10),
	'resize-edge': (r3, f3, c3) => getCursorCss(EDGE_SVG, r3, 0, f3, c3),
	'resize-corner': (r3, f3, c3) => getCursorCss(CORNER_SVG, r3, 0, f3, c3),
	'ew-resize': (r3, f3, c3) => getCursorCss(EDGE_SVG, r3, 0, f3, c3),
	'ns-resize': (r3, f3, c3) => getCursorCss(EDGE_SVG, r3, 90, f3, c3),
	'nesw-resize': (r3, f3, c3) => getCursorCss(CORNER_SVG, r3, 0, f3, c3),
	'nwse-resize': (r3, f3, c3) => getCursorCss(CORNER_SVG, r3, 90, f3, c3),
	rotate: (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 45, f3, c3),
	'nwse-rotate': (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 0, f3, c3),
	'nesw-rotate': (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 90, f3, c3),
	'senw-rotate': (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 180, f3, c3),
	'swne-rotate': (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 270, f3, c3),
	'zoom-in': (r3, f3, c3) => getCursorCss(ZOOM_IN_SVG, r3, 0, f3, c3),
	'zoom-out': (r3, f3, c3) => getCursorCss(ZOOM_OUT_SVG, r3, 0, f3, c3),
}
function getCursor(cursor, rotation = 0, color = 'black') {
	return CURSORS[cursor](radiansToDegrees(rotation), false, color)
}
function useCursor() {
	const app = useApp()
	const container = useContainer()
	useQuickReactor(
		'useCursor',
		() => {
			const { type, rotation, color } = app.cursor
			container.style.setProperty('--tl-cursor', getCursor(type, rotation, color))
		},
		[app, container]
	)
	useQuickReactor(
		'useStaticCursor',
		() => {
			for (const key in CURSORS) {
				container.style.setProperty(`--tl-cursor-${key}`, getCursor(key))
			}
		},
		[app, container]
	)
}

// ../packages/editor/src/lib/hooks/useSelectionEvents.ts
init_define_process()
var import_react31 = __toESM(require_react())
function useSelectionEvents(handle) {
	const app = useApp()
	const events = (0, import_react31.useMemo)(
		function selectionEvents() {
			const onPointerDown = (e2) => {
				if (e2.isKilled) return
				if (e2.button !== 0) return
				const elm = loopToHtmlElement(e2.currentTarget)
				function releaseCapture() {
					elm.removeEventListener('pointerup', releaseCapture)
					releasePointerCapture(elm, e2)
				}
				setPointerCapture(elm, e2)
				elm.addEventListener('pointerup', releaseCapture)
				app.dispatch({
					name: 'pointer_down',
					type: 'pointer',
					target: 'selection',
					handle,
					...getPointerInfo(e2, app.getContainer()),
				})
				e2.stopPropagation()
			}
			let lastX, lastY
			function onPointerMove(e2) {
				if (e2.isKilled) return
				if (e2.button !== 0) return
				if (e2.clientX === lastX && e2.clientY === lastY) return
				lastX = e2.clientX
				lastY = e2.clientY
				app.dispatch({
					name: 'pointer_move',
					type: 'pointer',
					target: 'selection',
					handle,
					...getPointerInfo(e2, app.getContainer()),
				})
			}
			const onPointerUp = (e2) => {
				if (e2.isKilled) return
				if (e2.button !== 0) return
				app.dispatch({
					name: 'pointer_up',
					type: 'pointer',
					target: 'selection',
					handle,
					...getPointerInfo(e2, app.getContainer()),
				})
			}
			return {
				onPointerDown,
				onPointerMove,
				onPointerUp,
			}
		},
		[app, handle]
	)
	return events
}

// ../packages/editor/src/lib/components/CropHandles.tsx
init_define_process()
var import_classnames8 = __toESM(require_classnames())
var import_jsx_runtime36 = __toESM(require_jsx_runtime())
function CropHandles({ size, width, height, hideAlternateHandles }) {
	const cropStrokeWidth = toDomPrecision(size / 3)
	const offset = cropStrokeWidth / 2
	return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)('svg', {
		className: 'tl-overlays__item',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime36.jsx)('polyline', {
				className: 'tl-corner-crop-handle',
				points: `
						${toDomPrecision(0 - offset)},${toDomPrecision(size)} 
						${toDomPrecision(0 - offset)},${toDomPrecision(0 - offset)} 
						${toDomPrecision(size)},${toDomPrecision(0 - offset)}`,
				strokeWidth: cropStrokeWidth,
				'data-testid': 'selection.crop.top_left',
				'aria-label': 'top_left handle',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime36.jsx)('line', {
				className: (0, import_classnames8.default)('tl-corner-crop-edge-handle', {
					'tl-hidden': hideAlternateHandles,
				}),
				x1: toDomPrecision(width / 2 - size),
				y1: toDomPrecision(0 - offset),
				x2: toDomPrecision(width / 2 + size),
				y2: toDomPrecision(0 - offset),
				strokeWidth: cropStrokeWidth,
				'data-testid': 'selection.crop.top',
				'aria-label': 'top handle',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime36.jsx)('polyline', {
				className: (0, import_classnames8.default)('tl-corner-crop-handle', {
					'tl-hidden': hideAlternateHandles,
				}),
				points: `
						${toDomPrecision(width - size)},${toDomPrecision(0 - offset)} 
						${toDomPrecision(width + offset)},${toDomPrecision(0 - offset)} 
						${toDomPrecision(width + offset)},${toDomPrecision(size)}`,
				strokeWidth: cropStrokeWidth,
				'data-testid': 'selection.crop.top_right',
				'aria-label': 'top_right handle',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime36.jsx)('line', {
				className: (0, import_classnames8.default)('tl-corner-crop-edge-handle', {
					'tl-hidden': hideAlternateHandles,
				}),
				x1: toDomPrecision(width + offset),
				y1: toDomPrecision(height / 2 - size),
				x2: toDomPrecision(width + offset),
				y2: toDomPrecision(height / 2 + size),
				strokeWidth: cropStrokeWidth,
				'data-testid': 'selection.crop.right',
				'aria-label': 'right handle',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime36.jsx)('polyline', {
				className: 'tl-corner-crop-handle',
				points: `
						${toDomPrecision(width + offset)},${toDomPrecision(height - size)} 
						${toDomPrecision(width + offset)},${toDomPrecision(height + offset)}
						${toDomPrecision(width - size)},${toDomPrecision(height + offset)}`,
				strokeWidth: cropStrokeWidth,
				'data-testid': 'selection.crop.bottom_right',
				'aria-label': 'bottom_right handle',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime36.jsx)('line', {
				className: (0, import_classnames8.default)('tl-corner-crop-edge-handle', {
					'tl-hidden': hideAlternateHandles,
				}),
				x1: toDomPrecision(width / 2 - size),
				y1: toDomPrecision(height + offset),
				x2: toDomPrecision(width / 2 + size),
				y2: toDomPrecision(height + offset),
				strokeWidth: cropStrokeWidth,
				'data-testid': 'selection.crop.bottom',
				'aria-label': 'bottom handle',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime36.jsx)('polyline', {
				className: (0, import_classnames8.default)('tl-corner-crop-handle', {
					'tl-hidden': hideAlternateHandles,
				}),
				points: `
						${toDomPrecision(0 + size)},${toDomPrecision(height + offset)} 
						${toDomPrecision(0 - offset)},${toDomPrecision(height + offset)}
						${toDomPrecision(0 - offset)},${toDomPrecision(height - size)}`,
				strokeWidth: cropStrokeWidth,
				'data-testid': 'selection.crop.bottom_left',
				'aria-label': 'bottom_left handle',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime36.jsx)('line', {
				className: (0, import_classnames8.default)('tl-corner-crop-edge-handle', {
					'tl-hidden': hideAlternateHandles,
				}),
				x1: toDomPrecision(0 - offset),
				y1: toDomPrecision(height / 2 - size),
				x2: toDomPrecision(0 - offset),
				y2: toDomPrecision(height / 2 + size),
				strokeWidth: cropStrokeWidth,
				'data-testid': 'selection.crop.left',
				'aria-label': 'left handle',
			}),
		],
	})
}

// ../packages/editor/src/lib/components/SelectionFg.tsx
var import_jsx_runtime37 = __toESM(require_jsx_runtime())
var IS_FIREFOX =
	typeof navigator !== 'undefined' &&
	navigator.userAgent &&
	navigator.userAgent.toLowerCase().indexOf('firefox') > -1
var SelectionFg = track(function SelectionFg2() {
	const app = useApp()
	const rSvg = (0, import_react32.useRef)(null)
	const isReadonlyMode = app.isReadOnly
	const topEvents = useSelectionEvents('top')
	const rightEvents = useSelectionEvents('right')
	const bottomEvents = useSelectionEvents('bottom')
	const leftEvents = useSelectionEvents('left')
	const topLeftEvents = useSelectionEvents('top_left')
	const topRightEvents = useSelectionEvents('top_right')
	const bottomRightEvents = useSelectionEvents('bottom_right')
	const bottomLeftEvents = useSelectionEvents('bottom_left')
	const isDefaultCursor = !app.isMenuOpen && app.cursor.type === 'default'
	const isCoarsePointer = app.isCoarsePointer
	let bounds = app.selectionBounds
	const shapes = app.selectedShapes
	const onlyShape = shapes.length === 1 ? shapes[0] : null
	const expandOutlineBy = onlyShape
		? app.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape)
		: 0
	useTransform(rSvg, bounds?.x, bounds?.y, 1, app.selectionRotation, {
		x: -expandOutlineBy,
		y: -expandOutlineBy,
	})
	if (!bounds) return null
	bounds = bounds.clone().expandBy(expandOutlineBy)
	const zoom = app.zoomLevel
	const rotation = app.selectionRotation
	const isChangingStyles = app.isChangingStyle
	const width = Math.max(1, bounds.width)
	const height = Math.max(1, bounds.height)
	const size = 8 / zoom
	const isTinyX = width < size * 2
	const isTinyY = height < size * 2
	const isSmallX = width < size * 4
	const isSmallY = height < size * 4
	const isSmallCropX = width < size * 5
	const isSmallCropY = height < size * 5
	const mobileHandleMultiplier = isCoarsePointer ? 1.75 : 1
	const targetSize = (6 / zoom) * mobileHandleMultiplier
	const targetSizeX = (isSmallX ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75)
	const targetSizeY = (isSmallY ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75)
	const showSelectionBounds =
		(onlyShape ? !app.getShapeUtil(onlyShape).hideSelectionBoundsFg(onlyShape) : true) &&
		!isChangingStyles
	let shouldDisplayBox =
		(showSelectionBounds &&
			app.isInAny(
				'select.idle',
				'select.brushing',
				'select.scribble_brushing',
				'select.pointing_canvas',
				'select.pointing_selection',
				'select.pointing_shape',
				'select.crop.idle',
				'select.crop.pointing_crop',
				'select.pointing_resize_handle',
				'select.pointing_crop_handle',
				'select.editing_shape'
			)) ||
		(showSelectionBounds && app.isIn('select.resizing') && onlyShape && shapes[0].type === 'text')
	if (IS_FIREFOX && shouldDisplayBox) {
		if (app.onlySelectedShape?.type === 'embed') {
			shouldDisplayBox = false
		}
	}
	const showCropHandles =
		app.isInAny('select.pointing_crop_handle', 'select.crop.idle', 'select.crop.pointing_crop') &&
		!isChangingStyles &&
		!isReadonlyMode
	const shouldDisplayControls =
		app.isInAny(
			'select.idle',
			'select.pointing_selection',
			'select.pointing_shape',
			'select.crop.idle'
		) &&
		!isChangingStyles &&
		!isReadonlyMode
	const showCornerRotateHandles =
		!isCoarsePointer &&
		!(isTinyX || isTinyY) &&
		(shouldDisplayControls || showCropHandles) &&
		(onlyShape ? !app.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true)
	const showMobileRotateHandle =
		isCoarsePointer &&
		(!isSmallX || !isSmallY) &&
		(shouldDisplayControls || showCropHandles) &&
		(onlyShape ? !app.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true)
	const showResizeHandles =
		shouldDisplayControls &&
		(onlyShape
			? app.getShapeUtil(onlyShape).canResize(onlyShape) &&
			  !app.getShapeUtil(onlyShape).hideResizeHandles(onlyShape)
			: true) &&
		!showCropHandles
	const hideAlternateCornerHandles = isTinyX || isTinyY
	const showOnlyOneHandle = isTinyX && isTinyY
	const hideAlternateCropHandles = isSmallCropX || isSmallCropY
	const showHandles = showResizeHandles || showCropHandles
	const hideRotateCornerHandles = !showCornerRotateHandles
	const hideMobileRotateHandle = !shouldDisplayControls || !showMobileRotateHandle
	const hideTopLeftCorner = !shouldDisplayControls || !showHandles
	const hideTopRightCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles
	const hideBottomLeftCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles
	const hideBottomRightCorner =
		!shouldDisplayControls || !showHandles || (showOnlyOneHandle && !showCropHandles)
	let hideEdgeTargetsDueToCoarsePointer = isCoarsePointer
	if (
		hideEdgeTargetsDueToCoarsePointer &&
		shapes.every((shape) => app.getShapeUtil(shape).isAspectRatioLocked(shape))
	) {
		hideEdgeTargetsDueToCoarsePointer = false
	}
	let hideEdgeTargets = true
	if (showCropHandles) {
		hideEdgeTargets = hideAlternateCropHandles
	} else if (showResizeHandles) {
		hideEdgeTargets =
			hideAlternateCornerHandles || showOnlyOneHandle || hideEdgeTargetsDueToCoarsePointer
	}
	const textHandleHeight = Math.min(24 / zoom, height - targetSizeY * 3)
	const showTextResizeHandles =
		shouldDisplayControls &&
		isCoarsePointer &&
		onlyShape?.type === 'text' &&
		textHandleHeight * zoom >= 4
	return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)('svg', {
		ref: rSvg,
		className: 'tl-overlays__item tl-selection__fg',
		'data-testid': 'selection-foreground',
		children: [
			shouldDisplayBox &&
				/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
					className: (0, import_classnames9.default)('tl-selection__fg__outline'),
					width: toDomPrecision(width),
					height: toDomPrecision(height),
				}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RotateCornerHandle, {
				'data-testid': 'selection.rotate.top-left',
				cx: 0,
				cy: 0,
				targetSize,
				corner: 'top_left_rotate',
				cursor: isDefaultCursor ? getCursor('nwse-rotate', rotation) : void 0,
				isHidden: hideRotateCornerHandles,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RotateCornerHandle, {
				'data-testid': 'selection.rotate.top-right',
				cx: width + targetSize * 3,
				cy: 0,
				targetSize,
				corner: 'top_right_rotate',
				cursor: isDefaultCursor ? getCursor('nesw-rotate', rotation) : void 0,
				isHidden: hideRotateCornerHandles,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RotateCornerHandle, {
				'data-testid': 'selection.rotate.bottom-left',
				cx: 0,
				cy: height + targetSize * 3,
				targetSize,
				corner: 'bottom_left_rotate',
				cursor: isDefaultCursor ? getCursor('swne-rotate', rotation) : void 0,
				isHidden: hideRotateCornerHandles,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)(RotateCornerHandle, {
				'data-testid': 'selection.rotate.bottom-right',
				cx: width + targetSize * 3,
				cy: height + targetSize * 3,
				targetSize,
				corner: 'bottom_right_rotate',
				cursor: isDefaultCursor ? getCursor('senw-rotate', rotation) : void 0,
				isHidden: hideRotateCornerHandles,
			}),
			' ',
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)(MobileRotateHandle, {
				'data-testid': 'selection.rotate.mobile',
				cx: isSmallX ? -targetSize * 1.5 : width / 2,
				cy: isSmallX ? height / 2 : -targetSize * 1.5,
				size,
				isHidden: hideMobileRotateHandle,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
				className: (0, import_classnames9.default)('tl-transparent', {
					'tl-hidden': hideEdgeTargets,
				}),
				'data-testid': 'selection.resize.top',
				'aria-label': 'top target',
				pointerEvents: 'all',
				x: 0,
				y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY)),
				width: toDomPrecision(Math.max(1, width)),
				height: toDomPrecision(Math.max(1, targetSizeY * 2)),
				style: isDefaultCursor ? { cursor: getCursor('ns-resize', rotation) } : void 0,
				...topEvents,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
				className: (0, import_classnames9.default)('tl-transparent', {
					'tl-hidden': hideEdgeTargets,
				}),
				'data-testid': 'selection.resize.right',
				'aria-label': 'right target',
				pointerEvents: 'all',
				x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX)),
				y: 0,
				height: toDomPrecision(Math.max(1, height)),
				width: toDomPrecision(Math.max(1, targetSizeX * 2)),
				style: isDefaultCursor ? { cursor: getCursor('ew-resize', rotation) } : void 0,
				...rightEvents,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
				className: (0, import_classnames9.default)('tl-transparent', {
					'tl-hidden': hideEdgeTargets,
				}),
				'data-testid': 'selection.resize.bottom',
				'aria-label': 'bottom target',
				pointerEvents: 'all',
				x: 0,
				y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY)),
				width: toDomPrecision(Math.max(1, width)),
				height: toDomPrecision(Math.max(1, targetSizeY * 2)),
				style: isDefaultCursor ? { cursor: getCursor('ns-resize', rotation) } : void 0,
				...bottomEvents,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
				className: (0, import_classnames9.default)('tl-transparent', {
					'tl-hidden': hideEdgeTargets,
				}),
				'data-testid': 'selection.resize.left',
				'aria-label': 'left target',
				pointerEvents: 'all',
				x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX)),
				y: 0,
				height: toDomPrecision(Math.max(1, height)),
				width: toDomPrecision(Math.max(1, targetSizeX * 2)),
				style: isDefaultCursor ? { cursor: getCursor('ew-resize', rotation) } : void 0,
				...leftEvents,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
				className: (0, import_classnames9.default)('tl-transparent', {
					'tl-hidden': hideTopLeftCorner,
				}),
				'data-testid': 'selection.target.top-left',
				'aria-label': 'top-left target',
				pointerEvents: 'all',
				x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX * 1.5)),
				y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
				width: toDomPrecision(targetSizeX * 3),
				height: toDomPrecision(targetSizeY * 3),
				style: isDefaultCursor ? { cursor: getCursor('nwse-resize', rotation) } : void 0,
				...topLeftEvents,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
				className: (0, import_classnames9.default)('tl-transparent', {
					'tl-hidden': hideTopRightCorner,
				}),
				'data-testid': 'selection.target.top-right',
				'aria-label': 'top-right target',
				pointerEvents: 'all',
				x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX * 1.5)),
				y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
				width: toDomPrecision(targetSizeX * 3),
				height: toDomPrecision(targetSizeY * 3),
				style: isDefaultCursor ? { cursor: getCursor('nesw-resize', rotation) } : void 0,
				...topRightEvents,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
				className: (0, import_classnames9.default)('tl-transparent', {
					'tl-hidden': hideBottomRightCorner,
				}),
				'data-testid': 'selection.target.bottom-right',
				'aria-label': 'bottom-right target',
				pointerEvents: 'all',
				x: toDomPrecision(width - (isSmallX ? targetSizeX : targetSizeX * 1.5)),
				y: toDomPrecision(height - (isSmallY ? targetSizeY : targetSizeY * 1.5)),
				width: toDomPrecision(targetSizeX * 3),
				height: toDomPrecision(targetSizeY * 3),
				style: isDefaultCursor ? { cursor: getCursor('nwse-resize', rotation) } : void 0,
				...bottomRightEvents,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
				className: (0, import_classnames9.default)('tl-transparent', {
					'tl-hidden': hideBottomLeftCorner,
				}),
				'data-testid': 'selection.target.bottom-left',
				'aria-label': 'bottom-left target',
				pointerEvents: 'all',
				x: toDomPrecision(0 - (isSmallX ? targetSizeX * 3 : targetSizeX * 1.5)),
				y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY * 1.5)),
				width: toDomPrecision(targetSizeX * 3),
				height: toDomPrecision(targetSizeY * 3),
				style: isDefaultCursor ? { cursor: getCursor('nesw-resize', rotation) } : void 0,
				...bottomLeftEvents,
			}),
			showResizeHandles &&
				/* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, {
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
							'data-testid': 'selection.resize.top-left',
							className: (0, import_classnames9.default)('tl-corner-handle', {
								'tl-hidden': hideTopLeftCorner,
							}),
							'aria-label': 'top_left handle',
							x: toDomPrecision(0 - size / 2),
							y: toDomPrecision(0 - size / 2),
							width: toDomPrecision(size),
							height: toDomPrecision(size),
						}),
						/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
							'data-testid': 'selection.resize.top-right',
							className: (0, import_classnames9.default)('tl-corner-handle', {
								'tl-hidden': hideTopRightCorner,
							}),
							'aria-label': 'top_right handle',
							x: toDomPrecision(width - size / 2),
							y: toDomPrecision(0 - size / 2),
							width: toDomPrecision(size),
							height: toDomPrecision(size),
						}),
						/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
							'data-testid': 'selection.resize.bottom-right',
							className: (0, import_classnames9.default)('tl-corner-handle', {
								'tl-hidden': hideBottomRightCorner,
							}),
							'aria-label': 'bottom_right handle',
							x: toDomPrecision(width - size / 2),
							y: toDomPrecision(height - size / 2),
							width: toDomPrecision(size),
							height: toDomPrecision(size),
						}),
						/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
							'data-testid': 'selection.resize.bottom-left',
							className: (0, import_classnames9.default)('tl-corner-handle', {
								'tl-hidden': hideBottomLeftCorner,
							}),
							'aria-label': 'bottom_left handle',
							x: toDomPrecision(0 - size / 2),
							y: toDomPrecision(height - size / 2),
							width: toDomPrecision(size),
							height: toDomPrecision(size),
						}),
					],
				}),
			showTextResizeHandles &&
				/* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, {
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
							'data-testid': 'selection.text-resize.left.handle',
							className: 'tl-text-handle',
							'aria-label': 'bottom_left handle',
							x: toDomPrecision(0 - size / 4),
							y: toDomPrecision(height / 2 - textHandleHeight / 2),
							rx: size / 4,
							width: toDomPrecision(size / 2),
							height: toDomPrecision(textHandleHeight),
						}),
						/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
							'data-testid': 'selection.text-resize.right.handle',
							className: 'tl-text-handle',
							'aria-label': 'bottom_left handle',
							rx: size / 4,
							x: toDomPrecision(width - size / 4),
							y: toDomPrecision(height / 2 - textHandleHeight / 2),
							width: toDomPrecision(size / 2),
							height: toDomPrecision(textHandleHeight),
						}),
					],
				}),
			showCropHandles &&
				/* @__PURE__ */ (0, import_jsx_runtime37.jsx)(CropHandles, {
					...{
						size,
						width,
						height,
						hideAlternateHandles: hideAlternateCropHandles,
					},
				}),
		],
	})
})
var RotateCornerHandle = function RotateCornerHandle2({
	cx,
	cy,
	targetSize,
	corner,
	cursor,
	isHidden,
	'data-testid': dataWd,
}) {
	const events = useSelectionEvents(corner)
	return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)('rect', {
		className: (0, import_classnames9.default)('tl-transparent', 'tl-rotate-corner', {
			'tl-hidden': isHidden,
		}),
		'data-testid': dataWd,
		'aria-label': `${corner} target`,
		pointerEvents: 'all',
		x: toDomPrecision(cx - targetSize * 3),
		y: toDomPrecision(cy - targetSize * 3),
		width: toDomPrecision(Math.max(1, targetSize * 3)),
		height: toDomPrecision(Math.max(1, targetSize * 3)),
		cursor,
		...events,
	})
}
var SQUARE_ROOT_PI = Math.sqrt(Math.PI)
var MobileRotateHandle = function RotateHandle({ cx, cy, size, isHidden, 'data-testid': dataWd }) {
	const events = useSelectionEvents('mobile_rotate')
	return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)('g', {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('circle', {
				'data-testid': dataWd,
				pointerEvents: 'all',
				className: (0, import_classnames9.default)('tl-transparent', 'tl-mobile-rotate__bg', {
					'tl-hidden': isHidden,
				}),
				cx,
				cy,
				...events,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime37.jsx)('circle', {
				className: (0, import_classnames9.default)('tl-mobile-rotate__fg', {
					'tl-hidden': isHidden,
				}),
				cx,
				cy,
				r: size / SQUARE_ROOT_PI,
			}),
		],
	})
}

// ../packages/editor/src/lib/components/Shape.tsx
init_define_process()
var React18 = __toESM(require_react())

// ../packages/editor/src/lib/hooks/useShapeEvents.ts
init_define_process()
var import_react33 = __toESM(require_react())
var pointerEventHandler = (app, shapeId, name) => {
	return (e2) => {
		if (name !== 'pointer_move' && app.pageState.editingId === shapeId) e2.isKilled = true
		if (e2.isKilled) return
		switch (name) {
			case 'pointer_down': {
				if (e2.button !== 0 && e2.button !== 1 && e2.button !== 2) return
				setPointerCapture(e2.currentTarget, e2)
				break
			}
			case 'pointer_up': {
				releasePointerCapture(e2.currentTarget, e2)
				break
			}
		}
		const shape = app.getShapeById(shapeId)
		if (!shape) {
			console.error('Shape not found', shapeId)
			return
		}
		app.dispatch({
			type: 'pointer',
			target: 'shape',
			shape,
			name,
			...getPointerInfo(e2, app.getContainer()),
		})
	}
}
function useShapeEvents(id) {
	const app = useApp()
	return import_react33.default.useMemo(() => {
		function onTouchStart(e2) {
			e2.isKilled = true
			preventDefault(e2)
		}
		function onTouchEnd(e2) {
			e2.isKilled = true
			preventDefault(e2)
		}
		const handlePointerMove = pointerEventHandler(app, id, 'pointer_move')
		let lastX, lastY
		function onPointerMove(e2) {
			if (e2.isKilled) return
			if (e2.clientX === lastX && e2.clientY === lastY) return
			lastX = e2.clientX
			lastY = e2.clientY
			return handlePointerMove(e2)
		}
		return {
			onPointerDown: pointerEventHandler(app, id, 'pointer_down'),
			onPointerUp: pointerEventHandler(app, id, 'pointer_up'),
			onPointerEnter: pointerEventHandler(app, id, 'pointer_enter'),
			onPointerLeave: pointerEventHandler(app, id, 'pointer_leave'),
			onPointerMove,
			onTouchStart,
			onTouchEnd,
		}
	}, [app, id])
}

// ../packages/editor/src/lib/components/Shape.tsx
var import_jsx_runtime38 = __toESM(require_jsx_runtime())
var Shape = track(function Shape2({ id, index: index2, opacity, isCulled }) {
	const app = useApp()
	const { ShapeErrorFallback } = useEditorComponents()
	const events = useShapeEvents(id)
	const rContainer = React18.useRef(null)
	useQuickReactor(
		'set shape container transform position',
		() => {
			const elm = rContainer.current
			if (!elm) return
			const shape2 = app.getShapeById(id)
			const pageTransform = app.getPageTransformById(id)
			if (!shape2 || !pageTransform) return null
			const transform = Matrix2d.toCssString(pageTransform)
			elm.style.setProperty('transform', transform)
		},
		[app]
	)
	useQuickReactor(
		'set shape container clip path / color',
		() => {
			const elm = rContainer.current
			const shape2 = app.getShapeById(id)
			if (!elm) return
			if (!shape2) return null
			const clipPath = app.getClipPathById(id)
			elm.style.setProperty('clip-path', clipPath ?? 'none')
			if ('color' in shape2.props) {
				elm.style.setProperty('color', app.getCssColor(shape2.props.color))
			}
		},
		[app]
	)
	useQuickReactor(
		'set shape height and width',
		() => {
			const elm = rContainer.current
			const shape2 = app.getShapeById(id)
			if (!elm) return
			if (!shape2) return null
			const util2 = app.getShapeUtil(shape2)
			const bounds = util2.bounds(shape2)
			elm.style.setProperty('width', Math.ceil(bounds.width) + 'px')
			elm.style.setProperty('height', Math.ceil(bounds.height) + 'px')
		},
		[app]
	)
	React18.useLayoutEffect(() => {
		const elm = rContainer.current
		if (!elm) return
		elm.style.setProperty('opacity', opacity + '')
		elm.style.setProperty('z-index', index2 + '')
	}, [opacity, index2])
	const shape = app.getShapeById(id)
	if (!shape) return null
	const util = app.getShapeUtil(shape)
	return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
		'div',
		{
			ref: rContainer,
			className: 'tl-shape',
			'data-shape-type': shape.type,
			draggable: false,
			onPointerDown: events.onPointerDown,
			onPointerMove: events.onPointerMove,
			onPointerUp: events.onPointerUp,
			onPointerEnter: events.onPointerEnter,
			onPointerLeave: events.onPointerLeave,
			children:
				isCulled && util.canUnmount(shape)
					? /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(CulledShape, { shape, util })
					: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(OptionalErrorBoundary, {
							fallback: ShapeErrorFallback
								? (error) =>
										/* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ShapeErrorFallback, { error })
								: null,
							onError: (error) =>
								app.annotateError(error, { origin: 'react.shape', willCrashApp: false }),
							children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(InnerShape, { shape, util }),
					  }),
		},
		id
	)
})
var InnerShape = React18.memo(
	function InnerShape2({ shape, util }) {
		return useStateTracking('InnerShape:' + util.type, () => util.render(shape))
	},
	(prev, next) => prev.shape.props === next.shape.props
)
var CulledShape = React18.memo(
	function CulledShap({ shape, util }) {
		const bounds = util.bounds(shape)
		return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)('div', {
			className: 'tl-shape__culled',
			style: {
				transform: `translate(${bounds.minX}px, ${bounds.minY}px)`,
				width: bounds.width,
				height: bounds.height,
			},
		})
	},
	() => true
)

// ../packages/editor/src/lib/components/Canvas.tsx
var import_jsx_runtime39 = __toESM(require_jsx_runtime())
var Canvas = track(function Canvas2({ onDropOverride }) {
	const app = useApp()
	const { Background, SvgDefs } = useEditorComponents()
	const rCanvas = React19.useRef(null)
	const rHtmlLayer = React19.useRef(null)
	useScreenBounds()
	useDocumentEvents()
	useCoarsePointer()
	useGestureEvents(rCanvas)
	useFixSafariDoubleTapZoomPencilEvents(rCanvas)
	useQuickReactor(
		'position layers',
		() => {
			const htmlElm = rHtmlLayer.current
			if (!htmlElm) return
			const { x: x3, y: y3, z: z2 } = app.camera
			const offset =
				z2 >= 1
					? modulate(z2, [1, 8], [0.125, 0.5], true)
					: modulate(z2, [0.1, 1], [-2, 0.125], true)
			htmlElm.style.setProperty(
				'transform',
				`scale(${toDomPrecision(z2)}) translate(${toDomPrecision(x3 + offset)}px,${toDomPrecision(
					y3 + offset
				)}px)`
			)
		},
		[app]
	)
	const { context: patternContext, isReady: patternIsReady } = usePattern()
	const events = useCanvasEvents()
	if (onDropOverride) {
		events.onDrop = onDropOverride(events.onDrop)
	}
	React19.useEffect(() => {
		if (patternIsReady && app.isSafari) {
			const htmlElm = rHtmlLayer.current
			if (htmlElm) {
				requestAnimationFrame(() => {
					htmlElm.style.display = 'none'
					requestAnimationFrame(() => {
						htmlElm.style.display = ''
					})
				})
			}
		}
	}, [app, patternIsReady])
	React19.useEffect(() => {
		rCanvas.current?.focus()
	}, [])
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsxs)('div', { ref: rCanvas, draggable: false, className: 'tl-canvas', 'data-testid': 'canvas', ...events, children: [Background && /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Background, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(GridWrapper, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(UiLogger, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)('div', { ref: rHtmlLayer, className: 'tl-html-layer', draggable: false, children: [/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('svg', { className: 'tl-svg-context', children: /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)('defs', { children: [patternContext, Cursor && /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Cursor, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(CollaboratorHint, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ArrowheadDot, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ArrowheadCross, {}), SvgDefs && /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SvgDefs, {})] }) }), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SelectionBg, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('div', { className: 'tl-shapes', children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ShapesToDisplay, {}) }), /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)('div', { className: 'tl-overlays', children: [/* @__PURE__ */ (0, import_jsx_runtime39.jsx)(HandlesWrapper, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(BrushWrapper, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ScribbleWrapper, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ZoomBrushWrapper, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SelectedIdIndicators, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(HoveredShapeIndicator, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(HintedShapeIndicator, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SnapLinesWrapper, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SelectionFg, {}), /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(LiveCollaborators, {})] })] })] })
})
var GridWrapper = track(function GridWrapper2() {
	const app = useApp()
	const { Grid } = useEditorComponents()
	const { x: x3, y: y3, z: z2 } = app.camera
	const isGridMode = app.isGridMode
	if (!(Grid && isGridMode)) return null
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsx)(Grid, { x: x3, y: y3, z: z2, size: app.gridSize })
})
var ScribbleWrapper = track(function ScribbleWrapper2() {
	const app = useApp()
	const scribble = app.scribble
	const zoom = app.zoomLevel
	const { Scribble } = useEditorComponents()
	if (!(Scribble && scribble)) return null
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsx)(Scribble, { className: 'tl-user-scribble', scribble, zoom })
})
var BrushWrapper = track(function BrushWrapper2() {
	const app = useApp()
	const { brush } = app
	const { Brush } = useEditorComponents()
	if (!(Brush && brush && app.isIn('select.brushing'))) return null
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Brush, { className: 'tl-user-brush', brush })
})
var ZoomBrushWrapper = track(function Zoom() {
	const app = useApp()
	const { zoomBrush } = app
	const { ZoomBrush } = useEditorComponents()
	if (!(ZoomBrush && zoomBrush && app.isIn('zoom'))) return null
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsx)(ZoomBrush, { className: 'tl-user-brush', brush: zoomBrush })
})
var SnapLinesWrapper = track(function SnapLines() {
	const app = useApp()
	const {
		snaps: { lines },
		zoomLevel,
	} = app
	const { SnapLine } = useEditorComponents()
	if (!(SnapLine && lines.length > 0)) return null
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsx)(import_jsx_runtime39.Fragment, { children: lines.map((line) => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(SnapLine, { className: 'tl-user-snapline', line, zoom: zoomLevel }, line.id)) })
})
var MIN_HANDLE_DISTANCE = 48
var HandlesWrapper = track(function HandlesWrapper2() {
	const app = useApp()
	const zoom = app.zoomLevel
	const isChangingStyle = app.isChangingStyle
	const onlySelectedShape = app.onlySelectedShape
	const shouldDisplayHandles =
		app.isInAny('select.idle', 'select.pointing_handle') && !isChangingStyle && !app.isReadOnly
	if (!(onlySelectedShape && shouldDisplayHandles)) return null
	const util = app.getShapeUtil(onlySelectedShape)
	const handles = util.handles?.(onlySelectedShape)
	if (!handles) return null
	const transform = app.getPageTransform(onlySelectedShape)
	if (!transform) return null
	const handlesToDisplay = []
	for (let i3 = 0, handle = handles[i3]; i3 < handles.length; i3++, handle = handles[i3]) {
		if (handle.type !== 'vertex') {
			const prev = handles[i3 - 1]
			const next = handles[i3 + 1]
			if (prev && next) {
				if (Math.hypot(prev.y - next.y, prev.x - next.x) < MIN_HANDLE_DISTANCE / zoom) {
					continue
				}
			}
		}
		handlesToDisplay.push(handle)
	}
	handlesToDisplay.sort((a3) => (a3.type === 'vertex' ? 1 : -1))
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('svg', {
		className: 'tl-user-handles tl-overlays__item',
		children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('g', {
			transform: Matrix2d.toCssString(transform),
			children: handlesToDisplay.map((handle) => {
				return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
					HandleWrapper,
					{ shapeId: onlySelectedShape.id, handle },
					handle.id
				)
			}),
		}),
	})
})
var HandleWrapper = ({ shapeId, handle }) => {
	const events = useHandleEvents(shapeId, handle.id)
	const { Handle } = useEditorComponents()
	if (!Handle) return null
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('g', {
		'aria-label': 'handle',
		transform: `translate(${handle.x}, ${handle.y})`,
		...events,
		children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Handle, { shapeId, handle }),
	})
}
var ShapesToDisplay = track(function ShapesToDisplay2() {
	const app = useApp()
	const { renderingShapes } = app
	const debugSvg = debugFlags.debugSvg.value
	if (debugSvg) {
		return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(import_jsx_runtime39.Fragment, {
			children: renderingShapes.map((result) =>
				/* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(
					React19.Fragment,
					{
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Shape, { ...result }),
							/* @__PURE__ */ (0, import_jsx_runtime39.jsx)(DebugSvgCopy, { id: result.id }),
						],
					},
					result.id + '_fragment'
				)
			),
		})
	}
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsx)(import_jsx_runtime39.Fragment, { children: renderingShapes.map((result) => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Shape, { ...result }, result.id + '_shape')) })
})
var SelectedIdIndicators = track(function SelectedIdIndicators2() {
	const app = useApp()
	const shouldDisplay =
		app.isInAny(
			'select.idle',
			'select.brushing',
			'select.scribble_brushing',
			'select.pointing_shape',
			'select.pointing_selection',
			'select.pointing_handle'
		) && !app.isChangingStyle
	if (!shouldDisplay) return null
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsx)(import_jsx_runtime39.Fragment, { children: app.selectedIds.map((id) => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ShapeIndicator, { className: 'tl-user-indicator__selected', id }, id + '_indicator')) })
})
var HoveredShapeIndicator = function HoveredShapeIndicator2() {
	const app = useApp()
	const displayingHoveredId = useValue(
		'hovered id and should display',
		() => (app.isInAny('select.idle', 'select.editing_shape') ? app.pageState.hoveredId : null),
		[app]
	)
	if (!displayingHoveredId) return null
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ShapeIndicator, {
		className: 'tl-user-indicator__hovered',
		id: displayingHoveredId,
	})
}
var HintedShapeIndicator = track(function HintedShapeIndicator2() {
	const app = useApp()
	const ids = dedupe(app.hintingIds)
	if (!ids.length) return null
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsx)(import_jsx_runtime39.Fragment, { children: ids.map((id) => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ShapeIndicator, { className: 'tl-user-indicator__hint', id }, id + '_hinting')) })
})
function Cursor() {
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)('g', {
		id: 'cursor',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime39.jsxs)('g', {
				fill: 'rgba(0,0,0,.2)',
				transform: 'translate(-11,-11)',
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('path', {
						d: 'm12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z',
					}),
					/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('path', {
						d: 'm21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z',
					}),
				],
			}),
			/* @__PURE__ */ (0, import_jsx_runtime39.jsxs)('g', {
				fill: 'white',
				transform: 'translate(-12,-12)',
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('path', {
						d: 'm12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z',
					}),
					/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('path', {
						d: 'm21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z',
					}),
				],
			}),
			/* @__PURE__ */ (0, import_jsx_runtime39.jsxs)('g', {
				fill: 'currentColor',
				transform: 'translate(-12,-12)',
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('path', {
						d: 'm19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z',
					}),
					/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('path', {
						d: 'm13 10.814v11.188l2.969-2.866.428-.139h4.768z',
					}),
				],
			}),
		],
	})
}
function CollaboratorHint() {
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('path', {
		id: 'cursor_hint',
		fill: 'currentColor',
		d: 'M -2,-5 2,0 -2,5 Z',
	})
}
function ArrowheadDot() {
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('marker', {
		id: 'arrowhead-dot',
		className: 'tl-arrow-hint',
		refX: '3.0',
		refY: '3.0',
		orient: '0',
		children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('circle', {
			cx: '3',
			cy: '3',
			r: '2',
			strokeDasharray: '100%',
		}),
	})
}
function ArrowheadCross() {
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)('marker', {
		id: 'arrowhead-cross',
		className: 'tl-arrow-hint',
		refX: '3.0',
		refY: '3.0',
		orient: 'auto',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('line', {
				x1: '1.5',
				y1: '1.5',
				x2: '4.5',
				y2: '4.5',
				strokeDasharray: '100%',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime39.jsx)('line', {
				x1: '1.5',
				y1: '4.5',
				x2: '4.5',
				y2: '1.5',
				strokeDasharray: '100%',
			}),
		],
	})
}
var DebugSvgCopy = track(function DupSvg({ id }) {
	const app = useApp()
	const shape = app.getShapeById(id)
	const [html, setHtml] = React19.useState('')
	const isInRoot = shape?.parentId === app.currentPageId
	React19.useEffect(() => {
		if (!isInRoot) return
		let latest = null
		const unsubscribe = react('shape to svg', async () => {
			const renderId = Math.random()
			latest = renderId
			const bb = app.getPageBoundsById(id)
			const el = await app.getSvg([id], { padding: 0 })
			if (el && bb && latest === renderId) {
				el.style.setProperty('overflow', 'visible')
				el.setAttribute('preserveAspectRatio', 'xMidYMin slice')
				el.style.setProperty('transform', `translate(${bb.x}px, ${bb.y + bb.h + 12}px)`)
				el.style.setProperty('border', '1px solid black')
				setHtml(el?.outerHTML)
			}
		})
		return () => {
			latest = null
			unsubscribe()
		}
	}, [app, id, isInRoot])
	if (!isInRoot) return null
	return /* @__PURE__ */ (0,
	import_jsx_runtime39.jsx)('div', { style: { paddingTop: 12, position: 'absolute' }, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('div', { style: { display: 'flex' }, dangerouslySetInnerHTML: { __html: html } }) })
})
var UiLogger = () => {
	const logMessages = useValue(debugFlags.logMessages)
	return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)('div', {
		className: 'debug__ui-logger',
		children: logMessages.map((message, messageIndex) => {
			const text = typeof message === 'string' ? message : JSON.stringify(message)
			return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
				'div',
				{ className: 'debug__ui-logger__line', children: text },
				messageIndex
			)
		}),
	})
}

// ../packages/editor/src/lib/components/DefaultErrorFallback.tsx
var import_jsx_runtime40 = __toESM(require_jsx_runtime())
var BASE_ERROR_URL = 'https://github.com/tldraw/tldraw/issues/new'
function noop2() {}
var DefaultErrorFallback = ({ error, app }) => {
	const containerRef = (0, import_react34.useRef)(null)
	const [shouldShowError, setShouldShowError] = (0, import_react34.useState)(
		define_process_default.env.NODE_ENV === 'development'
	)
	const [didCopy, setDidCopy] = (0, import_react34.useState)(false)
	const [shouldShowResetConfirmation, setShouldShowResetConfirmation] = (0,
	import_react34.useState)(false)
	const errorMessage = error instanceof Error ? error.message : String(error)
	const errorStack = error instanceof Error ? error.stack : null
	const isDarkModeFromApp = useValue(
		'isDarkMode',
		() => {
			try {
				if (app) {
					return app.isDarkMode
				}
			} catch {}
			return null
		},
		[app]
	)
	const [isDarkMode, setIsDarkMode] = (0, import_react34.useState)(null)
	;(0, import_react34.useLayoutEffect)(() => {
		if (isDarkModeFromApp !== null) {
			setIsDarkMode(isDarkModeFromApp)
		}
		let parent = containerRef.current?.parentElement
		let foundParentThemeClass = false
		while (parent) {
			if (
				parent.classList.contains('tl-theme__dark') ||
				parent.classList.contains('tl-theme__light')
			) {
				foundParentThemeClass = true
				break
			}
			parent = parent.parentElement
		}
		if (foundParentThemeClass) {
			setIsDarkMode(null)
			return
		}
		setIsDarkMode(window.matchMedia('(prefetl-color-scheme: dark)').matches)
	}, [isDarkModeFromApp])
	;(0, import_react34.useEffect)(() => {
		if (didCopy) {
			const timeout = setTimeout(() => {
				setDidCopy(false)
			}, 2e3)
			return () => clearTimeout(timeout)
		}
	}, [didCopy])
	const copyError = () => {
		const textarea = document.createElement('textarea')
		textarea.value = errorStack ?? errorMessage
		document.body.appendChild(textarea)
		textarea.select()
		document.execCommand('copy')
		textarea.remove()
		setDidCopy(true)
	}
	const refresh = () => {
		refreshPage()
	}
	const resetLocalState = async () => {
		hardResetApp()
	}
	const url = new URL(BASE_ERROR_URL)
	url.searchParams.set('title', errorMessage)
	url.searchParams.set('labels', `bug`)
	url.searchParams.set(
		'body',
		`Hey, I ran into an error while using tldraw:

\`\`\`js
${errorStack ?? errorMessage}
\`\`\`

My browser: ${navigator.userAgent}`
	)
	return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)('div', {
		ref: containerRef,
		className: (0, import_classnames10.default)(
			'tl-container tl-error-boundary',
			// error-boundary is sometimes used outside of the theme
			// container, so we need to provide it with a theme for our
			// styles to work correctly
			isDarkMode === null ? '' : isDarkMode ? 'tl-theme__dark' : 'tl-theme__light'
		),
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('div', {
				className: 'tl-error-boundary__overlay',
			}),
			app && // opportunistically attempt to render the canvas to reassure
				// the user that their document is still there. there's a good
				// chance this won't work (ie the error that we're currently
				// notifying the user about originates in the canvas) so it's
				// not a big deal if it doesn't work - in that case we just have
				// a plain grey background.
				/* @__PURE__ */ (0, import_jsx_runtime40.jsx)(ErrorBoundary, {
					onError: noop2,
					fallback: () => null,
					children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(AppContext.Provider, {
						value: app,
						children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)('div', {
							className: 'tl-overlay tl-error-boundary__canvas',
							children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Canvas, {}),
						}),
					}),
				}),
			/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('div', {
				className: (0, import_classnames10.default)('tl-modal', 'tl-error-boundary__content', {
					'tl-error-boundary__content__expanded': shouldShowError && !shouldShowResetConfirmation,
				}),
				children: shouldShowResetConfirmation
					? /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, {
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('h2', { children: 'Are you sure?' }),
								/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('p', {
									children: 'Resetting your data will delete your drawing and cannot be undone.',
								}),
								/* @__PURE__ */ (0, import_jsx_runtime40.jsxs)('div', {
									className: 'tl-error-boundary__content__actions',
									children: [
										/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('button', {
											onClick: () => setShouldShowResetConfirmation(false),
											children: 'Cancel',
										}),
										/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('button', {
											className: 'tl-error-boundary__reset',
											onClick: resetLocalState,
											children: 'Reset data',
										}),
									],
								}),
							],
					  })
					: /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, {
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('h2', {
									children: "Something's gone wrong.",
								}),
								/* @__PURE__ */ (0, import_jsx_runtime40.jsxs)('p', {
									children: [
										'Sorry, we encountered an error. Please refresh the page to continue. If you keep seeing this error, you can ',
										/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('a', {
											href: url.toString(),
											children: 'create a GitHub issue',
										}),
										' or',
										' ',
										/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('a', {
											href: 'https://discord.gg/Cq6cPsTfNy',
											children: 'ask for help on Discord',
										}),
										'.',
									],
								}),
								shouldShowError &&
									/* @__PURE__ */ (0, import_jsx_runtime40.jsxs)('div', {
										className: 'tl-error-boundary__content__error',
										children: [
											/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('pre', {
												children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)('code', {
													children: errorStack ?? errorMessage,
												}),
											}),
											/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('button', {
												onClick: copyError,
												children: didCopy ? 'Copied!' : 'Copy',
											}),
										],
									}),
								/* @__PURE__ */ (0, import_jsx_runtime40.jsxs)('div', {
									className: 'tl-error-boundary__content__actions',
									children: [
										/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('button', {
											onClick: () => setShouldShowError(!shouldShowError),
											children: shouldShowError ? 'Hide details' : 'Show details',
										}),
										/* @__PURE__ */ (0, import_jsx_runtime40.jsxs)('div', {
											className: 'tl-error-boundary__content__actions__group',
											children: [
												/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('button', {
													className: 'tl-error-boundary__reset',
													onClick: () => setShouldShowResetConfirmation(true),
													children: 'Reset data',
												}),
												/* @__PURE__ */ (0, import_jsx_runtime40.jsx)('button', {
													className: 'tl-error-boundary__refresh',
													onClick: refresh,
													children: 'Refresh Page',
												}),
											],
										}),
									],
								}),
							],
					  }),
			}),
		],
	})
}

// ../packages/editor/src/lib/hooks/useDarkMode.ts
init_define_process()
var import_react35 = __toESM(require_react())
function useDarkMode() {
	const app = useApp()
	const container = useContainer()
	const isDarkMode = useValue('isDarkMode', () => app.isDarkMode, [app])
	import_react35.default.useEffect(() => {
		if (isDarkMode) {
			container.setAttribute('data-color-mode', 'dark')
			container.classList.remove('tl-theme__light')
			container.classList.add('tl-theme__dark')
			app.setCursor({
				color: 'white',
			})
		} else {
			container.setAttribute('data-color-mode', 'light')
			container.classList.remove('tl-theme__dark')
			container.classList.add('tl-theme__light')
			app.setCursor({
				color: 'black',
			})
		}
	}, [app, container, isDarkMode])
}

// ../packages/editor/src/lib/hooks/useEvent.tsx
init_define_process()
var import_react36 = __toESM(require_react())
function useEvent(handler) {
	const handlerRef = (0, import_react36.useRef)()
	;(0, import_react36.useLayoutEffect)(() => {
		handlerRef.current = handler
	})
	;(0, import_react36.useDebugValue)(handler)
	return (0, import_react36.useCallback)((...args) => {
		const fn = handlerRef.current
		assert(fn, 'fn does not exist')
		return fn(...args)
	}, [])
}

// ../packages/editor/src/lib/hooks/useForceUpdate.ts
init_define_process()
var import_react37 = __toESM(require_react())
function useForceUpdate() {
	const [_, ss] = (0, import_react37.useState)(0)
	;(0, import_react37.useEffect)(() => ss((s3) => s3 + 1), [])
}

// ../packages/editor/src/lib/hooks/usePreloadAssets.ts
init_define_process()
var import_react38 = __toESM(require_react())
var usePreloadFont = (id, font) => {
	const [state, setState] = (0, import_react38.useState)(2 /* WAITING */)
	;(0, import_react38.useEffect)(() => {
		const {
			url,
			style = 'normal',
			weight = '500',
			display,
			featureSettings,
			stretch,
			unicodeRange,
			variant,
		} = font
		let cancelled = false
		setState(2 /* WAITING */)
		const descriptors = {
			style,
			weight,
			display,
			featureSettings,
			stretch,
			unicodeRange,
			variant,
		}
		const fontInstance = new FontFace(id, `url(${url})`, descriptors)
		fontInstance
			.load()
			.then(() => {
				if (cancelled) return
				document.fonts.add(fontInstance)
				setState(0 /* SUCCESS */)
			})
			.catch((err) => {
				if (cancelled) return
				console.error(err)
				setState(1 /* FAILED */)
			})
		fontInstance.$$_url = url
		fontInstance.$$_fontface = `
@font-face {
	font-family: ${fontInstance.family};
	font-stretch: ${fontInstance.stretch};
	font-weight: ${fontInstance.weight};
	font-style: ${fontInstance.style};
	src: url("${url}") format("woff2")
}`
		return () => {
			document.fonts.delete(fontInstance)
			cancelled = true
		}
	}, [id, font])
	return state
}
function getTypefaces(assetUrls2) {
	return {
		draw: { url: assetUrls2.fonts.draw },
		serif: { url: assetUrls2.fonts.serif },
		sansSerif: { url: assetUrls2.fonts.sansSerif },
		monospace: { url: assetUrls2.fonts.monospace },
	}
}
function usePreloadAssets(assetUrls2) {
	const typefaces = (0, import_react38.useMemo)(() => getTypefaces(assetUrls2), [assetUrls2])
	const results = [
		usePreloadFont('tldraw_draw', typefaces.draw),
		usePreloadFont('tldraw_serif', typefaces.serif),
		usePreloadFont('tldraw_sans', typefaces.sansSerif),
		usePreloadFont('tldraw_mono', typefaces.monospace),
	]
	return {
		// If any of the results have errored, then preloading has failed
		error: results.some((result) => result === 1 /* FAILED */),
		// If any of the results are waiting, then we're not done yet
		done: !results.some((result) => result === 2 /* WAITING */),
	}
}

// ../packages/editor/src/lib/hooks/useSafariFocusOutFix.ts
init_define_process()
var React21 = __toESM(require_react())
var isMobileSafari = false
if (typeof window !== 'undefined') {
	const ua = window.navigator.userAgent
	const iOS2 = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i)
	const webkit = !!ua.match(/WebKit/i)
	isMobileSafari = iOS2 && webkit && !ua.match(/CriOS/i)
}
function useSafariFocusOutFix() {
	const app = useApp()
	React21.useEffect(() => {
		if (!isMobileSafari) return
		function handleFocusOut(e2) {
			if (
				(e2.target instanceof HTMLInputElement && e2.target.type === 'text') ||
				e2.target instanceof HTMLTextAreaElement
			) {
				app.complete()
			}
		}
		document.addEventListener('focusout', handleFocusOut)
		return () => document.removeEventListener('focusout', handleFocusOut)
	}, [app])
}

// ../packages/editor/src/lib/hooks/useZoomCss.ts
init_define_process()
var React22 = __toESM(require_react())
function useZoomCss() {
	const app = useApp()
	const container = useContainer()
	React22.useEffect(() => {
		const setScale = (s3) => container.style.setProperty('--tl-zoom', s3.toString())
		const setScaleDebounced = debounce(setScale, 100)
		const scheduler = new EffectScheduler('useZoomCss', () => {
			const numShapes = app.shapeIds.size
			if (numShapes < 300) {
				setScale(app.zoomLevel)
			} else {
				setScaleDebounced(app.zoomLevel)
			}
		})
		scheduler.attach()
		scheduler.execute()
		return () => {
			scheduler.detach()
		}
	}, [app, container])
}

// ../packages/editor/src/lib/TldrawEditor.tsx
var import_jsx_runtime41 = __toESM(require_jsx_runtime())
function TldrawEditor(props) {
	const [container, setContainer] = import_react39.default.useState(null)
	const { components, ...rest } = props
	const ErrorFallback =
		components?.ErrorFallback === void 0 ? DefaultErrorFallback : components?.ErrorFallback
	return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)('div', {
		ref: setContainer,
		draggable: false,
		className: 'tl-container tl-theme__light',
		tabIndex: 0,
		children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(OptionalErrorBoundary, {
			fallback: ErrorFallback
				? (error) => /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(ErrorFallback, { error })
				: null,
			onError: (error) => annotateError(error, { tags: { origin: 'react.tldraw-before-app' } }),
			children:
				container &&
				/* @__PURE__ */ (0, import_jsx_runtime41.jsx)(ContainerProvider, {
					container,
					children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(EditorComponentsProvider, {
						overrides: components,
						children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(TldrawEditorBeforeLoading, {
							...rest,
						}),
					}),
				}),
		}),
	})
}
function TldrawEditorBeforeLoading({ config, instanceId, store, ...props }) {
	const { done: preloadingComplete, error: preloadingError } = usePreloadAssets(
		props.assetUrls ?? defaultEditorAssetUrls
	)
	const _store = (0, import_react39.useMemo)(() => {
		return (
			store ??
			config.createStore({
				instanceId: instanceId ?? InstanceRecordType.createId(),
			})
		)
	}, [store, config, instanceId])
	let loadedStore
	if (!(_store instanceof Store)) {
		if (_store.error) {
			throw _store.error
		}
		if (!_store.store) {
			return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(LoadingScreen, {
				children: 'Connecting...',
			})
		}
		loadedStore = _store.store
	} else {
		loadedStore = _store
	}
	if (instanceId && loadedStore.props.instanceId !== instanceId) {
		console.error(
			`The store's instanceId (${loadedStore.props.instanceId}) does not match the instanceId prop (${instanceId}). This may cause unexpected behavior.`
		)
	}
	if (preloadingError) {
		return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(ErrorScreen, {
			children: 'Could not load assets. Please refresh the page.',
		})
	}
	if (!preloadingComplete) {
		return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(LoadingScreen, {
			children: 'Loading assets...',
		})
	}
	return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(TldrawEditorAfterLoading, {
		...props,
		store: loadedStore,
		config,
	})
}
function TldrawEditorAfterLoading({
	onMount,
	config,
	children,
	onCreateAssetFromFile,
	onCreateBookmarkFromUrl,
	store,
	autoFocus,
}) {
	const container = useContainer()
	const [app, setApp] = import_react39.default.useState(null)
	const { ErrorFallback } = useEditorComponents()
	import_react39.default.useLayoutEffect(() => {
		const app2 = new App({
			store,
			config,
			getContainer: () => container,
		})
		setApp(app2)
		if (autoFocus) {
			app2.focus()
		}
		window.app = app2
		return () => {
			app2.dispose()
			setApp((prevApp) => (prevApp === app2 ? null : prevApp))
		}
	}, [container, config, store, autoFocus])
	import_react39.default.useEffect(() => {
		if (app) {
			if (onCreateAssetFromFile) {
				app.onCreateAssetFromFile = onCreateAssetFromFile
			}
			if (onCreateBookmarkFromUrl) {
				app.onCreateBookmarkFromUrl = onCreateBookmarkFromUrl
			}
		}
	}, [app, onCreateAssetFromFile, onCreateBookmarkFromUrl])
	const onMountEvent = useEvent((app2) => {
		onMount?.(app2)
		app2.emit('mount')
		window.tldrawReady = true
	})
	import_react39.default.useEffect(() => {
		if (app) {
			onMountEvent(app)
		}
	}, [app, onMountEvent])
	const crashingError = (0, import_react39.useSyncExternalStore)(
		(0, import_react39.useCallback)(
			(onStoreChange) => {
				if (app) {
					app.on('crash', onStoreChange)
					return () => app.off('crash', onStoreChange)
				}
				return () => {}
			},
			[app]
		),
		() => app?.crashingError ?? null
	)
	if (!app) {
		return null
	}
	return (
		// the top-level tldraw component also renders an error boundary almost
		// identical to this one. the reason we have two is because this one has
		// access to `App`, which means that here we can enrich errors with data
		// from app for reporting, and also still attempt to render the user's
		// document in the event of an error to reassure them that their work is
		// not lost.
		/* @__PURE__ */ (0, import_jsx_runtime41.jsx)(OptionalErrorBoundary, {
			fallback: ErrorFallback
				? (error) => /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(ErrorFallback, { error, app })
				: null,
			onError: (error) => app.annotateError(error, { origin: 'react.tldraw', willCrashApp: true }),
			children: crashingError
				? /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Crash, { crashingError })
				: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(AppContext.Provider, {
						value: app,
						children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Layout, { children }),
				  }),
		})
	)
}
function Layout({ children }) {
	useZoomCss()
	useCursor()
	useDarkMode()
	useSafariFocusOutFix()
	useForceUpdate()
	return children
}
function Crash({ crashingError }) {
	throw crashingError
}
function LoadingScreen({ children }) {
	const { Spinner: Spinner2 } = useEditorComponents()
	return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)('div', {
		className: 'tl-loading',
		children: [
			Spinner2 ? /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Spinner2, {}) : null,
			children,
		],
	})
}
function ErrorScreen({ children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)('div', { className: 'tl-loading', children })
}

// ../packages/editor/src/lib/app/shapeutils/TLBookmarkUtil/TLBookmarkUtil.tsx
init_define_process()
var import_jsx_runtime42 = __toESM(require_jsx_runtime())
var TLBookmarkUtil = class extends TLBoxUtil {
	canResize = () => false
	hideSelectionBoundsBg = () => true
	hideSelectionBoundsFg = () => true
	defaultProps() {
		return {
			opacity: '1',
			url: '',
			w: DEFAULT_BOOKMARK_WIDTH,
			h: DEFAULT_BOOKMARK_HEIGHT,
			assetId: null,
		}
	}
	render(shape) {
		const asset = shape.props.assetId ? this.app.getAssetById(shape.props.assetId) : null
		const pageRotation = this.app.getPageRotation(shape)
		const address = this.getHumanReadableAddress(shape)
		return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(HTMLContainer, {
			children: /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)('div', {
				className: 'tl-bookmark__container tl-hitarea-stroke',
				style: {
					boxShadow: rotateBoxShadow(pageRotation, ROTATING_SHADOWS),
				},
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime42.jsxs)('div', {
						className: 'tl-bookmark__image_container',
						children: [
							asset?.props.image
								? /* @__PURE__ */ (0, import_jsx_runtime42.jsx)('img', {
										className: 'tl-bookmark__image',
										draggable: false,
										src: asset?.props.image,
										alt: asset?.props.title || '',
								  })
								: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)('div', {
										className: 'tl-bookmark__placeholder',
								  }),
							/* @__PURE__ */ (0, import_jsx_runtime42.jsx)(HyperlinkButton, {
								url: shape.props.url,
								zoomLevel: this.app.zoomLevel,
							}),
						],
					}),
					/* @__PURE__ */ (0, import_jsx_runtime42.jsxs)('div', {
						className: 'tl-bookmark__copy_container',
						children: [
							asset?.props.title &&
								/* @__PURE__ */ (0, import_jsx_runtime42.jsx)('h2', {
									className: 'tl-bookmark__heading',
									children: truncateStringWithEllipsis(asset?.props.title || '', 54),
								}),
							asset?.props.description &&
								/* @__PURE__ */ (0, import_jsx_runtime42.jsx)('p', {
									className: 'tl-bookmark__description',
									children: truncateStringWithEllipsis(asset?.props.description || '', 128),
								}),
							/* @__PURE__ */ (0, import_jsx_runtime42.jsx)('a', {
								className: 'tl-bookmark__link',
								href: shape.props.url || '',
								target: '_blank',
								rel: 'noopener noreferrer',
								onPointerDown: stopEventPropagation,
								onPointerUp: stopEventPropagation,
								onClick: stopEventPropagation,
								children: truncateStringWithEllipsis(address, 45),
							}),
						],
					}),
				],
			}),
		})
	}
	indicator(shape) {
		return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)('rect', {
			width: toDomPrecision(shape.props.w),
			height: toDomPrecision(shape.props.h),
			rx: '8',
			ry: '8',
		})
	}
	onBeforeCreate = (shape) => {
		this.updateBookmarkAsset(shape)
	}
	onBeforeUpdate = (prev, shape) => {
		if (prev.props.url !== shape.props.url) {
			this.updateBookmarkAsset(shape)
		}
	}
	getHumanReadableAddress(shape) {
		try {
			const url = new URL(shape.props.url)
			const path = url.pathname.replace(/\/*$/, '')
			return `${url.hostname}${path}`
		} catch (e2) {
			return shape.props.url
		}
	}
	updateBookmarkAsset = debounce((shape) => {
		const { url } = shape.props
		const assetId = AssetRecordType.createCustomId(getHashForString(url))
		const existing = this.app.getAssetById(assetId)
		if (existing) {
			if (shape.props.assetId !== existing.id) {
				this.app.updateShapes([
					{
						id: shape.id,
						type: shape.type,
						props: { assetId },
					},
				])
			}
		} else if (this.app.onCreateBookmarkFromUrl) {
			this.app.onCreateBookmarkFromUrl(url).then((meta) => {
				if (!meta) {
					this.app.updateShapes([
						{
							id: shape.id,
							type: shape.type,
							props: { assetId: void 0 },
						},
					])
					return
				}
				this.app.batch(() => {
					this.app
						.createAssets([
							{
								id: assetId,
								typeName: 'asset',
								type: 'bookmark',
								props: {
									src: url,
									description: meta.description,
									image: meta.image,
									title: meta.title,
								},
							},
						])
						.updateShapes([
							{
								id: shape.id,
								type: shape.type,
								props: { assetId },
							},
						])
				})
			})
		}
	}, 500)
}
__publicField(TLBookmarkUtil, 'type', 'bookmark')

// ../packages/editor/src/lib/app/shapeutils/TLEmbedUtil/TLEmbedUtil.tsx
init_define_process()
var React24 = __toESM(require_react())
var import_react40 = __toESM(require_react())

// ../packages/editor/src/lib/utils/embeds.ts
init_define_process()

// ../node_modules/escape-string-regexp/index.js
init_define_process()
function escapeStringRegexp(string2) {
	if (typeof string2 !== 'string') {
		throw new TypeError('Expected a string')
	}
	return string2.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d')
}

// ../packages/editor/src/lib/utils/embeds.ts
function matchEmbedUrl(url) {
	const host = new URL(url).host.replace('www.', '')
	for (const localEmbedDef of EMBED_DEFINITIONS) {
		if (checkHostnames(localEmbedDef.hostnames, host)) {
			const originalUrl = localEmbedDef.fromEmbedUrl(url)
			if (originalUrl) {
				return {
					definition: localEmbedDef,
					url: originalUrl,
					embedUrl: url,
				}
			}
		}
	}
}
var globlikeRegExp = (input) => {
	return input
		.split('*')
		.map((str) => escapeStringRegexp(str))
		.join('.+')
}
var checkHostnames = (hostnames, targetHostname) => {
	return !!hostnames.find((hostname) => {
		const re = new RegExp(globlikeRegExp(hostname))
		return targetHostname.match(re)
	})
}
function matchUrl(url) {
	const host = new URL(url).host.replace('www.', '')
	for (const localEmbedDef of EMBED_DEFINITIONS) {
		if (checkHostnames(localEmbedDef.hostnames, host)) {
			const embedUrl = localEmbedDef.toEmbedUrl(url)
			if (embedUrl) {
				return {
					definition: localEmbedDef,
					embedUrl,
					url,
				}
			}
		}
	}
}
function getEmbedInfoUnsafely(inputUrl) {
	const result = matchUrl(inputUrl) ?? matchEmbedUrl(inputUrl)
	return result
}
function getEmbedInfo(inputUrl) {
	try {
		return getEmbedInfoUnsafely(inputUrl)
	} catch (e2) {
		console.error(e2)
	}
	return void 0
}

// ../packages/editor/src/lib/app/shapeutils/TLEmbedUtil/TLEmbedUtil.tsx
var import_jsx_runtime43 = __toESM(require_jsx_runtime())
var getSandboxPermissions = (permissions) => {
	return Object.entries(permissions)
		.filter(([_perm, isEnabled]) => isEnabled)
		.map(([perm]) => perm)
		.join(' ')
}
var TLEmbedUtil = class extends TLBoxUtil {
	canUnmount = () => false
	canResize = (shape) => {
		const result = getEmbedInfo(shape.props.url)
		return !!result?.definition?.doesResize
	}
	hideSelectionBoundsBg = (shape) => !this.canResize(shape)
	hideSelectionBoundsFg = (shape) => !this.canResize(shape)
	canEdit = () => true
	defaultProps() {
		return {
			opacity: '1',
			w: 300,
			h: 300,
			url: '',
			doesResize: true,
		}
	}
	isAspectRatioLocked = (shape) => {
		const embedInfo = getEmbedInfo(shape.props.url)
		return embedInfo?.definition.isAspectRatioLocked ?? false
	}
	onResize = (shape, info) => {
		const isAspectRatioLocked = this.isAspectRatioLocked(shape)
		const embedInfo = getEmbedInfo(shape.props.url)
		let minWidth = embedInfo?.definition.minWidth ?? 200
		let minHeight = embedInfo?.definition.minHeight ?? 200
		if (isAspectRatioLocked) {
			const aspectRatio = shape.props.w / shape.props.h
			if (aspectRatio > 1) {
				minWidth *= aspectRatio
			} else {
				minHeight /= aspectRatio
			}
		}
		return resizeBox(shape, info, { minWidth, minHeight })
	}
	render(shape) {
		const { w: w3, h: h3, url } = shape.props
		const isEditing = useIsEditing(shape.id)
		const embedInfo = (0, import_react40.useMemo)(() => getEmbedInfoUnsafely(url), [url])
		const isHoveringWhileEditingSameShape = useValue(
			'is hovering',
			() => {
				const { editingId, hoveredId } = this.app.pageState
				if (editingId && hoveredId !== editingId) {
					const editingShape = this.app.getShapeById(editingId)
					if (editingShape && editingShape.type === 'embed') {
						return true
					}
				}
				return false
			},
			[]
		)
		const pageRotation = this.app.getPageRotation(shape)
		const isInteractive = isEditing || isHoveringWhileEditingSameShape
		if (embedInfo?.definition.type === 'github_gist') {
			const idFromGistUrl = embedInfo.url.split('/').pop()
			if (idFromGistUrl) {
				return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(HTMLContainer, {
					className: 'tl-embed-container',
					id: shape.id,
					children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Gist, {
						id: idFromGistUrl,
						width: toDomPrecision(w3),
						height: toDomPrecision(h3),
						isInteractive,
						pageRotation,
					}),
				})
			}
		}
		const sandbox = getSandboxPermissions({
			...tlEmbedShapePermissionDefaults,
			...(embedInfo?.definition.overridePermissions ?? {}),
		})
		return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(HTMLContainer, {
			className: 'tl-embed-container',
			id: shape.id,
			children: embedInfo?.definition
				? /* @__PURE__ */ (0, import_jsx_runtime43.jsx)('iframe', {
						className: `tl-embed tl-embed-${shape.id}`,
						sandbox,
						src: embedInfo.embedUrl,
						width: toDomPrecision(w3),
						height: toDomPrecision(h3),
						draggable: false,
						frameBorder: '0',
						referrerPolicy: 'no-referrer-when-downgrade',
						style: {
							border: 0,
							pointerEvents: isInteractive ? 'auto' : 'none',
							// Fix for safari <https://stackoverflow.com/a/49150908>
							zIndex: isInteractive ? '' : '-1',
							boxShadow: rotateBoxShadow(pageRotation, ROTATING_SHADOWS),
							borderRadius: embedInfo?.definition.overrideOutlineRadius ?? 8,
							background: embedInfo?.definition.backgroundColor,
						},
				  })
				: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)('g', {
						transform: `translate(${(w3 - 38) / 2}, ${(h3 - 38) / 2})`,
						children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(DefaultSpinner, {}),
				  }),
		})
	}
	indicator(shape) {
		const embedInfo = (0, import_react40.useMemo)(
			() => getEmbedInfo(shape.props.url),
			[shape.props.url]
		)
		return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)('rect', {
			width: toDomPrecision(shape.props.w),
			height: toDomPrecision(shape.props.h),
			rx: embedInfo?.definition.overrideOutlineRadius ?? 8,
			ry: embedInfo?.definition.overrideOutlineRadius ?? 8,
		})
	}
}
__publicField(TLEmbedUtil, 'type', 'embed')
function Gist({ id, file, isInteractive, width, height, style, pageRotation }) {
	const rIframe = React24.useRef(null)
	const fileArg = file ? `?file=${file}` : ''
	const gistLink = `https://gist.github.com/${id}.js${fileArg}`
	return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)('iframe', {
		ref: rIframe,
		className: 'tl-embed',
		draggable: false,
		width: toDomPrecision(width),
		height: toDomPrecision(height),
		frameBorder: '0',
		scrolling: 'no',
		seamless: true,
		referrerPolicy: 'no-referrer-when-downgrade',
		style: {
			...style,
			pointerEvents: isInteractive ? 'all' : 'none',
			// Fix for safari <https://stackoverflow.com/a/49150908>
			zIndex: isInteractive ? '' : '-1',
			boxShadow: rotateBoxShadow(pageRotation, ROTATING_SHADOWS),
		},
		srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${gistLink}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`,
	})
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/TLGeoUtil.tsx
init_define_process()

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DashStyleEllipse.tsx
init_define_process()
var React25 = __toESM(require_react())
var import_jsx_runtime44 = __toESM(require_jsx_runtime())
var DashStyleEllipse = React25.memo(function DashStyleEllipse2({
	w: w3,
	h: h3,
	strokeWidth: sw,
	dash,
	color,
	fill,
}) {
	const cx = w3 / 2
	const cy = h3 / 2
	const rx = Math.max(0, cx - sw / 2)
	const ry = Math.max(0, cy - sw / 2)
	const perimeter = perimeterOfEllipse(rx, ry)
	const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
		perimeter < 64 ? perimeter * 2 : perimeter,
		sw,
		{
			style: dash,
			snap: 4,
			closed: true,
		}
	)
	const d3 = `M${cx - rx},${cy}a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`
	return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime44.jsx)(ShapeFill, { d: d3, color, fill }),
			/* @__PURE__ */ (0, import_jsx_runtime44.jsx)('path', {
				d: d3,
				strokeWidth: sw,
				width: toDomPrecision(w3),
				height: toDomPrecision(h3),
				fill: 'none',
				stroke: 'currentColor',
				strokeDasharray,
				strokeDashoffset,
				pointerEvents: 'all',
			}),
		],
	})
})
function DashStyleEllipseSvg({ w: w3, h: h3, strokeWidth: sw, dash, color, colors, fill }) {
	const cx = w3 / 2
	const cy = h3 / 2
	const rx = Math.max(0, cx - sw / 2)
	const ry = Math.max(0, cy - sw / 2)
	const perimeter = perimeterOfEllipse(rx, ry)
	const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
		perimeter < 64 ? perimeter * 2 : perimeter,
		sw,
		{
			style: dash,
			snap: 4,
			closed: true,
		}
	)
	const d3 = `M${cx - rx},${cy}a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`
	const strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	strokeElement.setAttribute('d', d3)
	strokeElement.setAttribute('stroke-width', sw.toString())
	strokeElement.setAttribute('width', w3.toString())
	strokeElement.setAttribute('height', h3.toString())
	strokeElement.setAttribute('fill', 'none')
	strokeElement.setAttribute('stroke', colors.fill[color])
	strokeElement.setAttribute('stroke-dasharray', strokeDasharray)
	strokeElement.setAttribute('stroke-dashoffset', strokeDashoffset)
	const fillElement = getShapeFillSvg({
		d: d3,
		fill,
		color,
		colors,
	})
	return getSvgWithShapeFill(strokeElement, fillElement)
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DashStyleOval.tsx
init_define_process()
var React26 = __toESM(require_react())

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/helpers.ts
init_define_process()
function getOvalSolidPath(w3, h3) {
	if (h3 > w3) {
		const offset2 = w3 / 2
		return `
    M0,${offset2}
    a${offset2},${offset2},0,1,1,${offset2 * 2},0
    L${w3},${h3 - offset2}
    a${offset2},${offset2},0,1,1,-${offset2 * 2},0
    Z`
	}
	const offset = h3 / 2
	return `
    M${offset},0
    L${w3 - offset},0
    a${offset},${offset},0,1,1,0,${offset * 2}
    L${offset},${h3}
    a${offset},${offset},0,1,1,0,${-offset * 2}
    Z`
}
function getOvalPerimeter(h3, w3) {
	if (h3 > w3) {
		const offset2 = w3 / 2
		return perimeterOfEllipse(offset2, offset2) + (h3 - offset2 * 2) * 2
	}
	const offset = h3 / 2
	return perimeterOfEllipse(offset, offset) + (w3 - offset * 2) * 2
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DashStyleOval.tsx
var import_jsx_runtime45 = __toESM(require_jsx_runtime())
var DashStyleOval = React26.memo(function DashStyleOval2({
	w: w3,
	h: h3,
	strokeWidth: sw,
	dash,
	color,
	fill,
}) {
	const d3 = getOvalSolidPath(w3, h3)
	const perimeter = getOvalPerimeter(w3, h3)
	const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
		perimeter < 64 ? perimeter * 2 : perimeter,
		sw,
		{
			style: dash,
			snap: 4,
			start: 'outset',
			end: 'outset',
			closed: true,
		}
	)
	return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime45.jsx)(ShapeFill, { d: d3, color, fill }),
			/* @__PURE__ */ (0, import_jsx_runtime45.jsx)('path', {
				d: d3,
				strokeWidth: sw,
				width: toDomPrecision(w3),
				height: toDomPrecision(h3),
				fill: 'none',
				stroke: 'currentColor',
				strokeDasharray,
				strokeDashoffset,
				pointerEvents: 'all',
			}),
		],
	})
})
function DashStyleOvalSvg({ w: w3, h: h3, strokeWidth: sw, dash, color, colors, fill }) {
	const d3 = getOvalSolidPath(w3, h3)
	const perimeter = getOvalPerimeter(w3, h3)
	const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
		perimeter < 64 ? perimeter * 2 : perimeter,
		sw,
		{
			style: dash,
			snap: 4,
			closed: true,
		}
	)
	const strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	strokeElement.setAttribute('d', d3)
	strokeElement.setAttribute('stroke-width', sw.toString())
	strokeElement.setAttribute('width', w3.toString())
	strokeElement.setAttribute('height', h3.toString())
	strokeElement.setAttribute('fill', 'none')
	strokeElement.setAttribute('stroke', colors.fill[color])
	strokeElement.setAttribute('stroke-dasharray', strokeDasharray)
	strokeElement.setAttribute('stroke-dashoffset', strokeDashoffset)
	const fillElement = getShapeFillSvg({
		d: d3,
		fill,
		color,
		colors,
	})
	return getSvgWithShapeFill(strokeElement, fillElement)
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DashStylePolygon.tsx
init_define_process()
var React27 = __toESM(require_react())
var import_jsx_runtime46 = __toESM(require_jsx_runtime())
var DashStylePolygon = React27.memo(function DashStylePolygon2({
	dash,
	fill,
	color,
	strokeWidth,
	outline,
	lines,
}) {
	const innerPath = 'M' + outline[0] + 'L' + outline.slice(1) + 'Z'
	return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime46.jsx)(ShapeFill, { d: innerPath, fill, color }),
			lines &&
				lines.map((l3, i3) =>
					/* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
						'path',
						{
							className: 'tl-hitarea-stroke',
							fill: 'none',
							d: `M${l3[0].x},${l3[0].y}L${l3[1].x},${l3[1].y}`,
						},
						`line_bg_${i3}`
					)
				),
			/* @__PURE__ */ (0, import_jsx_runtime46.jsxs)('g', {
				strokeWidth,
				stroke: 'currentColor',
				fill: 'none',
				pointerEvents: 'all',
				children: [
					Array.from(Array(outline.length)).map((_, i3) => {
						const A2 = outline[i3]
						const B = outline[(i3 + 1) % outline.length]
						const dist = Vec2d.Dist(A2, B)
						const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
							style: dash,
							start: 'outset',
							end: 'outset',
						})
						return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
							'line',
							{
								x1: A2.x,
								y1: A2.y,
								x2: B.x,
								y2: B.y,
								strokeDasharray,
								strokeDashoffset,
							},
							i3
						)
					}),
					lines &&
						lines.map(([A2, B], i3) => {
							const dist = Vec2d.Dist(A2, B)
							const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
								style: dash,
								start: 'skip',
								end: 'outset',
								snap: dash === 'dotted' ? 4 : void 0,
							})
							return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
								'path',
								{
									d: `M${A2.x},${A2.y}L${B.x},${B.y}`,
									stroke: 'currentColor',
									strokeWidth,
									fill: 'none',
									strokeDasharray,
									strokeDashoffset,
								},
								`line_fg_${i3}`
							)
						}),
				],
			}),
		],
	})
})
function DashStylePolygonSvg({ dash, fill, color, colors, strokeWidth, outline, lines }) {
	const strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')
	strokeElement.setAttribute('stroke-width', strokeWidth.toString())
	strokeElement.setAttribute('stroke', colors.fill[color])
	strokeElement.setAttribute('fill', 'none')
	Array.from(Array(outline.length)).forEach((_, i3) => {
		const A2 = outline[i3]
		const B = outline[(i3 + 1) % outline.length]
		const dist = Vec2d.Dist(A2, B)
		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
			style: dash,
		})
		const line = document.createElementNS('http://www.w3.org/2000/svg', 'line')
		line.setAttribute('x1', A2.x.toString())
		line.setAttribute('y1', A2.y.toString())
		line.setAttribute('x2', B.x.toString())
		line.setAttribute('y2', B.y.toString())
		line.setAttribute('stroke-dasharray', strokeDasharray.toString())
		line.setAttribute('stroke-dashoffset', strokeDashoffset.toString())
		strokeElement.appendChild(line)
	})
	if (lines) {
		for (const [A2, B] of lines) {
			const dist = Vec2d.Dist(A2, B)
			const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
				style: dash,
				start: 'skip',
				end: 'skip',
				snap: dash === 'dotted' ? 4 : 2,
			})
			const line = document.createElementNS('http://www.w3.org/2000/svg', 'line')
			line.setAttribute('x1', A2.x.toString())
			line.setAttribute('y1', A2.y.toString())
			line.setAttribute('x2', B.x.toString())
			line.setAttribute('y2', B.y.toString())
			line.setAttribute('stroke-dasharray', strokeDasharray.toString())
			line.setAttribute('stroke-dashoffset', strokeDashoffset.toString())
			strokeElement.appendChild(line)
		}
	}
	const fillElement = getShapeFillSvg({
		d: 'M' + outline[0] + 'L' + outline.slice(1) + 'Z',
		fill,
		color,
		colors,
	})
	return getSvgWithShapeFill(strokeElement, fillElement)
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DrawStyleEllipse.tsx
init_define_process()
var React28 = __toESM(require_react())
var import_jsx_runtime47 = __toESM(require_jsx_runtime())
var DrawStyleEllipse = React28.memo(function DrawStyleEllipse2({
	id,
	w: w3,
	h: h3,
	strokeWidth: sw,
	fill,
	color,
}) {
	const innerPath = getEllipseIndicatorPath(id, w3, h3, sw)
	const outerPath = getEllipsePath(id, w3, h3, sw)
	return /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime47.jsx)(ShapeFill, { d: innerPath, color, fill }),
			/* @__PURE__ */ (0, import_jsx_runtime47.jsx)('path', {
				d: outerPath,
				fill: 'currentColor',
				strokeWidth: 0,
				pointerEvents: 'all',
			}),
		],
	})
})
function DrawStyleEllipseSvg({ id, w: w3, h: h3, strokeWidth: sw, fill, color, colors }) {
	const strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	strokeElement.setAttribute('d', getEllipsePath(id, w3, h3, sw))
	strokeElement.setAttribute('fill', colors.fill[color])
	const fillElement = getShapeFillSvg({
		d: getEllipseIndicatorPath(id, w3, h3, sw),
		fill,
		color,
		colors,
	})
	return getSvgWithShapeFill(strokeElement, fillElement)
}
function getEllipseStrokeOptions(strokeWidth) {
	return {
		size: 1 + strokeWidth,
		thinning: 0.25,
		end: { taper: strokeWidth },
		start: { taper: strokeWidth },
		streamline: 0,
		smoothing: 1,
		simulatePressure: false,
	}
}
function getEllipseStrokePoints(id, width, height, strokeWidth) {
	const getRandom = rng(id)
	const rx = width / 2
	const ry = height / 2
	const perimeter = perimeterOfEllipse(rx, ry)
	const points2 = []
	const start = PI2 * getRandom()
	const length = PI2 + TAU / 2 + Math.abs(getRandom()) * TAU
	const count = Math.max(16, perimeter / 10)
	for (let i3 = 0; i3 < count; i3++) {
		const t4 = i3 / (count - 1)
		const r3 = start + t4 * length
		const c3 = Math.cos(r3)
		const s3 = Math.sin(r3)
		points2.push(
			new Vec2d(
				rx * c3 + width * 0.5 + 0.05 * getRandom(),
				ry * s3 + height / 2 + 0.05 * getRandom(),
				Math.min(
					1,
					0.5 +
						Math.abs(0.5 - (getRandom() > 0 ? EASINGS.easeInOutSine(t4) : EASINGS.easeInExpo(t4))) /
							2
				)
			)
		)
	}
	return getStrokePoints(points2, getEllipseStrokeOptions(strokeWidth))
}
function getEllipsePath(id, width, height, strokeWidth) {
	const options = getEllipseStrokeOptions(strokeWidth)
	return getSvgPathFromStroke(
		getStrokeOutlinePoints(
			setStrokePointRadii(getEllipseStrokePoints(id, width, height, strokeWidth), options),
			options
		)
	)
}
function getEllipseIndicatorPath(id, width, height, strokeWidth) {
	return getSvgPathFromStrokePoints(getEllipseStrokePoints(id, width, height, strokeWidth))
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DrawStylePolygon.tsx
init_define_process()
var React29 = __toESM(require_react())
var import_jsx_runtime48 = __toESM(require_jsx_runtime())
var DrawStylePolygon = React29.memo(function DrawStylePolygon2({
	id,
	outline,
	lines,
	fill,
	color,
	strokeWidth,
}) {
	const polygonPoints = getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2)
	let strokePathData = getRoundedInkyPolygonPath(polygonPoints)
	if (lines) {
		for (const [A2, B] of lines) {
			strokePathData += `M${A2.x},${A2.y}L${B.x},${B.y}`
		}
	}
	const innerPolygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)
	const innerPathData = getRoundedInkyPolygonPath(innerPolygonPoints)
	return /* @__PURE__ */ (0, import_jsx_runtime48.jsxs)(import_jsx_runtime48.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime48.jsx)(ShapeFill, { d: innerPathData, fill, color }),
			/* @__PURE__ */ (0, import_jsx_runtime48.jsx)('path', {
				d: strokePathData,
				stroke: 'currentColor',
				strokeWidth,
				fill: 'none',
			}),
		],
	})
})
function DrawStylePolygonSvg({ id, outline, lines, fill, color, colors, strokeWidth }) {
	const polygonPoints = getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2)
	let strokePathData = getRoundedInkyPolygonPath(polygonPoints)
	if (lines) {
		for (const [A2, B] of lines) {
			strokePathData += `M${A2.x},${A2.y}L${B.x},${B.y}`
		}
	}
	const innerPolygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)
	const innerPathData = getRoundedInkyPolygonPath(innerPolygonPoints)
	const strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	strokeElement.setAttribute('d', strokePathData)
	strokeElement.setAttribute('fill', 'none')
	strokeElement.setAttribute('stroke', colors.fill[color])
	strokeElement.setAttribute('stroke-width', strokeWidth.toString())
	const fillElement = getShapeFillSvg({
		d: innerPathData,
		fill,
		color,
		colors,
	})
	return getSvgWithShapeFill(strokeElement, fillElement)
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/SolidStyleEllipse.tsx
init_define_process()
var React30 = __toESM(require_react())
var import_jsx_runtime49 = __toESM(require_jsx_runtime())
var SolidStyleEllipse = React30.memo(function SolidStyleEllipse2({
	w: w3,
	h: h3,
	strokeWidth: sw,
	fill,
	color,
}) {
	const cx = w3 / 2
	const cy = h3 / 2
	const rx = Math.max(0, cx)
	const ry = Math.max(0, cy)
	const d3 = `M${cx - rx},${cy}a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`
	return /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime49.jsx)(ShapeFill, { d: d3, color, fill }),
			/* @__PURE__ */ (0, import_jsx_runtime49.jsx)('path', {
				d: d3,
				stroke: `var(--palette-${color})`,
				strokeWidth: sw,
				fill: 'none',
			}),
		],
	})
})
function SolidStyleEllipseSvg({ w: w3, h: h3, strokeWidth: sw, fill, color, colors }) {
	const cx = w3 / 2
	const cy = h3 / 2
	const rx = Math.max(0, cx)
	const ry = Math.max(0, cy)
	const d3 = `M${cx - rx},${cy}a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`
	const strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	strokeElement.setAttribute('d', d3)
	strokeElement.setAttribute('stroke-width', sw.toString())
	strokeElement.setAttribute('width', w3.toString())
	strokeElement.setAttribute('height', h3.toString())
	strokeElement.setAttribute('fill', 'none')
	strokeElement.setAttribute('stroke', colors.fill[color])
	const fillElement = getShapeFillSvg({
		d: d3,
		fill,
		color,
		colors,
	})
	return getSvgWithShapeFill(strokeElement, fillElement)
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/SolidStyleOval.tsx
init_define_process()
var React31 = __toESM(require_react())
var import_jsx_runtime50 = __toESM(require_jsx_runtime())
var SolidStyleOval = React31.memo(function SolidStyleOval2({
	w: w3,
	h: h3,
	strokeWidth: sw,
	fill,
	color,
}) {
	const d3 = getOvalIndicatorPath(w3, h3)
	return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(import_jsx_runtime50.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ShapeFill, { d: d3, color, fill }),
			/* @__PURE__ */ (0, import_jsx_runtime50.jsx)('path', {
				d: d3,
				stroke: `var(--palette-${color})`,
				strokeWidth: sw,
				fill: 'none',
			}),
		],
	})
})
function SolidStyleOvalSvg({ w: w3, h: h3, strokeWidth: sw, fill, color, colors }) {
	const d3 = getOvalIndicatorPath(w3, h3)
	const strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	strokeElement.setAttribute('d', d3)
	strokeElement.setAttribute('stroke-width', sw.toString())
	strokeElement.setAttribute('width', w3.toString())
	strokeElement.setAttribute('height', h3.toString())
	strokeElement.setAttribute('fill', 'none')
	strokeElement.setAttribute('stroke', colors.fill[color])
	const fillElement = getShapeFillSvg({
		d: d3,
		fill,
		color,
		colors,
	})
	return getSvgWithShapeFill(strokeElement, fillElement)
}
function getOvalIndicatorPath(w3, h3) {
	let d3
	if (h3 > w3) {
		const offset = w3 / 2
		d3 = `
    M0,${offset}
    a${offset},${offset},0,1,1,${offset * 2},0
    L${w3},${h3 - offset}
    a${offset},${offset},0,1,1,-${offset * 2},0
    Z`
	} else {
		const offset = h3 / 2
		d3 = `
    M${offset},0
    L${w3 - offset},0
    a${offset},${offset},0,1,1,0,${offset * 2}
    L${offset},${h3}
    a${offset},${offset},0,1,1,0,${-offset * 2}
    Z`
	}
	return d3
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/SolidStylePolygon.tsx
init_define_process()
var React32 = __toESM(require_react())
var import_jsx_runtime51 = __toESM(require_jsx_runtime())
var SolidStylePolygon = React32.memo(function SolidStylePolygon2({
	outline,
	lines,
	fill,
	color,
	strokeWidth,
}) {
	let path = 'M' + outline[0] + 'L' + outline.slice(1) + 'Z'
	if (lines) {
		for (const [A2, B] of lines) {
			path += `M${A2.x},${A2.y}L${B.x},${B.y}`
		}
	}
	return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(import_jsx_runtime51.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime51.jsx)(ShapeFill, { d: path, fill, color }),
			/* @__PURE__ */ (0, import_jsx_runtime51.jsx)('path', {
				d: path,
				stroke: `var(--palette-${color}`,
				strokeWidth,
				fill: 'none',
			}),
		],
	})
})
function SolidStylePolygonSvg({ outline, lines, fill, color, strokeWidth, colors }) {
	const pathData = 'M' + outline[0] + 'L' + outline.slice(1) + 'Z'
	const fillPathData = pathData
	let strokePathData = pathData
	if (lines) {
		for (const [A2, B] of lines) {
			strokePathData += `M${A2.x},${A2.y}L${B.x},${B.y}`
		}
	}
	const strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')
	strokeElement.setAttribute('d', strokePathData)
	strokeElement.setAttribute('stroke-width', strokeWidth.toString())
	strokeElement.setAttribute('stroke', colors.fill[color])
	strokeElement.setAttribute('fill', 'none')
	const fillElement = getShapeFillSvg({
		d: fillPathData,
		fill,
		color,
		colors,
	})
	return getSvgWithShapeFill(strokeElement, fillElement)
}

// ../packages/editor/src/lib/app/shapeutils/TLGeoUtil/TLGeoUtil.tsx
var import_jsx_runtime52 = __toESM(require_jsx_runtime())
var LABEL_PADDING = 16
var MIN_SIZE_WITH_LABEL = 17 * 3
var TLGeoUtil = class extends TLBoxUtil {
	canEdit = () => true
	defaultProps() {
		return {
			w: 100,
			h: 100,
			geo: 'rectangle',
			color: 'black',
			labelColor: 'black',
			fill: 'none',
			dash: 'draw',
			size: 'm',
			opacity: '1',
			font: 'draw',
			text: '',
			align: 'middle',
			verticalAlign: 'middle',
			growY: 0,
			url: '',
		}
	}
	hitTestLineSegment(shape, A2, B) {
		const outline = this.outline(shape)
		for (let i3 = 0; i3 < outline.length; i3++) {
			const C2 = outline[i3]
			const D3 = outline[(i3 + 1) % outline.length]
			if (linesIntersect(A2, B, C2, D3)) return true
		}
		const lines = getLines(shape.props, 0)
		if (lines !== void 0) {
			for (const [C2, D3] of lines) {
				if (linesIntersect(A2, B, C2, D3)) return true
			}
		}
		return false
	}
	hitTestPoint(shape, point2) {
		const outline = this.outline(shape)
		if (shape.props.fill === 'none') {
			const zoomLevel = this.app.zoomLevel
			const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel
			for (let i3 = 0; i3 < outline.length; i3++) {
				const C2 = outline[i3]
				const D3 = outline[(i3 + 1) % outline.length]
				if (Vec2d.DistanceToLineSegment(C2, D3, point2) < offsetDist) return true
			}
			const lines = getLines(shape.props, 1)
			if (lines !== void 0) {
				for (const [C2, D3] of lines) {
					if (Vec2d.DistanceToLineSegment(C2, D3, point2) < offsetDist) return true
				}
			}
			return false
		}
		return pointInPolygon(point2, outline)
	}
	getBounds(shape) {
		return new Box2d(0, 0, shape.props.w, shape.props.h + shape.props.growY)
	}
	getCenter(shape) {
		return new Vec2d(shape.props.w / 2, (shape.props.h + shape.props.growY) / 2)
	}
	getOutline(shape) {
		const w3 = Math.max(1, shape.props.w)
		const h3 = Math.max(1, shape.props.h + shape.props.growY)
		const cx = w3 / 2
		const cy = h3 / 2
		switch (shape.props.geo) {
			case 'triangle': {
				return [new Vec2d(cx, 0), new Vec2d(w3, h3), new Vec2d(0, h3)]
			}
			case 'diamond': {
				return [new Vec2d(cx, 0), new Vec2d(w3, cy), new Vec2d(cx, h3), new Vec2d(0, cy)]
			}
			case 'pentagon': {
				return getPolygonVertices(w3, h3, 5)
			}
			case 'hexagon': {
				return getPolygonVertices(w3, h3, 6)
			}
			case 'octagon': {
				return getPolygonVertices(w3, h3, 8)
			}
			case 'ellipse': {
				const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2)
				const p3 = PI * (cx + cy) * (1 + (3 * q) / (10 + Math.sqrt(4 - 3 * q)))
				let len = Math.max(4, Math.ceil(p3 / 10))
				len = Math.ceil(len / 4) * 4
				const step = PI2 / len
				const a3 = Math.cos(step)
				const b3 = Math.sin(step)
				let sin = 0
				let cos = 1
				let ts = 0
				let tc = 1
				const points2 = Array(len)
				for (let i3 = 0; i3 < len; i3++) {
					points2[i3] = new Vec2d(cx + cx * cos, cy + cy * sin)
					ts = b3 * cos + a3 * sin
					tc = a3 * cos - b3 * sin
					sin = ts
					cos = tc
				}
				return points2
			}
			case 'oval': {
				const len = 10
				const points2 = Array(len * 2)
				if (h3 > w3) {
					for (let i3 = 0; i3 < len; i3++) {
						const t1 = -PI + (PI * i3) / (len - 2)
						const t22 = (PI * i3) / (len - 2)
						points2[i3] = new Vec2d(cx + cx * Math.cos(t1), cx + cx * Math.sin(t1))
						points2[i3 + len] = new Vec2d(cx + cx * Math.cos(t22), h3 - cx + cx * Math.sin(t22))
					}
				} else {
					for (let i3 = 0; i3 < len; i3++) {
						const t1 = -TAU + (PI * i3) / (len - 2)
						const t22 = TAU + (PI * -i3) / (len - 2)
						points2[i3] = new Vec2d(w3 - cy + cy * Math.cos(t1), h3 - cy + cy * Math.sin(t1))
						points2[i3 + len] = new Vec2d(cy - cy * Math.cos(t22), h3 - cy + cy * Math.sin(t22))
					}
				}
				return points2
			}
			case 'star': {
				const sides = 5
				const step = PI2 / sides / 2
				const rightMostIndex = Math.floor(sides / 4) * 2
				const leftMostIndex = sides * 2 - rightMostIndex
				const topMostIndex = 0
				const bottomMostIndex = Math.floor(sides / 2) * 2
				const maxX = (Math.cos(-TAU + rightMostIndex * step) * w3) / 2
				const minX = (Math.cos(-TAU + leftMostIndex * step) * w3) / 2
				const minY = (Math.sin(-TAU + topMostIndex * step) * h3) / 2
				const maxY = (Math.sin(-TAU + bottomMostIndex * step) * h3) / 2
				const diffX = w3 - Math.abs(maxX - minX)
				const diffY = h3 - Math.abs(maxY - minY)
				const offsetX = w3 / 2 + minX - (w3 / 2 - maxX)
				const offsetY = h3 / 2 + minY - (h3 / 2 - maxY)
				const ratio = 1
				const cx2 = (w3 - offsetX) / 2
				const cy2 = (h3 - offsetY) / 2
				const ox = (w3 + diffX) / 2
				const oy = (h3 + diffY) / 2
				const ix = (ox * ratio) / 2
				const iy = (oy * ratio) / 2
				return Array.from(Array(sides * 2)).map((_, i3) => {
					const theta = -TAU + i3 * step
					return new Vec2d(
						cx2 + (i3 % 2 ? ix : ox) * Math.cos(theta),
						cy2 + (i3 % 2 ? iy : oy) * Math.sin(theta)
					)
				})
			}
			case 'rhombus': {
				const offset = Math.min(w3 * 0.38, h3 * 0.38)
				return [
					new Vec2d(offset, 0),
					new Vec2d(w3, 0),
					new Vec2d(w3 - offset, h3),
					new Vec2d(0, h3),
				]
			}
			case 'rhombus-2': {
				const offset = Math.min(w3 * 0.38, h3 * 0.38)
				return [
					new Vec2d(0, 0),
					new Vec2d(w3 - offset, 0),
					new Vec2d(w3, h3),
					new Vec2d(offset, h3),
				]
			}
			case 'trapezoid': {
				const offset = Math.min(w3 * 0.38, h3 * 0.38)
				return [
					new Vec2d(offset, 0),
					new Vec2d(w3 - offset, 0),
					new Vec2d(w3, h3),
					new Vec2d(0, h3),
				]
			}
			case 'arrow-right': {
				const ox = Math.min(w3, h3) * 0.38
				const oy = h3 * 0.16
				return [
					new Vec2d(0, oy),
					new Vec2d(w3 - ox, oy),
					new Vec2d(w3 - ox, 0),
					new Vec2d(w3, h3 / 2),
					new Vec2d(w3 - ox, h3),
					new Vec2d(w3 - ox, h3 - oy),
					new Vec2d(0, h3 - oy),
				]
			}
			case 'arrow-left': {
				const ox = Math.min(w3, h3) * 0.38
				const oy = h3 * 0.16
				return [
					new Vec2d(ox, 0),
					new Vec2d(ox, oy),
					new Vec2d(w3, oy),
					new Vec2d(w3, h3 - oy),
					new Vec2d(ox, h3 - oy),
					new Vec2d(ox, h3),
					new Vec2d(0, h3 / 2),
				]
			}
			case 'arrow-up': {
				const ox = w3 * 0.16
				const oy = Math.min(w3, h3) * 0.38
				return [
					new Vec2d(w3 / 2, 0),
					new Vec2d(w3, oy),
					new Vec2d(w3 - ox, oy),
					new Vec2d(w3 - ox, h3),
					new Vec2d(ox, h3),
					new Vec2d(ox, oy),
					new Vec2d(0, oy),
				]
			}
			case 'arrow-down': {
				const ox = w3 * 0.16
				const oy = Math.min(w3, h3) * 0.38
				return [
					new Vec2d(ox, 0),
					new Vec2d(w3 - ox, 0),
					new Vec2d(w3 - ox, h3 - oy),
					new Vec2d(w3, h3 - oy),
					new Vec2d(w3 / 2, h3),
					new Vec2d(0, h3 - oy),
					new Vec2d(ox, h3 - oy),
				]
			}
			case 'check-box':
			case 'x-box':
			case 'rectangle': {
				return [new Vec2d(0, 0), new Vec2d(w3, 0), new Vec2d(w3, h3), new Vec2d(0, h3)]
			}
		}
	}
	onEditEnd = (shape) => {
		const {
			id,
			type,
			props: { text },
		} = shape
		if (text.trimEnd() !== shape.props.text) {
			this.app.updateShapes([
				{
					id,
					type,
					props: {
						text: text.trimEnd(),
					},
				},
			])
		}
	}
	render(shape) {
		const { id, type, props } = shape
		const forceSolid = useForceSolid()
		const strokeWidth = this.app.getStrokeWidth(props.size)
		const {
			w: w3,
			color,
			labelColor,
			fill,
			dash,
			growY,
			font,
			align,
			verticalAlign,
			size,
			text,
		} = props
		const getShape = () => {
			const h3 = props.h + growY
			switch (props.geo) {
				case 'ellipse': {
					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(SolidStyleEllipse, {
							strokeWidth,
							w: w3,
							h: h3,
							color,
							fill,
						})
					} else if (dash === 'dashed' || dash === 'dotted') {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(DashStyleEllipse, {
							id,
							strokeWidth,
							w: w3,
							h: h3,
							dash: dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash,
							color,
							fill,
						})
					} else if (dash === 'draw') {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(SolidStyleEllipse, {
							strokeWidth,
							w: w3,
							h: h3,
							color,
							fill,
						})
					}
					break
				}
				case 'oval': {
					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(SolidStyleOval, {
							strokeWidth,
							w: w3,
							h: h3,
							color,
							fill,
						})
					} else if (dash === 'dashed' || dash === 'dotted') {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(DashStyleOval, {
							id,
							strokeWidth,
							w: w3,
							h: h3,
							dash: dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash,
							color,
							fill,
						})
					} else if (dash === 'draw') {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(SolidStyleOval, {
							strokeWidth,
							w: w3,
							h: h3,
							color,
							fill,
						})
					}
					break
				}
				default: {
					const outline = this.outline(shape)
					const lines = getLines(shape.props, strokeWidth)
					if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(SolidStylePolygon, {
							fill,
							color,
							strokeWidth,
							outline,
							lines,
						})
					} else if (dash === 'dashed' || dash === 'dotted') {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(DashStylePolygon, {
							dash: dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash,
							fill,
							color,
							strokeWidth,
							outline,
							lines,
						})
					} else if (dash === 'draw') {
						return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(DrawStylePolygon, {
							id,
							fill,
							color,
							strokeWidth,
							outline,
							lines,
						})
					}
				}
			}
		}
		return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(import_jsx_runtime52.Fragment, {
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime52.jsx)(SVGContainer, { id, children: getShape() }),
				/* @__PURE__ */ (0, import_jsx_runtime52.jsx)(TextLabel, {
					id,
					type,
					font,
					fill,
					size,
					align,
					verticalAlign,
					text,
					labelColor: this.app.getCssColor(labelColor),
					wrap: true,
				}),
				'url' in shape.props &&
					shape.props.url &&
					/* @__PURE__ */ (0, import_jsx_runtime52.jsx)(HyperlinkButton, {
						url: shape.props.url,
						zoomLevel: this.app.zoomLevel,
					}),
			],
		})
	}
	indicator(shape) {
		const { id, props } = shape
		const { w: w3, h: h3, growY, size } = props
		const forceSolid = useForceSolid()
		const strokeWidth = this.app.getStrokeWidth(size)
		switch (props.geo) {
			case 'ellipse': {
				if (props.dash === 'draw' && !forceSolid) {
					return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)('path', {
						d: getEllipseIndicatorPath(id, w3, h3 + growY, strokeWidth),
					})
				}
				return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)('ellipse', {
					cx: w3 / 2,
					cy: (h3 + growY) / 2,
					rx: w3 / 2,
					ry: (h3 + growY) / 2,
				})
			}
			case 'oval': {
				return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)('path', {
					d: getOvalIndicatorPath(w3, h3 + growY),
				})
			}
			default: {
				const outline = this.outline(shape)
				let path
				if (props.dash === 'draw' && !forceSolid) {
					const polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)
					path = getRoundedInkyPolygonPath(polygonPoints)
				} else {
					path = 'M' + outline[0] + 'L' + outline.slice(1) + 'Z'
				}
				const lines = getLines(shape.props, strokeWidth)
				if (lines) {
					for (const [A2, B] of lines) {
						path += `M${A2.x},${A2.y}L${B.x},${B.y}`
					}
				}
				return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)('path', { d: path })
			}
		}
	}
	toSvg(shape, font, colors) {
		const { id, props } = shape
		const strokeWidth = this.app.getStrokeWidth(props.size)
		let svgElm
		switch (props.geo) {
			case 'ellipse': {
				switch (props.dash) {
					case 'draw':
						svgElm = DrawStyleEllipseSvg({
							id,
							w: props.w,
							h: props.h,
							color: props.color,
							fill: props.fill,
							strokeWidth,
							colors,
						})
						break
					case 'solid':
						svgElm = SolidStyleEllipseSvg({
							strokeWidth,
							w: props.w,
							h: props.h,
							color: props.color,
							fill: props.fill,
							colors,
						})
						break
					default:
						svgElm = DashStyleEllipseSvg({
							id,
							strokeWidth,
							w: props.w,
							h: props.h,
							dash: props.dash,
							color: props.color,
							fill: props.fill,
							colors,
						})
						break
				}
				break
			}
			case 'oval': {
				switch (props.dash) {
					case 'draw':
						svgElm = DashStyleOvalSvg({
							id,
							strokeWidth,
							w: props.w,
							h: props.h,
							dash: props.dash,
							color: props.color,
							fill: props.fill,
							colors,
						})
						break
					case 'solid':
						svgElm = SolidStyleOvalSvg({
							strokeWidth,
							w: props.w,
							h: props.h,
							color: props.color,
							fill: props.fill,
							colors,
						})
						break
					default:
						svgElm = DashStyleOvalSvg({
							id,
							strokeWidth,
							w: props.w,
							h: props.h,
							dash: props.dash,
							color: props.color,
							fill: props.fill,
							colors,
						})
				}
				break
			}
			default: {
				const outline = this.outline(shape)
				const lines = getLines(shape.props, strokeWidth)
				switch (props.dash) {
					case 'draw':
						svgElm = DrawStylePolygonSvg({
							id,
							fill: props.fill,
							color: props.color,
							strokeWidth,
							outline,
							lines,
							colors,
						})
						break
					case 'solid':
						svgElm = SolidStylePolygonSvg({
							fill: props.fill,
							color: props.color,
							strokeWidth,
							outline,
							lines,
							colors,
						})
						break
					default:
						svgElm = DashStylePolygonSvg({
							dash: props.dash,
							fill: props.fill,
							color: props.color,
							strokeWidth,
							outline,
							lines,
							colors,
						})
						break
				}
				break
			}
		}
		if (props.text) {
			const bounds = this.bounds(shape)
			const padding = 16
			const opts = {
				fontSize: LABEL_FONT_SIZES[shape.props.size],
				fontFamily: font,
				textAlign: shape.props.align,
				padding,
				verticalTextAlign: shape.props.verticalAlign,
				lineHeight: TEXT_PROPS.lineHeight,
				fontStyle: 'normal',
				fontWeight: 'normal',
				width: Math.ceil(bounds.width),
				height: Math.ceil(bounds.height),
				overflow: 'wrap',
				offsetX: 0,
			}
			const spans = this.app.textMeasure.measureTextSpans(props.text, opts)
			const offsetX = getLegacyOffsetX(shape.props.align, padding, spans, bounds.width)
			if (offsetX) {
				opts.offsetX = offsetX
			}
			const groupEl = document.createElementNS('http://www.w3.org/2000/svg', 'g')
			const textBgEl = createTextSvgElementFromSpans(this.app, spans, {
				...opts,
				strokeWidth: 2,
				stroke: colors.background,
				fill: colors.background,
			})
			const textElm = textBgEl.cloneNode(true)
			textElm.setAttribute('fill', colors.fill[shape.props.labelColor])
			textElm.setAttribute('stroke', 'none')
			groupEl.append(textBgEl)
			groupEl.append(textElm)
			if (svgElm.nodeName === 'g') {
				svgElm.appendChild(groupEl)
				return svgElm
			} else {
				const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
				g3.appendChild(svgElm)
				g3.appendChild(groupEl)
				return g3
			}
		}
		return svgElm
	}
	onResize = (shape, { initialBounds, handle, newPoint, scaleX, scaleY }) => {
		let w3 = initialBounds.width * scaleX
		let h3 = initialBounds.height * scaleY
		let overShrinkX = 0
		let overShrinkY = 0
		if (shape.props.text.trim()) {
			let newW = Math.max(Math.abs(w3), MIN_SIZE_WITH_LABEL)
			let newH = Math.max(Math.abs(h3), MIN_SIZE_WITH_LABEL)
			if (newW < MIN_SIZE_WITH_LABEL && newH === MIN_SIZE_WITH_LABEL) {
				newW = MIN_SIZE_WITH_LABEL
			}
			if (newW === MIN_SIZE_WITH_LABEL && newH < MIN_SIZE_WITH_LABEL) {
				newH = MIN_SIZE_WITH_LABEL
			}
			const labelSize = getLabelSize(this.app, {
				...shape,
				props: {
					...shape.props,
					w: newW,
					h: newH,
				},
			})
			const nextW = Math.max(Math.abs(w3), labelSize.w) * Math.sign(w3)
			const nextH = Math.max(Math.abs(h3), labelSize.h) * Math.sign(h3)
			overShrinkX = Math.abs(nextW) - Math.abs(w3)
			overShrinkY = Math.abs(nextH) - Math.abs(h3)
			w3 = nextW
			h3 = nextH
		}
		const offset = new Vec2d(0, 0)
		if (scaleX < 0) {
			offset.x += w3
		}
		if (handle === 'left' || handle === 'top_left' || handle === 'bottom_left') {
			offset.x += scaleX < 0 ? overShrinkX : -overShrinkX
		}
		if (scaleY < 0) {
			offset.y += h3
		}
		if (handle === 'top' || handle === 'top_left' || handle === 'top_right') {
			offset.y += scaleY < 0 ? overShrinkY : -overShrinkY
		}
		const { x: x3, y: y3 } = offset.rot(shape.rotation).add(newPoint)
		return {
			x: x3,
			y: y3,
			props: {
				w: Math.max(Math.abs(w3), 1),
				h: Math.max(Math.abs(h3), 1),
				growY: 0,
			},
		}
	}
	onBeforeCreate = (shape) => {
		if (!shape.props.text) {
			if (shape.props.growY) {
				return {
					...shape,
					props: {
						...shape.props,
						growY: 0,
					},
				}
			} else {
				return
			}
		}
		const prevHeight = shape.props.h
		const nextHeight = getLabelSize(this.app, shape).h
		let growY = null
		if (nextHeight > prevHeight) {
			growY = nextHeight - prevHeight
		} else {
			if (shape.props.growY) {
				growY = 0
			}
		}
		if (growY !== null) {
			return {
				...shape,
				props: {
					...shape.props,
					growY,
				},
			}
		}
	}
	onBeforeUpdate = (prev, next) => {
		const prevText = prev.props.text.trimEnd()
		const nextText = next.props.text.trimEnd()
		if (
			prevText === nextText &&
			prev.props.font === next.props.font &&
			prev.props.size === next.props.size
		) {
			return
		}
		if (prevText && !nextText) {
			return {
				...next,
				props: {
					...next.props,
					growY: 0,
				},
			}
		}
		const prevWidth = prev.props.w
		const prevHeight = prev.props.h
		const nextSize = getLabelSize(this.app, next)
		const nextWidth = nextSize.w
		const nextHeight = nextSize.h
		if (!prevText && nextText && nextText.length === 1) {
			let w3 = Math.max(prevWidth, nextWidth)
			let h3 = Math.max(prevHeight, nextHeight)
			if (prev.props.w < MIN_SIZE_WITH_LABEL && prev.props.h < MIN_SIZE_WITH_LABEL) {
				w3 = Math.max(w3, MIN_SIZE_WITH_LABEL)
				h3 = Math.max(h3, MIN_SIZE_WITH_LABEL)
				w3 = Math.max(w3, h3)
				h3 = Math.max(w3, h3)
			}
			return {
				...next,
				props: {
					...next.props,
					w: w3,
					h: h3,
					growY: 0,
				},
			}
		}
		let growY = null
		if (nextHeight > prevHeight) {
			growY = nextHeight - prevHeight
		} else {
			if (prev.props.growY) {
				growY = 0
			}
		}
		if (growY !== null) {
			return {
				...next,
				props: {
					...next.props,
					growY,
					w: Math.max(next.props.w, nextWidth),
				},
			}
		}
		if (nextWidth > prev.props.w) {
			return {
				...next,
				props: {
					...next.props,
					w: nextWidth,
				},
			}
		}
	}
	onDoubleClick = (shape) => {
		if (this.app.inputs.altKey) {
			switch (shape.props.geo) {
				case 'rectangle': {
					return {
						...shape,
						props: {
							geo: 'check-box',
						},
					}
				}
				case 'check-box': {
					return {
						...shape,
						props: {
							geo: 'rectangle',
						},
					}
				}
			}
		}
		return
	}
}
__publicField(TLGeoUtil, 'type', 'geo')
function getLabelSize(app, shape) {
	const text = shape.props.text.trimEnd()
	if (!text) {
		return { w: 0, h: 0 }
	}
	const minSize = app.textMeasure.measureText('w', {
		...TEXT_PROPS,
		fontFamily: FONT_FAMILIES[shape.props.font],
		fontSize: LABEL_FONT_SIZES[shape.props.size],
		width: 'fit-content',
		maxWidth: '100px',
	})
	const sizes = {
		s: 2,
		m: 3.5,
		l: 5,
		xl: 10,
	}
	const size = app.textMeasure.measureText(text, {
		...TEXT_PROPS,
		fontFamily: FONT_FAMILIES[shape.props.font],
		fontSize: LABEL_FONT_SIZES[shape.props.size],
		width: 'fit-content',
		minWidth: minSize.w + 'px',
		maxWidth:
			Math.max(
				// Guard because a DOM nodes can't be less 0
				0,
				// A 'w' width that we're setting as the min-width
				Math.ceil(minSize.w + sizes[shape.props.size]),
				// The actual text size
				Math.ceil(shape.props.w - LABEL_PADDING * 2)
			) + 'px',
	})
	return {
		w: size.w + LABEL_PADDING * 2,
		h: size.h + LABEL_PADDING * 2,
	}
}
function getLines(props, sw) {
	switch (props.geo) {
		case 'x-box': {
			return getXBoxLines(props.w, props.h, sw, props.dash)
		}
		case 'check-box': {
			return getCheckBoxLines(props.w, props.h)
		}
		default: {
			return void 0
		}
	}
}
function getXBoxLines(w3, h3, sw, dash) {
	const inset = dash === 'draw' ? 0.62 : 0
	if (dash === 'dashed') {
		return [
			[new Vec2d(0, 0), new Vec2d(w3 / 2, h3 / 2)],
			[new Vec2d(w3, h3), new Vec2d(w3 / 2, h3 / 2)],
			[new Vec2d(0, h3), new Vec2d(w3 / 2, h3 / 2)],
			[new Vec2d(w3, 0), new Vec2d(w3 / 2, h3 / 2)],
		]
	}
	return [
		[new Vec2d(sw * inset, sw * inset), new Vec2d(w3 - sw * inset, h3 - sw * inset)],
		[new Vec2d(sw * inset, h3 - sw * inset), new Vec2d(w3 - sw * inset, sw * inset)],
	]
}
function getCheckBoxLines(w3, h3) {
	const size = Math.min(w3, h3) * 0.82
	const ox = (w3 - size) / 2
	const oy = (h3 - size) / 2
	return [
		[new Vec2d(ox + size * 0.25, oy + size * 0.52), new Vec2d(ox + size * 0.45, oy + size * 0.82)],
		[new Vec2d(ox + size * 0.45, oy + size * 0.82), new Vec2d(ox + size * 0.82, oy + size * 0.22)],
	]
}

// ../packages/editor/src/lib/app/shapeutils/TLVideoUtil/TLVideoUtil.tsx
init_define_process()
var React33 = __toESM(require_react())
var import_jsx_runtime53 = __toESM(require_jsx_runtime())
var TLVideoUtil = class extends TLBoxUtil {
	canEdit = () => true
	isAspectRatioLocked = () => true
	defaultProps() {
		return {
			opacity: '1',
			w: 100,
			h: 100,
			assetId: null,
			time: 0,
			playing: true,
			url: '',
		}
	}
	render(shape) {
		return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(TLVideoUtilComponent, {
			shape,
			videoUtil: this,
		})
	}
	indicator(shape) {
		return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)('rect', {
			width: toDomPrecision(shape.props.w),
			height: toDomPrecision(shape.props.h),
		})
	}
	toSvg(shape) {
		const g3 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
		const image = document.createElementNS('http://www.w3.org/2000/svg', 'image')
		image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', serializeVideo(shape.id))
		image.setAttribute('width', shape.props.w.toString())
		image.setAttribute('height', shape.props.h.toString())
		g3.appendChild(image)
		return g3
	}
}
__publicField(TLVideoUtil, 'type', 'video')
function serializeVideo(id) {
	const splitId = id.split(':')[1]
	const video = document.querySelector(`.tl-video-shape-${splitId}`)
	if (video) {
		const canvas = document.createElement('canvas')
		canvas.width = video.videoWidth
		canvas.height = video.videoHeight
		canvas.getContext('2d').drawImage(video, 0, 0)
		return canvas.toDataURL('image/png')
	} else throw new Error('Video with id ' + splitId + ' not found')
}
var TLVideoUtilComponent = track(function TLVideoUtilComponent2(props) {
	const { shape, videoUtil } = props
	const showControls = videoUtil.app.getBounds(shape).w * videoUtil.app.zoomLevel >= 110
	const asset = shape.props.assetId ? videoUtil.app.getAssetById(shape.props.assetId) : null
	const { w: w3, h: h3, time, playing } = shape.props
	const isEditing = useIsEditing(shape.id)
	const prefersReducedMotion = usePrefersReducedMotion()
	const rVideo = React33.useRef(null)
	const handlePlay = React33.useCallback(
		(e2) => {
			const video = e2.currentTarget
			videoUtil.app.updateShapes([
				{
					type: 'video',
					id: shape.id,
					props: {
						playing: true,
						time: video.currentTime,
					},
				},
			])
		},
		[shape.id, videoUtil.app]
	)
	const handlePause = React33.useCallback(
		(e2) => {
			const video = e2.currentTarget
			videoUtil.app.updateShapes([
				{
					type: 'video',
					id: shape.id,
					props: {
						playing: false,
						time: video.currentTime,
					},
				},
			])
		},
		[shape.id, videoUtil.app]
	)
	const handleSetCurrentTime = React33.useCallback(
		(e2) => {
			const video = e2.currentTarget
			if (isEditing) {
				videoUtil.app.updateShapes([
					{
						type: 'video',
						id: shape.id,
						props: {
							time: video.currentTime,
						},
					},
				])
			}
		},
		[isEditing, shape.id, videoUtil.app]
	)
	const [isLoaded, setIsLoaded] = React33.useState(false)
	const handleLoadedData = React33.useCallback(
		(e2) => {
			const video = e2.currentTarget
			if (time !== video.currentTime) {
				video.currentTime = time
			}
			if (!playing) {
				video.pause()
			}
			setIsLoaded(true)
		},
		[playing, time]
	)
	React33.useEffect(() => {
		const video = rVideo.current
		if (!video) return
		if (isLoaded && !isEditing && time !== video.currentTime) {
			video.currentTime = time
		}
	}, [isEditing, isLoaded, time])
	React33.useEffect(() => {
		if (prefersReducedMotion) {
			const video = rVideo.current
			video.pause()
			video.currentTime = 0
		}
	}, [rVideo, prefersReducedMotion])
	return /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)(import_jsx_runtime53.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime53.jsx)(HTMLContainer, {
				id: shape.id,
				children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)('div', {
					className: 'tl-counter-scaled',
					children: asset?.props.src
						? /* @__PURE__ */ (0, import_jsx_runtime53.jsx)('video', {
								ref: rVideo,
								className: `tl-video tl-video-shape-${shape.id.split(':')[1]} tl-hitarea-stroke`,
								width: '100%',
								height: '100%',
								draggable: false,
								playsInline: true,
								autoPlay: true,
								muted: true,
								loop: true,
								disableRemotePlayback: true,
								disablePictureInPicture: true,
								controls: isEditing && showControls,
								onPlay: handlePlay,
								onPause: handlePause,
								onTimeUpdate: handleSetCurrentTime,
								onLoadedData: handleLoadedData,
								hidden: !isLoaded,
								children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)('source', {
									src: asset.props.src,
								}),
						  })
						: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)('g', {
								transform: `translate(${(w3 - 38) / 2}, ${(h3 - 38) / 2})`,
								children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(DefaultSpinner, {}),
						  }),
				}),
			}),
			'url' in shape.props &&
				shape.props.url &&
				/* @__PURE__ */ (0, import_jsx_runtime53.jsx)(HyperlinkButton, {
					url: shape.props.url,
					zoomLevel: videoUtil.app.zoomLevel,
				}),
		],
	})
})

// ../packages/editor/src/lib/app/types/clipboard-types.ts
init_define_process()

// ../packages/editor/src/lib/app/types/emit-types.ts
init_define_process()

// ../packages/editor/src/lib/app/types/history-types.ts
init_define_process()

// ../packages/editor/src/lib/app/types/misc-types.ts
init_define_process()

// ../packages/editor/src/lib/app/types/selection-types.ts
init_define_process()

// ../packages/editor/src/lib/config/SyncedStore.tsx
init_define_process()

// ../packages/editor/src/lib/config/TLUserPreferences.ts
init_define_process()
var USER_DATA_KEY = 'TLDRAW_USER_DATA_v3'
var userTypeValidator = validation_exports.object({
	id: validation_exports.string,
	name: validation_exports.string,
	locale: validation_exports.string,
	color: validation_exports.string,
	isDarkMode: validation_exports.boolean,
})
var userTypeMigrations = defineMigrations({})
var USER_COLORS = [
	'#FF802B',
	'#EC5E41',
	'#F2555A',
	'#F04F88',
	'#E34BA9',
	'#BD54C6',
	'#9D5BD2',
	'#7B66DC',
	'#02B1CC',
	'#11B3A3',
	'#39B178',
	'#55B467',
]
function getRandomColor() {
	return USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)]
}
function getFreshUserPreferences() {
	return {
		id: uniqueId(),
		locale: typeof window !== 'undefined' ? getDefaultTranslationLocale() : 'en',
		name: 'New User',
		color: getRandomColor(),
		// TODO: detect dark mode
		isDarkMode: false,
	}
}
function migrateUserPreferences(userData) {
	if (userData === null || typeof userData !== 'object') {
		return getFreshUserPreferences()
	}
	if (!('version' in userData) || !('user' in userData) || typeof userData.version !== 'number') {
		return getFreshUserPreferences()
	}
	const migrationResult = migrate({
		value: userData.user,
		fromVersion: userData.version,
		toVersion: userTypeMigrations.currentVersion ?? 0,
		migrations: userTypeMigrations,
	})
	if (migrationResult.type === 'error') {
		return getFreshUserPreferences()
	}
	try {
		userTypeValidator.validate(migrationResult.value)
	} catch (e2) {
		return getFreshUserPreferences()
	}
	return migrationResult.value
}
function loadUserPreferences() {
	const userData =
		typeof window === 'undefined'
			? null
			: JSON.parse(window?.localStorage?.getItem(USER_DATA_KEY) || 'null') ?? null
	return migrateUserPreferences(userData)
}
var globalUserPreferences = atom('globalUserData', loadUserPreferences())
function storeUserPreferences() {
	if (typeof window !== 'undefined' && window.localStorage) {
		window.localStorage.setItem(
			USER_DATA_KEY,
			JSON.stringify({
				version: userTypeMigrations.currentVersion,
				user: globalUserPreferences.value,
			})
		)
	}
}
function setUserPreferences(user) {
	userTypeValidator.validate(user)
	globalUserPreferences.set(user)
	storeUserPreferences()
	broadcastUserPreferencesChange()
}
var isTest2 =
	typeof define_process_default !== 'undefined' && define_process_default.env.NODE_ENV === 'test'
var channel =
	typeof BroadcastChannel !== 'undefined' && !isTest2
		? new BroadcastChannel('tldraw-user-sync')
		: null
channel?.addEventListener('message', (e2) => {
	const data = e2.data
	if (data?.type === broadcastEventKey && data?.origin !== broadcastOrigin) {
		globalUserPreferences.set(migrateUserPreferences(data.data))
	}
})
var broadcastOrigin = uniqueId()
var broadcastEventKey = 'tldraw-user-preferences-change'
function broadcastUserPreferencesChange() {
	channel?.postMessage({
		type: broadcastEventKey,
		origin: broadcastOrigin,
		data: {
			user: globalUserPreferences.value,
			version: userTypeMigrations.currentVersion,
		},
	})
}
function getUserPreferences() {
	return globalUserPreferences.value
}

// ../packages/editor/src/lib/config/TldrawEditorConfig.tsx
init_define_process()
var DEFAULT_SHAPE_UTILS = {
	arrow: TLArrowUtil,
	bookmark: TLBookmarkUtil,
	draw: TLDrawUtil,
	embed: TLEmbedUtil,
	frame: TLFrameUtil,
	geo: TLGeoUtil,
	group: TLGroupUtil,
	image: TLImageUtil,
	line: TLLineUtil,
	note: TLNoteUtil,
	text: TLTextUtil,
	video: TLVideoUtil,
}
var TldrawEditorConfig = class {
	// Custom tools
	tools
	// Custom shape utils
	shapeUtils
	// The record used for TLShape incorporating any custom shapes
	TLShape
	// The schema used for the store incorporating any custom shapes
	storeSchema
	derivePresenceState
	userPreferences
	setUserPreferences
	constructor(opts = {}) {
		const { shapes = {}, tools = [], derivePresenceState } = opts
		this.tools = tools
		this.derivePresenceState = derivePresenceState ?? (() => computed('presence', () => null))
		this.userPreferences =
			opts.userPreferences ?? computed('userPreferences', () => getUserPreferences())
		this.setUserPreferences = opts.setUserPreferences ?? setUserPreferences
		this.shapeUtils = {
			...DEFAULT_SHAPE_UTILS,
			...Object.fromEntries(Object.entries(shapes).map(([k2, v3]) => [k2, v3.util])),
		}
		this.storeSchema = createTLSchema({
			customShapes: shapes,
		})
		this.TLShape = this.storeSchema.types.shape
	}
	createStore(config) {
		let initialData = config.initialData
		if (initialData) {
			initialData = CLIENT_FIXUP_SCRIPT(initialData)
		}
		return new Store({
			schema: this.storeSchema,
			initialData,
			props: {
				instanceId: config?.instanceId ?? InstanceRecordType.createId(),
				documentId: TLDOCUMENT_ID,
			},
		})
	}
}

// ../packages/editor/src/lib/hooks/useReactor.ts
init_define_process()
var import_react41 = __toESM(require_react())

// ../packages/editor/src/lib/utils/buildFromV1Document.ts
init_define_process()

// ../packages/editor/src/lib/utils/export.ts
init_define_process()
function getSvgAsString(svg) {
	const clone = svg.cloneNode(true)
	svg.setAttribute('width', +svg.getAttribute('width') + '')
	svg.setAttribute('height', +svg.getAttribute('height') + '')
	const out = new XMLSerializer()
		.serializeToString(clone)
		.replaceAll('&#10;      ', '')
		.replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, '$1')
	return out
}
async function getSvgAsImage(svg, options) {
	const { type, quality, scale } = options
	const width = +svg.getAttribute('width')
	const height = +svg.getAttribute('height')
	const dataUrl = await getSvgAsDataUrl(svg)
	const canvas = await new Promise((resolve) => {
		const image = new Image()
		image.crossOrigin = 'anonymous'
		image.onload = async () => {
			await new Promise((resolve2) => setTimeout(resolve2, 250))
			const canvas2 = document.createElement('canvas')
			const ctx = canvas2.getContext('2d')
			canvas2.width = width * scale
			canvas2.height = height * scale
			ctx.imageSmoothingEnabled = true
			ctx.imageSmoothingQuality = 'high'
			ctx.drawImage(image, 0, 0, width * scale, height * scale)
			URL.revokeObjectURL(dataUrl)
			resolve(canvas2)
		}
		image.onerror = () => {
			resolve(null)
		}
		image.src = dataUrl
	})
	if (!canvas) return null
	const blob = await new Promise((resolve) =>
		canvas.toBlob(
			(blob2) => {
				if (!blob2 || debugFlags.throwToBlob.value) {
					resolve(null)
				}
				resolve(blob2)
			},
			'image/' + type,
			quality
		)
	)
	if (!blob) return null
	const view = new DataView(await blob.arrayBuffer())
	return setPhysChunk(view, scale, {
		type: 'image/' + type,
	})
}
async function getSvgAsDataUrl(svg) {
	const clone = svg.cloneNode(true)
	clone.setAttribute('encoding', 'UTF-8"')
	const fileReader = new FileReader()
	const imgs = Array.from(clone.querySelectorAll('image'))
	for (const img of imgs) {
		const src = img.getAttribute('xlink:href')
		if (src) {
			if (!src.startsWith('data:')) {
				const blob = await (await fetch(src)).blob()
				const base64 = await new Promise((resolve, reject) => {
					fileReader.onload = () => resolve(fileReader.result)
					fileReader.onerror = () => reject(fileReader.error)
					fileReader.readAsDataURL(blob)
				})
				img.setAttribute('xlink:href', base64)
			}
		}
	}
	return getSvgAsDataUrlSync(clone)
}
function getSvgAsDataUrlSync(node) {
	const svgStr = new XMLSerializer().serializeToString(node)
	const base64SVG = window.btoa(unescape(encodeURIComponent(svgStr)))
	return `data:image/svg+xml;base64,${base64SVG}`
}
function downloadDataURLAsFile(dataUrl, filename) {
	const link = document.createElement('a')
	link.href = dataUrl
	link.download = filename
	link.click()
}

// ../packages/editor/src/lib/utils/window-open.ts
init_define_process()
function openWindow(url, target = '_blank') {
	runtime.openWindow(url, target)
}

// ../packages/tlsync-client/src/index.ts
init_define_process()

// ../packages/tlsync-client/src/lib/hardReset.ts
init_define_process()

// ../node_modules/idb/build/index.js
init_define_process()

// ../node_modules/idb/build/wrap-idb-value.js
init_define_process()
var instanceOfAny = (object2, constructors) => constructors.some((c3) => object2 instanceof c3)
var idbProxyableTypes
var cursorAdvanceMethods
function getIdbProxyableTypes() {
	return (
		idbProxyableTypes ||
		(idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
	)
}
function getCursorAdvanceMethods() {
	return (
		cursorAdvanceMethods ||
		(cursorAdvanceMethods = [
			IDBCursor.prototype.advance,
			IDBCursor.prototype.continue,
			IDBCursor.prototype.continuePrimaryKey,
		])
	)
}
var cursorRequestMap = /* @__PURE__ */ new WeakMap()
var transactionDoneMap = /* @__PURE__ */ new WeakMap()
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap()
var transformCache = /* @__PURE__ */ new WeakMap()
var reverseTransformCache = /* @__PURE__ */ new WeakMap()
function promisifyRequest(request) {
	const promise = new Promise((resolve, reject) => {
		const unlisten = () => {
			request.removeEventListener('success', success)
			request.removeEventListener('error', error)
		}
		const success = () => {
			resolve(wrap(request.result))
			unlisten()
		}
		const error = () => {
			reject(request.error)
			unlisten()
		}
		request.addEventListener('success', success)
		request.addEventListener('error', error)
	})
	promise
		.then((value) => {
			if (value instanceof IDBCursor) {
				cursorRequestMap.set(value, request)
			}
		})
		.catch(() => {})
	reverseTransformCache.set(promise, request)
	return promise
}
function cacheDonePromiseForTransaction(tx) {
	if (transactionDoneMap.has(tx)) return
	const done = new Promise((resolve, reject) => {
		const unlisten = () => {
			tx.removeEventListener('complete', complete)
			tx.removeEventListener('error', error)
			tx.removeEventListener('abort', error)
		}
		const complete = () => {
			resolve()
			unlisten()
		}
		const error = () => {
			reject(tx.error || new DOMException('AbortError', 'AbortError'))
			unlisten()
		}
		tx.addEventListener('complete', complete)
		tx.addEventListener('error', error)
		tx.addEventListener('abort', error)
	})
	transactionDoneMap.set(tx, done)
}
var idbProxyTraps = {
	get(target, prop, receiver) {
		if (target instanceof IDBTransaction) {
			if (prop === 'done') return transactionDoneMap.get(target)
			if (prop === 'objectStoreNames') {
				return target.objectStoreNames || transactionStoreNamesMap.get(target)
			}
			if (prop === 'store') {
				return receiver.objectStoreNames[1]
					? void 0
					: receiver.objectStore(receiver.objectStoreNames[0])
			}
		}
		return wrap(target[prop])
	},
	set(target, prop, value) {
		target[prop] = value
		return true
	},
	has(target, prop) {
		if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {
			return true
		}
		return prop in target
	},
}
function replaceTraps(callback) {
	idbProxyTraps = callback(idbProxyTraps)
}
function wrapFunction(func) {
	if (
		func === IDBDatabase.prototype.transaction &&
		!('objectStoreNames' in IDBTransaction.prototype)
	) {
		return function (storeNames, ...args) {
			const tx = func.call(unwrap(this), storeNames, ...args)
			transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames])
			return wrap(tx)
		}
	}
	if (getCursorAdvanceMethods().includes(func)) {
		return function (...args) {
			func.apply(unwrap(this), args)
			return wrap(cursorRequestMap.get(this))
		}
	}
	return function (...args) {
		return wrap(func.apply(unwrap(this), args))
	}
}
function transformCachableValue(value) {
	if (typeof value === 'function') return wrapFunction(value)
	if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value)
	if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps)
	return value
}
function wrap(value) {
	if (value instanceof IDBRequest) return promisifyRequest(value)
	if (transformCache.has(value)) return transformCache.get(value)
	const newValue = transformCachableValue(value)
	if (newValue !== value) {
		transformCache.set(value, newValue)
		reverseTransformCache.set(newValue, value)
	}
	return newValue
}
var unwrap = (value) => reverseTransformCache.get(value)

// ../node_modules/idb/build/index.js
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
	const request = indexedDB.open(name, version)
	const openPromise = wrap(request)
	if (upgrade) {
		request.addEventListener('upgradeneeded', (event) => {
			upgrade(
				wrap(request.result),
				event.oldVersion,
				event.newVersion,
				wrap(request.transaction),
				event
			)
		})
	}
	if (blocked) {
		request.addEventListener('blocked', (event) =>
			blocked(
				// Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
				event.oldVersion,
				event.newVersion,
				event
			)
		)
	}
	openPromise
		.then((db) => {
			if (terminated) db.addEventListener('close', () => terminated())
			if (blocking) {
				db.addEventListener('versionchange', (event) =>
					blocking(event.oldVersion, event.newVersion, event)
				)
			}
		})
		.catch(() => {})
	return openPromise
}
function deleteDB(name, { blocked } = {}) {
	const request = indexedDB.deleteDatabase(name)
	if (blocked) {
		request.addEventListener('blocked', (event) =>
			blocked(
				// Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
				event.oldVersion,
				event
			)
		)
	}
	return wrap(request).then(() => void 0)
}
var readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count']
var writeMethods = ['put', 'add', 'delete', 'clear']
var cachedMethods = /* @__PURE__ */ new Map()
function getMethod(target, prop) {
	if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {
		return
	}
	if (cachedMethods.get(prop)) return cachedMethods.get(prop)
	const targetFuncName = prop.replace(/FromIndex$/, '')
	const useIndex = prop !== targetFuncName
	const isWrite = writeMethods.includes(targetFuncName)
	if (
		// Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
		!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
		!(isWrite || readMethods.includes(targetFuncName))
	) {
		return
	}
	const method = async function (storeName, ...args) {
		const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly')
		let target2 = tx.store
		if (useIndex) target2 = target2.index(args.shift())
		return (await Promise.all([target2[targetFuncName](...args), isWrite && tx.done]))[0]
	}
	cachedMethods.set(prop, method)
	return method
}
replaceTraps((oldTraps) => ({
	...oldTraps,
	get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
	has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}))

// ../packages/tlsync-client/src/lib/persistence-constants.ts
init_define_process()
var tabIdKey = 'TLDRAW_TAB_ID_v2'
var window2 = globalThis.window
function iOS() {
	if (!window2) return false
	return (
		['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(
			window2.navigator.platform
		) || // iPad on iOS 13 detection
		(window2.navigator.userAgent.includes('Mac') && 'ontouchend' in document)
	)
}
var defaultDocumentKey = 'TLDRAW_DEFAULT_DOCUMENT_NAME_v2'
var DEFAULT_DOCUMENT_NAME = window2?.localStorage.getItem(defaultDocumentKey) ?? uniqueId()
window2?.localStorage.setItem(defaultDocumentKey, DEFAULT_DOCUMENT_NAME)
var STORE_PREFIX = 'TLDRAW_DOCUMENT_v2'
var TAB_ID =
	window2?.[tabIdKey] ?? window2?.sessionStorage[tabIdKey] ?? InstanceRecordType.createId()
if (window2) {
	window2[tabIdKey] = TAB_ID
	if (iOS()) {
		window2.sessionStorage[tabIdKey] = TAB_ID
	} else {
		delete window2.sessionStorage[tabIdKey]
	}
}
window2?.addEventListener('beforeunload', () => {
	window2.sessionStorage[tabIdKey] = TAB_ID
})
var dbNameIndexKey = 'TLDRAW_DB_NAME_INDEX_v2'
function getAllIndexDbNames() {
	const result = JSON.parse(window2?.localStorage.getItem(dbNameIndexKey) || '[]') ?? []
	if (!Array.isArray(result)) {
		return []
	}
	return result
}
function addDbName(name) {
	const all = new Set(getAllIndexDbNames())
	all.add(name)
	window2?.localStorage.setItem(dbNameIndexKey, JSON.stringify([...all]))
}

// ../packages/tlsync-client/src/lib/hardReset.ts
async function hardReset({ shouldReload = true } = {}) {
	sessionStorage.clear()
	await Promise.all(getAllIndexDbNames().map((db) => deleteDB(db)))
	localStorage.clear()
	if (shouldReload) {
		window.location.reload()
	}
}
if (typeof window !== 'undefined') {
	if (define_process_default.env.NODE_ENV === 'development') {
		window.hardReset = hardReset
	}
	window.__tldraw__hardReset = hardReset
}

// ../packages/tlsync-client/src/lib/hooks/useLocalSyncClient.ts
init_define_process()
var import_react42 = __toESM(require_react())

// ../packages/tlsync-client/src/lib/TLLocalSyncClient.ts
init_define_process()

// ../packages/tlsync-client/src/lib/alerts.ts
init_define_process()
function showCantWriteToIndexDbAlert() {
	window.alert(
		`Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
\u2022 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
\u2022 If your hard disk is full, try clearing up some space and then reload the page.`
	)
}
function showCantReadFromIndexDbAlert() {
	window.alert(
		`Oops! We could not access to your browser's storage\u2014and the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
\u2022 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
	)
}

// ../packages/tlsync-client/src/lib/indexedDb.ts
init_define_process()
async function withDb(storeId, cb) {
	addDbName(storeId)
	const db = await openDB(storeId, 2, {
		upgrade(database) {
			if (!database.objectStoreNames.contains('records')) {
				database.createObjectStore('records')
			}
			database.createObjectStore('schema')
		},
	})
	try {
		return await cb(db)
	} finally {
		db.close()
	}
}
async function loadDataFromStore(universalPersistenceKey, opts) {
	const storeId = STORE_PREFIX + universalPersistenceKey
	if (!getAllIndexDbNames().includes(storeId)) return void 0
	return await withDb(storeId, async (db) => {
		if (opts?.didCancel?.()) return void 0
		const tx = db.transaction(['records', 'schema'], 'readonly')
		const recordsStore = tx.objectStore('records')
		const schemaStore = tx.objectStore('schema')
		return {
			records: await recordsStore.getAll(),
			schema: await schemaStore.get('schema'),
		}
	})
}
async function storeChangesInIndexedDb(universalPersistenceKey, schema, changes, opts) {
	const storeId = STORE_PREFIX + universalPersistenceKey
	await withDb(storeId, async (db) => {
		const tx = db.transaction(['records', 'schema'], 'readwrite')
		const recordsStore = tx.objectStore('records')
		const schemaStore = tx.objectStore('schema')
		for (const [id, record] of Object.entries(changes.added)) {
			await recordsStore.put(record, id)
		}
		for (const [_prev, updated] of Object.values(changes.updated)) {
			await recordsStore.put(updated, updated.id)
		}
		for (const id of Object.keys(changes.removed)) {
			await recordsStore.delete(id)
		}
		schemaStore.put(schema.serialize(), 'schema')
		if (opts?.didCancel?.()) return tx.abort()
		await tx.done
	})
}
async function storeSnapshotInIndexedDb(universalPersistenceKey, schema, snapshot, opts) {
	const storeId = STORE_PREFIX + universalPersistenceKey
	await withDb(storeId, async (db) => {
		const tx = db.transaction(['records', 'schema'], 'readwrite')
		const recordsStore = tx.objectStore('records')
		const schemaStore = tx.objectStore('schema')
		await recordsStore.clear()
		for (const [id, record] of Object.entries(snapshot)) {
			await recordsStore.put(record, id)
		}
		schemaStore.put(schema.serialize(), 'schema')
		if (opts?.didCancel?.()) return tx.abort()
		await tx.done
	})
}

// ../packages/tlsync-client/src/lib/TLLocalSyncClient.ts
var PERSIST_THROTTLE_MS = 350
var PERSIST_RETRY_THROTTLE_MS = 1e4
var msg = (msg2) => msg2
var BroadcastChannelMock = class {
	onmessage
	constructor(_name) {}
	postMessage(_msg) {}
	close() {}
}
var BC = typeof BroadcastChannel === 'undefined' ? BroadcastChannelMock : BroadcastChannel
var TLLocalSyncClient = class {
	constructor(
		store,
		{ universalPersistenceKey, onLoad, onLoadError },
		channel2 = new BC(`tldraw-tab-sync-${universalPersistenceKey}`)
	) {
		this.store = store
		this.channel = channel2
		if (typeof window !== 'undefined') {
			window.tlsync = this
		}
		this.universalPersistenceKey = universalPersistenceKey
		this.serializedSchema = this.store.schema.serialize()
		this.disposables.add(
			// Set up a subscription to changes from the store: When
			// the store changes (and if the change was made by the user)
			// then immediately send the diff to other tabs via postMessage
			// and schedule a persist.
			store.listen(({ changes, source }) => {
				this.debug('changes', changes, source)
				if (source === 'user') {
					this.diffQueue.push(changes)
					this.channel.postMessage(
						msg({
							type: 'diff',
							instanceId: this.store.props.instanceId,
							changes,
							schema: this.serializedSchema,
						})
					)
					this.schedulePersist()
				}
			})
		)
		this.connect(onLoad, onLoadError)
	}
	disposables = /* @__PURE__ */ new Set()
	diffQueue = []
	didDispose = false
	shouldDoFullDBWrite = true
	isReloading = false
	universalPersistenceKey
	serializedSchema
	isDebugging = false
	initTime = Date.now()
	debug(...args) {
		if (this.isDebugging) {
			console.debug(...args)
		}
	}
	async connect(onLoad, onLoadError) {
		this.debug('connecting')
		let data
		try {
			data = await loadDataFromStore(this.universalPersistenceKey)
		} catch (error) {
			onLoadError(error)
			showCantReadFromIndexDbAlert()
			if (typeof window !== 'undefined') {
				window.location.reload()
			}
			return
		}
		this.debug('loaded data from store', data, 'didDispose', this.didDispose)
		if (this.didDispose) return
		try {
			if (data) {
				const snapshot = Object.fromEntries(data.records.map((r3) => [r3.id, r3]))
				const migrationResult = this.store.schema.migrateStoreSnapshot(
					snapshot,
					data.schema ?? this.store.schema.serializeEarliestVersion()
				)
				if (migrationResult.type === 'error') {
					console.error('failed to migrate store', migrationResult)
					onLoadError(new Error(`Failed to migrate store: ${migrationResult.reason}`))
					return
				}
				this.store.mergeRemoteChanges(() => {
					this.store.put(
						Object.values(migrationResult.value).filter(
							(r3) => this.store.schema.types[r3.typeName].scope !== 'presence'
						),
						'initialize'
					)
				})
			}
			this.channel.onmessage = ({ data: data2 }) => {
				this.debug('got message', data2)
				const msg2 = data2
				const comparison = compareSchemas(
					this.serializedSchema,
					msg2.schema ?? this.store.schema.serializeEarliestVersion()
				)
				if (comparison === -1) {
					const timeSinceInit = Date.now() - this.initTime
					if (timeSinceInit < 5e3) {
						onLoadError(new Error('Schema mismatch, please close other tabs and reload the page'))
						return
					}
					this.debug('reloading')
					this.isReloading = true
					window?.location?.reload?.()
					return
				} else if (comparison === 1) {
					this.debug('telling them to reload')
					this.channel.postMessage({ type: 'announce', schema: this.serializedSchema })
					this.shouldDoFullDBWrite = true
					this.persistIfNeeded()
					return
				}
				if (msg2.type === 'diff') {
					this.debug('applying diff')
					const doesDeleteInstance = hasOwnProperty(
						msg2.changes.removed,
						this.store.props.instanceId
					)
					transact(() => {
						this.store.mergeRemoteChanges(() => {
							this.store.applyDiff(msg2.changes)
						})
						if (doesDeleteInstance) {
							this.store.ensureStoreIsUsable()
						}
					})
				}
			}
			this.channel.postMessage({ type: 'announce', schema: this.serializedSchema })
			this.disposables.add(() => {
				this.channel.close()
			})
			onLoad(this)
		} catch (e2) {
			this.debug('error loading data from store', e2)
			if (this.didDispose) return
			onLoadError(e2)
			return
		}
	}
	close() {
		this.debug('closing')
		this.didDispose = true
		this.disposables.forEach((d3) => d3())
	}
	isPersisting = false
	didLastWriteError = false
	scheduledPersistTimeout = null
	/**
	 * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
	 * often, and will retry if failed.
	 *
	 * @internal
	 */
	schedulePersist() {
		this.debug('schedulePersist', this.scheduledPersistTimeout)
		if (this.scheduledPersistTimeout) return
		this.scheduledPersistTimeout = setTimeout(
			() => {
				this.scheduledPersistTimeout = null
				this.persistIfNeeded()
			},
			this.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS
		)
	}
	/**
	 * Persist to indexeddb only under certain circumstances:
	 *
	 * - If we're not already persisting
	 * - If we're not reloading the page
	 * - And we have something to persist (a full db write scheduled or changes in the diff queue)
	 *
	 * @internal
	 */
	persistIfNeeded() {
		this.debug('persistIfNeeded', {
			isPersisting: this.isPersisting,
			isReloading: this.isReloading,
			shouldDoFullDBWrite: this.shouldDoFullDBWrite,
			diffQueueLength: this.diffQueue.length,
			storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted(),
		})
		if (this.scheduledPersistTimeout) {
			clearTimeout(this.scheduledPersistTimeout)
			this.scheduledPersistTimeout = null
		}
		if (this.isPersisting) return
		if (this.isReloading) return
		if (this.store.isPossiblyCorrupted()) return
		if (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {
			this.doPersist()
		}
	}
	/**
	 * Actually persist to indexeddb. If the write fails, then we'll retry with a full db write after
	 * a short delay.
	 */
	async doPersist() {
		assert(!this.isPersisting, 'persist already in progress')
		this.isPersisting = true
		this.debug('doPersist start')
		const diffQueue = this.diffQueue
		this.diffQueue = []
		try {
			if (this.shouldDoFullDBWrite) {
				this.shouldDoFullDBWrite = false
				await storeSnapshotInIndexedDb(
					this.universalPersistenceKey,
					this.store.schema,
					this.store.serialize(),
					{
						didCancel: () => this.didDispose,
					}
				)
			} else {
				const diffs = squashRecordDiffs(diffQueue)
				await storeChangesInIndexedDb(this.universalPersistenceKey, this.store.schema, diffs)
			}
			this.didLastWriteError = false
		} catch (e2) {
			this.shouldDoFullDBWrite = true
			this.didLastWriteError = true
			console.error('failed to store changes in indexed db', e2)
			showCantWriteToIndexDbAlert()
			if (typeof window !== 'undefined') {
				window.location.reload()
			}
		}
		this.isPersisting = false
		this.debug('doPersist end')
		this.schedulePersist()
	}
}

// ../packages/tlsync-client/src/lib/hooks/useLocalSyncClient.ts
function useLocalSyncClient({ universalPersistenceKey, instanceId, config }) {
	const [state, setState] = (0, import_react42.useState)(null)
	;(0, import_react42.useEffect)(() => {
		const id = uniqueId()
		setState({
			id,
			syncedStore: { status: 'loading' },
		})
		const setSyncedStore = (syncedStore) => {
			setState((prev) => {
				if (prev?.id === id) {
					return { id, syncedStore }
				}
				return prev
			})
		}
		const store = config.createStore({ instanceId })
		const client = new TLLocalSyncClient(store, {
			universalPersistenceKey,
			onLoad() {
				setSyncedStore({ status: 'synced', store })
			},
			onLoadError(err) {
				setSyncedStore({ status: 'error', error: err })
			},
		})
		return () => {
			setState((prevState) => (prevState?.id === id ? null : prevState))
			client.close()
		}
	}, [instanceId, universalPersistenceKey, config])
	return state?.syncedStore ?? { status: 'loading' }
}

// ../packages/ui/src/index.ts
init_define_process()

// ../packages/ui/src/lib/components/primitives/Dialog.tsx
init_define_process()

// ../node_modules/@radix-ui/react-dialog/dist/index.module.js
init_define_process()

// ../node_modules/@babel/runtime/helpers/esm/extends.js
init_define_process()
function _extends() {
	_extends = Object.assign
		? Object.assign.bind()
		: function (target) {
				for (var i3 = 1; i3 < arguments.length; i3++) {
					var source = arguments[i3]
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key]
						}
					}
				}
				return target
		  }
	return _extends.apply(this, arguments)
}

// ../node_modules/@radix-ui/react-dialog/dist/index.module.js
var import_react57 = __toESM(require_react())

// ../node_modules/@radix-ui/primitive/dist/index.module.js
init_define_process()
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(
	originalEventHandler,
	ourEventHandler,
	{ checkForDefaultPrevented = true } = {}
) {
	return function handleEvent(event) {
		originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event)
		if (checkForDefaultPrevented === false || !event.defaultPrevented)
			return ourEventHandler === null || ourEventHandler === void 0
				? void 0
				: ourEventHandler(event)
	}
}

// ../node_modules/@radix-ui/react-compose-refs/dist/index.module.js
init_define_process()
var import_react43 = __toESM(require_react())
function $6ed0406888f73fc4$var$setRef(ref, value) {
	if (typeof ref === 'function') ref(value)
	else if (ref !== null && ref !== void 0) ref.current = value
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
	return (node) => refs.forEach((ref) => $6ed0406888f73fc4$var$setRef(ref, node))
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
	return (0, import_react43.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs)
}

// ../node_modules/@radix-ui/react-context/dist/index.module.js
init_define_process()
var import_react44 = __toESM(require_react())
function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
	const Context = /* @__PURE__ */ (0, import_react44.createContext)(defaultContext)
	function Provider(props) {
		const { children, ...context } = props
		const value = (0, import_react44.useMemo)(() => context, Object.values(context))
		return /* @__PURE__ */ (0, import_react44.createElement)(
			Context.Provider,
			{
				value,
			},
			children
		)
	}
	function useContext11(consumerName) {
		const context = (0, import_react44.useContext)(Context)
		if (context) return context
		if (defaultContext !== void 0) return defaultContext
		throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``)
	}
	Provider.displayName = rootComponentName + 'Provider'
	return [Provider, useContext11]
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
	let defaultContexts = []
	function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
		const BaseContext = /* @__PURE__ */ (0, import_react44.createContext)(defaultContext)
		const index2 = defaultContexts.length
		defaultContexts = [...defaultContexts, defaultContext]
		function Provider(props) {
			const { scope, children, ...context } = props
			const Context =
				(scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext
			const value = (0, import_react44.useMemo)(() => context, Object.values(context))
			return /* @__PURE__ */ (0, import_react44.createElement)(
				Context.Provider,
				{
					value,
				},
				children
			)
		}
		function useContext11(consumerName, scope) {
			const Context =
				(scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext
			const context = (0, import_react44.useContext)(Context)
			if (context) return context
			if (defaultContext !== void 0) return defaultContext
			throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``)
		}
		Provider.displayName = rootComponentName + 'Provider'
		return [Provider, useContext11]
	}
	const createScope = () => {
		const scopeContexts = defaultContexts.map((defaultContext) => {
			return /* @__PURE__ */ (0, import_react44.createContext)(defaultContext)
		})
		return function useScope(scope) {
			const contexts =
				(scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts
			return (0, import_react44.useMemo)(
				() => ({
					[`__scope${scopeName}`]: {
						...scope,
						[scopeName]: contexts,
					},
				}),
				[scope, contexts]
			)
		}
	}
	createScope.scopeName = scopeName
	return [
		$c512c27ab02ef895$export$fd42f52fd3ae11092,
		$c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps),
	]
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
	const baseScope = scopes[0]
	if (scopes.length === 1) return baseScope
	const createScope1 = () => {
		const scopeHooks = scopes.map((createScope) => ({
			useScope: createScope(),
			scopeName: createScope.scopeName,
		}))
		return function useComposedScopes(overrideScopes) {
			const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
				const scopeProps = useScope(overrideScopes)
				const currentScope = scopeProps[`__scope${scopeName}`]
				return {
					...nextScopes,
					...currentScope,
				}
			}, {})
			return (0, import_react44.useMemo)(
				() => ({
					[`__scope${baseScope.scopeName}`]: nextScopes1,
				}),
				[nextScopes1]
			)
		}
	}
	createScope1.scopeName = baseScope.scopeName
	return createScope1
}

// ../node_modules/@radix-ui/react-id/dist/index.module.js
init_define_process()
var $2AODx$react = __toESM(require_react())

// ../node_modules/@radix-ui/react-use-layout-effect/dist/index.module.js
init_define_process()
var import_react45 = __toESM(require_react())
var $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(
	globalThis === null || globalThis === void 0 ? void 0 : globalThis.document
)
	? import_react45.useLayoutEffect
	: () => {}

// ../node_modules/@radix-ui/react-id/dist/index.module.js
var $1746a345f3d73bb7$var$useReactId = $2AODx$react['useId'.toString()] || (() => void 0)
var $1746a345f3d73bb7$var$count = 0
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
	const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId())
	$9f79659886946c16$export$e5c5a5f917a5871c(() => {
		if (!deterministicId)
			setId((reactId) =>
				reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
			)
	}, [deterministicId])
	return deterministicId || (id ? `radix-${id}` : '')
}

// ../node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
init_define_process()
var import_react47 = __toESM(require_react())

// ../node_modules/@radix-ui/react-use-callback-ref/dist/index.module.js
init_define_process()
var import_react46 = __toESM(require_react())
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
	const callbackRef = (0, import_react46.useRef)(callback)
	;(0, import_react46.useEffect)(() => {
		callbackRef.current = callback
	})
	return (0, import_react46.useMemo)(
		() =>
			(...args) => {
				var _callbackRef$current
				return (_callbackRef$current = callbackRef.current) === null ||
					_callbackRef$current === void 0
					? void 0
					: _callbackRef$current.call(callbackRef, ...args)
			},
		[]
	)
}

// ../node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {} }) {
	const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
		defaultProp,
		onChange,
	})
	const isControlled = prop !== void 0
	const value1 = isControlled ? prop : uncontrolledProp
	const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange)
	const setValue = (0, import_react47.useCallback)(
		(nextValue) => {
			if (isControlled) {
				const setter = nextValue
				const value = typeof nextValue === 'function' ? setter(prop) : nextValue
				if (value !== prop) handleChange(value)
			} else setUncontrolledProp(nextValue)
		},
		[isControlled, prop, setUncontrolledProp, handleChange]
	)
	return [value1, setValue]
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
	const uncontrolledState = (0, import_react47.useState)(defaultProp)
	const [value] = uncontrolledState
	const prevValueRef = (0, import_react47.useRef)(value)
	const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange)
	;(0, import_react47.useEffect)(() => {
		if (prevValueRef.current !== value) {
			handleChange(value)
			prevValueRef.current = value
		}
	}, [value, prevValueRef, handleChange])
	return uncontrolledState
}

// ../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
init_define_process()
var import_react51 = __toESM(require_react())

// ../node_modules/@radix-ui/react-primitive/dist/index.module.js
init_define_process()
var import_react49 = __toESM(require_react())
var import_react_dom = __toESM(require_react_dom())

// ../node_modules/@radix-ui/react-slot/dist/index.module.js
init_define_process()
var import_react48 = __toESM(require_react())
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react48.forwardRef)(
	(props, forwardedRef) => {
		const { children, ...slotProps } = props
		const childrenArray = import_react48.Children.toArray(children)
		const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable)
		if (slottable) {
			const newElement = slottable.props.children
			const newChildren = childrenArray.map((child) => {
				if (child === slottable) {
					if (import_react48.Children.count(newElement) > 1)
						return import_react48.Children.only(null)
					return /* @__PURE__ */ (0, import_react48.isValidElement)(newElement)
						? newElement.props.children
						: null
				} else return child
			})
			return /* @__PURE__ */ (0, import_react48.createElement)(
				$5e63c961fc1ce211$var$SlotClone,
				_extends({}, slotProps, {
					ref: forwardedRef,
				}),
				/* @__PURE__ */ (0, import_react48.isValidElement)(newElement)
					? /* @__PURE__ */ (0, import_react48.cloneElement)(newElement, void 0, newChildren)
					: null
			)
		}
		return /* @__PURE__ */ (0, import_react48.createElement)(
			$5e63c961fc1ce211$var$SlotClone,
			_extends({}, slotProps, {
				ref: forwardedRef,
			}),
			children
		)
	}
)
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = 'Slot'
var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react48.forwardRef)(
	(props, forwardedRef) => {
		const { children, ...slotProps } = props
		if (/* @__PURE__ */ (0, import_react48.isValidElement)(children))
			return /* @__PURE__ */ (0, import_react48.cloneElement)(children, {
				...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
				ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref),
			})
		return import_react48.Children.count(children) > 1 ? import_react48.Children.only(null) : null
	}
)
$5e63c961fc1ce211$var$SlotClone.displayName = 'SlotClone'
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
	return /* @__PURE__ */ (0, import_react48.createElement)(import_react48.Fragment, null, children)
}
function $5e63c961fc1ce211$var$isSlottable(child) {
	return (
		/* @__PURE__ */ (0, import_react48.isValidElement)(child) &&
		child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45
	)
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
	const overrideProps = {
		...childProps,
	}
	for (const propName in childProps) {
		const slotPropValue = slotProps[propName]
		const childPropValue = childProps[propName]
		const isHandler = /^on[A-Z]/.test(propName)
		if (isHandler) {
			if (slotPropValue && childPropValue)
				overrideProps[propName] = (...args) => {
					childPropValue(...args)
					slotPropValue(...args)
				}
			else if (slotPropValue) overrideProps[propName] = slotPropValue
		} else if (propName === 'style')
			overrideProps[propName] = {
				...slotPropValue,
				...childPropValue,
			}
		else if (propName === 'className')
			overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ')
	}
	return {
		...slotProps,
		...overrideProps,
	}
}

// ../node_modules/@radix-ui/react-primitive/dist/index.module.js
var $8927f6f2acc4f386$var$NODES = [
	'a',
	'button',
	'div',
	'form',
	'h2',
	'h3',
	'img',
	'input',
	'label',
	'li',
	'nav',
	'ol',
	'p',
	'span',
	'svg',
	'ul',
]
var $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce(
	(primitive, node) => {
		const Node2 = /* @__PURE__ */ (0, import_react49.forwardRef)((props, forwardedRef) => {
			const { asChild, ...primitiveProps } = props
			const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node
			;(0, import_react49.useEffect)(() => {
				window[Symbol.for('radix-ui')] = true
			}, [])
			return /* @__PURE__ */ (0, import_react49.createElement)(
				Comp,
				_extends({}, primitiveProps, {
					ref: forwardedRef,
				})
			)
		})
		Node2.displayName = `Primitive.${node}`
		return {
			...primitive,
			[node]: Node2,
		}
	},
	{}
)
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
	if (target) (0, import_react_dom.flushSync)(() => target.dispatchEvent(event))
}

// ../node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js
init_define_process()
var import_react50 = __toESM(require_react())
function $addc16e1bbe58fd0$export$3a72a57244d6e765(
	onEscapeKeyDownProp,
	ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document
) {
	const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp)
	;(0, import_react50.useEffect)(() => {
		const handleKeyDown = (event) => {
			if (event.key === 'Escape') onEscapeKeyDown(event)
		}
		ownerDocument.addEventListener('keydown', handleKeyDown)
		return () => ownerDocument.removeEventListener('keydown', handleKeyDown)
	}, [onEscapeKeyDown, ownerDocument])
}

// ../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
var $5cb92bef7577960e$var$CONTEXT_UPDATE = 'dismissableLayer.update'
var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside'
var $5cb92bef7577960e$var$FOCUS_OUTSIDE = 'dismissableLayer.focusOutside'
var $5cb92bef7577960e$var$originalBodyPointerEvents
var $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0,
import_react51.createContext)({
	layers: /* @__PURE__ */ new Set(),
	layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
	branches: /* @__PURE__ */ new Set(),
})
var $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react51.forwardRef)(
	(props, forwardedRef) => {
		var _node$ownerDocument
		const {
			disableOutsidePointerEvents = false,
			onEscapeKeyDown,
			onPointerDownOutside,
			onFocusOutside,
			onInteractOutside,
			onDismiss,
			...layerProps
		} = props
		const context = (0, import_react51.useContext)($5cb92bef7577960e$var$DismissableLayerContext)
		const [node1, setNode] = (0, import_react51.useState)(null)
		const ownerDocument =
			(_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !==
				null && _node$ownerDocument !== void 0
				? _node$ownerDocument
				: globalThis === null || globalThis === void 0
				? void 0
				: globalThis.document
		const [, force] = (0, import_react51.useState)({})
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setNode(node)
		)
		const layers = Array.from(context.layers)
		const [highestLayerWithOutsidePointerEventsDisabled] = [
			...context.layersWithOutsidePointerEventsDisabled,
		].slice(-1)
		const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(
			highestLayerWithOutsidePointerEventsDisabled
		)
		const index2 = node1 ? layers.indexOf(node1) : -1
		const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0
		const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex
		const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
			const target = event.target
			const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target))
			if (!isPointerEventsEnabled || isPointerDownOnBranch) return
			onPointerDownOutside === null ||
				onPointerDownOutside === void 0 ||
				onPointerDownOutside(event)
			onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event)
			if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss()
		}, ownerDocument)
		const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
			const target = event.target
			const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target))
			if (isFocusInBranch) return
			onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event)
			onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event)
			if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss()
		}, ownerDocument)
		$addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
			const isHighestLayer = index2 === context.layers.size - 1
			if (!isHighestLayer) return
			onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event)
			if (!event.defaultPrevented && onDismiss) {
				event.preventDefault()
				onDismiss()
			}
		}, ownerDocument)
		;(0, import_react51.useEffect)(() => {
			if (!node1) return
			if (disableOutsidePointerEvents) {
				if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
					$5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents
					ownerDocument.body.style.pointerEvents = 'none'
				}
				context.layersWithOutsidePointerEventsDisabled.add(node1)
			}
			context.layers.add(node1)
			$5cb92bef7577960e$var$dispatchUpdate()
			return () => {
				if (
					disableOutsidePointerEvents &&
					context.layersWithOutsidePointerEventsDisabled.size === 1
				)
					ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents
			}
		}, [node1, ownerDocument, disableOutsidePointerEvents, context])
		;(0, import_react51.useEffect)(() => {
			return () => {
				if (!node1) return
				context.layers.delete(node1)
				context.layersWithOutsidePointerEventsDisabled.delete(node1)
				$5cb92bef7577960e$var$dispatchUpdate()
			}
		}, [node1, context])
		;(0, import_react51.useEffect)(() => {
			const handleUpdate = () => force({})
			document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate)
			return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate)
		}, [])
		return /* @__PURE__ */ (0, import_react51.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
			_extends({}, layerProps, {
				ref: composedRefs,
				style: {
					pointerEvents: isBodyPointerEventsDisabled
						? isPointerEventsEnabled
							? 'auto'
							: 'none'
						: void 0,
					...props.style,
				},
				onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
					props.onFocusCapture,
					focusOutside.onFocusCapture
				),
				onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
					props.onBlurCapture,
					focusOutside.onBlurCapture
				),
				onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
					props.onPointerDownCapture,
					pointerDownOutside.onPointerDownCapture
				),
			})
		)
	}
)
var $5cb92bef7577960e$export$4d5eb2109db14228 = /* @__PURE__ */ (0, import_react51.forwardRef)(
	(props, forwardedRef) => {
		const context = (0, import_react51.useContext)($5cb92bef7577960e$var$DismissableLayerContext)
		const ref = (0, import_react51.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		;(0, import_react51.useEffect)(() => {
			const node = ref.current
			if (node) {
				context.branches.add(node)
				return () => {
					context.branches.delete(node)
				}
			}
		}, [context.branches])
		return /* @__PURE__ */ (0, import_react51.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
			_extends({}, props, {
				ref: composedRefs,
			})
		)
	}
)
function $5cb92bef7577960e$var$usePointerDownOutside(
	onPointerDownOutside,
	ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document
) {
	const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside)
	const isPointerInsideReactTreeRef = (0, import_react51.useRef)(false)
	const handleClickRef = (0, import_react51.useRef)(() => {})
	;(0, import_react51.useEffect)(() => {
		const handlePointerDown = (event) => {
			if (event.target && !isPointerInsideReactTreeRef.current) {
				let handleAndDispatchPointerDownOutsideEvent = function () {
					$5cb92bef7577960e$var$handleAndDispatchCustomEvent(
						$5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE,
						handlePointerDownOutside,
						eventDetail,
						{
							discrete: true,
						}
					)
				}
				const eventDetail = {
					originalEvent: event,
				}
				if (event.pointerType === 'touch') {
					ownerDocument.removeEventListener('click', handleClickRef.current)
					handleClickRef.current = handleAndDispatchPointerDownOutsideEvent
					ownerDocument.addEventListener('click', handleClickRef.current, {
						once: true,
					})
				} else handleAndDispatchPointerDownOutsideEvent()
			}
			isPointerInsideReactTreeRef.current = false
		}
		const timerId = window.setTimeout(() => {
			ownerDocument.addEventListener('pointerdown', handlePointerDown)
		}, 0)
		return () => {
			window.clearTimeout(timerId)
			ownerDocument.removeEventListener('pointerdown', handlePointerDown)
			ownerDocument.removeEventListener('click', handleClickRef.current)
		}
	}, [ownerDocument, handlePointerDownOutside])
	return {
		// ensures we check React component tree (not just DOM tree)
		onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),
	}
}
function $5cb92bef7577960e$var$useFocusOutside(
	onFocusOutside,
	ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document
) {
	const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside)
	const isFocusInsideReactTreeRef = (0, import_react51.useRef)(false)
	;(0, import_react51.useEffect)(() => {
		const handleFocus = (event) => {
			if (event.target && !isFocusInsideReactTreeRef.current) {
				const eventDetail = {
					originalEvent: event,
				}
				$5cb92bef7577960e$var$handleAndDispatchCustomEvent(
					$5cb92bef7577960e$var$FOCUS_OUTSIDE,
					handleFocusOutside,
					eventDetail,
					{
						discrete: false,
					}
				)
			}
		}
		ownerDocument.addEventListener('focusin', handleFocus)
		return () => ownerDocument.removeEventListener('focusin', handleFocus)
	}, [ownerDocument, handleFocusOutside])
	return {
		onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),
		onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),
	}
}
function $5cb92bef7577960e$var$dispatchUpdate() {
	const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE)
	document.dispatchEvent(event)
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
	const target = detail.originalEvent.target
	const event = new CustomEvent(name, {
		bubbles: false,
		cancelable: true,
		detail,
	})
	if (handler)
		target.addEventListener(name, handler, {
			once: true,
		})
	if (discrete) $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event)
	else target.dispatchEvent(event)
}
var $5cb92bef7577960e$export$be92b6f5f03c0fe9 = $5cb92bef7577960e$export$177fb62ff3ec1f22
var $5cb92bef7577960e$export$aecb2ddcb55c95be = $5cb92bef7577960e$export$4d5eb2109db14228

// ../node_modules/@radix-ui/react-focus-scope/dist/index.module.js
init_define_process()
var import_react52 = __toESM(require_react())
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount'
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount'
var $d3863c46a17e8a28$var$EVENT_OPTIONS = {
	bubbles: false,
	cancelable: true,
}
var $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react52.forwardRef)(
	(props, forwardedRef) => {
		const {
			loop = false,
			trapped = false,
			onMountAutoFocus: onMountAutoFocusProp,
			onUnmountAutoFocus: onUnmountAutoFocusProp,
			...scopeProps
		} = props
		const [container1, setContainer] = (0, import_react52.useState)(null)
		const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp)
		const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp)
		const lastFocusedElementRef = (0, import_react52.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setContainer(node)
		)
		const focusScope = (0, import_react52.useRef)({
			paused: false,
			pause() {
				this.paused = true
			},
			resume() {
				this.paused = false
			},
		}).current
		;(0, import_react52.useEffect)(() => {
			if (trapped) {
				let handleFocusIn = function (event) {
						if (focusScope.paused || !container1) return
						const target = event.target
						if (container1.contains(target)) lastFocusedElementRef.current = target
						else
							$d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
								select: true,
							})
					},
					handleFocusOut = function (event) {
						if (focusScope.paused || !container1) return
						if (!container1.contains(event.relatedTarget))
							$d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
								select: true,
							})
					}
				document.addEventListener('focusin', handleFocusIn)
				document.addEventListener('focusout', handleFocusOut)
				return () => {
					document.removeEventListener('focusin', handleFocusIn)
					document.removeEventListener('focusout', handleFocusOut)
				}
			}
		}, [trapped, container1, focusScope.paused])
		;(0, import_react52.useEffect)(() => {
			if (container1) {
				$d3863c46a17e8a28$var$focusScopesStack.add(focusScope)
				const previouslyFocusedElement = document.activeElement
				const hasFocusedCandidate = container1.contains(previouslyFocusedElement)
				if (!hasFocusedCandidate) {
					const mountEvent = new CustomEvent(
						$d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT,
						$d3863c46a17e8a28$var$EVENT_OPTIONS
					)
					container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus)
					container1.dispatchEvent(mountEvent)
					if (!mountEvent.defaultPrevented) {
						$d3863c46a17e8a28$var$focusFirst(
							$d3863c46a17e8a28$var$removeLinks(
								$d3863c46a17e8a28$var$getTabbableCandidates(container1)
							),
							{
								select: true,
							}
						)
						if (document.activeElement === previouslyFocusedElement)
							$d3863c46a17e8a28$var$focus(container1)
					}
				}
				return () => {
					container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus)
					setTimeout(() => {
						const unmountEvent = new CustomEvent(
							$d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT,
							$d3863c46a17e8a28$var$EVENT_OPTIONS
						)
						container1.addEventListener(
							$d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT,
							onUnmountAutoFocus
						)
						container1.dispatchEvent(unmountEvent)
						if (!unmountEvent.defaultPrevented)
							$d3863c46a17e8a28$var$focus(
								previouslyFocusedElement !== null && previouslyFocusedElement !== void 0
									? previouslyFocusedElement
									: document.body,
								{
									select: true,
								}
							)
						container1.removeEventListener(
							$d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT,
							onUnmountAutoFocus
						)
						$d3863c46a17e8a28$var$focusScopesStack.remove(focusScope)
					}, 0)
				}
			}
		}, [container1, onMountAutoFocus, onUnmountAutoFocus, focusScope])
		const handleKeyDown = (0, import_react52.useCallback)(
			(event) => {
				if (!loop && !trapped) return
				if (focusScope.paused) return
				const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey
				const focusedElement = document.activeElement
				if (isTabKey && focusedElement) {
					const container = event.currentTarget
					const [first, last2] = $d3863c46a17e8a28$var$getTabbableEdges(container)
					const hasTabbableElementsInside = first && last2
					if (!hasTabbableElementsInside) {
						if (focusedElement === container) event.preventDefault()
					} else {
						if (!event.shiftKey && focusedElement === last2) {
							event.preventDefault()
							if (loop)
								$d3863c46a17e8a28$var$focus(first, {
									select: true,
								})
						} else if (event.shiftKey && focusedElement === first) {
							event.preventDefault()
							if (loop)
								$d3863c46a17e8a28$var$focus(last2, {
									select: true,
								})
						}
					}
				}
			},
			[loop, trapped, focusScope.paused]
		)
		return /* @__PURE__ */ (0, import_react52.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
			_extends(
				{
					tabIndex: -1,
				},
				scopeProps,
				{
					ref: composedRefs,
					onKeyDown: handleKeyDown,
				}
			)
		)
	}
)
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
	const previouslyFocusedElement = document.activeElement
	for (const candidate of candidates) {
		$d3863c46a17e8a28$var$focus(candidate, {
			select,
		})
		if (document.activeElement !== previouslyFocusedElement) return
	}
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
	const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container)
	const first = $d3863c46a17e8a28$var$findVisible(candidates, container)
	const last2 = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container)
	return [first, last2]
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
	const nodes = []
	const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
		acceptNode: (node) => {
			const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'
			if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP
			return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
		},
	})
	while (walker.nextNode()) nodes.push(walker.currentNode)
	return nodes
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
	for (const element of elements) {
		if (
			!$d3863c46a17e8a28$var$isHidden(element, {
				upTo: container,
			})
		)
			return element
	}
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
	if (getComputedStyle(node).visibility === 'hidden') return true
	while (node) {
		if (upTo !== void 0 && node === upTo) return false
		if (getComputedStyle(node).display === 'none') return true
		node = node.parentElement
	}
	return false
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
	return element instanceof HTMLInputElement && 'select' in element
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
	if (element && element.focus) {
		const previouslyFocusedElement = document.activeElement
		element.focus({
			preventScroll: true,
		})
		if (
			element !== previouslyFocusedElement &&
			$d3863c46a17e8a28$var$isSelectableInput(element) &&
			select
		)
			element.select()
	}
}
var $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack()
function $d3863c46a17e8a28$var$createFocusScopesStack() {
	let stack3 = []
	return {
		add(focusScope) {
			const activeFocusScope = stack3[0]
			if (focusScope !== activeFocusScope)
				activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause()
			stack3 = $d3863c46a17e8a28$var$arrayRemove(stack3, focusScope)
			stack3.unshift(focusScope)
		},
		remove(focusScope) {
			var _stack$
			stack3 = $d3863c46a17e8a28$var$arrayRemove(stack3, focusScope)
			;(_stack$ = stack3[0]) === null || _stack$ === void 0 || _stack$.resume()
		},
	}
}
function $d3863c46a17e8a28$var$arrayRemove(array2, item) {
	const updatedArray = [...array2]
	const index2 = updatedArray.indexOf(item)
	if (index2 !== -1) updatedArray.splice(index2, 1)
	return updatedArray
}
function $d3863c46a17e8a28$var$removeLinks(items) {
	return items.filter((item) => item.tagName !== 'A')
}

// ../node_modules/@radix-ui/react-portal/dist/index.module.js
init_define_process()
var import_react53 = __toESM(require_react())
var import_react_dom2 = __toESM(require_react_dom())
var $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react53.forwardRef)(
	(props, forwardedRef) => {
		var _globalThis$document
		const {
			container = globalThis === null || globalThis === void 0
				? void 0
				: (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0
				? void 0
				: _globalThis$document.body,
			...portalProps
		} = props
		return container
			? /* @__PURE__ */ import_react_dom2.default.createPortal(
					/* @__PURE__ */ (0, import_react53.createElement)(
						$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
						_extends({}, portalProps, {
							ref: forwardedRef,
						})
					),
					container
			  )
			: null
	}
)

// ../node_modules/@radix-ui/react-presence/dist/index.module.js
init_define_process()
var import_react54 = __toESM(require_react())
var import_react_dom3 = __toESM(require_react_dom())
function $fe963b355347cc68$export$3e6543de14f8614f(initialState2, machine) {
	return (0, import_react54.useReducer)((state, event) => {
		const nextState = machine[state][event]
		return nextState !== null && nextState !== void 0 ? nextState : state
	}, initialState2)
}
var $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
	const { present, children } = props
	const presence = $921a889cee6df7e8$var$usePresence(present)
	const child =
		typeof children === 'function'
			? children({
					present: presence.isPresent,
			  })
			: import_react54.Children.only(children)
	const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref)
	const forceMount = typeof children === 'function'
	return forceMount || presence.isPresent
		? /* @__PURE__ */ (0, import_react54.cloneElement)(child, {
				ref,
		  })
		: null
}
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = 'Presence'
function $921a889cee6df7e8$var$usePresence(present) {
	const [node1, setNode] = (0, import_react54.useState)()
	const stylesRef = (0, import_react54.useRef)({})
	const prevPresentRef = (0, import_react54.useRef)(present)
	const prevAnimationNameRef = (0, import_react54.useRef)('none')
	const initialState2 = present ? 'mounted' : 'unmounted'
	const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState2, {
		mounted: {
			UNMOUNT: 'unmounted',
			ANIMATION_OUT: 'unmountSuspended',
		},
		unmountSuspended: {
			MOUNT: 'mounted',
			ANIMATION_END: 'unmounted',
		},
		unmounted: {
			MOUNT: 'mounted',
		},
	})
	;(0, import_react54.useEffect)(() => {
		const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current)
		prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none'
	}, [state])
	$9f79659886946c16$export$e5c5a5f917a5871c(() => {
		const styles2 = stylesRef.current
		const wasPresent = prevPresentRef.current
		const hasPresentChanged = wasPresent !== present
		if (hasPresentChanged) {
			const prevAnimationName = prevAnimationNameRef.current
			const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles2)
			if (present) send('MOUNT')
			else if (
				currentAnimationName === 'none' ||
				(styles2 === null || styles2 === void 0 ? void 0 : styles2.display) === 'none'
			)
				send('UNMOUNT')
			else {
				const isAnimating = prevAnimationName !== currentAnimationName
				if (wasPresent && isAnimating) send('ANIMATION_OUT')
				else send('UNMOUNT')
			}
			prevPresentRef.current = present
		}
	}, [present, send])
	$9f79659886946c16$export$e5c5a5f917a5871c(() => {
		if (node1) {
			const handleAnimationEnd = (event) => {
				const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current)
				const isCurrentAnimation = currentAnimationName.includes(event.animationName)
				if (event.target === node1 && isCurrentAnimation)
					(0, import_react_dom3.flushSync)(() => send('ANIMATION_END'))
			}
			const handleAnimationStart = (event) => {
				if (event.target === node1)
					prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current)
			}
			node1.addEventListener('animationstart', handleAnimationStart)
			node1.addEventListener('animationcancel', handleAnimationEnd)
			node1.addEventListener('animationend', handleAnimationEnd)
			return () => {
				node1.removeEventListener('animationstart', handleAnimationStart)
				node1.removeEventListener('animationcancel', handleAnimationEnd)
				node1.removeEventListener('animationend', handleAnimationEnd)
			}
		} else send('ANIMATION_END')
	}, [node1, send])
	return {
		isPresent: ['mounted', 'unmountSuspended'].includes(state),
		ref: (0, import_react54.useCallback)((node) => {
			if (node) stylesRef.current = getComputedStyle(node)
			setNode(node)
		}, []),
	}
}
function $921a889cee6df7e8$var$getAnimationName(styles2) {
	return (styles2 === null || styles2 === void 0 ? void 0 : styles2.animationName) || 'none'
}

// ../node_modules/@radix-ui/react-focus-guards/dist/index.module.js
init_define_process()
var import_react55 = __toESM(require_react())
var $3db38b7d1fb3fe6a$var$count = 0
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
	;(0, import_react55.useEffect)(() => {
		var _edgeGuards$, _edgeGuards$2
		const edgeGuards = document.querySelectorAll('[data-radix-focus-guard]')
		document.body.insertAdjacentElement(
			'afterbegin',
			(_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0
				? _edgeGuards$
				: $3db38b7d1fb3fe6a$var$createFocusGuard()
		)
		document.body.insertAdjacentElement(
			'beforeend',
			(_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0
				? _edgeGuards$2
				: $3db38b7d1fb3fe6a$var$createFocusGuard()
		)
		$3db38b7d1fb3fe6a$var$count++
		return () => {
			if ($3db38b7d1fb3fe6a$var$count === 1)
				document.querySelectorAll('[data-radix-focus-guard]').forEach((node) => node.remove())
			$3db38b7d1fb3fe6a$var$count--
		}
	}, [])
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
	const element = document.createElement('span')
	element.setAttribute('data-radix-focus-guard', '')
	element.tabIndex = 0
	element.style.cssText = 'outline: none; opacity: 0; position: fixed; pointer-events: none'
	return element
}

// ../node_modules/react-remove-scroll/dist/es2015/index.js
init_define_process()

// ../node_modules/react-remove-scroll/dist/es2015/Combination.js
init_define_process()

// ../node_modules/tslib/tslib.es6.js
init_define_process()
var __assign = function () {
	__assign =
		Object.assign ||
		function __assign2(t4) {
			for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
				s3 = arguments[i3]
				for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3)) t4[p3] = s3[p3]
			}
			return t4
		}
	return __assign.apply(this, arguments)
}
function __rest(s3, e2) {
	var t4 = {}
	for (var p3 in s3)
		if (Object.prototype.hasOwnProperty.call(s3, p3) && e2.indexOf(p3) < 0) t4[p3] = s3[p3]
	if (s3 != null && typeof Object.getOwnPropertySymbols === 'function')
		for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
			if (e2.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
				t4[p3[i3]] = s3[p3[i3]]
		}
	return t4
}
function __spreadArray(to, from, pack) {
	if (pack || arguments.length === 2)
		for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
			if (ar || !(i3 in from)) {
				if (!ar) ar = Array.prototype.slice.call(from, 0, i3)
				ar[i3] = from[i3]
			}
		}
	return to.concat(ar || Array.prototype.slice.call(from))
}

// ../node_modules/react-remove-scroll/dist/es2015/Combination.js
var React39 = __toESM(require_react())

// ../node_modules/react-remove-scroll/dist/es2015/UI.js
init_define_process()
var React35 = __toESM(require_react())

// ../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
init_define_process()
var zeroRightClassName = 'right-scroll-bar-position'
var fullWidthClassName = 'width-before-scroll-bar'
var noScrollbarsClassName = 'with-scroll-bars-hidden'
var removedBarSizeVariable = '--removed-body-scroll-bar-size'

// ../node_modules/use-callback-ref/dist/es2015/index.js
init_define_process()

// ../node_modules/use-callback-ref/dist/es2015/assignRef.js
init_define_process()
function assignRef(ref, value) {
	if (typeof ref === 'function') {
		ref(value)
	} else if (ref) {
		ref.current = value
	}
	return ref
}

// ../node_modules/use-callback-ref/dist/es2015/useRef.js
init_define_process()
var import_react56 = __toESM(require_react())
function useCallbackRef(initialValue, callback) {
	var ref = (0, import_react56.useState)(function () {
		return {
			// value
			value: initialValue,
			// last callback
			callback,
			// "memoized" public interface
			facade: {
				get current() {
					return ref.value
				},
				set current(value) {
					var last2 = ref.value
					if (last2 !== value) {
						ref.value = value
						ref.callback(value, last2)
					}
				},
			},
		}
	})[0]
	ref.callback = callback
	return ref.facade
}

// ../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
init_define_process()
function useMergeRefs(refs, defaultValue) {
	return useCallbackRef(defaultValue || null, function (newValue) {
		return refs.forEach(function (ref) {
			return assignRef(ref, newValue)
		})
	})
}

// ../node_modules/react-remove-scroll/dist/es2015/medium.js
init_define_process()

// ../node_modules/use-sidecar/dist/es2015/index.js
init_define_process()

// ../node_modules/use-sidecar/dist/es2015/medium.js
init_define_process()
function ItoI(a3) {
	return a3
}
function innerCreateMedium(defaults, middleware) {
	if (middleware === void 0) {
		middleware = ItoI
	}
	var buffer = []
	var assigned = false
	var medium = {
		read: function () {
			if (assigned) {
				throw new Error(
					'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.'
				)
			}
			if (buffer.length) {
				return buffer[buffer.length - 1]
			}
			return defaults
		},
		useMedium: function (data) {
			var item = middleware(data, assigned)
			buffer.push(item)
			return function () {
				buffer = buffer.filter(function (x3) {
					return x3 !== item
				})
			}
		},
		assignSyncMedium: function (cb) {
			assigned = true
			while (buffer.length) {
				var cbs = buffer
				buffer = []
				cbs.forEach(cb)
			}
			buffer = {
				push: function (x3) {
					return cb(x3)
				},
				filter: function () {
					return buffer
				},
			}
		},
		assignMedium: function (cb) {
			assigned = true
			var pendingQueue = []
			if (buffer.length) {
				var cbs = buffer
				buffer = []
				cbs.forEach(cb)
				pendingQueue = buffer
			}
			var executeQueue = function () {
				var cbs2 = pendingQueue
				pendingQueue = []
				cbs2.forEach(cb)
			}
			var cycle = function () {
				return Promise.resolve().then(executeQueue)
			}
			cycle()
			buffer = {
				push: function (x3) {
					pendingQueue.push(x3)
					cycle()
				},
				filter: function (filter2) {
					pendingQueue = pendingQueue.filter(filter2)
					return buffer
				},
			}
		},
	}
	return medium
}
function createSidecarMedium(options) {
	if (options === void 0) {
		options = {}
	}
	var medium = innerCreateMedium(null)
	medium.options = __assign({ async: true, ssr: false }, options)
	return medium
}

// ../node_modules/use-sidecar/dist/es2015/exports.js
init_define_process()
var React34 = __toESM(require_react())
var SideCar = function (_a) {
	var sideCar = _a.sideCar,
		rest = __rest(_a, ['sideCar'])
	if (!sideCar) {
		throw new Error('Sidecar: please provide `sideCar` property to import the right car')
	}
	var Target = sideCar.read()
	if (!Target) {
		throw new Error('Sidecar medium not found')
	}
	return React34.createElement(Target, __assign({}, rest))
}
SideCar.isSideCarExport = true
function exportSidecar(medium, exported) {
	medium.useMedium(exported)
	return SideCar
}

// ../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium()

// ../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function () {
	return
}
var RemoveScroll = React35.forwardRef(function (props, parentRef) {
	var ref = React35.useRef(null)
	var _a = React35.useState({
			onScrollCapture: nothing,
			onWheelCapture: nothing,
			onTouchMoveCapture: nothing,
		}),
		callbacks = _a[0],
		setCallbacks = _a[1]
	var forwardProps = props.forwardProps,
		children = props.children,
		className = props.className,
		removeScrollBar = props.removeScrollBar,
		enabled = props.enabled,
		shards = props.shards,
		sideCar = props.sideCar,
		noIsolation = props.noIsolation,
		inert = props.inert,
		allowPinchZoom = props.allowPinchZoom,
		_b = props.as,
		Container = _b === void 0 ? 'div' : _b,
		rest = __rest(props, [
			'forwardProps',
			'children',
			'className',
			'removeScrollBar',
			'enabled',
			'shards',
			'sideCar',
			'noIsolation',
			'inert',
			'allowPinchZoom',
			'as',
		])
	var SideCar2 = sideCar
	var containerRef = useMergeRefs([ref, parentRef])
	var containerProps = __assign(__assign({}, rest), callbacks)
	return React35.createElement(
		React35.Fragment,
		null,
		enabled &&
			React35.createElement(SideCar2, {
				sideCar: effectCar,
				removeScrollBar,
				shards,
				noIsolation,
				inert,
				setCallbacks,
				allowPinchZoom: !!allowPinchZoom,
				lockRef: ref,
			}),
		forwardProps
			? React35.cloneElement(
					React35.Children.only(children),
					__assign(__assign({}, containerProps), { ref: containerRef })
			  )
			: React35.createElement(
					Container,
					__assign({}, containerProps, { className, ref: containerRef }),
					children
			  )
	)
})
RemoveScroll.defaultProps = {
	enabled: true,
	removeScrollBar: true,
	inert: false,
}
RemoveScroll.classNames = {
	fullWidth: fullWidthClassName,
	zeroRight: zeroRightClassName,
}

// ../node_modules/react-remove-scroll/dist/es2015/sidecar.js
init_define_process()

// ../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
init_define_process()
var React38 = __toESM(require_react())

// ../node_modules/react-remove-scroll-bar/dist/es2015/index.js
init_define_process()

// ../node_modules/react-remove-scroll-bar/dist/es2015/component.js
init_define_process()
var React37 = __toESM(require_react())

// ../node_modules/react-style-singleton/dist/es2015/index.js
init_define_process()

// ../node_modules/react-style-singleton/dist/es2015/component.js
init_define_process()

// ../node_modules/react-style-singleton/dist/es2015/hook.js
init_define_process()
var React36 = __toESM(require_react())

// ../node_modules/react-style-singleton/dist/es2015/singleton.js
init_define_process()

// ../node_modules/get-nonce/dist/es2015/index.js
init_define_process()
var currentNonce
var getNonce = function () {
	if (currentNonce) {
		return currentNonce
	}
	if (typeof __webpack_nonce__ !== 'undefined') {
		return __webpack_nonce__
	}
	return void 0
}

// ../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
	if (!document) return null
	var tag = document.createElement('style')
	tag.type = 'text/css'
	var nonce = getNonce()
	if (nonce) {
		tag.setAttribute('nonce', nonce)
	}
	return tag
}
function injectStyles(tag, css) {
	if (tag.styleSheet) {
		tag.styleSheet.cssText = css
	} else {
		tag.appendChild(document.createTextNode(css))
	}
}
function insertStyleTag(tag) {
	var head = document.head || document.getElementsByTagName('head')[0]
	head.appendChild(tag)
}
var stylesheetSingleton = function () {
	var counter = 0
	var stylesheet = null
	return {
		add: function (style) {
			if (counter == 0) {
				if ((stylesheet = makeStyleTag())) {
					injectStyles(stylesheet, style)
					insertStyleTag(stylesheet)
				}
			}
			counter++
		},
		remove: function () {
			counter--
			if (!counter && stylesheet) {
				stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet)
				stylesheet = null
			}
		},
	}
}

// ../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function () {
	var sheet = stylesheetSingleton()
	return function (styles2, isDynamic) {
		React36.useEffect(
			function () {
				sheet.add(styles2)
				return function () {
					sheet.remove()
				}
			},
			[styles2 && isDynamic]
		)
	}
}

// ../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function () {
	var useStyle = styleHookSingleton()
	var Sheet = function (_a) {
		var styles2 = _a.styles,
			dynamic = _a.dynamic
		useStyle(styles2, dynamic)
		return null
	}
	return Sheet
}

// ../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
init_define_process()
var zeroGap = {
	left: 0,
	top: 0,
	right: 0,
	gap: 0,
}
var parse2 = function (x3) {
	return parseInt(x3 || '', 10) || 0
}
var getOffset = function (gapMode) {
	var cs = window.getComputedStyle(document.body)
	var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft']
	var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop']
	var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight']
	return [parse2(left), parse2(top), parse2(right)]
}
var getGapWidth = function (gapMode) {
	if (gapMode === void 0) {
		gapMode = 'margin'
	}
	if (typeof window === 'undefined') {
		return zeroGap
	}
	var offsets = getOffset(gapMode)
	var documentWidth = document.documentElement.clientWidth
	var windowWidth = window.innerWidth
	return {
		left: offsets[0],
		top: offsets[1],
		right: offsets[2],
		gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0]),
	}
}

// ../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton()
var getStyles = function (_a, allowRelative, gapMode, important) {
	var left = _a.left,
		top = _a.top,
		right = _a.right,
		gap = _a.gap
	if (gapMode === void 0) {
		gapMode = 'margin'
	}
	return '\n  .'
		.concat(noScrollbarsClassName, ' {\n   overflow: hidden ')
		.concat(important, ';\n   padding-right: ')
		.concat(gap, 'px ')
		.concat(important, ';\n  }\n  body {\n    overflow: hidden ')
		.concat(important, ';\n    overscroll-behavior: contain;\n    ')
		.concat(
			[
				allowRelative && 'position: relative '.concat(important, ';'),
				gapMode === 'margin' &&
					'\n    padding-left: '
						.concat(left, 'px;\n    padding-top: ')
						.concat(top, 'px;\n    padding-right: ')
						.concat(right, 'px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ')
						.concat(gap, 'px ')
						.concat(important, ';\n    '),
				gapMode === 'padding' && 'padding-right: '.concat(gap, 'px ').concat(important, ';'),
			]
				.filter(Boolean)
				.join(''),
			'\n  }\n  \n  .'
		)
		.concat(zeroRightClassName, ' {\n    right: ')
		.concat(gap, 'px ')
		.concat(important, ';\n  }\n  \n  .')
		.concat(fullWidthClassName, ' {\n    margin-right: ')
		.concat(gap, 'px ')
		.concat(important, ';\n  }\n  \n  .')
		.concat(zeroRightClassName, ' .')
		.concat(zeroRightClassName, ' {\n    right: 0 ')
		.concat(important, ';\n  }\n  \n  .')
		.concat(fullWidthClassName, ' .')
		.concat(fullWidthClassName, ' {\n    margin-right: 0 ')
		.concat(important, ';\n  }\n  \n  body {\n    ')
		.concat(removedBarSizeVariable, ': ')
		.concat(gap, 'px;\n  }\n')
}
var RemoveScrollBar = function (props) {
	var noRelative = props.noRelative,
		noImportant = props.noImportant,
		_a = props.gapMode,
		gapMode = _a === void 0 ? 'margin' : _a
	var gap = React37.useMemo(
		function () {
			return getGapWidth(gapMode)
		},
		[gapMode]
	)
	return React37.createElement(Style, {
		styles: getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : ''),
	})
}

// ../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
init_define_process()
var passiveSupported = false
if (typeof window !== 'undefined') {
	try {
		options = Object.defineProperty({}, 'passive', {
			get: function () {
				passiveSupported = true
				return true
			},
		})
		window.addEventListener('test', options, options)
		window.removeEventListener('test', options, options)
	} catch (err) {
		passiveSupported = false
	}
}
var options
var nonPassive = passiveSupported ? { passive: false } : false

// ../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
init_define_process()
var alwaysContainsScroll = function (node) {
	return node.tagName === 'TEXTAREA'
}
var elementCanBeScrolled = function (node, overflow) {
	var styles2 = window.getComputedStyle(node)
	return (
		// not-not-scrollable
		styles2[overflow] !== 'hidden' && // contains scroll inside self
		!(
			styles2.overflowY === styles2.overflowX &&
			!alwaysContainsScroll(node) &&
			styles2[overflow] === 'visible'
		)
	)
}
var elementCouldBeVScrolled = function (node) {
	return elementCanBeScrolled(node, 'overflowY')
}
var elementCouldBeHScrolled = function (node) {
	return elementCanBeScrolled(node, 'overflowX')
}
var locationCouldBeScrolled = function (axis, node) {
	var current = node
	do {
		if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {
			current = current.host
		}
		var isScrollable = elementCouldBeScrolled(axis, current)
		if (isScrollable) {
			var _a = getScrollVariables(axis, current),
				s3 = _a[1],
				d3 = _a[2]
			if (s3 > d3) {
				return true
			}
		}
		current = current.parentNode
	} while (current && current !== document.body)
	return false
}
var getVScrollVariables = function (_a) {
	var scrollTop = _a.scrollTop,
		scrollHeight = _a.scrollHeight,
		clientHeight = _a.clientHeight
	return [scrollTop, scrollHeight, clientHeight]
}
var getHScrollVariables = function (_a) {
	var scrollLeft = _a.scrollLeft,
		scrollWidth = _a.scrollWidth,
		clientWidth = _a.clientWidth
	return [scrollLeft, scrollWidth, clientWidth]
}
var elementCouldBeScrolled = function (axis, node) {
	return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node)
}
var getScrollVariables = function (axis, node) {
	return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node)
}
var getDirectionFactor = function (axis, direction) {
	return axis === 'h' && direction === 'rtl' ? -1 : 1
}
var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {
	var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction)
	var delta = directionFactor * sourceDelta
	var target = event.target
	var targetInLock = endTarget.contains(target)
	var shouldCancelScroll = false
	var isDeltaPositive = delta > 0
	var availableScroll = 0
	var availableScrollTop = 0
	do {
		var _a = getScrollVariables(axis, target),
			position = _a[0],
			scroll_1 = _a[1],
			capacity = _a[2]
		var elementScroll = scroll_1 - capacity - directionFactor * position
		if (position || elementScroll) {
			if (elementCouldBeScrolled(axis, target)) {
				availableScroll += elementScroll
				availableScrollTop += position
			}
		}
		target = target.parentNode
	} while (
		// portaled content
		(!targetInLock && target !== document.body) || // self content
		(targetInLock && (endTarget.contains(target) || endTarget === target))
	)
	if (
		isDeltaPositive &&
		((noOverscroll && availableScroll === 0) || (!noOverscroll && delta > availableScroll))
	) {
		shouldCancelScroll = true
	} else if (
		!isDeltaPositive &&
		((noOverscroll && availableScrollTop === 0) || (!noOverscroll && -delta > availableScrollTop))
	) {
		shouldCancelScroll = true
	}
	return shouldCancelScroll
}

// ../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function (event) {
	return 'changedTouches' in event
		? [event.changedTouches[0].clientX, event.changedTouches[0].clientY]
		: [0, 0]
}
var getDeltaXY = function (event) {
	return [event.deltaX, event.deltaY]
}
var extractRef = function (ref) {
	return ref && 'current' in ref ? ref.current : ref
}
var deltaCompare = function (x3, y3) {
	return x3[0] === y3[0] && x3[1] === y3[1]
}
var generateStyle = function (id) {
	return '\n  .block-interactivity-'
		.concat(id, ' {pointer-events: none;}\n  .allow-interactivity-')
		.concat(id, ' {pointer-events: all;}\n')
}
var idCounter = 0
var lockStack = []
function RemoveScrollSideCar(props) {
	var shouldPreventQueue = React38.useRef([])
	var touchStartRef = React38.useRef([0, 0])
	var activeAxis = React38.useRef()
	var id = React38.useState(idCounter++)[0]
	var Style2 = React38.useState(function () {
		return styleSingleton()
	})[0]
	var lastProps = React38.useRef(props)
	React38.useEffect(
		function () {
			lastProps.current = props
		},
		[props]
	)
	React38.useEffect(
		function () {
			if (props.inert) {
				document.body.classList.add('block-interactivity-'.concat(id))
				var allow_1 = __spreadArray(
					[props.lockRef.current],
					(props.shards || []).map(extractRef),
					true
				).filter(Boolean)
				allow_1.forEach(function (el) {
					return el.classList.add('allow-interactivity-'.concat(id))
				})
				return function () {
					document.body.classList.remove('block-interactivity-'.concat(id))
					allow_1.forEach(function (el) {
						return el.classList.remove('allow-interactivity-'.concat(id))
					})
				}
			}
			return
		},
		[props.inert, props.lockRef.current, props.shards]
	)
	var shouldCancelEvent = React38.useCallback(function (event, parent) {
		if ('touches' in event && event.touches.length === 2) {
			return !lastProps.current.allowPinchZoom
		}
		var touch = getTouchXY(event)
		var touchStart = touchStartRef.current
		var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0]
		var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1]
		var currentAxis
		var target = event.target
		var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v'
		if ('touches' in event && moveDirection === 'h' && target.type === 'range') {
			return false
		}
		var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)
		if (!canBeScrolledInMainDirection) {
			return true
		}
		if (canBeScrolledInMainDirection) {
			currentAxis = moveDirection
		} else {
			currentAxis = moveDirection === 'v' ? 'h' : 'v'
			canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)
		}
		if (!canBeScrolledInMainDirection) {
			return false
		}
		if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {
			activeAxis.current = currentAxis
		}
		if (!currentAxis) {
			return true
		}
		var cancelingAxis = activeAxis.current || currentAxis
		return handleScroll(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY, true)
	}, [])
	var shouldPrevent = React38.useCallback(function (_event) {
		var event = _event
		if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
			return
		}
		var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event)
		var sourceEvent = shouldPreventQueue.current.filter(function (e2) {
			return e2.name === event.type && e2.target === event.target && deltaCompare(e2.delta, delta)
		})[0]
		if (sourceEvent && sourceEvent.should) {
			if (event.cancelable) {
				event.preventDefault()
			}
			return
		}
		if (!sourceEvent) {
			var shardNodes = (lastProps.current.shards || [])
				.map(extractRef)
				.filter(Boolean)
				.filter(function (node) {
					return node.contains(event.target)
				})
			var shouldStop =
				shardNodes.length > 0
					? shouldCancelEvent(event, shardNodes[0])
					: !lastProps.current.noIsolation
			if (shouldStop) {
				if (event.cancelable) {
					event.preventDefault()
				}
			}
		}
	}, [])
	var shouldCancel = React38.useCallback(function (name, delta, target, should) {
		var event = { name, delta, target, should }
		shouldPreventQueue.current.push(event)
		setTimeout(function () {
			shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e2) {
				return e2 !== event
			})
		}, 1)
	}, [])
	var scrollTouchStart = React38.useCallback(function (event) {
		touchStartRef.current = getTouchXY(event)
		activeAxis.current = void 0
	}, [])
	var scrollWheel = React38.useCallback(function (event) {
		shouldCancel(
			event.type,
			getDeltaXY(event),
			event.target,
			shouldCancelEvent(event, props.lockRef.current)
		)
	}, [])
	var scrollTouchMove = React38.useCallback(function (event) {
		shouldCancel(
			event.type,
			getTouchXY(event),
			event.target,
			shouldCancelEvent(event, props.lockRef.current)
		)
	}, [])
	React38.useEffect(function () {
		lockStack.push(Style2)
		props.setCallbacks({
			onScrollCapture: scrollWheel,
			onWheelCapture: scrollWheel,
			onTouchMoveCapture: scrollTouchMove,
		})
		document.addEventListener('wheel', shouldPrevent, nonPassive)
		document.addEventListener('touchmove', shouldPrevent, nonPassive)
		document.addEventListener('touchstart', scrollTouchStart, nonPassive)
		return function () {
			lockStack = lockStack.filter(function (inst) {
				return inst !== Style2
			})
			document.removeEventListener('wheel', shouldPrevent, nonPassive)
			document.removeEventListener('touchmove', shouldPrevent, nonPassive)
			document.removeEventListener('touchstart', scrollTouchStart, nonPassive)
		}
	}, [])
	var removeScrollBar = props.removeScrollBar,
		inert = props.inert
	return React38.createElement(
		React38.Fragment,
		null,
		inert ? React38.createElement(Style2, { styles: generateStyle(id) }) : null,
		removeScrollBar ? React38.createElement(RemoveScrollBar, { gapMode: 'margin' }) : null
	)
}

// ../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar)

// ../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React39.forwardRef(function (props, ref) {
	return React39.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }))
})
ReactRemoveScroll.classNames = RemoveScroll.classNames
var Combination_default = ReactRemoveScroll

// ../node_modules/aria-hidden/dist/es2015/index.js
init_define_process()
var getDefaultParent = function (originalTarget) {
	if (typeof document === 'undefined') {
		return null
	}
	var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget
	return sampleTarget.ownerDocument.body
}
var counterMap = /* @__PURE__ */ new WeakMap()
var uncontrolledNodes = /* @__PURE__ */ new WeakMap()
var markerMap = {}
var lockCount = 0
var unwrapHost = function (node) {
	return node && (node.host || unwrapHost(node.parentNode))
}
var correctTargets = function (parent, targets) {
	return targets
		.map(function (target) {
			if (parent.contains(target)) {
				return target
			}
			var correctedTarget = unwrapHost(target)
			if (correctedTarget && parent.contains(correctedTarget)) {
				return correctedTarget
			}
			console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing')
			return null
		})
		.filter(function (x3) {
			return Boolean(x3)
		})
}
var applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {
	var targets = correctTargets(
		parentNode,
		Array.isArray(originalTarget) ? originalTarget : [originalTarget]
	)
	if (!markerMap[markerName]) {
		markerMap[markerName] = /* @__PURE__ */ new WeakMap()
	}
	var markerCounter = markerMap[markerName]
	var hiddenNodes = []
	var elementsToKeep = /* @__PURE__ */ new Set()
	var elementsToStop = new Set(targets)
	var keep = function (el) {
		if (!el || elementsToKeep.has(el)) {
			return
		}
		elementsToKeep.add(el)
		keep(el.parentNode)
	}
	targets.forEach(keep)
	var deep = function (parent) {
		if (!parent || elementsToStop.has(parent)) {
			return
		}
		Array.prototype.forEach.call(parent.children, function (node) {
			if (elementsToKeep.has(node)) {
				deep(node)
			} else {
				var attr = node.getAttribute(controlAttribute)
				var alreadyHidden = attr !== null && attr !== 'false'
				var counterValue = (counterMap.get(node) || 0) + 1
				var markerValue = (markerCounter.get(node) || 0) + 1
				counterMap.set(node, counterValue)
				markerCounter.set(node, markerValue)
				hiddenNodes.push(node)
				if (counterValue === 1 && alreadyHidden) {
					uncontrolledNodes.set(node, true)
				}
				if (markerValue === 1) {
					node.setAttribute(markerName, 'true')
				}
				if (!alreadyHidden) {
					node.setAttribute(controlAttribute, 'true')
				}
			}
		})
	}
	deep(parentNode)
	elementsToKeep.clear()
	lockCount++
	return function () {
		hiddenNodes.forEach(function (node) {
			var counterValue = counterMap.get(node) - 1
			var markerValue = markerCounter.get(node) - 1
			counterMap.set(node, counterValue)
			markerCounter.set(node, markerValue)
			if (!counterValue) {
				if (!uncontrolledNodes.has(node)) {
					node.removeAttribute(controlAttribute)
				}
				uncontrolledNodes.delete(node)
			}
			if (!markerValue) {
				node.removeAttribute(markerName)
			}
		})
		lockCount--
		if (!lockCount) {
			counterMap = /* @__PURE__ */ new WeakMap()
			counterMap = /* @__PURE__ */ new WeakMap()
			uncontrolledNodes = /* @__PURE__ */ new WeakMap()
			markerMap = {}
		}
	}
}
var hideOthers = function (originalTarget, parentNode, markerName) {
	if (markerName === void 0) {
		markerName = 'data-aria-hidden'
	}
	var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget])
	var activeParentNode = parentNode || getDefaultParent(originalTarget)
	if (!activeParentNode) {
		return function () {
			return null
		}
	}
	targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')))
	return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden')
}

// ../node_modules/@radix-ui/react-dialog/dist/index.module.js
var $5d3850c4d0b4e6c7$var$DIALOG_NAME = 'Dialog'
var [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME)
var [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] =
	$5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME)
var $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {
	const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props
	const triggerRef = (0, import_react57.useRef)(null)
	const contentRef = (0, import_react57.useRef)(null)
	const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
		prop: openProp,
		defaultProp: defaultOpen,
		onChange: onOpenChange,
	})
	return /* @__PURE__ */ (0, import_react57.createElement)(
		$5d3850c4d0b4e6c7$var$DialogProvider,
		{
			scope: __scopeDialog,
			triggerRef,
			contentRef,
			contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
			titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
			descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
			open,
			onOpenChange: setOpen,
			onOpenToggle: (0, import_react57.useCallback)(
				() => setOpen((prevOpen) => !prevOpen),
				[setOpen]
			),
			modal,
		},
		children
	)
}
var $5d3850c4d0b4e6c7$var$PORTAL_NAME = 'DialogPortal'
var [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] =
	$5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
		forceMount: void 0,
	})
var $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {
	const { __scopeDialog, forceMount, children, container } = props
	const context = $5d3850c4d0b4e6c7$var$useDialogContext(
		$5d3850c4d0b4e6c7$var$PORTAL_NAME,
		__scopeDialog
	)
	return /* @__PURE__ */ (0, import_react57.createElement)(
		$5d3850c4d0b4e6c7$var$PortalProvider,
		{
			scope: __scopeDialog,
			forceMount,
		},
		import_react57.Children.map(children, (child) =>
			/* @__PURE__ */ (0, import_react57.createElement)(
				$921a889cee6df7e8$export$99c2b779aa4e8b8b,
				{
					present: forceMount || context.open,
				},
				/* @__PURE__ */ (0, import_react57.createElement)(
					$f1701beae083dbae$export$602eac185826482c,
					{
						asChild: true,
						container,
					},
					child
				)
			)
		)
	)
}
var $5d3850c4d0b4e6c7$var$OVERLAY_NAME = 'DialogOverlay'
var $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ (0, import_react57.forwardRef)(
	(props, forwardedRef) => {
		const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext(
			$5d3850c4d0b4e6c7$var$OVERLAY_NAME,
			props.__scopeDialog
		)
		const { forceMount = portalContext.forceMount, ...overlayProps } = props
		const context = $5d3850c4d0b4e6c7$var$useDialogContext(
			$5d3850c4d0b4e6c7$var$OVERLAY_NAME,
			props.__scopeDialog
		)
		return context.modal
			? /* @__PURE__ */ (0, import_react57.createElement)(
					$921a889cee6df7e8$export$99c2b779aa4e8b8b,
					{
						present: forceMount || context.open,
					},
					/* @__PURE__ */ (0, import_react57.createElement)(
						$5d3850c4d0b4e6c7$var$DialogOverlayImpl,
						_extends({}, overlayProps, {
							ref: forwardedRef,
						})
					)
			  )
			: null
	}
)
var $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ (0, import_react57.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDialog, ...overlayProps } = props
		const context = $5d3850c4d0b4e6c7$var$useDialogContext(
			$5d3850c4d0b4e6c7$var$OVERLAY_NAME,
			__scopeDialog
		)
		return (
			// Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
			// ie. when `Overlay` and `Content` are siblings
			/* @__PURE__ */ (0, import_react57.createElement)(
				Combination_default,
				{
					as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
					allowPinchZoom: true,
					shards: [context.contentRef],
				},
				/* @__PURE__ */ (0, import_react57.createElement)(
					$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
					_extends(
						{
							'data-state': $5d3850c4d0b4e6c7$var$getState(context.open),
						},
						overlayProps,
						{
							ref: forwardedRef,
							style: {
								pointerEvents: 'auto',
								...overlayProps.style,
							},
						}
					)
				)
			)
		)
	}
)
var $5d3850c4d0b4e6c7$var$CONTENT_NAME = 'DialogContent'
var $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ (0, import_react57.forwardRef)(
	(props, forwardedRef) => {
		const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext(
			$5d3850c4d0b4e6c7$var$CONTENT_NAME,
			props.__scopeDialog
		)
		const { forceMount = portalContext.forceMount, ...contentProps } = props
		const context = $5d3850c4d0b4e6c7$var$useDialogContext(
			$5d3850c4d0b4e6c7$var$CONTENT_NAME,
			props.__scopeDialog
		)
		return /* @__PURE__ */ (0, import_react57.createElement)(
			$921a889cee6df7e8$export$99c2b779aa4e8b8b,
			{
				present: forceMount || context.open,
			},
			context.modal
				? /* @__PURE__ */ (0, import_react57.createElement)(
						$5d3850c4d0b4e6c7$var$DialogContentModal,
						_extends({}, contentProps, {
							ref: forwardedRef,
						})
				  )
				: /* @__PURE__ */ (0, import_react57.createElement)(
						$5d3850c4d0b4e6c7$var$DialogContentNonModal,
						_extends({}, contentProps, {
							ref: forwardedRef,
						})
				  )
		)
	}
)
var $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ (0, import_react57.forwardRef)(
	(props, forwardedRef) => {
		const context = $5d3850c4d0b4e6c7$var$useDialogContext(
			$5d3850c4d0b4e6c7$var$CONTENT_NAME,
			props.__scopeDialog
		)
		const contentRef = (0, import_react57.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
			forwardedRef,
			context.contentRef,
			contentRef
		)
		;(0, import_react57.useEffect)(() => {
			const content = contentRef.current
			if (content) return hideOthers(content)
		}, [])
		return /* @__PURE__ */ (0, import_react57.createElement)(
			$5d3850c4d0b4e6c7$var$DialogContentImpl,
			_extends({}, props, {
				ref: composedRefs,
				trapFocus: context.open,
				disableOutsidePointerEvents: true,
				onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
					props.onCloseAutoFocus,
					(event) => {
						var _context$triggerRef$c
						event.preventDefault()
						;(_context$triggerRef$c = context.triggerRef.current) === null ||
							_context$triggerRef$c === void 0 ||
							_context$triggerRef$c.focus()
					}
				),
				onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
					props.onPointerDownOutside,
					(event) => {
						const originalEvent = event.detail.originalEvent
						const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true
						const isRightClick = originalEvent.button === 2 || ctrlLeftClick
						if (isRightClick) event.preventDefault()
					}
				),
				onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event) =>
					event.preventDefault()
				),
			})
		)
	}
)
var $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ (0, import_react57.forwardRef)(
	(props, forwardedRef) => {
		const context = $5d3850c4d0b4e6c7$var$useDialogContext(
			$5d3850c4d0b4e6c7$var$CONTENT_NAME,
			props.__scopeDialog
		)
		const hasInteractedOutsideRef = (0, import_react57.useRef)(false)
		return /* @__PURE__ */ (0, import_react57.createElement)(
			$5d3850c4d0b4e6c7$var$DialogContentImpl,
			_extends({}, props, {
				ref: forwardedRef,
				trapFocus: false,
				disableOutsidePointerEvents: false,
				onCloseAutoFocus: (event) => {
					var _props$onCloseAutoFoc
					;(_props$onCloseAutoFoc = props.onCloseAutoFocus) === null ||
						_props$onCloseAutoFoc === void 0 ||
						_props$onCloseAutoFoc.call(props, event)
					if (!event.defaultPrevented) {
						var _context$triggerRef$c2
						if (!hasInteractedOutsideRef.current)
							(_context$triggerRef$c2 = context.triggerRef.current) === null ||
								_context$triggerRef$c2 === void 0 ||
								_context$triggerRef$c2.focus()
						event.preventDefault()
					}
					hasInteractedOutsideRef.current = false
				},
				onInteractOutside: (event) => {
					var _props$onInteractOuts, _context$triggerRef$c3
					;(_props$onInteractOuts = props.onInteractOutside) === null ||
						_props$onInteractOuts === void 0 ||
						_props$onInteractOuts.call(props, event)
					if (!event.defaultPrevented) hasInteractedOutsideRef.current = true
					const target = event.target
					const targetIsTrigger =
						(_context$triggerRef$c3 = context.triggerRef.current) === null ||
						_context$triggerRef$c3 === void 0
							? void 0
							: _context$triggerRef$c3.contains(target)
					if (targetIsTrigger) event.preventDefault()
				},
			})
		)
	}
)
var $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ (0, import_react57.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props
		const context = $5d3850c4d0b4e6c7$var$useDialogContext(
			$5d3850c4d0b4e6c7$var$CONTENT_NAME,
			__scopeDialog
		)
		const contentRef = (0, import_react57.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef)
		$3db38b7d1fb3fe6a$export$b7ece24a22aeda8c()
		return /* @__PURE__ */ (0, import_react57.createElement)(
			import_react57.Fragment,
			null,
			/* @__PURE__ */ (0, import_react57.createElement)(
				$d3863c46a17e8a28$export$20e40289641fbbb6,
				{
					asChild: true,
					loop: true,
					trapped: trapFocus,
					onMountAutoFocus: onOpenAutoFocus,
					onUnmountAutoFocus: onCloseAutoFocus,
				},
				/* @__PURE__ */ (0, import_react57.createElement)(
					$5cb92bef7577960e$export$177fb62ff3ec1f22,
					_extends(
						{
							role: 'dialog',
							id: context.contentId,
							'aria-describedby': context.descriptionId,
							'aria-labelledby': context.titleId,
							'data-state': $5d3850c4d0b4e6c7$var$getState(context.open),
						},
						contentProps,
						{
							ref: composedRefs,
							onDismiss: () => context.onOpenChange(false),
						}
					)
				)
			),
			false
		)
	}
)
var $5d3850c4d0b4e6c7$var$TITLE_NAME = 'DialogTitle'
var $5d3850c4d0b4e6c7$export$16f7638e4a34b909 = /* @__PURE__ */ (0, import_react57.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDialog, ...titleProps } = props
		const context = $5d3850c4d0b4e6c7$var$useDialogContext(
			$5d3850c4d0b4e6c7$var$TITLE_NAME,
			__scopeDialog
		)
		return /* @__PURE__ */ (0, import_react57.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.h2,
			_extends(
				{
					id: context.titleId,
				},
				titleProps,
				{
					ref: forwardedRef,
				}
			)
		)
	}
)
var $5d3850c4d0b4e6c7$var$CLOSE_NAME = 'DialogClose'
var $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ (0, import_react57.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDialog, ...closeProps } = props
		const context = $5d3850c4d0b4e6c7$var$useDialogContext(
			$5d3850c4d0b4e6c7$var$CLOSE_NAME,
			__scopeDialog
		)
		return /* @__PURE__ */ (0, import_react57.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.button,
			_extends(
				{
					type: 'button',
				},
				closeProps,
				{
					ref: forwardedRef,
					onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, () =>
						context.onOpenChange(false)
					),
				}
			)
		)
	}
)
function $5d3850c4d0b4e6c7$var$getState(open) {
	return open ? 'open' : 'closed'
}
var $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME = 'DialogTitleWarning'
var [$5d3850c4d0b4e6c7$export$69b62a49393917d6, $5d3850c4d0b4e6c7$var$useWarningContext] =
	$c512c27ab02ef895$export$fd42f52fd3ae1109($5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, {
		contentName: $5d3850c4d0b4e6c7$var$CONTENT_NAME,
		titleName: $5d3850c4d0b4e6c7$var$TITLE_NAME,
		docsSlug: 'dialog',
	})
var $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153
var $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0
var $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17
var $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf

// ../packages/ui/src/lib/components/primitives/Dialog.tsx
var import_classnames13 = __toESM(require_classnames())

// ../packages/ui/src/lib/components/primitives/Button.tsx
init_define_process()
var import_classnames12 = __toESM(require_classnames())
var React41 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/useTranslation/useTranslation.tsx
init_define_process()
var React40 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/useAssetUrls.tsx
init_define_process()
var import_react58 = __toESM(require_react())
var import_jsx_runtime54 = __toESM(require_jsx_runtime())
var AssetUrlsContext = (0, import_react58.createContext)(null)
function AssetUrlsProvider({ assetUrls: assetUrls2, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(AssetUrlsContext.Provider, {
		value: assetUrls2,
		children,
	})
}
function useAssetUrls() {
	const assetUrls2 = (0, import_react58.useContext)(AssetUrlsContext)
	if (!assetUrls2) {
		throw new Error('useAssetUrls must be used within an AssetUrlsProvider')
	}
	return assetUrls2
}

// ../packages/ui/src/lib/hooks/useTranslation/defaultTranslation.ts
init_define_process()
var DEFAULT_TRANSLATION = {
	'action.convert-to-bookmark': 'Convert to Bookmark',
	'action.convert-to-embed': 'Convert to Embed',
	'action.open-embed-link': 'Open link',
	'action.align-bottom': 'Align bottom',
	'action.align-center-horizontal': 'Align horizontally',
	'action.align-center-vertical': 'Align vertically',
	'action.align-center-horizontal.short': 'Align H',
	'action.align-center-vertical.short': 'Align V',
	'action.align-left': 'Align left',
	'action.align-right': 'Align right',
	'action.align-top': 'Align top',
	'action.back-to-content': 'Back to content',
	'action.bring-forward': 'Bring forward',
	'action.bring-to-front': 'Bring to front',
	'action.copy-as-json.short': 'JSON',
	'action.copy-as-json': 'Copy as JSON',
	'action.copy-as-png.short': 'PNG',
	'action.copy-as-png': 'Copy as PNG',
	'action.copy-as-svg.short': 'SVG',
	'action.copy-as-svg': 'Copy as SVG',
	'action.copy': 'Copy',
	'action.cut': 'Cut',
	'action.delete': 'Delete',
	'action.distribute-horizontal': 'Distribute horizontally',
	'action.distribute-vertical': 'Distribute vertically',
	'action.distribute-horizontal.short': 'Distribute H',
	'action.distribute-vertical.short': 'Distribute V',
	'action.duplicate': 'Duplicate',
	'action.edit-link': 'Edit link',
	'action.exit-pen-mode': 'Exit pen mode',
	'action.export-as-json.short': 'JSON',
	'action.export-as-json': 'Export as JSON',
	'action.export-as-png.short': 'PNG',
	'action.export-as-png': 'Export as PNG',
	'action.export-as-svg.short': 'SVG',
	'action.export-as-svg': 'Export as SVG',
	'action.flip-horizontal': 'Flip horizontally',
	'action.flip-vertical': 'Flip vertically',
	'action.flip-horizontal.short': 'Flip H',
	'action.flip-vertical.short': 'Flip V',
	'action.fork-project': 'Fork this project',
	'action.group': 'Group',
	'action.insert-embed': 'Insert embed',
	'action.insert-media': 'Upload media',
	'action.leave-shared-project': 'Leave shared project',
	'action.new-project': 'New project',
	'action.new-shared-project': 'New shared project',
	'action.open-file': 'Open file',
	'action.pack': 'Pack',
	'action.paste': 'Paste',
	'action.print': 'Print',
	'action.redo': 'Redo',
	'action.rotate-ccw': 'Rotate counterclockwise',
	'action.rotate-cw': 'Rotate clockwise',
	'action.save-copy': 'Save a copy',
	'action.select-all': 'Select all',
	'action.select-none': 'Select none',
	'action.send-backward': 'Send backward',
	'action.send-to-back': 'Send to back',
	'action.share-project': 'Share this project',
	'action.stack-horizontal': 'Stack horizontally',
	'action.stack-vertical': 'Stack vertically',
	'action.stack-horizontal.short': 'Stack H',
	'action.stack-vertical.short': 'Stack V',
	'action.stop-following': 'Stop following',
	'action.stretch-horizontal': 'Stretch horizontally',
	'action.stretch-vertical': 'Stretch vertically',
	'action.stretch-horizontal.short': 'Stretch H',
	'action.stretch-vertical.short': 'Stretch V',
	'action.toggle-auto-size': 'Toggle auto size',
	'action.toggle-dark-mode.menu': 'Dark mode',
	'action.toggle-dark-mode': 'Toggle dark mode',
	'action.toggle-debug-mode.menu': 'Debug mode',
	'action.toggle-debug-mode': 'Toggle debug mode',
	'action.toggle-focus-mode.menu': 'Focus mode',
	'action.toggle-focus-mode': 'Toggle focus mode',
	'action.toggle-grid.menu': 'Show grid',
	'action.toggle-grid': 'Toggle grid',
	'action.toggle-snap-mode.menu': 'Always snap',
	'action.toggle-snap-mode': 'Toggle always snap',
	'action.toggle-tool-lock.menu': 'Tool lock',
	'action.toggle-tool-lock': 'Toggle tool lock',
	'action.toggle-transparent.context-menu': 'Transparent',
	'action.toggle-transparent.menu': 'Transparent',
	'action.toggle-transparent': 'Toggle transparent background',
	'action.undo': 'Undo',
	'action.ungroup': 'Ungroup',
	'action.zoom-in': 'Zoom in',
	'action.zoom-out': 'Zoom out',
	'action.zoom-to-100': 'Zoom to 100%',
	'action.zoom-to-fit': 'Zoom to fit',
	'action.zoom-to-selection': 'Zoom to selection',
	'color-style.black': 'Black',
	'color-style.blue': 'Blue',
	'color-style.green': 'Green',
	'color-style.grey': 'Grey',
	'color-style.light-blue': 'Light blue',
	'color-style.light-green': 'Light green',
	'color-style.light-red': 'Light red',
	'color-style.light-violet': 'Light violet',
	'color-style.orange': 'Orange',
	'color-style.red': 'Red',
	'color-style.violet': 'Violet',
	'color-style.yellow': 'Yellow',
	'fill-style.none': 'None',
	'fill-style.semi': 'Semi',
	'fill-style.solid': 'Solid',
	'fill-style.pattern': 'Pattern',
	'dash-style.dashed': 'Dashed',
	'dash-style.dotted': 'Dotted',
	'dash-style.draw': 'Draw',
	'dash-style.solid': 'Solid',
	'size-style.s': 'Small',
	'size-style.m': 'Medium',
	'size-style.l': 'Large',
	'size-style.xl': 'Extra large',
	'opacity-style.0.1': '10%',
	'opacity-style.0.25': '25%',
	'opacity-style.0.5': '50%',
	'opacity-style.0.75': '75%',
	'opacity-style.1': '100%',
	'font-style.draw': 'Draw',
	'font-style.sans': 'Sans',
	'font-style.serif': 'Serif',
	'font-style.mono': 'Mono',
	'align-style.start': 'Start',
	'align-style.middle': 'Middle',
	'align-style.end': 'End',
	'align-style.justify': 'Justify',
	'geo-style.arrow-down': 'Arrow down',
	'geo-style.arrow-left': 'Arrow left',
	'geo-style.arrow-right': 'Arrow right',
	'geo-style.arrow-up': 'Arrow up',
	'geo-style.diamond': 'Diamond',
	'geo-style.ellipse': 'Ellipse',
	'geo-style.hexagon': 'Hexagon',
	'geo-style.octagon': 'Octagon',
	'geo-style.oval': 'Oval',
	'geo-style.pentagon': 'Pentagon',
	'geo-style.rectangle': 'Rectangle',
	'geo-style.rhombus-2': 'Rhombus 2',
	'geo-style.rhombus': 'Rhombus',
	'geo-style.star': 'Star',
	'geo-style.trapezoid': 'Trapezoid',
	'geo-style.triangle': 'Triangle',
	'geo-style.x-box': 'X box',
	'geo-style.check-box': 'Check box',
	'arrowheadStart-style.none': 'None',
	'arrowheadStart-style.arrow': 'Arrow',
	'arrowheadStart-style.bar': 'Bar',
	'arrowheadStart-style.diamond': 'Diamond',
	'arrowheadStart-style.dot': 'Dot',
	'arrowheadStart-style.inverted': 'Inverted',
	'arrowheadStart-style.pipe': 'Pipe',
	'arrowheadStart-style.square': 'Square',
	'arrowheadStart-style.triangle': 'Triangle',
	'arrowheadEnd-style.none': 'None',
	'arrowheadEnd-style.arrow': 'Arrow',
	'arrowheadEnd-style.bar': 'Bar',
	'arrowheadEnd-style.diamond': 'Diamond',
	'arrowheadEnd-style.dot': 'Dot',
	'arrowheadEnd-style.inverted': 'Inverted',
	'arrowheadEnd-style.pipe': 'Pipe',
	'arrowheadEnd-style.square': 'Square',
	'arrowheadEnd-style.triangle': 'Triangle',
	'spline-style.line': 'Line',
	'spline-style.cubic': 'Cubic',
	'tool.select': 'Select',
	'tool.hand': 'Hand',
	'tool.draw': 'Draw',
	'tool.eraser': 'Eraser',
	'tool.arrow-down': 'Arrow down',
	'tool.arrow-left': 'Arrow left',
	'tool.arrow-right': 'Arrow right',
	'tool.arrow-up': 'Arrow up',
	'tool.arrow': 'Arrow',
	'tool.diamond': 'Diamond',
	'tool.ellipse': 'Ellipse',
	'tool.hexagon': 'Hexagon',
	'tool.line': 'Line',
	'tool.octagon': 'Octagon',
	'tool.oval': 'Oval',
	'tool.pentagon': 'Pentagon',
	'tool.rectangle': 'Rectangle',
	'tool.rhombus': 'Rhombus',
	'tool.star': 'Star',
	'tool.trapezoid': 'Trapezoid',
	'tool.triangle': 'Triangle',
	'tool.x-box': 'X box',
	'tool.check-box': 'Check box',
	'tool.asset': 'Asset',
	'tool.frame': 'Frame',
	'tool.note': 'Note',
	'tool.laser': 'Laser',
	'tool.embed': 'Embed',
	'tool.text': 'Text',
	'menu.title': 'Menu',
	'menu.copy-as': 'Copy as',
	'menu.edit': 'Edit',
	'menu.export-as': 'Export as',
	'menu.file': 'File',
	'menu.language': 'Language',
	'menu.preferences': 'Preferences',
	'menu.view': 'View',
	'context-menu.arrange': 'Arrange',
	'context-menu.copy-as': 'Copy as',
	'context-menu.export-as': 'Export as',
	'context-menu.move-to-page': 'Move to page',
	'context-menu.reorder': 'Reorder',
	'page-menu.title': 'Pages',
	'page-menu.create-new-page': 'Create new page',
	'page-menu.max-page-count-reached': 'Max pages reached',
	'page-menu.new-page-initial-name': 'Page 1',
	'page-menu.edit-start': 'Edit',
	'page-menu.edit-done': 'Done',
	'page-menu.go-to-page': 'Go to page',
	'page-menu.submenu.rename': 'Rename',
	'page-menu.submenu.duplicate-page': 'Duplicate',
	'page-menu.submenu.title': 'Menu',
	'page-menu.submenu.move-down': 'Move down',
	'page-menu.submenu.move-up': 'Move up',
	'page-menu.submenu.delete': 'Delete',
	'share-menu.title': 'Share',
	'share-menu.save-note': 'Download this project to your computer as a .tldr file.',
	'share-menu.fork-note': 'Create a new shared project based on this snapshot.',
	'share-menu.share-project': 'Share this project',
	'share-menu.copy-link': 'Copy share link',
	'share-menu.readonly-link': 'Read-only',
	'share-menu.create-snapshot-link': 'Copy snapshot link',
	'share-menu.snapshot-link-note': 'Capture and share this project as a read-only snapshot link.',
	'share-menu.copy-readonly-link': 'Copy read-only link',
	'share-menu.offline-note': 'Create a new shared project based on your current project.',
	'share-menu.copy-link-note': 'Anyone with the link will be able to view and edit this project.',
	'share-menu.copy-readonly-link-note':
		'Anyone with the link will be able to view (but not edit) this project.',
	'share-menu.project-too-large':
		"Sorry, this project can't be shared because it's too large. We're working on it!",
	'share-menu.upload-failed':
		"Sorry, we couldn't upload your project at the moment. Please try again or let us know if the problem persists.",
	'people-menu.title': 'People',
	'people-menu.change-name': 'Change name',
	'people-menu.change-color': 'Change color',
	'people-menu.follow': 'Following',
	'people-menu.following': 'Following',
	'people-menu.leading': 'Following You',
	'people-menu.user': '(You)',
	'people-menu.invite': 'Invite others',
	'help-menu.title': 'Help and resources',
	'help-menu.about': 'About',
	'help-menu.discord': 'Discord',
	'help-menu.github': 'GitHub',
	'help-menu.keyboard-shortcuts': 'Keyboard shortcuts',
	'help-menu.twitter': 'Twitter',
	'actions-menu.title': 'Actions',
	'edit-link-dialog.title': 'Edit link',
	'edit-link-dialog.invalid-url': 'A link must be a valid URL.',
	'edit-link-dialog.detail': 'Links will open in a new tab.',
	'edit-link-dialog.url': 'URL',
	'edit-link-dialog.clear': 'Clear',
	'edit-link-dialog.save': 'Continue',
	'edit-link-dialog.cancel': 'Cancel',
	'embed-dialog.title': 'Insert embed',
	'embed-dialog.back': 'Back',
	'embed-dialog.create': 'Create',
	'embed-dialog.cancel': 'Cancel',
	'embed-dialog.url': 'URL',
	'embed-dialog.instruction': "Paste in the site's URL to create the embed.",
	'embed-dialog.invalid-url': 'We could not create an embed from that URL.',
	'edit-pages-dialog.move-down': 'Move down',
	'edit-pages-dialog.move-up': 'Move up',
	'shortcuts-dialog.title': 'Keyboard shortcuts',
	'shortcuts-dialog.edit': 'Edit',
	'shortcuts-dialog.file': 'File',
	'shortcuts-dialog.preferences': 'Preferences',
	'shortcuts-dialog.tools': 'Tools',
	'shortcuts-dialog.transform': 'Transform',
	'shortcuts-dialog.view': 'View',
	'style-panel.title': 'Styles',
	'style-panel.align': 'Align',
	'style-panel.vertical-align': 'Vertical align',
	'style-panel.position': 'Position',
	'style-panel.arrowheads': 'Arrowheads',
	'style-panel.arrowhead-start': 'Start',
	'style-panel.arrowhead-end': 'End',
	'style-panel.color': 'Color',
	'style-panel.dash': 'Dash',
	'style-panel.fill': 'Fill',
	'style-panel.font': 'Font',
	'style-panel.geo': 'Shape',
	'style-panel.mixed': 'Mixed',
	'style-panel.opacity': 'Opacity',
	'style-panel.size': 'Size',
	'style-panel.spline': 'Spline',
	'tool-panel.drawing': 'Drawing',
	'tool-panel.shapes': 'Shapes',
	'tool-panel.more': 'More',
	'debug-panel.more': 'More',
	'navigation-zone.toggle-minimap': 'Toggle minimap',
	'navigation-zone.zoom': 'Zoom',
	'focus-mode.toggle-focus-mode': 'Toggle focus mode',
	'toast.close': 'Close',
	'file-system.file-open-error.title': 'Could not open file',
	'file-system.file-open-error.not-a-tldraw-file':
		"The file you tried to open doesn't look like a tldraw file.",
	'file-system.file-open-error.file-format-version-too-new':
		'The file you tried to open is from a newer version of tldraw. Please reload the page and try again.',
	'file-system.file-open-error.generic-corrupted-file': 'The file you tried to open is corrupted.',
	'file-system.confirm-open.title': 'Overwrite current project?',
	'file-system.confirm-open.description':
		'Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?',
	'file-system.confirm-open.cancel': 'Cancel',
	'file-system.confirm-open.open': 'Open file',
	'file-system.confirm-open.dont-show-again': "Don't ask again",
	'file-system.confirm-clear.title': 'Clear current project?',
	'file-system.confirm-clear.description':
		'Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?',
	'file-system.confirm-clear.cancel': 'Cancel',
	'file-system.confirm-clear.continue': 'Continue',
	'file-system.confirm-clear.dont-show-again': "Don't ask again",
	'file-system.shared-document-file-open-error.title': 'Could not open file',
	'file-system.shared-document-file-open-error.description':
		'Opening files from shared projects is not supported.',
	'sharing.confirm-leave.title': 'Leave current project?',
	'sharing.confirm-leave.description':
		'Are you sure you want to leave this shared project? You can return to it by navigating to its URL.',
	'sharing.confirm-leave.cancel': 'Cancel',
	'sharing.confirm-leave.leave': 'Leave',
	'sharing.confirm-leave.dont-show-again': "Don't ask again",
	'toast.error.export-fail.title': 'Failed export',
	'toast.error.export-fail.desc': 'Failed to export image',
	'toast.error.copy-fail.title': 'Failed copy',
	'toast.error.copy-fail.desc': 'Failed to copy image',
	'context.pages.new-page': 'New page',
	'vscode.file-open.desc':
		"We've updated this document to work with the current version of tldraw. If you'd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
	'vscode.file-open.open': 'Continue',
	'vscode.file-open.backup': 'Backup',
	'vscode.file-open.backup-saved': 'Backup saved',
	'vscode.file-open.backup-failed': 'Backup failed: this is not a .tldr file.',
	'vscode.file-open.dont-show-again': "Don't ask again",
}

// ../packages/ui/src/lib/hooks/useTranslation/translations.ts
init_define_process()

// ../packages/ui/src/lib/hooks/useTranslation/languages.ts
init_define_process()
var LANGUAGES2 = [
	{ locale: 'ar', label: '\u0639\u0631\u0628\u064A' },
	{ locale: 'ca', label: 'Catal\xE0' },
	{ locale: 'da', label: 'Danish' },
	{ locale: 'de', label: 'Deutsch' },
	{ locale: 'en', label: 'English' },
	{ locale: 'es', label: 'Espa\xF1ol' },
	{ locale: 'fa', label: '\u0641\u0627\u0631\u0633\u06CC' },
	{ locale: 'fi', label: 'Suomi' },
	{ locale: 'fr', label: 'Fran\xE7ais' },
	{ locale: 'gl', label: 'Galego' },
	{ locale: 'he', label: '\u05E2\u05D1\u05E8\u05D9\u05EA' },
	{ locale: 'it', label: 'Italiano' },
	{ locale: 'ja', label: '\u65E5\u672C\u8A9E' },
	{ locale: 'ko-kr', label: '\uD55C\uAD6D\uC5B4' },
	{ locale: 'ku', label: '\u06A9\u0648\u0631\u062F\u06CC' },
	{ locale: 'hi-in', label: '\u0939\u093F\u0928\u094D\u0926\u0940' },
	{ locale: 'hu', label: 'Magyar' },
	{ locale: 'my', label: '\u1019\u103C\u1014\u103A\u1019\u102C\u1005\u102C' },
	{ locale: 'ne', label: '\u0928\u0947\u092A\u093E\u0932\u0940' },
	{ locale: 'no', label: 'Norwegian' },
	{ locale: 'pl', label: 'Polski' },
	{ locale: 'pt-br', label: 'Portugu\xEAs - Brasil' },
	{ locale: 'pt-pt', label: 'Portugu\xEAs - Europeu' },
	{ locale: 'ro', label: 'Rom\xE2n\u0103' },
	{ locale: 'ru', label: 'Russian' },
	{ locale: 'sv', label: 'Svenska' },
	{ locale: 'te', label: '\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41' },
	{ locale: 'th', label: '\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22' },
	{ locale: 'tr', label: 'T\xFCrk\xE7e' },
	{ locale: 'uk', label: 'Ukrainian' },
	{ locale: 'vi', label: 'Ti\u1EBFng Vi\u1EC7t' },
	{ locale: 'zh-cn', label: 'Chinese - Simplified' },
	{ locale: 'zh-tw', label: '\u7E41\u9AD4\u4E2D\u6587 (\u53F0\u7063)' },
]

// ../packages/ui/src/lib/hooks/useTranslation/translations.ts
var EN_TRANSLATION = {
	locale: 'en',
	label: 'English',
	messages: DEFAULT_TRANSLATION,
}
async function fetchTranslation(locale, assetUrls2) {
	const mainRes = await fetch(assetUrls2.translations.en)
	if (!mainRes.ok) {
		console.warn(`No main translations found.`)
		return EN_TRANSLATION
	}
	if (locale === 'en') {
		return EN_TRANSLATION
	}
	const language = LANGUAGES2.find((t4) => t4.locale === locale)
	if (!language) {
		console.warn(`No translation found for locale ${locale}`)
		return EN_TRANSLATION
	}
	const res = await fetch(assetUrls2.translations[language.locale])
	const messages = await res.json()
	if (!messages) {
		console.warn(`No messages found for locale ${locale}`)
		return EN_TRANSLATION
	}
	const missing = []
	for (const key in EN_TRANSLATION) {
		if (!messages[key]) {
			missing.push(key)
		}
	}
	if (missing.length > 0 && define_process_default.env.NODE_ENV === 'development') {
		console.warn(`Language ${locale}: missing messages for keys:
${missing.join('\n')}`)
	}
	return {
		locale,
		label: language.label,
		messages: { ...EN_TRANSLATION.messages, ...messages },
	}
}
async function getTranslation(locale, assetUrls2) {
	return await fetchTranslation(locale, assetUrls2)
}

// ../packages/ui/src/lib/hooks/useTranslation/useTranslation.tsx
var import_jsx_runtime55 = __toESM(require_jsx_runtime())
var TranslationsContext = React40.createContext({})
var useCurrentTranslation = () => React40.useContext(TranslationsContext)
var TranslationProvider = track(function TranslationProvider2({ overrides, children }) {
	const app = useApp()
	const locale = app.locale
	const getAssetUrl = useAssetUrls()
	const [currentTranslation, setCurrentTranslation] = React40.useState(() => {
		if (overrides && overrides['en']) {
			return {
				locale: 'en',
				label: 'English',
				messages: { ...DEFAULT_TRANSLATION, ...overrides['en'] },
			}
		}
		return {
			locale: 'en',
			label: 'English',
			messages: DEFAULT_TRANSLATION,
		}
	})
	React40.useEffect(() => {
		let isCancelled = false
		async function loadTranslation() {
			const translation = await getTranslation(locale, getAssetUrl)
			if (translation && !isCancelled) {
				if (overrides && overrides[locale]) {
					setCurrentTranslation({
						...translation,
						messages: { ...translation.messages, ...overrides[locale] },
					})
				} else {
					setCurrentTranslation(translation)
				}
			}
		}
		loadTranslation()
		return () => {
			isCancelled = true
		}
	}, [getAssetUrl, locale, overrides])
	return /* @__PURE__ */ (0,
	import_jsx_runtime55.jsx)(TranslationsContext.Provider, { value: currentTranslation, children })
})
function useTranslation() {
	const translation = useCurrentTranslation()
	return React40.useCallback(
		function msg2(id) {
			return translation.messages[id] ?? id
		},
		[translation]
	)
}

// ../packages/ui/src/lib/components/Spinner.tsx
init_define_process()
var import_jsx_runtime56 = __toESM(require_jsx_runtime())
function Spinner(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)('svg', {
		width: 16,
		height: 16,
		viewBox: '0 0 16 16',
		...props,
		children: /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)('g', {
			strokeWidth: 2,
			fill: 'none',
			fillRule: 'evenodd',
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime56.jsx)('circle', {
					strokeOpacity: 0.25,
					cx: 8,
					cy: 8,
					r: 7,
					stroke: 'currentColor',
				}),
				/* @__PURE__ */ (0, import_jsx_runtime56.jsx)('path', {
					strokeLinecap: 'round',
					d: 'M15 8c0-4.5-4.5-7-7-7',
					stroke: 'currentColor',
					children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)('animateTransform', {
						attributeName: 'transform',
						type: 'rotate',
						from: '0 8 8',
						to: '360 8 8',
						dur: '1s',
						repeatCount: 'indefinite',
					}),
				}),
			],
		}),
	})
}

// ../packages/ui/src/lib/components/primitives/Icon.tsx
init_define_process()
var import_classnames11 = __toESM(require_classnames())
var import_react59 = __toESM(require_react())
var import_jsx_runtime57 = __toESM(require_jsx_runtime())
var Icon = (0, import_react59.memo)(function Icon2({
	small,
	invertIcon,
	icon,
	color,
	className,
	...props
}) {
	const assetUrls2 = useAssetUrls()
	const asset = assetUrls2.icons[icon]
	const ref = (0, import_react59.useRef)(null)
	;(0, import_react59.useLayoutEffect)(() => {
		if (ref?.current) {
			ref.current.style.webkitMask = `url(${asset}) center 100% / 100% no-repeat`
		}
	}, [ref, asset])
	return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)('div', {
		...props,
		ref,
		className: (0, import_classnames11.default)(
			'tlui-icon',
			{ 'tlui-icon__small': small },
			className
		),
		style: {
			color,
			mask: `url(${asset}) center 100% / 100% no-repeat`,
			transform: invertIcon ? 'scale(-1, 1)' : void 0,
		},
	})
})

// ../packages/ui/src/lib/components/primitives/Kbd.tsx
init_define_process()

// ../packages/ui/src/lib/components/primitives/shared.ts
init_define_process()
var isDarwin =
	typeof window === 'undefined'
		? false
		: window.navigator.userAgent.toLowerCase().indexOf('mac') > -1
var cmdKey = isDarwin ? '\u2318' : 'Ctrl'
var altKey = isDarwin ? '\u2325' : 'Alt'
function kbd(str) {
	return str
		.split(',')[0]
		.split('')
		.map((sub) => {
			const subStr = sub.replace(/\$/g, cmdKey).replace(/\?/g, altKey).replace(/!/g, '\u21E7')
			return subStr[0].toUpperCase() + subStr.slice(1)
		})
}
function kbdStr(str) {
	return (
		'\u2014 ' +
		str
			.split(',')[0]
			.split('')
			.map((sub) => {
				const subStr = sub.replace(/\$/g, cmdKey).replace(/\?/g, altKey).replace(/!/g, '\u21E7')
				return subStr[0].toUpperCase() + subStr.slice(1)
			})
			.join('\u2009')
	)
}
var getBaseUrl = () => {
	if (typeof define_process_default === 'undefined') {
		return 'http://localhost:5420'
	}
	if (define_process_default.env.NODE_ENV === 'development') {
		return 'http://localhost:3000'
	}
	if (define_process_default.env.NEXT_PUBLIC_VERCEL_ENV === 'production') {
		return 'https://www.tldraw.com'
	}
	if (define_process_default.env.NEXT_PUBLIC_VERCEL_ENV === 'preview') {
		return `https://${define_process_default.env.NEXT_PUBLIC_VERCEL_URL}`
	}
	return 'http://localhost:3000'
}
var BASE_URL = getBaseUrl()

// ../packages/ui/src/lib/components/primitives/Kbd.tsx
var import_jsx_runtime58 = __toESM(require_jsx_runtime())
function Kbd({ children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)('kbd', {
		className: 'tlui-kbd',
		children: kbd(children).map((k2, i3) =>
			/* @__PURE__ */ (0, import_jsx_runtime58.jsx)('span', { children: k2 }, i3)
		),
	})
}

// ../packages/ui/src/lib/components/primitives/Button.tsx
var import_jsx_runtime59 = __toESM(require_jsx_runtime())
var Button = React41.forwardRef(function Button2(
	{
		label,
		icon,
		invertIcon,
		iconLeft,
		smallIcon,
		kbd: kbd2,
		isChecked = false,
		type = 'normal',
		children,
		spinner,
		...props
	},
	ref
) {
	const msg2 = useTranslation()
	const labelStr = label ? msg2(label) : ''
	return /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)('button', {
		ref,
		draggable: false,
		type: 'button',
		...props,
		title: props.title ?? labelStr,
		className: (0, import_classnames12.default)(
			'tlui-button',
			`tlui-button__${type}`,
			props.className
		),
		children: [
			iconLeft &&
				/* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Icon, {
					icon: iconLeft,
					className: 'tlui-icon-left',
					small: true,
				}),
			children,
			label &&
				/* @__PURE__ */ (0, import_jsx_runtime59.jsxs)('span', {
					draggable: false,
					children: [
						labelStr,
						isChecked && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Icon, { icon: 'check' }),
					],
				}),
			kbd2 && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Kbd, { children: kbd2 }),
			icon &&
				!spinner &&
				/* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Icon, {
					icon,
					small: !!label || smallIcon,
					invertIcon,
				}),
			spinner && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Spinner, {}),
		],
	})
})

// ../packages/ui/src/lib/components/primitives/Dialog.tsx
var import_jsx_runtime60 = __toESM(require_jsx_runtime())
function Header({ className, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)('div', {
		className: (0, import_classnames13.default)('tlui-dialog__header', className),
		children,
	})
}
function Title({ className, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)($5d3850c4d0b4e6c7$export$16f7638e4a34b909, {
		dir: 'ltr',
		className: (0, import_classnames13.default)('tlui-dialog__header__title', className),
		children,
	})
}
function CloseButton() {
	return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)('div', {
		className: 'tlui-dialog__header__close',
		children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
			$5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac,
			{
				'data-testid': 'dialog.close',
				dir: 'ltr',
				asChild: true,
				children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Button, {
					'aria-label': 'Close',
					onTouchEnd: (e2) => e2.target.click(),
					children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Icon, {
						small: true,
						icon: 'cross-2',
					}),
				}),
			}
		),
	})
}
function Body({ className, children, style }) {
	return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)('div', {
		className: (0, import_classnames13.default)('tlui-dialog__body', className),
		style,
		children,
	})
}
function Footer({ className, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)('div', {
		className: (0, import_classnames13.default)('tlui-dialog__footer', className),
		children,
	})
}

// ../packages/ui/src/lib/components/primitives/DropdownMenu.tsx
init_define_process()

// ../node_modules/@radix-ui/react-dropdown-menu/dist/index.module.js
init_define_process()
var import_react67 = __toESM(require_react())

// ../node_modules/@radix-ui/react-menu/dist/index.module.js
init_define_process()
var import_react66 = __toESM(require_react())

// ../node_modules/@radix-ui/react-collection/dist/index.module.js
init_define_process()
var import_react60 = __toESM(require_react())
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
	const PROVIDER_NAME = name + 'CollectionProvider'
	const [createCollectionContext, createCollectionScope] =
		$c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME)
	const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
		collectionRef: {
			current: null,
		},
		itemMap: /* @__PURE__ */ new Map(),
	})
	const CollectionProvider = (props) => {
		const { scope, children } = props
		const ref = import_react60.default.useRef(null)
		const itemMap = import_react60.default.useRef(/* @__PURE__ */ new Map()).current
		return /* @__PURE__ */ import_react60.default.createElement(
			CollectionProviderImpl,
			{
				scope,
				itemMap,
				collectionRef: ref,
			},
			children
		)
	}
	/* @__PURE__ */ Object.assign(CollectionProvider, {
		displayName: PROVIDER_NAME,
	})
	const COLLECTION_SLOT_NAME = name + 'CollectionSlot'
	const CollectionSlot = /* @__PURE__ */ import_react60.default.forwardRef(
		(props, forwardedRef) => {
			const { scope, children } = props
			const context = useCollectionContext(COLLECTION_SLOT_NAME, scope)
			const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
				forwardedRef,
				context.collectionRef
			)
			return /* @__PURE__ */ import_react60.default.createElement(
				$5e63c961fc1ce211$export$8c6ed5c666ac1360,
				{
					ref: composedRefs,
				},
				children
			)
		}
	)
	/* @__PURE__ */ Object.assign(CollectionSlot, {
		displayName: COLLECTION_SLOT_NAME,
	})
	const ITEM_SLOT_NAME = name + 'CollectionItemSlot'
	const ITEM_DATA_ATTR = 'data-radix-collection-item'
	const CollectionItemSlot = /* @__PURE__ */ import_react60.default.forwardRef(
		(props, forwardedRef) => {
			const { scope, children, ...itemData } = props
			const ref = import_react60.default.useRef(null)
			const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
			const context = useCollectionContext(ITEM_SLOT_NAME, scope)
			import_react60.default.useEffect(() => {
				context.itemMap.set(ref, {
					ref,
					...itemData,
				})
				return () => void context.itemMap.delete(ref)
			})
			return /* @__PURE__ */ import_react60.default.createElement(
				$5e63c961fc1ce211$export$8c6ed5c666ac1360,
				{
					[ITEM_DATA_ATTR]: '',
					ref: composedRefs,
				},
				children
			)
		}
	)
	/* @__PURE__ */ Object.assign(CollectionItemSlot, {
		displayName: ITEM_SLOT_NAME,
	})
	function useCollection(scope) {
		const context = useCollectionContext(name + 'CollectionConsumer', scope)
		const getItems = import_react60.default.useCallback(() => {
			const collectionNode = context.collectionRef.current
			if (!collectionNode) return []
			const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`))
			const items = Array.from(context.itemMap.values())
			const orderedItems = items.sort(
				(a3, b3) => orderedNodes.indexOf(a3.ref.current) - orderedNodes.indexOf(b3.ref.current)
			)
			return orderedItems
		}, [context.collectionRef, context.itemMap])
		return getItems
	}
	return [
		{
			Provider: CollectionProvider,
			Slot: CollectionSlot,
			ItemSlot: CollectionItemSlot,
		},
		useCollection,
		createCollectionScope,
	]
}

// ../node_modules/@radix-ui/react-direction/dist/index.module.js
init_define_process()
var import_react61 = __toESM(require_react())
var $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ (0, import_react61.createContext)(
	void 0
)
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
	const globalDir = (0, import_react61.useContext)($f631663db3294ace$var$DirectionContext)
	return localDir || globalDir || 'ltr'
}

// ../node_modules/@radix-ui/react-popper/dist/index.module.js
init_define_process()
var import_react64 = __toESM(require_react())

// ../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
init_define_process()

// ../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
init_define_process()

// ../node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs
init_define_process()
function t2(t4) {
	return t4.split('-')[0]
}
function e(t4) {
	return t4.split('-')[1]
}
function n(e2) {
	return ['top', 'bottom'].includes(t2(e2)) ? 'x' : 'y'
}
function r(t4) {
	return 'y' === t4 ? 'height' : 'width'
}
function i(i3, o3, a3) {
	let { reference: l3, floating: s3 } = i3
	const c3 = l3.x + l3.width / 2 - s3.width / 2,
		f3 = l3.y + l3.height / 2 - s3.height / 2,
		u3 = n(o3),
		m3 = r(u3),
		g3 = l3[m3] / 2 - s3[m3] / 2,
		d3 = 'x' === u3
	let p3
	switch (t2(o3)) {
		case 'top':
			p3 = { x: c3, y: l3.y - s3.height }
			break
		case 'bottom':
			p3 = { x: c3, y: l3.y + l3.height }
			break
		case 'right':
			p3 = { x: l3.x + l3.width, y: f3 }
			break
		case 'left':
			p3 = { x: l3.x - s3.width, y: f3 }
			break
		default:
			p3 = { x: l3.x, y: l3.y }
	}
	switch (e(o3)) {
		case 'start':
			p3[u3] -= g3 * (a3 && d3 ? -1 : 1)
			break
		case 'end':
			p3[u3] += g3 * (a3 && d3 ? -1 : 1)
	}
	return p3
}
var o = async (t4, e2, n3) => {
	const {
			placement: r3 = 'bottom',
			strategy: o3 = 'absolute',
			middleware: a3 = [],
			platform: l3,
		} = n3,
		s3 = await (null == l3.isRTL ? void 0 : l3.isRTL(e2))
	let c3 = await l3.getElementRects({ reference: t4, floating: e2, strategy: o3 }),
		{ x: f3, y: u3 } = i(c3, r3, s3),
		m3 = r3,
		g3 = {},
		d3 = 0
	for (let n4 = 0; n4 < a3.length; n4++) {
		const { name: p3, fn: h3 } = a3[n4],
			{
				x: y3,
				y: x3,
				data: w3,
				reset: v3,
			} = await h3({
				x: f3,
				y: u3,
				initialPlacement: r3,
				placement: m3,
				strategy: o3,
				middlewareData: g3,
				rects: c3,
				platform: l3,
				elements: { reference: t4, floating: e2 },
			})
		;(f3 = null != y3 ? y3 : f3),
			(u3 = null != x3 ? x3 : u3),
			(g3 = { ...g3, [p3]: { ...g3[p3], ...w3 } }),
			v3 &&
				d3 <= 50 &&
				(d3++,
				'object' == typeof v3 &&
					(v3.placement && (m3 = v3.placement),
					v3.rects &&
						(c3 =
							true === v3.rects
								? await l3.getElementRects({ reference: t4, floating: e2, strategy: o3 })
								: v3.rects),
					({ x: f3, y: u3 } = i(c3, m3, s3))),
				(n4 = -1))
	}
	return { x: f3, y: u3, placement: m3, strategy: o3, middlewareData: g3 }
}
function a(t4) {
	return 'number' != typeof t4
		? (function (t5) {
				return { top: 0, right: 0, bottom: 0, left: 0, ...t5 }
		  })(t4)
		: { top: t4, right: t4, bottom: t4, left: t4 }
}
function l(t4) {
	return { ...t4, top: t4.y, left: t4.x, right: t4.x + t4.width, bottom: t4.y + t4.height }
}
async function s(t4, e2) {
	var n3
	void 0 === e2 && (e2 = {})
	const { x: r3, y: i3, platform: o3, rects: s3, elements: c3, strategy: f3 } = t4,
		{
			boundary: u3 = 'clippingAncestors',
			rootBoundary: m3 = 'viewport',
			elementContext: g3 = 'floating',
			altBoundary: d3 = false,
			padding: p3 = 0,
		} = e2,
		h3 = a(p3),
		y3 = c3[d3 ? ('floating' === g3 ? 'reference' : 'floating') : g3],
		x3 = l(
			await o3.getClippingRect({
				element:
					null == (n3 = await (null == o3.isElement ? void 0 : o3.isElement(y3))) || n3
						? y3
						: y3.contextElement ||
						  (await (null == o3.getDocumentElement ? void 0 : o3.getDocumentElement(c3.floating))),
				boundary: u3,
				rootBoundary: m3,
				strategy: f3,
			})
		),
		w3 = l(
			o3.convertOffsetParentRelativeRectToViewportRelativeRect
				? await o3.convertOffsetParentRelativeRectToViewportRelativeRect({
						rect: 'floating' === g3 ? { ...s3.floating, x: r3, y: i3 } : s3.reference,
						offsetParent: await (null == o3.getOffsetParent
							? void 0
							: o3.getOffsetParent(c3.floating)),
						strategy: f3,
				  })
				: s3[g3]
		)
	return {
		top: x3.top - w3.top + h3.top,
		bottom: w3.bottom - x3.bottom + h3.bottom,
		left: x3.left - w3.left + h3.left,
		right: w3.right - x3.right + h3.right,
	}
}
var c = Math.min
var f = Math.max
function u(t4, e2, n3) {
	return f(t4, c(e2, n3))
}
var m = (t4) => ({
	name: 'arrow',
	options: t4,
	async fn(i3) {
		const { element: o3, padding: l3 = 0 } = null != t4 ? t4 : {},
			{ x: s3, y: c3, placement: f3, rects: m3, platform: g3 } = i3
		if (null == o3) return {}
		const d3 = a(l3),
			p3 = { x: s3, y: c3 },
			h3 = n(f3),
			y3 = e(f3),
			x3 = r(h3),
			w3 = await g3.getDimensions(o3),
			v3 = 'y' === h3 ? 'top' : 'left',
			b3 = 'y' === h3 ? 'bottom' : 'right',
			R3 = m3.reference[x3] + m3.reference[h3] - p3[h3] - m3.floating[x3],
			A2 = p3[h3] - m3.reference[h3],
			P2 = await (null == g3.getOffsetParent ? void 0 : g3.getOffsetParent(o3))
		let T3 = P2 ? ('y' === h3 ? P2.clientHeight || 0 : P2.clientWidth || 0) : 0
		0 === T3 && (T3 = m3.floating[x3])
		const O2 = R3 / 2 - A2 / 2,
			D3 = d3[v3],
			L3 = T3 - w3[x3] - d3[b3],
			k2 = T3 / 2 - w3[x3] / 2 + O2,
			E3 = u(D3, k2, L3),
			C2 =
				('start' === y3 ? d3[v3] : d3[b3]) > 0 && k2 !== E3 && m3.reference[x3] <= m3.floating[x3]
		return {
			[h3]: p3[h3] - (C2 ? (k2 < D3 ? D3 - k2 : L3 - k2) : 0),
			data: { [h3]: E3, centerOffset: k2 - E3 },
		}
	},
})
var g = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }
function d(t4) {
	return t4.replace(/left|right|bottom|top/g, (t5) => g[t5])
}
function p(t4, i3, o3) {
	void 0 === o3 && (o3 = false)
	const a3 = e(t4),
		l3 = n(t4),
		s3 = r(l3)
	let c3 =
		'x' === l3
			? a3 === (o3 ? 'end' : 'start')
				? 'right'
				: 'left'
			: 'start' === a3
			? 'bottom'
			: 'top'
	return i3.reference[s3] > i3.floating[s3] && (c3 = d(c3)), { main: c3, cross: d(c3) }
}
var h = { start: 'end', end: 'start' }
function y(t4) {
	return t4.replace(/start|end/g, (t5) => h[t5])
}
var x = ['top', 'right', 'bottom', 'left']
var w = x.reduce((t4, e2) => t4.concat(e2, e2 + '-start', e2 + '-end'), [])
var b = function (e2) {
	return (
		void 0 === e2 && (e2 = {}),
		{
			name: 'flip',
			options: e2,
			async fn(n3) {
				var r3
				const {
						placement: i3,
						middlewareData: o3,
						rects: a3,
						initialPlacement: l3,
						platform: c3,
						elements: f3,
					} = n3,
					{
						mainAxis: u3 = true,
						crossAxis: m3 = true,
						fallbackPlacements: g3,
						fallbackStrategy: h3 = 'bestFit',
						flipAlignment: x3 = true,
						...w3
					} = e2,
					v3 = t2(i3),
					b3 =
						g3 ||
						(v3 === l3 || !x3
							? [d(l3)]
							: (function (t4) {
									const e3 = d(t4)
									return [y(t4), e3, y(e3)]
							  })(l3)),
					R3 = [l3, ...b3],
					A2 = await s(n3, w3),
					P2 = []
				let T3 = (null == (r3 = o3.flip) ? void 0 : r3.overflows) || []
				if ((u3 && P2.push(A2[v3]), m3)) {
					const { main: t4, cross: e3 } = p(
						i3,
						a3,
						await (null == c3.isRTL ? void 0 : c3.isRTL(f3.floating))
					)
					P2.push(A2[t4], A2[e3])
				}
				if (((T3 = [...T3, { placement: i3, overflows: P2 }]), !P2.every((t4) => t4 <= 0))) {
					var O2, D3
					const t4 = (null != (O2 = null == (D3 = o3.flip) ? void 0 : D3.index) ? O2 : 0) + 1,
						e3 = R3[t4]
					if (e3) return { data: { index: t4, overflows: T3 }, reset: { placement: e3 } }
					let n4 = 'bottom'
					switch (h3) {
						case 'bestFit': {
							var L3
							const t5 =
								null ==
								(L3 = T3.map((t6) => [
									t6,
									t6.overflows.filter((t7) => t7 > 0).reduce((t7, e4) => t7 + e4, 0),
								]).sort((t6, e4) => t6[1] - e4[1])[0])
									? void 0
									: L3[0].placement
							t5 && (n4 = t5)
							break
						}
						case 'initialPlacement':
							n4 = l3
					}
					if (i3 !== n4) return { reset: { placement: n4 } }
				}
				return {}
			},
		}
	)
}
function R(t4, e2) {
	return {
		top: t4.top - e2.height,
		right: t4.right - e2.width,
		bottom: t4.bottom - e2.height,
		left: t4.left - e2.width,
	}
}
function A(t4) {
	return x.some((e2) => t4[e2] >= 0)
}
var P = function (t4) {
	let { strategy: e2 = 'referenceHidden', ...n3 } = void 0 === t4 ? {} : t4
	return {
		name: 'hide',
		async fn(t5) {
			const { rects: r3 } = t5
			switch (e2) {
				case 'referenceHidden': {
					const e3 = R(await s(t5, { ...n3, elementContext: 'reference' }), r3.reference)
					return { data: { referenceHiddenOffsets: e3, referenceHidden: A(e3) } }
				}
				case 'escaped': {
					const e3 = R(await s(t5, { ...n3, altBoundary: true }), r3.floating)
					return { data: { escapedOffsets: e3, escaped: A(e3) } }
				}
				default:
					return {}
			}
		},
	}
}
var T = function (r3) {
	return (
		void 0 === r3 && (r3 = 0),
		{
			name: 'offset',
			options: r3,
			async fn(i3) {
				const { x: o3, y: a3 } = i3,
					l3 = await (async function (r4, i4) {
						const { placement: o4, platform: a4, elements: l4 } = r4,
							s3 = await (null == a4.isRTL ? void 0 : a4.isRTL(l4.floating)),
							c3 = t2(o4),
							f3 = e(o4),
							u3 = 'x' === n(o4),
							m3 = ['left', 'top'].includes(c3) ? -1 : 1,
							g3 = s3 && u3 ? -1 : 1,
							d3 = 'function' == typeof i4 ? i4(r4) : i4
						let {
							mainAxis: p3,
							crossAxis: h3,
							alignmentAxis: y3,
						} = 'number' == typeof d3
							? { mainAxis: d3, crossAxis: 0, alignmentAxis: null }
							: { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d3 }
						return (
							f3 && 'number' == typeof y3 && (h3 = 'end' === f3 ? -1 * y3 : y3),
							u3 ? { x: h3 * g3, y: p3 * m3 } : { x: p3 * m3, y: h3 * g3 }
						)
					})(i3, r3)
				return { x: o3 + l3.x, y: a3 + l3.y, data: l3 }
			},
		}
	)
}
function O(t4) {
	return 'x' === t4 ? 'y' : 'x'
}
var D = function (e2) {
	return (
		void 0 === e2 && (e2 = {}),
		{
			name: 'shift',
			options: e2,
			async fn(r3) {
				const { x: i3, y: o3, placement: a3 } = r3,
					{
						mainAxis: l3 = true,
						crossAxis: c3 = false,
						limiter: f3 = {
							fn: (t4) => {
								let { x: e3, y: n3 } = t4
								return { x: e3, y: n3 }
							},
						},
						...m3
					} = e2,
					g3 = { x: i3, y: o3 },
					d3 = await s(r3, m3),
					p3 = n(t2(a3)),
					h3 = O(p3)
				let y3 = g3[p3],
					x3 = g3[h3]
				if (l3) {
					const t4 = 'y' === p3 ? 'bottom' : 'right'
					y3 = u(y3 + d3['y' === p3 ? 'top' : 'left'], y3, y3 - d3[t4])
				}
				if (c3) {
					const t4 = 'y' === h3 ? 'bottom' : 'right'
					x3 = u(x3 + d3['y' === h3 ? 'top' : 'left'], x3, x3 - d3[t4])
				}
				const w3 = f3.fn({ ...r3, [p3]: y3, [h3]: x3 })
				return { ...w3, data: { x: w3.x - i3, y: w3.y - o3 } }
			},
		}
	)
}
var L = function (e2) {
	return (
		void 0 === e2 && (e2 = {}),
		{
			options: e2,
			fn(r3) {
				const { x: i3, y: o3, placement: a3, rects: l3, middlewareData: s3 } = r3,
					{ offset: c3 = 0, mainAxis: f3 = true, crossAxis: u3 = true } = e2,
					m3 = { x: i3, y: o3 },
					g3 = n(a3),
					d3 = O(g3)
				let p3 = m3[g3],
					h3 = m3[d3]
				const y3 = 'function' == typeof c3 ? c3({ ...l3, placement: a3 }) : c3,
					x3 =
						'number' == typeof y3
							? { mainAxis: y3, crossAxis: 0 }
							: { mainAxis: 0, crossAxis: 0, ...y3 }
				if (f3) {
					const t4 = 'y' === g3 ? 'height' : 'width',
						e3 = l3.reference[g3] - l3.floating[t4] + x3.mainAxis,
						n3 = l3.reference[g3] + l3.reference[t4] - x3.mainAxis
					p3 < e3 ? (p3 = e3) : p3 > n3 && (p3 = n3)
				}
				if (u3) {
					var w3, v3, b3, R3
					const e3 = 'y' === g3 ? 'width' : 'height',
						n3 = ['top', 'left'].includes(t2(a3)),
						r4 =
							l3.reference[d3] -
							l3.floating[e3] +
							(n3 && null != (w3 = null == (v3 = s3.offset) ? void 0 : v3[d3]) ? w3 : 0) +
							(n3 ? 0 : x3.crossAxis),
						i4 =
							l3.reference[d3] +
							l3.reference[e3] +
							(n3 ? 0 : null != (b3 = null == (R3 = s3.offset) ? void 0 : R3[d3]) ? b3 : 0) -
							(n3 ? x3.crossAxis : 0)
					h3 < r4 ? (h3 = r4) : h3 > i4 && (h3 = i4)
				}
				return { [g3]: p3, [d3]: h3 }
			},
		}
	)
}
var k = function (n3) {
	return (
		void 0 === n3 && (n3 = {}),
		{
			name: 'size',
			options: n3,
			async fn(r3) {
				const { placement: i3, rects: o3, platform: a3, elements: l3 } = r3,
					{ apply: c3, ...u3 } = n3,
					m3 = await s(r3, u3),
					g3 = t2(i3),
					d3 = e(i3)
				let p3, h3
				'top' === g3 || 'bottom' === g3
					? ((p3 = g3),
					  (h3 =
							d3 === ((await (null == a3.isRTL ? void 0 : a3.isRTL(l3.floating))) ? 'start' : 'end')
								? 'left'
								: 'right'))
					: ((h3 = g3), (p3 = 'end' === d3 ? 'top' : 'bottom'))
				const y3 = f(m3.left, 0),
					x3 = f(m3.right, 0),
					w3 = f(m3.top, 0),
					v3 = f(m3.bottom, 0),
					b3 = {
						availableHeight:
							o3.floating.height -
							(['left', 'right'].includes(i3)
								? 2 * (0 !== w3 || 0 !== v3 ? w3 + v3 : f(m3.top, m3.bottom))
								: m3[p3]),
						availableWidth:
							o3.floating.width -
							(['top', 'bottom'].includes(i3)
								? 2 * (0 !== y3 || 0 !== x3 ? y3 + x3 : f(m3.left, m3.right))
								: m3[h3]),
					},
					R3 = await a3.getDimensions(l3.floating)
				null == c3 || c3({ ...r3, ...b3 })
				const A2 = await a3.getDimensions(l3.floating)
				return R3.width !== A2.width || R3.height !== A2.height ? { reset: { rects: true } } : {}
			},
		}
	)
}

// ../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
function n2(t4) {
	return t4 && t4.document && t4.location && t4.alert && t4.setInterval
}
function o2(t4) {
	if (null == t4) return window
	if (!n2(t4)) {
		const e2 = t4.ownerDocument
		return (e2 && e2.defaultView) || window
	}
	return t4
}
function i2(t4) {
	return o2(t4).getComputedStyle(t4)
}
function r2(t4) {
	return n2(t4) ? '' : t4 ? (t4.nodeName || '').toLowerCase() : ''
}
function l2() {
	const t4 = navigator.userAgentData
	return null != t4 && t4.brands
		? t4.brands.map((t5) => t5.brand + '/' + t5.version).join(' ')
		: navigator.userAgent
}
function c2(t4) {
	return t4 instanceof o2(t4).HTMLElement
}
function f2(t4) {
	return t4 instanceof o2(t4).Element
}
function s2(t4) {
	if ('undefined' == typeof ShadowRoot) return false
	return t4 instanceof o2(t4).ShadowRoot || t4 instanceof ShadowRoot
}
function u2(t4) {
	const { overflow: e2, overflowX: n3, overflowY: o3 } = i2(t4)
	return /auto|scroll|overlay|hidden/.test(e2 + o3 + n3)
}
function d2(t4) {
	return ['table', 'td', 'th'].includes(r2(t4))
}
function h2(t4) {
	const e2 = /firefox/i.test(l2()),
		n3 = i2(t4)
	return (
		'none' !== n3.transform ||
		'none' !== n3.perspective ||
		'paint' === n3.contain ||
		['transform', 'perspective'].includes(n3.willChange) ||
		(e2 && 'filter' === n3.willChange) ||
		(e2 && !!n3.filter && 'none' !== n3.filter)
	)
}
function a2() {
	return !/^((?!chrome|android).)*safari/i.test(l2())
}
var g2 = Math.min
var p2 = Math.max
var m2 = Math.round
function w2(t4, e2, n3) {
	var i3, r3, l3, s3
	void 0 === e2 && (e2 = false), void 0 === n3 && (n3 = false)
	const u3 = t4.getBoundingClientRect()
	let d3 = 1,
		h3 = 1
	e2 &&
		c2(t4) &&
		((d3 = (t4.offsetWidth > 0 && m2(u3.width) / t4.offsetWidth) || 1),
		(h3 = (t4.offsetHeight > 0 && m2(u3.height) / t4.offsetHeight) || 1))
	const g3 = f2(t4) ? o2(t4) : window,
		p3 = !a2() && n3,
		w3 =
			(u3.left +
				(p3 && null != (i3 = null == (r3 = g3.visualViewport) ? void 0 : r3.offsetLeft) ? i3 : 0)) /
			d3,
		v3 =
			(u3.top +
				(p3 && null != (l3 = null == (s3 = g3.visualViewport) ? void 0 : s3.offsetTop) ? l3 : 0)) /
			h3,
		y3 = u3.width / d3,
		x3 = u3.height / h3
	return { width: y3, height: x3, top: v3, right: w3 + y3, bottom: v3 + x3, left: w3, x: w3, y: v3 }
}
function v2(t4) {
	return ((e2 = t4),
	(e2 instanceof o2(e2).Node ? t4.ownerDocument : t4.document) || window.document).documentElement
	var e2
}
function y2(t4) {
	return f2(t4)
		? { scrollLeft: t4.scrollLeft, scrollTop: t4.scrollTop }
		: { scrollLeft: t4.pageXOffset, scrollTop: t4.pageYOffset }
}
function x2(t4) {
	return w2(v2(t4)).left + y2(t4).scrollLeft
}
function b2(t4, e2, n3) {
	const o3 = c2(e2),
		i3 = v2(e2),
		l3 = w2(
			t4,
			o3 &&
				(function (t5) {
					const e3 = w2(t5)
					return m2(e3.width) !== t5.offsetWidth || m2(e3.height) !== t5.offsetHeight
				})(e2),
			'fixed' === n3
		)
	let f3 = { scrollLeft: 0, scrollTop: 0 }
	const s3 = { x: 0, y: 0 }
	if (o3 || (!o3 && 'fixed' !== n3))
		if ((('body' !== r2(e2) || u2(i3)) && (f3 = y2(e2)), c2(e2))) {
			const t5 = w2(e2, true)
			;(s3.x = t5.x + e2.clientLeft), (s3.y = t5.y + e2.clientTop)
		} else i3 && (s3.x = x2(i3))
	return {
		x: l3.left + f3.scrollLeft - s3.x,
		y: l3.top + f3.scrollTop - s3.y,
		width: l3.width,
		height: l3.height,
	}
}
function L2(t4) {
	return 'html' === r2(t4)
		? t4
		: t4.assignedSlot || t4.parentNode || (s2(t4) ? t4.host : null) || v2(t4)
}
function R2(t4) {
	return c2(t4) && 'fixed' !== getComputedStyle(t4).position ? t4.offsetParent : null
}
function T2(t4) {
	const e2 = o2(t4)
	let n3 = R2(t4)
	for (; n3 && d2(n3) && 'static' === getComputedStyle(n3).position; ) n3 = R2(n3)
	return n3 &&
		('html' === r2(n3) ||
			('body' === r2(n3) && 'static' === getComputedStyle(n3).position && !h2(n3)))
		? e2
		: n3 ||
				(function (t5) {
					let e3 = L2(t5)
					for (s2(e3) && (e3 = e3.host); c2(e3) && !['html', 'body'].includes(r2(e3)); ) {
						if (h2(e3)) return e3
						e3 = e3.parentNode
					}
					return null
				})(t4) ||
				e2
}
function W(t4) {
	if (c2(t4)) return { width: t4.offsetWidth, height: t4.offsetHeight }
	const e2 = w2(t4)
	return { width: e2.width, height: e2.height }
}
function E2(t4) {
	const e2 = L2(t4)
	return ['html', 'body', '#document'].includes(r2(e2))
		? t4.ownerDocument.body
		: c2(e2) && u2(e2)
		? e2
		: E2(e2)
}
function H(t4, e2) {
	var n3
	void 0 === e2 && (e2 = [])
	const i3 = E2(t4),
		r3 = i3 === (null == (n3 = t4.ownerDocument) ? void 0 : n3.body),
		l3 = o2(i3),
		c3 = r3 ? [l3].concat(l3.visualViewport || [], u2(i3) ? i3 : []) : i3,
		f3 = e2.concat(c3)
	return r3 ? f3 : f3.concat(H(c3))
}
function C(e2, n3, r3) {
	return 'viewport' === n3
		? l(
				(function (t4, e3) {
					const n4 = o2(t4),
						i3 = v2(t4),
						r4 = n4.visualViewport
					let l3 = i3.clientWidth,
						c3 = i3.clientHeight,
						f3 = 0,
						s3 = 0
					if (r4) {
						;(l3 = r4.width), (c3 = r4.height)
						const t5 = a2()
						;(t5 || (!t5 && 'fixed' === e3)) && ((f3 = r4.offsetLeft), (s3 = r4.offsetTop))
					}
					return { width: l3, height: c3, x: f3, y: s3 }
				})(e2, r3)
		  )
		: f2(n3)
		? (function (t4, e3) {
				const n4 = w2(t4, false, 'fixed' === e3),
					o3 = n4.top + t4.clientTop,
					i3 = n4.left + t4.clientLeft
				return {
					top: o3,
					left: i3,
					x: i3,
					y: o3,
					right: i3 + t4.clientWidth,
					bottom: o3 + t4.clientHeight,
					width: t4.clientWidth,
					height: t4.clientHeight,
				}
		  })(n3, r3)
		: l(
				(function (t4) {
					var e3
					const n4 = v2(t4),
						o3 = y2(t4),
						r4 = null == (e3 = t4.ownerDocument) ? void 0 : e3.body,
						l3 = p2(
							n4.scrollWidth,
							n4.clientWidth,
							r4 ? r4.scrollWidth : 0,
							r4 ? r4.clientWidth : 0
						),
						c3 = p2(
							n4.scrollHeight,
							n4.clientHeight,
							r4 ? r4.scrollHeight : 0,
							r4 ? r4.clientHeight : 0
						)
					let f3 = -o3.scrollLeft + x2(t4)
					const s3 = -o3.scrollTop
					return (
						'rtl' === i2(r4 || n4).direction &&
							(f3 += p2(n4.clientWidth, r4 ? r4.clientWidth : 0) - l3),
						{ width: l3, height: c3, x: f3, y: s3 }
					)
				})(v2(e2))
		  )
}
function S(t4) {
	const e2 = H(t4),
		n3 = ['absolute', 'fixed'].includes(i2(t4).position) && c2(t4) ? T2(t4) : t4
	return f2(n3)
		? e2.filter(
				(t5) =>
					f2(t5) &&
					(function (t6, e3) {
						const n4 = null == e3.getRootNode ? void 0 : e3.getRootNode()
						if (t6.contains(e3)) return true
						if (n4 && s2(n4)) {
							let n5 = e3
							do {
								if (n5 && t6 === n5) return true
								n5 = n5.parentNode || n5.host
							} while (n5)
						}
						return false
					})(t5, n3) &&
					'body' !== r2(t5)
		  )
		: []
}
var D2 = {
	getClippingRect: function (t4) {
		let { element: e2, boundary: n3, rootBoundary: o3, strategy: i3 } = t4
		const r3 = [...('clippingAncestors' === n3 ? S(e2) : [].concat(n3)), o3],
			l3 = r3[0],
			c3 = r3.reduce((t5, n4) => {
				const o4 = C(e2, n4, i3)
				return (
					(t5.top = p2(o4.top, t5.top)),
					(t5.right = g2(o4.right, t5.right)),
					(t5.bottom = g2(o4.bottom, t5.bottom)),
					(t5.left = p2(o4.left, t5.left)),
					t5
				)
			}, C(e2, l3, i3))
		return { width: c3.right - c3.left, height: c3.bottom - c3.top, x: c3.left, y: c3.top }
	},
	convertOffsetParentRelativeRectToViewportRelativeRect: function (t4) {
		let { rect: e2, offsetParent: n3, strategy: o3 } = t4
		const i3 = c2(n3),
			l3 = v2(n3)
		if (n3 === l3) return e2
		let f3 = { scrollLeft: 0, scrollTop: 0 }
		const s3 = { x: 0, y: 0 }
		if (
			(i3 || (!i3 && 'fixed' !== o3)) &&
			(('body' !== r2(n3) || u2(l3)) && (f3 = y2(n3)), c2(n3))
		) {
			const t5 = w2(n3, true)
			;(s3.x = t5.x + n3.clientLeft), (s3.y = t5.y + n3.clientTop)
		}
		return { ...e2, x: e2.x - f3.scrollLeft + s3.x, y: e2.y - f3.scrollTop + s3.y }
	},
	isElement: f2,
	getDimensions: W,
	getOffsetParent: T2,
	getDocumentElement: v2,
	getElementRects: (t4) => {
		let { reference: e2, floating: n3, strategy: o3 } = t4
		return { reference: b2(e2, T2(n3), o3), floating: { ...W(n3), x: 0, y: 0 } }
	},
	getClientRects: (t4) => Array.from(t4.getClientRects()),
	isRTL: (t4) => 'rtl' === i2(t4).direction,
}
function N(t4, e2, n3, o3) {
	void 0 === o3 && (o3 = {})
	const {
			ancestorScroll: i3 = true,
			ancestorResize: r3 = true,
			elementResize: l3 = true,
			animationFrame: c3 = false,
		} = o3,
		s3 = i3 && !c3,
		u3 = r3 && !c3,
		d3 = s3 || u3 ? [...(f2(t4) ? H(t4) : []), ...H(e2)] : []
	d3.forEach((t5) => {
		s3 && t5.addEventListener('scroll', n3, { passive: true }),
			u3 && t5.addEventListener('resize', n3)
	})
	let h3,
		a3 = null
	if (l3) {
		let o4 = true
		;(a3 = new ResizeObserver(() => {
			o4 || n3(), (o4 = false)
		})),
			f2(t4) && !c3 && a3.observe(t4),
			a3.observe(e2)
	}
	let g3 = c3 ? w2(t4) : null
	return (
		c3 &&
			(function e3() {
				const o4 = w2(t4)
				!g3 ||
					(o4.x === g3.x && o4.y === g3.y && o4.width === g3.width && o4.height === g3.height) ||
					n3()
				;(g3 = o4), (h3 = requestAnimationFrame(e3))
			})(),
		n3(),
		() => {
			var t5
			d3.forEach((t6) => {
				s3 && t6.removeEventListener('scroll', n3), u3 && t6.removeEventListener('resize', n3)
			}),
				null == (t5 = a3) || t5.disconnect(),
				(a3 = null),
				c3 && cancelAnimationFrame(h3)
		}
	)
}
var z = (t4, n3, o3) => o(t4, n3, { platform: D2, ...o3 })

// ../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var React42 = __toESM(require_react())
var import_react62 = __toESM(require_react())
var ReactDOM = __toESM(require_react_dom())
var index =
	typeof document !== 'undefined' ? import_react62.useLayoutEffect : import_react62.useEffect
function deepEqual(a3, b3) {
	if (a3 === b3) {
		return true
	}
	if (typeof a3 !== typeof b3) {
		return false
	}
	if (typeof a3 === 'function' && a3.toString() === b3.toString()) {
		return true
	}
	let length, i3, keys
	if (a3 && b3 && typeof a3 == 'object') {
		if (Array.isArray(a3)) {
			length = a3.length
			if (length != b3.length) return false
			for (i3 = length; i3-- !== 0; ) {
				if (!deepEqual(a3[i3], b3[i3])) {
					return false
				}
			}
			return true
		}
		keys = Object.keys(a3)
		length = keys.length
		if (length !== Object.keys(b3).length) {
			return false
		}
		for (i3 = length; i3-- !== 0; ) {
			if (!Object.prototype.hasOwnProperty.call(b3, keys[i3])) {
				return false
			}
		}
		for (i3 = length; i3-- !== 0; ) {
			const key = keys[i3]
			if (key === '_owner' && a3.$$typeof) {
				continue
			}
			if (!deepEqual(a3[key], b3[key])) {
				return false
			}
		}
		return true
	}
	return a3 !== a3 && b3 !== b3
}
function useLatestRef(value) {
	const ref = React42.useRef(value)
	index(() => {
		ref.current = value
	})
	return ref
}
function useFloating(_temp) {
	let {
		middleware,
		placement = 'bottom',
		strategy = 'absolute',
		whileElementsMounted,
	} = _temp === void 0 ? {} : _temp
	const reference = React42.useRef(null)
	const floating = React42.useRef(null)
	const whileElementsMountedRef = useLatestRef(whileElementsMounted)
	const cleanupRef = React42.useRef(null)
	const [data, setData] = React42.useState({
		// Setting these to `null` will allow the consumer to determine if
		// `computePosition()` has run yet
		x: null,
		y: null,
		strategy,
		placement,
		middlewareData: {},
	})
	const [latestMiddleware, setLatestMiddleware] = React42.useState(middleware)
	if (
		!deepEqual(
			latestMiddleware == null
				? void 0
				: latestMiddleware.map((_ref) => {
						let { options } = _ref
						return options
				  }),
			middleware == null
				? void 0
				: middleware.map((_ref2) => {
						let { options } = _ref2
						return options
				  })
		)
	) {
		setLatestMiddleware(middleware)
	}
	const update = React42.useCallback(() => {
		if (!reference.current || !floating.current) {
			return
		}
		z(reference.current, floating.current, {
			middleware: latestMiddleware,
			placement,
			strategy,
		}).then((data2) => {
			if (isMountedRef.current) {
				ReactDOM.flushSync(() => {
					setData(data2)
				})
			}
		})
	}, [latestMiddleware, placement, strategy])
	index(() => {
		if (isMountedRef.current) {
			update()
		}
	}, [update])
	const isMountedRef = React42.useRef(false)
	index(() => {
		isMountedRef.current = true
		return () => {
			isMountedRef.current = false
		}
	}, [])
	const runElementMountCallback = React42.useCallback(() => {
		if (typeof cleanupRef.current === 'function') {
			cleanupRef.current()
			cleanupRef.current = null
		}
		if (reference.current && floating.current) {
			if (whileElementsMountedRef.current) {
				const cleanupFn = whileElementsMountedRef.current(
					reference.current,
					floating.current,
					update
				)
				cleanupRef.current = cleanupFn
			} else {
				update()
			}
		}
	}, [update, whileElementsMountedRef])
	const setReference = React42.useCallback(
		(node) => {
			reference.current = node
			runElementMountCallback()
		},
		[runElementMountCallback]
	)
	const setFloating = React42.useCallback(
		(node) => {
			floating.current = node
			runElementMountCallback()
		},
		[runElementMountCallback]
	)
	const refs = React42.useMemo(
		() => ({
			reference,
			floating,
		}),
		[]
	)
	return React42.useMemo(
		() => ({
			...data,
			update,
			refs,
			reference: setReference,
			floating: setFloating,
		}),
		[data, update, refs, setReference, setFloating]
	)
}
var arrow = (options) => {
	const { element, padding } = options
	function isRef(value) {
		return Object.prototype.hasOwnProperty.call(value, 'current')
	}
	return {
		name: 'arrow',
		options,
		fn(args) {
			if (isRef(element)) {
				if (element.current != null) {
					return m({
						element: element.current,
						padding,
					}).fn(args)
				}
				return {}
			} else if (element) {
				return m({
					element,
					padding,
				}).fn(args)
			}
			return {}
		},
	}
}

// ../node_modules/@radix-ui/react-use-size/dist/index.module.js
init_define_process()
var import_react63 = __toESM(require_react())
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
	const [size, setSize] = (0, import_react63.useState)(void 0)
	$9f79659886946c16$export$e5c5a5f917a5871c(() => {
		if (element) {
			setSize({
				width: element.offsetWidth,
				height: element.offsetHeight,
			})
			const resizeObserver = new ResizeObserver((entries) => {
				if (!Array.isArray(entries)) return
				if (!entries.length) return
				const entry = entries[0]
				let width
				let height
				if ('borderBoxSize' in entry) {
					const borderSizeEntry = entry['borderBoxSize']
					const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry
					width = borderSize['inlineSize']
					height = borderSize['blockSize']
				} else {
					width = element.offsetWidth
					height = element.offsetHeight
				}
				setSize({
					width,
					height,
				})
			})
			resizeObserver.observe(element, {
				box: 'border-box',
			})
			return () => resizeObserver.unobserve(element)
		} else setSize(void 0)
	}, [element])
	return size
}

// ../node_modules/@radix-ui/react-popper/dist/index.module.js
var $cf1ac5d9fe0e8206$var$POPPER_NAME = 'Popper'
var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME)
var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] =
	$cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME)
var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
	const { __scopePopper, children } = props
	const [anchor, setAnchor] = (0, import_react64.useState)(null)
	return /* @__PURE__ */ (0, import_react64.createElement)(
		$cf1ac5d9fe0e8206$var$PopperProvider,
		{
			scope: __scopePopper,
			anchor,
			onAnchorChange: setAnchor,
		},
		children
	)
}
var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = 'PopperAnchor'
var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react64.forwardRef)(
	(props, forwardedRef) => {
		const { __scopePopper, virtualRef, ...anchorProps } = props
		const context = $cf1ac5d9fe0e8206$var$usePopperContext(
			$cf1ac5d9fe0e8206$var$ANCHOR_NAME,
			__scopePopper
		)
		const ref = (0, import_react64.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		;(0, import_react64.useEffect)(() => {
			context.onAnchorChange(
				(virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current
			)
		})
		return virtualRef
			? null
			: /* @__PURE__ */ (0, import_react64.createElement)(
					$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
					_extends({}, anchorProps, {
						ref: composedRefs,
					})
			  )
	}
)
var $cf1ac5d9fe0e8206$var$CONTENT_NAME = 'PopperContent'
var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] =
	$cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME)
var [$cf1ac5d9fe0e8206$var$PositionContextProvider, $cf1ac5d9fe0e8206$var$usePositionContext] =
	$cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, {
		hasParent: false,
		positionUpdateFns: /* @__PURE__ */ new Set(),
	})
var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react64.forwardRef)(
	(props, forwardedRef) => {
		var _arrowSize$width,
			_arrowSize$height,
			_middlewareData$arrow,
			_middlewareData$arrow2,
			_middlewareData$arrow3,
			_middlewareData$hide,
			_middlewareData$trans,
			_middlewareData$trans2
		const {
			__scopePopper,
			side = 'bottom',
			sideOffset = 0,
			align = 'center',
			alignOffset = 0,
			arrowPadding = 0,
			collisionBoundary = [],
			collisionPadding: collisionPaddingProp = 0,
			sticky = 'partial',
			hideWhenDetached = false,
			avoidCollisions = true,
			onPlaced,
			...contentProps
		} = props
		const context = $cf1ac5d9fe0e8206$var$usePopperContext(
			$cf1ac5d9fe0e8206$var$CONTENT_NAME,
			__scopePopper
		)
		const [content, setContent] = (0, import_react64.useState)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setContent(node)
		)
		const [arrow2, setArrow] = (0, import_react64.useState)(null)
		const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2)
		const arrowWidth =
			(_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !==
				null && _arrowSize$width !== void 0
				? _arrowSize$width
				: 0
		const arrowHeight =
			(_arrowSize$height =
				arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null &&
			_arrowSize$height !== void 0
				? _arrowSize$height
				: 0
		const desiredPlacement = side + (align !== 'center' ? '-' + align : '')
		const collisionPadding =
			typeof collisionPaddingProp === 'number'
				? collisionPaddingProp
				: {
						top: 0,
						right: 0,
						bottom: 0,
						left: 0,
						...collisionPaddingProp,
				  }
		const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary]
		const hasExplicitBoundaries = boundary.length > 0
		const detectOverflowOptions = {
			padding: collisionPadding,
			boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
			// with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
			altBoundary: hasExplicitBoundaries,
		}
		const {
			reference,
			floating,
			strategy,
			x: x3,
			y: y3,
			placement,
			middlewareData,
			update,
		} = useFloating({
			// default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
			strategy: 'fixed',
			placement: desiredPlacement,
			whileElementsMounted: N,
			middleware: [
				$cf1ac5d9fe0e8206$var$anchorCssProperties(),
				T({
					mainAxis: sideOffset + arrowHeight,
					alignmentAxis: alignOffset,
				}),
				avoidCollisions
					? D({
							mainAxis: true,
							crossAxis: false,
							limiter: sticky === 'partial' ? L() : void 0,
							...detectOverflowOptions,
					  })
					: void 0,
				arrow2
					? arrow({
							element: arrow2,
							padding: arrowPadding,
					  })
					: void 0,
				avoidCollisions
					? b({
							...detectOverflowOptions,
					  })
					: void 0,
				k({
					...detectOverflowOptions,
					apply: ({ elements, availableWidth: width, availableHeight: height }) => {
						elements.floating.style.setProperty('--radix-popper-available-width', `${width}px`)
						elements.floating.style.setProperty('--radix-popper-available-height', `${height}px`)
					},
				}),
				$cf1ac5d9fe0e8206$var$transformOrigin({
					arrowWidth,
					arrowHeight,
				}),
				hideWhenDetached
					? P({
							strategy: 'referenceHidden',
					  })
					: void 0,
			].filter($cf1ac5d9fe0e8206$var$isDefined),
		})
		$9f79659886946c16$export$e5c5a5f917a5871c(() => {
			reference(context.anchor)
		}, [reference, context.anchor])
		const isPlaced = x3 !== null && y3 !== null
		const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement)
		const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced)
		$9f79659886946c16$export$e5c5a5f917a5871c(() => {
			if (isPlaced) handlePlaced === null || handlePlaced === void 0 || handlePlaced()
		}, [isPlaced, handlePlaced])
		const arrowX =
			(_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0
				? void 0
				: _middlewareData$arrow.x
		const arrowY =
			(_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0
				? void 0
				: _middlewareData$arrow2.y
		const cannotCenterArrow =
			((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0
				? void 0
				: _middlewareData$arrow3.centerOffset) !== 0
		const [contentZIndex, setContentZIndex] = (0, import_react64.useState)()
		$9f79659886946c16$export$e5c5a5f917a5871c(() => {
			if (content) setContentZIndex(window.getComputedStyle(content).zIndex)
		}, [content])
		const { hasParent, positionUpdateFns } = $cf1ac5d9fe0e8206$var$usePositionContext(
			$cf1ac5d9fe0e8206$var$CONTENT_NAME,
			__scopePopper
		)
		const isRoot = !hasParent
		;(0, import_react64.useLayoutEffect)(() => {
			if (!isRoot) {
				positionUpdateFns.add(update)
				return () => {
					positionUpdateFns.delete(update)
				}
			}
		}, [isRoot, positionUpdateFns, update])
		$9f79659886946c16$export$e5c5a5f917a5871c(() => {
			if (isRoot && isPlaced)
				Array.from(positionUpdateFns)
					.reverse()
					.forEach((fn) => requestAnimationFrame(fn))
		}, [isRoot, isPlaced, positionUpdateFns])
		const commonProps = {
			'data-side': placedSide,
			'data-align': placedAlign,
			...contentProps,
			ref: composedRefs,
			style: {
				...contentProps.style,
				// if the PopperContent hasn't been placed yet (not all measurements done)
				// we prevent animations so that users's animation don't kick in too early referring wrong sides
				animation: !isPlaced ? 'none' : void 0,
				// hide the content if using the hide middleware and should be hidden
				opacity:
					(_middlewareData$hide = middlewareData.hide) !== null &&
					_middlewareData$hide !== void 0 &&
					_middlewareData$hide.referenceHidden
						? 0
						: void 0,
			},
		}
		return /* @__PURE__ */ (0, import_react64.createElement)(
			'div',
			{
				ref: floating,
				'data-radix-popper-content-wrapper': '',
				style: {
					position: strategy,
					left: 0,
					top: 0,
					transform: isPlaced
						? `translate3d(${Math.round(x3)}px, ${Math.round(y3)}px, 0)`
						: 'translate3d(0, -200%, 0)',
					// keep off the page when measuring
					minWidth: 'max-content',
					zIndex: contentZIndex,
					['--radix-popper-transform-origin']: [
						(_middlewareData$trans = middlewareData.transformOrigin) === null ||
						_middlewareData$trans === void 0
							? void 0
							: _middlewareData$trans.x,
						(_middlewareData$trans2 = middlewareData.transformOrigin) === null ||
						_middlewareData$trans2 === void 0
							? void 0
							: _middlewareData$trans2.y,
					].join(' '),
				},
				dir: props.dir,
			},
			/* @__PURE__ */ (0, import_react64.createElement)(
				$cf1ac5d9fe0e8206$var$PopperContentProvider,
				{
					scope: __scopePopper,
					placedSide,
					onArrowChange: setArrow,
					arrowX,
					arrowY,
					shouldHideArrow: cannotCenterArrow,
				},
				isRoot
					? /* @__PURE__ */ (0, import_react64.createElement)(
							$cf1ac5d9fe0e8206$var$PositionContextProvider,
							{
								scope: __scopePopper,
								hasParent: true,
								positionUpdateFns,
							},
							/* @__PURE__ */ (0, import_react64.createElement)(
								$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
								commonProps
							)
					  )
					: /* @__PURE__ */ (0, import_react64.createElement)(
							$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
							commonProps
					  )
			)
		)
	}
)
function $cf1ac5d9fe0e8206$var$isDefined(value) {
	return value !== void 0
}
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
	return value !== null
}
var $cf1ac5d9fe0e8206$var$anchorCssProperties = () => ({
	name: 'anchorCssProperties',
	fn(data) {
		const { rects, elements } = data
		const { width, height } = rects.reference
		elements.floating.style.setProperty('--radix-popper-anchor-width', `${width}px`)
		elements.floating.style.setProperty('--radix-popper-anchor-height', `${height}px`)
		return {}
	},
})
var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
	name: 'transformOrigin',
	options,
	fn(data) {
		var _middlewareData$arrow4,
			_middlewareData$arrow5,
			_middlewareData$arrow6,
			_middlewareData$arrow7,
			_middlewareData$arrow8
		const { placement, rects, middlewareData } = data
		const cannotCenterArrow =
			((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0
				? void 0
				: _middlewareData$arrow4.centerOffset) !== 0
		const isArrowHidden = cannotCenterArrow
		const arrowWidth = isArrowHidden ? 0 : options.arrowWidth
		const arrowHeight = isArrowHidden ? 0 : options.arrowHeight
		const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement)
		const noArrowAlign = {
			start: '0%',
			center: '50%',
			end: '100%',
		}[placedAlign]
		const arrowXCenter =
			((_middlewareData$arrow5 =
				(_middlewareData$arrow6 = middlewareData.arrow) === null ||
				_middlewareData$arrow6 === void 0
					? void 0
					: _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0
				? _middlewareData$arrow5
				: 0) +
			arrowWidth / 2
		const arrowYCenter =
			((_middlewareData$arrow7 =
				(_middlewareData$arrow8 = middlewareData.arrow) === null ||
				_middlewareData$arrow8 === void 0
					? void 0
					: _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0
				? _middlewareData$arrow7
				: 0) +
			arrowHeight / 2
		let x3 = ''
		let y3 = ''
		if (placedSide === 'bottom') {
			x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`
			y3 = `${-arrowHeight}px`
		} else if (placedSide === 'top') {
			x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`
			y3 = `${rects.floating.height + arrowHeight}px`
		} else if (placedSide === 'right') {
			x3 = `${-arrowHeight}px`
			y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`
		} else if (placedSide === 'left') {
			x3 = `${rects.floating.width + arrowHeight}px`
			y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`
		}
		return {
			data: {
				x: x3,
				y: y3,
			},
		}
	},
})
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
	const [side, align = 'center'] = placement.split('-')
	return [side, align]
}
var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9
var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d
var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc

// ../node_modules/@radix-ui/react-roving-focus/dist/index.module.js
init_define_process()
var import_react65 = __toESM(require_react())
var $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus'
var $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
	bubbles: false,
	cancelable: true,
}
var $d7bdfb9eb0fdf311$var$GROUP_NAME = 'RovingFocusGroup'
var [
	$d7bdfb9eb0fdf311$var$Collection,
	$d7bdfb9eb0fdf311$var$useCollection,
	$d7bdfb9eb0fdf311$var$createCollectionScope,
] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME)
var [
	$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext,
	$d7bdfb9eb0fdf311$export$c7109489551a4f4,
] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
	$d7bdfb9eb0fdf311$var$createCollectionScope,
])
var [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] =
	$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME)
var $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ (0, import_react65.forwardRef)(
	(props, forwardedRef) => {
		return /* @__PURE__ */ (0, import_react65.createElement)(
			$d7bdfb9eb0fdf311$var$Collection.Provider,
			{
				scope: props.__scopeRovingFocusGroup,
			},
			/* @__PURE__ */ (0, import_react65.createElement)(
				$d7bdfb9eb0fdf311$var$Collection.Slot,
				{
					scope: props.__scopeRovingFocusGroup,
				},
				/* @__PURE__ */ (0, import_react65.createElement)(
					$d7bdfb9eb0fdf311$var$RovingFocusGroupImpl,
					_extends({}, props, {
						ref: forwardedRef,
					})
				)
			)
		)
	}
)
var $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ (0, import_react65.forwardRef)(
	(props, forwardedRef) => {
		const {
			__scopeRovingFocusGroup,
			orientation,
			loop = false,
			dir,
			currentTabStopId: currentTabStopIdProp,
			defaultCurrentTabStopId,
			onCurrentTabStopIdChange,
			onEntryFocus,
			...groupProps
		} = props
		const ref = (0, import_react65.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir)
		const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3(
			{
				prop: currentTabStopIdProp,
				defaultProp: defaultCurrentTabStopId,
				onChange: onCurrentTabStopIdChange,
			}
		)
		const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react65.useState)(false)
		const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus)
		const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup)
		const isClickFocusRef = (0, import_react65.useRef)(false)
		const [focusableItemsCount, setFocusableItemsCount] = (0, import_react65.useState)(0)
		;(0, import_react65.useEffect)(() => {
			const node = ref.current
			if (node) {
				node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus)
				return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus)
			}
		}, [handleEntryFocus])
		return /* @__PURE__ */ (0, import_react65.createElement)(
			$d7bdfb9eb0fdf311$var$RovingFocusProvider,
			{
				scope: __scopeRovingFocusGroup,
				orientation,
				dir: direction,
				loop,
				currentTabStopId,
				onItemFocus: (0, import_react65.useCallback)(
					(tabStopId) => setCurrentTabStopId(tabStopId),
					[setCurrentTabStopId]
				),
				onItemShiftTab: (0, import_react65.useCallback)(() => setIsTabbingBackOut(true), []),
				onFocusableItemAdd: (0, import_react65.useCallback)(
					() => setFocusableItemsCount((prevCount) => prevCount + 1),
					[]
				),
				onFocusableItemRemove: (0, import_react65.useCallback)(
					() => setFocusableItemsCount((prevCount) => prevCount - 1),
					[]
				),
			},
			/* @__PURE__ */ (0, import_react65.createElement)(
				$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
				_extends(
					{
						tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
						'data-orientation': orientation,
					},
					groupProps,
					{
						ref: composedRefs,
						style: {
							outline: 'none',
							...props.style,
						},
						onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
							isClickFocusRef.current = true
						}),
						onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
							const isKeyboardFocus = !isClickFocusRef.current
							if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
								const entryFocusEvent = new CustomEvent(
									$d7bdfb9eb0fdf311$var$ENTRY_FOCUS,
									$d7bdfb9eb0fdf311$var$EVENT_OPTIONS
								)
								event.currentTarget.dispatchEvent(entryFocusEvent)
								if (!entryFocusEvent.defaultPrevented) {
									const items = getItems().filter((item) => item.focusable)
									const activeItem = items.find((item) => item.active)
									const currentItem = items.find((item) => item.id === currentTabStopId)
									const candidateItems = [activeItem, currentItem, ...items].filter(Boolean)
									const candidateNodes = candidateItems.map((item) => item.ref.current)
									$d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
								}
							}
							isClickFocusRef.current = false
						}),
						onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, () =>
							setIsTabbingBackOut(false)
						),
					}
				)
			)
		)
	}
)
var $d7bdfb9eb0fdf311$var$ITEM_NAME = 'RovingFocusGroupItem'
var $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ (0, import_react65.forwardRef)(
	(props, forwardedRef) => {
		const {
			__scopeRovingFocusGroup,
			focusable = true,
			active = false,
			tabStopId,
			...itemProps
		} = props
		const autoId = $1746a345f3d73bb7$export$f680877a34711e37()
		const id = tabStopId || autoId
		const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext(
			$d7bdfb9eb0fdf311$var$ITEM_NAME,
			__scopeRovingFocusGroup
		)
		const isCurrentTabStop = context.currentTabStopId === id
		const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup)
		const { onFocusableItemAdd, onFocusableItemRemove } = context
		;(0, import_react65.useEffect)(() => {
			if (focusable) {
				onFocusableItemAdd()
				return () => onFocusableItemRemove()
			}
		}, [focusable, onFocusableItemAdd, onFocusableItemRemove])
		return /* @__PURE__ */ (0, import_react65.createElement)(
			$d7bdfb9eb0fdf311$var$Collection.ItemSlot,
			{
				scope: __scopeRovingFocusGroup,
				id,
				focusable,
				active,
			},
			/* @__PURE__ */ (0, import_react65.createElement)(
				$8927f6f2acc4f386$export$250ffa63cdc0d034.span,
				_extends(
					{
						tabIndex: isCurrentTabStop ? 0 : -1,
						'data-orientation': context.orientation,
					},
					itemProps,
					{
						ref: forwardedRef,
						onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
							if (!focusable) event.preventDefault()
							else context.onItemFocus(id)
						}),
						onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () =>
							context.onItemFocus(id)
						),
						onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
							if (event.key === 'Tab' && event.shiftKey) {
								context.onItemShiftTab()
								return
							}
							if (event.target !== event.currentTarget) return
							const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(
								event,
								context.orientation,
								context.dir
							)
							if (focusIntent !== void 0) {
								event.preventDefault()
								const items = getItems().filter((item) => item.focusable)
								let candidateNodes = items.map((item) => item.ref.current)
								if (focusIntent === 'last') candidateNodes.reverse()
								else if (focusIntent === 'prev' || focusIntent === 'next') {
									if (focusIntent === 'prev') candidateNodes.reverse()
									const currentIndex = candidateNodes.indexOf(event.currentTarget)
									candidateNodes = context.loop
										? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1)
										: candidateNodes.slice(currentIndex + 1)
								}
								setTimeout(() => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes))
							}
						}),
					}
				)
			)
		)
	}
)
var $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
	ArrowLeft: 'prev',
	ArrowUp: 'prev',
	ArrowRight: 'next',
	ArrowDown: 'next',
	PageUp: 'first',
	Home: 'first',
	PageDown: 'last',
	End: 'last',
}
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
	if (dir !== 'rtl') return key
	return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
	const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir)
	if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return void 0
	if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return void 0
	return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key]
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
	const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement
	for (const candidate of candidates) {
		if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return
		candidate.focus()
		if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return
	}
}
function $d7bdfb9eb0fdf311$var$wrapArray(array2, startIndex) {
	return array2.map((_, index2) => array2[(startIndex + index2) % array2.length])
}
var $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338
var $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454

// ../node_modules/@radix-ui/react-menu/dist/index.module.js
var $6cc32821e9371a1c$var$SELECTION_KEYS = ['Enter', ' ']
var $6cc32821e9371a1c$var$FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home']
var $6cc32821e9371a1c$var$LAST_KEYS = ['ArrowUp', 'PageDown', 'End']
var $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [
	...$6cc32821e9371a1c$var$FIRST_KEYS,
	...$6cc32821e9371a1c$var$LAST_KEYS,
]
var $6cc32821e9371a1c$var$SUB_OPEN_KEYS = {
	ltr: [...$6cc32821e9371a1c$var$SELECTION_KEYS, 'ArrowRight'],
	rtl: [...$6cc32821e9371a1c$var$SELECTION_KEYS, 'ArrowLeft'],
}
var $6cc32821e9371a1c$var$SUB_CLOSE_KEYS = {
	ltr: ['ArrowLeft'],
	rtl: ['ArrowRight'],
}
var $6cc32821e9371a1c$var$MENU_NAME = 'Menu'
var [
	$6cc32821e9371a1c$var$Collection,
	$6cc32821e9371a1c$var$useCollection,
	$6cc32821e9371a1c$var$createCollectionScope,
] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME)
var [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [
		$6cc32821e9371a1c$var$createCollectionScope,
		$cf1ac5d9fe0e8206$export$722aac194ae923,
		$d7bdfb9eb0fdf311$export$c7109489551a4f4,
	])
var $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923()
var $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4()
var [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] =
	$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME)
var [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] =
	$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME)
var $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props) => {
	const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props
	const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu)
	const [content, setContent] = (0, import_react66.useState)(null)
	const isUsingKeyboardRef = (0, import_react66.useRef)(false)
	const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange)
	const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir)
	;(0, import_react66.useEffect)(() => {
		const handleKeyDown = () => {
			isUsingKeyboardRef.current = true
			document.addEventListener('pointerdown', handlePointer, {
				capture: true,
				once: true,
			})
			document.addEventListener('pointermove', handlePointer, {
				capture: true,
				once: true,
			})
		}
		const handlePointer = () => (isUsingKeyboardRef.current = false)
		document.addEventListener('keydown', handleKeyDown, {
			capture: true,
		})
		return () => {
			document.removeEventListener('keydown', handleKeyDown, {
				capture: true,
			})
			document.removeEventListener('pointerdown', handlePointer, {
				capture: true,
			})
			document.removeEventListener('pointermove', handlePointer, {
				capture: true,
			})
		}
	}, [])
	return /* @__PURE__ */ (0, import_react66.createElement)(
		$cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9,
		popperScope,
		/* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$MenuProvider,
			{
				scope: __scopeMenu,
				open,
				onOpenChange: handleOpenChange,
				content,
				onContentChange: setContent,
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				$6cc32821e9371a1c$var$MenuRootProvider,
				{
					scope: __scopeMenu,
					onClose: (0, import_react66.useCallback)(
						() => handleOpenChange(false),
						[handleOpenChange]
					),
					isUsingKeyboardRef,
					dir: direction,
					modal,
				},
				children
			)
		)
	)
}
var $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeMenu, ...anchorProps } = props
		const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu)
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$cf1ac5d9fe0e8206$export$b688253958b8dfe7,
			_extends({}, popperScope, anchorProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $6cc32821e9371a1c$var$PORTAL_NAME = 'MenuPortal'
var [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] =
	$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {
		forceMount: void 0,
	})
var $6cc32821e9371a1c$export$793392f970497feb = (props) => {
	const { __scopeMenu, forceMount, children, container } = props
	const context = $6cc32821e9371a1c$var$useMenuContext(
		$6cc32821e9371a1c$var$PORTAL_NAME,
		__scopeMenu
	)
	return /* @__PURE__ */ (0, import_react66.createElement)(
		$6cc32821e9371a1c$var$PortalProvider,
		{
			scope: __scopeMenu,
			forceMount,
		},
		/* @__PURE__ */ (0, import_react66.createElement)(
			$921a889cee6df7e8$export$99c2b779aa4e8b8b,
			{
				present: forceMount || context.open,
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				$f1701beae083dbae$export$602eac185826482c,
				{
					asChild: true,
					container,
				},
				children
			)
		)
	)
}
var $6cc32821e9371a1c$var$CONTENT_NAME = 'MenuContent'
var [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] =
	$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME)
var $6cc32821e9371a1c$export$479f0f2f71193efe = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const portalContext = $6cc32821e9371a1c$var$usePortalContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			props.__scopeMenu
		)
		const { forceMount = portalContext.forceMount, ...contentProps } = props
		const context = $6cc32821e9371a1c$var$useMenuContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			props.__scopeMenu
		)
		const rootContext = $6cc32821e9371a1c$var$useMenuRootContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			props.__scopeMenu
		)
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$Collection.Provider,
			{
				scope: props.__scopeMenu,
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				$921a889cee6df7e8$export$99c2b779aa4e8b8b,
				{
					present: forceMount || context.open,
				},
				/* @__PURE__ */ (0, import_react66.createElement)(
					$6cc32821e9371a1c$var$Collection.Slot,
					{
						scope: props.__scopeMenu,
					},
					rootContext.modal
						? /* @__PURE__ */ (0, import_react66.createElement)(
								$6cc32821e9371a1c$var$MenuRootContentModal,
								_extends({}, contentProps, {
									ref: forwardedRef,
								})
						  )
						: /* @__PURE__ */ (0, import_react66.createElement)(
								$6cc32821e9371a1c$var$MenuRootContentNonModal,
								_extends({}, contentProps, {
									ref: forwardedRef,
								})
						  )
				)
			)
		)
	}
)
var $6cc32821e9371a1c$var$MenuRootContentModal = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const context = $6cc32821e9371a1c$var$useMenuContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			props.__scopeMenu
		)
		const ref = (0, import_react66.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		;(0, import_react66.useEffect)(() => {
			const content = ref.current
			if (content) return hideOthers(content)
		}, [])
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$MenuContentImpl,
			_extends({}, props, {
				ref: composedRefs,
				trapFocus: context.open,
				disableOutsidePointerEvents: context.open,
				disableOutsideScroll: true,
				onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
					props.onFocusOutside,
					(event) => event.preventDefault(),
					{
						checkForDefaultPrevented: false,
					}
				),
				onDismiss: () => context.onOpenChange(false),
			})
		)
	}
)
var $6cc32821e9371a1c$var$MenuRootContentNonModal = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const context = $6cc32821e9371a1c$var$useMenuContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			props.__scopeMenu
		)
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$MenuContentImpl,
			_extends({}, props, {
				ref: forwardedRef,
				trapFocus: false,
				disableOutsidePointerEvents: false,
				disableOutsideScroll: false,
				onDismiss: () => context.onOpenChange(false),
			})
		)
	}
)
var $6cc32821e9371a1c$var$MenuContentImpl = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const {
			__scopeMenu,
			loop = false,
			trapFocus,
			onOpenAutoFocus,
			onCloseAutoFocus,
			disableOutsidePointerEvents,
			onEntryFocus,
			onEscapeKeyDown,
			onPointerDownOutside,
			onFocusOutside,
			onInteractOutside,
			onDismiss,
			disableOutsideScroll,
			...contentProps
		} = props
		const context = $6cc32821e9371a1c$var$useMenuContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			__scopeMenu
		)
		const rootContext = $6cc32821e9371a1c$var$useMenuRootContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			__scopeMenu
		)
		const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu)
		const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu)
		const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu)
		const [currentItemId, setCurrentItemId] = (0, import_react66.useState)(null)
		const contentRef = (0, import_react66.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
			forwardedRef,
			contentRef,
			context.onContentChange
		)
		const timerRef = (0, import_react66.useRef)(0)
		const searchRef = (0, import_react66.useRef)('')
		const pointerGraceTimerRef = (0, import_react66.useRef)(0)
		const pointerGraceIntentRef = (0, import_react66.useRef)(null)
		const pointerDirRef = (0, import_react66.useRef)('right')
		const lastPointerXRef = (0, import_react66.useRef)(0)
		const ScrollLockWrapper = disableOutsideScroll ? Combination_default : import_react66.Fragment
		const scrollLockWrapperProps = disableOutsideScroll
			? {
					as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
					allowPinchZoom: true,
			  }
			: void 0
		const handleTypeaheadSearch = (key) => {
			var _items$find, _items$find2
			const search = searchRef.current + key
			const items = getItems().filter((item) => !item.disabled)
			const currentItem = document.activeElement
			const currentMatch =
				(_items$find = items.find((item) => item.ref.current === currentItem)) === null ||
				_items$find === void 0
					? void 0
					: _items$find.textValue
			const values = items.map((item) => item.textValue)
			const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch)
			const newItem =
				(_items$find2 = items.find((item) => item.textValue === nextMatch)) === null ||
				_items$find2 === void 0
					? void 0
					: _items$find2.ref.current
			;(function updateSearch(value) {
				searchRef.current = value
				window.clearTimeout(timerRef.current)
				if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1e3)
			})(search)
			if (newItem) setTimeout(() => newItem.focus())
		}
		;(0, import_react66.useEffect)(() => {
			return () => window.clearTimeout(timerRef.current)
		}, [])
		$3db38b7d1fb3fe6a$export$b7ece24a22aeda8c()
		const isPointerMovingToSubmenu = (0, import_react66.useCallback)((event) => {
			var _pointerGraceIntentRe, _pointerGraceIntentRe2
			const isMovingTowards =
				pointerDirRef.current ===
				((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null ||
				_pointerGraceIntentRe === void 0
					? void 0
					: _pointerGraceIntentRe.side)
			return (
				isMovingTowards &&
				$6cc32821e9371a1c$var$isPointerInGraceArea(
					event,
					(_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null ||
						_pointerGraceIntentRe2 === void 0
						? void 0
						: _pointerGraceIntentRe2.area
				)
			)
		}, [])
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$MenuContentProvider,
			{
				scope: __scopeMenu,
				searchRef,
				onItemEnter: (0, import_react66.useCallback)(
					(event) => {
						if (isPointerMovingToSubmenu(event)) event.preventDefault()
					},
					[isPointerMovingToSubmenu]
				),
				onItemLeave: (0, import_react66.useCallback)(
					(event) => {
						var _contentRef$current
						if (isPointerMovingToSubmenu(event)) return
						;(_contentRef$current = contentRef.current) === null ||
							_contentRef$current === void 0 ||
							_contentRef$current.focus()
						setCurrentItemId(null)
					},
					[isPointerMovingToSubmenu]
				),
				onTriggerLeave: (0, import_react66.useCallback)(
					(event) => {
						if (isPointerMovingToSubmenu(event)) event.preventDefault()
					},
					[isPointerMovingToSubmenu]
				),
				pointerGraceTimerRef,
				onPointerGraceIntentChange: (0, import_react66.useCallback)((intent) => {
					pointerGraceIntentRef.current = intent
				}, []),
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				ScrollLockWrapper,
				scrollLockWrapperProps,
				/* @__PURE__ */ (0, import_react66.createElement)(
					$d3863c46a17e8a28$export$20e40289641fbbb6,
					{
						asChild: true,
						trapped: trapFocus,
						onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
							onOpenAutoFocus,
							(event) => {
								var _contentRef$current2
								event.preventDefault()
								;(_contentRef$current2 = contentRef.current) === null ||
									_contentRef$current2 === void 0 ||
									_contentRef$current2.focus()
							}
						),
						onUnmountAutoFocus: onCloseAutoFocus,
					},
					/* @__PURE__ */ (0, import_react66.createElement)(
						$5cb92bef7577960e$export$177fb62ff3ec1f22,
						{
							asChild: true,
							disableOutsidePointerEvents,
							onEscapeKeyDown,
							onPointerDownOutside,
							onFocusOutside,
							onInteractOutside,
							onDismiss,
						},
						/* @__PURE__ */ (0, import_react66.createElement)(
							$d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9,
							_extends(
								{
									asChild: true,
								},
								rovingFocusGroupScope,
								{
									dir: rootContext.dir,
									orientation: 'vertical',
									loop,
									currentTabStopId: currentItemId,
									onCurrentTabStopIdChange: setCurrentItemId,
									onEntryFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEntryFocus, (event) => {
										if (!rootContext.isUsingKeyboardRef.current) event.preventDefault()
									}),
								}
							),
							/* @__PURE__ */ (0, import_react66.createElement)(
								$cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2,
								_extends(
									{
										role: 'menu',
										'aria-orientation': 'vertical',
										'data-state': $6cc32821e9371a1c$var$getOpenState(context.open),
										'data-radix-menu-content': '',
										dir: rootContext.dir,
									},
									popperScope,
									contentProps,
									{
										ref: composedRefs,
										style: {
											outline: 'none',
											...contentProps.style,
										},
										onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
											contentProps.onKeyDown,
											(event) => {
												const target = event.target
												const isKeyDownInside =
													target.closest('[data-radix-menu-content]') === event.currentTarget
												const isModifierKey = event.ctrlKey || event.altKey || event.metaKey
												const isCharacterKey = event.key.length === 1
												if (isKeyDownInside) {
													if (event.key === 'Tab') event.preventDefault()
													if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key)
												}
												const content = contentRef.current
												if (event.target !== content) return
												if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key)) return
												event.preventDefault()
												const items = getItems().filter((item) => !item.disabled)
												const candidateNodes = items.map((item) => item.ref.current)
												if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key))
													candidateNodes.reverse()
												$6cc32821e9371a1c$var$focusFirst(candidateNodes)
											}
										),
										onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {
											if (!event.currentTarget.contains(event.target)) {
												window.clearTimeout(timerRef.current)
												searchRef.current = ''
											}
										}),
										onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
											props.onPointerMove,
											$6cc32821e9371a1c$var$whenMouse((event) => {
												const target = event.target
												const pointerXHasChanged = lastPointerXRef.current !== event.clientX
												if (event.currentTarget.contains(target) && pointerXHasChanged) {
													const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left'
													pointerDirRef.current = newDir
													lastPointerXRef.current = event.clientX
												}
											})
										),
									}
								)
							)
						)
					)
				)
			)
		)
	}
)
var $6cc32821e9371a1c$export$22a631d1f72787bb = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeMenu, ...groupProps } = props
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
			_extends(
				{
					role: 'group',
				},
				groupProps,
				{
					ref: forwardedRef,
				}
			)
		)
	}
)
var $6cc32821e9371a1c$var$ITEM_NAME = 'MenuItem'
var $6cc32821e9371a1c$var$ITEM_SELECT = 'menu.itemSelect'
var $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const { disabled = false, onSelect, ...itemProps } = props
		const ref = (0, import_react66.useRef)(null)
		const rootContext = $6cc32821e9371a1c$var$useMenuRootContext(
			$6cc32821e9371a1c$var$ITEM_NAME,
			props.__scopeMenu
		)
		const contentContext = $6cc32821e9371a1c$var$useMenuContentContext(
			$6cc32821e9371a1c$var$ITEM_NAME,
			props.__scopeMenu
		)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		const isPointerDownRef = (0, import_react66.useRef)(false)
		const handleSelect = () => {
			const menuItem2 = ref.current
			if (!disabled && menuItem2) {
				const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {
					bubbles: true,
					cancelable: true,
				})
				menuItem2.addEventListener(
					$6cc32821e9371a1c$var$ITEM_SELECT,
					(event) => (onSelect === null || onSelect === void 0 ? void 0 : onSelect(event)),
					{
						once: true,
					}
				)
				$8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem2, itemSelectEvent)
				if (itemSelectEvent.defaultPrevented) isPointerDownRef.current = false
				else rootContext.onClose()
			}
		}
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$MenuItemImpl,
			_extends({}, itemProps, {
				ref: composedRefs,
				disabled,
				onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),
				onPointerDown: (event) => {
					var _props$onPointerDown
					;(_props$onPointerDown = props.onPointerDown) === null ||
						_props$onPointerDown === void 0 ||
						_props$onPointerDown.call(props, event)
					isPointerDownRef.current = true
				},
				onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
					var _event$currentTarget
					if (!isPointerDownRef.current)
						(_event$currentTarget = event.currentTarget) === null ||
							_event$currentTarget === void 0 ||
							_event$currentTarget.click()
				}),
				onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
					const isTypingAhead = contentContext.searchRef.current !== ''
					if (disabled || (isTypingAhead && event.key === ' ')) return
					if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {
						event.currentTarget.click()
						event.preventDefault()
					}
				}),
			})
		)
	}
)
var $6cc32821e9371a1c$var$MenuItemImpl = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeMenu, disabled = false, textValue, ...itemProps } = props
		const contentContext = $6cc32821e9371a1c$var$useMenuContentContext(
			$6cc32821e9371a1c$var$ITEM_NAME,
			__scopeMenu
		)
		const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu)
		const ref = (0, import_react66.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		const [isFocused, setIsFocused] = (0, import_react66.useState)(false)
		const [textContent, setTextContent] = (0, import_react66.useState)('')
		;(0, import_react66.useEffect)(() => {
			const menuItem2 = ref.current
			if (menuItem2) {
				var _menuItem$textContent
				setTextContent(
					((_menuItem$textContent = menuItem2.textContent) !== null &&
					_menuItem$textContent !== void 0
						? _menuItem$textContent
						: ''
					).trim()
				)
			}
		}, [itemProps.children])
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$Collection.ItemSlot,
			{
				scope: __scopeMenu,
				disabled,
				textValue: textValue !== null && textValue !== void 0 ? textValue : textContent,
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				$d7bdfb9eb0fdf311$export$6d08773d2e66f8f2,
				_extends(
					{
						asChild: true,
					},
					rovingFocusGroupScope,
					{
						focusable: !disabled,
					}
				),
				/* @__PURE__ */ (0, import_react66.createElement)(
					$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
					_extends(
						{
							role: 'menuitem',
							'data-highlighted': isFocused ? '' : void 0,
							'aria-disabled': disabled || void 0,
							'data-disabled': disabled ? '' : void 0,
						},
						itemProps,
						{
							ref: composedRefs,
							onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
								props.onPointerMove,
								$6cc32821e9371a1c$var$whenMouse((event) => {
									if (disabled) contentContext.onItemLeave(event)
									else {
										contentContext.onItemEnter(event)
										if (!event.defaultPrevented) {
											const item = event.currentTarget
											item.focus()
										}
									}
								})
							),
							onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
								props.onPointerLeave,
								$6cc32821e9371a1c$var$whenMouse((event) => contentContext.onItemLeave(event))
							),
							onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () =>
								setIsFocused(true)
							),
							onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, () =>
								setIsFocused(false)
							),
						}
					)
				)
			)
		)
	}
)
var $6cc32821e9371a1c$export$f6f243521332502d = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const { checked = false, onCheckedChange, ...checkboxItemProps } = props
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$ItemIndicatorProvider,
			{
				scope: props.__scopeMenu,
				checked,
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				$6cc32821e9371a1c$export$2ce376c2cc3355c8,
				_extends(
					{
						role: 'menuitemcheckbox',
						'aria-checked': $6cc32821e9371a1c$var$isIndeterminate(checked) ? 'mixed' : checked,
					},
					checkboxItemProps,
					{
						ref: forwardedRef,
						'data-state': $6cc32821e9371a1c$var$getCheckedState(checked),
						onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
							checkboxItemProps.onSelect,
							() =>
								onCheckedChange === null || onCheckedChange === void 0
									? void 0
									: onCheckedChange(
											$6cc32821e9371a1c$var$isIndeterminate(checked) ? true : !checked
									  ),
							{
								checkForDefaultPrevented: false,
							}
						),
					}
				)
			)
		)
	}
)
var $6cc32821e9371a1c$var$RADIO_GROUP_NAME = 'MenuRadioGroup'
var [$6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext] =
	$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {
		value: void 0,
		onValueChange: () => {},
	})
var $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = 'MenuItemIndicator'
var [$6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext] =
	$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {
		checked: false,
	})
var $6cc32821e9371a1c$export$a2593e23056970a3 = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeMenu, forceMount, ...itemIndicatorProps } = props
		const indicatorContext = $6cc32821e9371a1c$var$useItemIndicatorContext(
			$6cc32821e9371a1c$var$ITEM_INDICATOR_NAME,
			__scopeMenu
		)
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$921a889cee6df7e8$export$99c2b779aa4e8b8b,
			{
				present:
					forceMount ||
					$6cc32821e9371a1c$var$isIndeterminate(indicatorContext.checked) ||
					indicatorContext.checked === true,
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				$8927f6f2acc4f386$export$250ffa63cdc0d034.span,
				_extends({}, itemIndicatorProps, {
					ref: forwardedRef,
					'data-state': $6cc32821e9371a1c$var$getCheckedState(indicatorContext.checked),
				})
			)
		)
	}
)
var $6cc32821e9371a1c$var$SUB_NAME = 'MenuSub'
var [$6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext] =
	$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME)
var $6cc32821e9371a1c$export$71bdb9d1e2909932 = (props) => {
	const { __scopeMenu, children, open = false, onOpenChange } = props
	const parentMenuContext = $6cc32821e9371a1c$var$useMenuContext(
		$6cc32821e9371a1c$var$SUB_NAME,
		__scopeMenu
	)
	const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu)
	const [trigger2, setTrigger] = (0, import_react66.useState)(null)
	const [content, setContent] = (0, import_react66.useState)(null)
	const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange)
	;(0, import_react66.useEffect)(() => {
		if (parentMenuContext.open === false) handleOpenChange(false)
		return () => handleOpenChange(false)
	}, [parentMenuContext.open, handleOpenChange])
	return /* @__PURE__ */ (0, import_react66.createElement)(
		$cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9,
		popperScope,
		/* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$MenuProvider,
			{
				scope: __scopeMenu,
				open,
				onOpenChange: handleOpenChange,
				content,
				onContentChange: setContent,
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				$6cc32821e9371a1c$var$MenuSubProvider,
				{
					scope: __scopeMenu,
					contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
					triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
					trigger: trigger2,
					onTriggerChange: setTrigger,
				},
				children
			)
		)
	)
}
var $6cc32821e9371a1c$var$SUB_TRIGGER_NAME = 'MenuSubTrigger'
var $6cc32821e9371a1c$export$5fbbb3ba7297405f = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const context = $6cc32821e9371a1c$var$useMenuContext(
			$6cc32821e9371a1c$var$SUB_TRIGGER_NAME,
			props.__scopeMenu
		)
		const rootContext = $6cc32821e9371a1c$var$useMenuRootContext(
			$6cc32821e9371a1c$var$SUB_TRIGGER_NAME,
			props.__scopeMenu
		)
		const subContext = $6cc32821e9371a1c$var$useMenuSubContext(
			$6cc32821e9371a1c$var$SUB_TRIGGER_NAME,
			props.__scopeMenu
		)
		const contentContext = $6cc32821e9371a1c$var$useMenuContentContext(
			$6cc32821e9371a1c$var$SUB_TRIGGER_NAME,
			props.__scopeMenu
		)
		const openTimerRef = (0, import_react66.useRef)(null)
		const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext
		const scope = {
			__scopeMenu: props.__scopeMenu,
		}
		const clearOpenTimer = (0, import_react66.useCallback)(() => {
			if (openTimerRef.current) window.clearTimeout(openTimerRef.current)
			openTimerRef.current = null
		}, [])
		;(0, import_react66.useEffect)(() => clearOpenTimer, [clearOpenTimer])
		;(0, import_react66.useEffect)(() => {
			const pointerGraceTimer = pointerGraceTimerRef.current
			return () => {
				window.clearTimeout(pointerGraceTimer)
				onPointerGraceIntentChange(null)
			}
		}, [pointerGraceTimerRef, onPointerGraceIntentChange])
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$export$9fa5ebd18bee4d43,
			_extends(
				{
					asChild: true,
				},
				scope
			),
			/* @__PURE__ */ (0, import_react66.createElement)(
				$6cc32821e9371a1c$var$MenuItemImpl,
				_extends(
					{
						id: subContext.triggerId,
						'aria-haspopup': 'menu',
						'aria-expanded': context.open,
						'aria-controls': subContext.contentId,
						'data-state': $6cc32821e9371a1c$var$getOpenState(context.open),
					},
					props,
					{
						ref: $6ed0406888f73fc4$export$43e446d32b3d21af(
							forwardedRef,
							subContext.onTriggerChange
						),
						onClick: (event) => {
							var _props$onClick
							;(_props$onClick = props.onClick) === null ||
								_props$onClick === void 0 ||
								_props$onClick.call(props, event)
							if (props.disabled || event.defaultPrevented) return
							event.currentTarget.focus()
							if (!context.open) context.onOpenChange(true)
						},
						onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
							props.onPointerMove,
							$6cc32821e9371a1c$var$whenMouse((event) => {
								contentContext.onItemEnter(event)
								if (event.defaultPrevented) return
								if (!props.disabled && !context.open && !openTimerRef.current) {
									contentContext.onPointerGraceIntentChange(null)
									openTimerRef.current = window.setTimeout(() => {
										context.onOpenChange(true)
										clearOpenTimer()
									}, 100)
								}
							})
						),
						onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
							props.onPointerLeave,
							$6cc32821e9371a1c$var$whenMouse((event) => {
								var _context$content
								clearOpenTimer()
								const contentRect =
									(_context$content = context.content) === null || _context$content === void 0
										? void 0
										: _context$content.getBoundingClientRect()
								if (contentRect) {
									var _context$content2
									const side =
										(_context$content2 = context.content) === null || _context$content2 === void 0
											? void 0
											: _context$content2.dataset.side
									const rightSide = side === 'right'
									const bleed = rightSide ? -5 : 5
									const contentNearEdge = contentRect[rightSide ? 'left' : 'right']
									const contentFarEdge = contentRect[rightSide ? 'right' : 'left']
									contentContext.onPointerGraceIntentChange({
										area: [
											// consistently within polygon bounds
											{
												x: event.clientX + bleed,
												y: event.clientY,
											},
											{
												x: contentNearEdge,
												y: contentRect.top,
											},
											{
												x: contentFarEdge,
												y: contentRect.top,
											},
											{
												x: contentFarEdge,
												y: contentRect.bottom,
											},
											{
												x: contentNearEdge,
												y: contentRect.bottom,
											},
										],
										side,
									})
									window.clearTimeout(pointerGraceTimerRef.current)
									pointerGraceTimerRef.current = window.setTimeout(
										() => contentContext.onPointerGraceIntentChange(null),
										300
									)
								} else {
									contentContext.onTriggerLeave(event)
									if (event.defaultPrevented) return
									contentContext.onPointerGraceIntentChange(null)
								}
							})
						),
						onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
							const isTypingAhead = contentContext.searchRef.current !== ''
							if (props.disabled || (isTypingAhead && event.key === ' ')) return
							if ($6cc32821e9371a1c$var$SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
								var _context$content3
								context.onOpenChange(true)
								;(_context$content3 = context.content) === null ||
									_context$content3 === void 0 ||
									_context$content3.focus()
								event.preventDefault()
							}
						}),
					}
				)
			)
		)
	}
)
var $6cc32821e9371a1c$var$SUB_CONTENT_NAME = 'MenuSubContent'
var $6cc32821e9371a1c$export$e7142ab31822bde6 = /* @__PURE__ */ (0, import_react66.forwardRef)(
	(props, forwardedRef) => {
		const portalContext = $6cc32821e9371a1c$var$usePortalContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			props.__scopeMenu
		)
		const { forceMount = portalContext.forceMount, ...subContentProps } = props
		const context = $6cc32821e9371a1c$var$useMenuContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			props.__scopeMenu
		)
		const rootContext = $6cc32821e9371a1c$var$useMenuRootContext(
			$6cc32821e9371a1c$var$CONTENT_NAME,
			props.__scopeMenu
		)
		const subContext = $6cc32821e9371a1c$var$useMenuSubContext(
			$6cc32821e9371a1c$var$SUB_CONTENT_NAME,
			props.__scopeMenu
		)
		const ref = (0, import_react66.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		return /* @__PURE__ */ (0, import_react66.createElement)(
			$6cc32821e9371a1c$var$Collection.Provider,
			{
				scope: props.__scopeMenu,
			},
			/* @__PURE__ */ (0, import_react66.createElement)(
				$921a889cee6df7e8$export$99c2b779aa4e8b8b,
				{
					present: forceMount || context.open,
				},
				/* @__PURE__ */ (0, import_react66.createElement)(
					$6cc32821e9371a1c$var$Collection.Slot,
					{
						scope: props.__scopeMenu,
					},
					/* @__PURE__ */ (0, import_react66.createElement)(
						$6cc32821e9371a1c$var$MenuContentImpl,
						_extends(
							{
								id: subContext.contentId,
								'aria-labelledby': subContext.triggerId,
							},
							subContentProps,
							{
								ref: composedRefs,
								align: 'start',
								side: rootContext.dir === 'rtl' ? 'left' : 'right',
								disableOutsidePointerEvents: false,
								disableOutsideScroll: false,
								trapFocus: false,
								onOpenAutoFocus: (event) => {
									var _ref$current
									if (rootContext.isUsingKeyboardRef.current)
										(_ref$current = ref.current) === null ||
											_ref$current === void 0 ||
											_ref$current.focus()
									event.preventDefault()
								},
								onCloseAutoFocus: (event) => event.preventDefault(),
								onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
									props.onFocusOutside,
									(event) => {
										if (event.target !== subContext.trigger) context.onOpenChange(false)
									}
								),
								onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
									props.onEscapeKeyDown,
									(event) => {
										rootContext.onClose()
										event.preventDefault()
									}
								),
								onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
									const isKeyDownInside = event.currentTarget.contains(event.target)
									const isCloseKey = $6cc32821e9371a1c$var$SUB_CLOSE_KEYS[rootContext.dir].includes(
										event.key
									)
									if (isKeyDownInside && isCloseKey) {
										var _subContext$trigger
										context.onOpenChange(false)
										;(_subContext$trigger = subContext.trigger) === null ||
											_subContext$trigger === void 0 ||
											_subContext$trigger.focus()
										event.preventDefault()
									}
								}),
							}
						)
					)
				)
			)
		)
	}
)
function $6cc32821e9371a1c$var$getOpenState(open) {
	return open ? 'open' : 'closed'
}
function $6cc32821e9371a1c$var$isIndeterminate(checked) {
	return checked === 'indeterminate'
}
function $6cc32821e9371a1c$var$getCheckedState(checked) {
	return $6cc32821e9371a1c$var$isIndeterminate(checked)
		? 'indeterminate'
		: checked
		? 'checked'
		: 'unchecked'
}
function $6cc32821e9371a1c$var$focusFirst(candidates) {
	const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement
	for (const candidate of candidates) {
		if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return
		candidate.focus()
		if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return
	}
}
function $6cc32821e9371a1c$var$wrapArray(array2, startIndex) {
	return array2.map((_, index2) => array2[(startIndex + index2) % array2.length])
}
function $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {
	const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])
	const normalizedSearch = isRepeated ? search[0] : search
	const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1
	let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0))
	const excludeCurrentMatch = normalizedSearch.length === 1
	if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v3) => v3 !== currentMatch)
	const nextMatch = wrappedValues.find((value) =>
		value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
	)
	return nextMatch !== currentMatch ? nextMatch : void 0
}
function $6cc32821e9371a1c$var$isPointInPolygon(point2, polygon) {
	const { x: x3, y: y3 } = point2
	let inside = false
	for (let i3 = 0, j = polygon.length - 1; i3 < polygon.length; j = i3++) {
		const xi = polygon[i3].x
		const yi = polygon[i3].y
		const xj = polygon[j].x
		const yj = polygon[j].y
		const intersect = yi > y3 !== yj > y3 && x3 < ((xj - xi) * (y3 - yi)) / (yj - yi) + xi
		if (intersect) inside = !inside
	}
	return inside
}
function $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {
	if (!area) return false
	const cursorPos = {
		x: event.clientX,
		y: event.clientY,
	}
	return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area)
}
function $6cc32821e9371a1c$var$whenMouse(handler) {
	return (event) => (event.pointerType === 'mouse' ? handler(event) : void 0)
}
var $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f
var $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43
var $6cc32821e9371a1c$export$602eac185826482c = $6cc32821e9371a1c$export$793392f970497feb
var $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe
var $6cc32821e9371a1c$export$eb2fcfdbd7ba97d4 = $6cc32821e9371a1c$export$22a631d1f72787bb
var $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8
var $6cc32821e9371a1c$export$16ce288f89fa631c = $6cc32821e9371a1c$export$f6f243521332502d
var $6cc32821e9371a1c$export$c3468e2714d175fa = $6cc32821e9371a1c$export$a2593e23056970a3
var $6cc32821e9371a1c$export$d7a01e11500dfb6f = $6cc32821e9371a1c$export$71bdb9d1e2909932
var $6cc32821e9371a1c$export$2ea8a7a591ac5eac = $6cc32821e9371a1c$export$5fbbb3ba7297405f
var $6cc32821e9371a1c$export$6d4de93b380beddf = $6cc32821e9371a1c$export$e7142ab31822bde6

// ../node_modules/@radix-ui/react-dropdown-menu/dist/index.module.js
var $d08ef79370b62062$var$DROPDOWN_MENU_NAME = 'DropdownMenu'
var [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [
		$6cc32821e9371a1c$export$4027731b685e72eb,
	])
var $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb()
var [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] =
	$d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME)
var $d08ef79370b62062$export$e44a253a59704894 = (props) => {
	const {
		__scopeDropdownMenu,
		children,
		dir,
		open: openProp,
		defaultOpen,
		onOpenChange,
		modal = true,
	} = props
	const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
	const triggerRef = (0, import_react67.useRef)(null)
	const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
		prop: openProp,
		defaultProp: defaultOpen,
		onChange: onOpenChange,
	})
	return /* @__PURE__ */ (0, import_react67.createElement)(
		$d08ef79370b62062$var$DropdownMenuProvider,
		{
			scope: __scopeDropdownMenu,
			triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
			triggerRef,
			contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
			open,
			onOpenChange: setOpen,
			onOpenToggle: (0, import_react67.useCallback)(
				() => setOpen((prevOpen) => !prevOpen),
				[setOpen]
			),
			modal,
		},
		/* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$be92b6f5f03c0fe9,
			_extends({}, menuScope, {
				open,
				onOpenChange: setOpen,
				dir,
				modal,
			}),
			children
		)
	)
}
var $d08ef79370b62062$var$TRIGGER_NAME = 'DropdownMenuTrigger'
var $d08ef79370b62062$export$d2469213b3befba9 = /* @__PURE__ */ (0, import_react67.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props
		const context = $d08ef79370b62062$var$useDropdownMenuContext(
			$d08ef79370b62062$var$TRIGGER_NAME,
			__scopeDropdownMenu
		)
		const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
		return /* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$b688253958b8dfe7,
			_extends(
				{
					asChild: true,
				},
				menuScope
			),
			/* @__PURE__ */ (0, import_react67.createElement)(
				$8927f6f2acc4f386$export$250ffa63cdc0d034.button,
				_extends(
					{
						type: 'button',
						id: context.triggerId,
						'aria-haspopup': 'menu',
						'aria-expanded': context.open,
						'aria-controls': context.open ? context.contentId : void 0,
						'data-state': context.open ? 'open' : 'closed',
						'data-disabled': disabled ? '' : void 0,
						disabled,
					},
					triggerProps,
					{
						ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),
						onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
							props.onPointerDown,
							(event) => {
								if (!disabled && event.button === 0 && event.ctrlKey === false) {
									context.onOpenToggle()
									if (!context.open) event.preventDefault()
								}
							}
						),
						onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
							if (disabled) return
							if (['Enter', ' '].includes(event.key)) context.onOpenToggle()
							if (event.key === 'ArrowDown') context.onOpenChange(true)
							if (['Enter', ' ', 'ArrowDown'].includes(event.key)) event.preventDefault()
						}),
					}
				)
			)
		)
	}
)
var $d08ef79370b62062$export$cd369b4d4d54efc9 = (props) => {
	const { __scopeDropdownMenu, ...portalProps } = props
	const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
	return /* @__PURE__ */ (0, import_react67.createElement)(
		$6cc32821e9371a1c$export$602eac185826482c,
		_extends({}, menuScope, portalProps)
	)
}
var $d08ef79370b62062$var$CONTENT_NAME = 'DropdownMenuContent'
var $d08ef79370b62062$export$6e76d93a37c01248 = /* @__PURE__ */ (0, import_react67.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDropdownMenu, ...contentProps } = props
		const context = $d08ef79370b62062$var$useDropdownMenuContext(
			$d08ef79370b62062$var$CONTENT_NAME,
			__scopeDropdownMenu
		)
		const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
		const hasInteractedOutsideRef = (0, import_react67.useRef)(false)
		return /* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$7c6e2c02157bb7d2,
			_extends(
				{
					id: context.contentId,
					'aria-labelledby': context.triggerId,
				},
				menuScope,
				contentProps,
				{
					ref: forwardedRef,
					onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
						props.onCloseAutoFocus,
						(event) => {
							var _context$triggerRef$c
							if (!hasInteractedOutsideRef.current)
								(_context$triggerRef$c = context.triggerRef.current) === null ||
									_context$triggerRef$c === void 0 ||
									_context$triggerRef$c.focus()
							hasInteractedOutsideRef.current = false
							event.preventDefault()
						}
					),
					onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
						props.onInteractOutside,
						(event) => {
							const originalEvent = event.detail.originalEvent
							const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true
							const isRightClick = originalEvent.button === 2 || ctrlLeftClick
							if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true
						}
					),
					style: {
						...props.style,
						'--radix-dropdown-menu-content-transform-origin':
							'var(--radix-popper-transform-origin)',
						'--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',
						'--radix-dropdown-menu-content-available-height':
							'var(--radix-popper-available-height)',
						'--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',
						'--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',
					},
				}
			)
		)
	}
)
var $d08ef79370b62062$export$246bebaba3a2f70e = /* @__PURE__ */ (0, import_react67.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDropdownMenu, ...groupProps } = props
		const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
		return /* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$eb2fcfdbd7ba97d4,
			_extends({}, menuScope, groupProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $d08ef79370b62062$export$ed97964d1871885d = /* @__PURE__ */ (0, import_react67.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDropdownMenu, ...itemProps } = props
		const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
		return /* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$6d08773d2e66f8f2,
			_extends({}, menuScope, itemProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $d08ef79370b62062$export$53a69729da201fa9 = /* @__PURE__ */ (0, import_react67.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDropdownMenu, ...checkboxItemProps } = props
		const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
		return /* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$16ce288f89fa631c,
			_extends({}, menuScope, checkboxItemProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $d08ef79370b62062$export$42355ae145153fb6 = /* @__PURE__ */ (0, import_react67.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDropdownMenu, ...itemIndicatorProps } = props
		const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
		return /* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$c3468e2714d175fa,
			_extends({}, menuScope, itemIndicatorProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $d08ef79370b62062$export$2f307d81a64f5442 = (props) => {
	const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props
	const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
	const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
		prop: openProp,
		defaultProp: defaultOpen,
		onChange: onOpenChange,
	})
	return /* @__PURE__ */ (0, import_react67.createElement)(
		$6cc32821e9371a1c$export$d7a01e11500dfb6f,
		_extends({}, menuScope, {
			open,
			onOpenChange: setOpen,
		}),
		children
	)
}
var $d08ef79370b62062$export$21dcb7ec56f874cf = /* @__PURE__ */ (0, import_react67.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDropdownMenu, ...subTriggerProps } = props
		const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
		return /* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$2ea8a7a591ac5eac,
			_extends({}, menuScope, subTriggerProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $d08ef79370b62062$export$f34ec8bc2482cc5f = /* @__PURE__ */ (0, import_react67.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeDropdownMenu, ...subContentProps } = props
		const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu)
		return /* @__PURE__ */ (0, import_react67.createElement)(
			$6cc32821e9371a1c$export$6d4de93b380beddf,
			_extends({}, menuScope, subContentProps, {
				ref: forwardedRef,
				style: {
					...props.style,
					'--radix-dropdown-menu-content-transform-origin': 'var(--radix-popper-transform-origin)',
					'--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',
					'--radix-dropdown-menu-content-available-height': 'var(--radix-popper-available-height)',
					'--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',
					'--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',
				},
			})
		)
	}
)
var $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894
var $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9
var $d08ef79370b62062$export$602eac185826482c = $d08ef79370b62062$export$cd369b4d4d54efc9
var $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248
var $d08ef79370b62062$export$eb2fcfdbd7ba97d4 = $d08ef79370b62062$export$246bebaba3a2f70e
var $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d
var $d08ef79370b62062$export$16ce288f89fa631c = $d08ef79370b62062$export$53a69729da201fa9
var $d08ef79370b62062$export$c3468e2714d175fa = $d08ef79370b62062$export$42355ae145153fb6
var $d08ef79370b62062$export$d7a01e11500dfb6f = $d08ef79370b62062$export$2f307d81a64f5442
var $d08ef79370b62062$export$2ea8a7a591ac5eac = $d08ef79370b62062$export$21dcb7ec56f874cf
var $d08ef79370b62062$export$6d4de93b380beddf = $d08ef79370b62062$export$f34ec8bc2482cc5f

// ../packages/ui/src/lib/hooks/useMenuIsOpen.ts
init_define_process()
var import_react68 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/useEventsProvider.tsx
init_define_process()
var React43 = __toESM(require_react())
var import_jsx_runtime61 = __toESM(require_jsx_runtime())
var defaultEventHandler = () => void 0
var EventsContext = React43.createContext({})
function EventsProvider({ onEvent, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(EventsContext.Provider, {
		value: onEvent ?? defaultEventHandler,
		children,
	})
}
function useEvents() {
	return React43.useContext(EventsContext)
}

// ../packages/ui/src/lib/hooks/useMenuIsOpen.ts
function useMenuIsOpen(id, cb) {
	const app = useApp()
	const rIsOpen = (0, import_react68.useRef)(false)
	const trackEvent = useEvents()
	const onOpenChange = (0, import_react68.useCallback)(
		(isOpen2) => {
			rIsOpen.current = isOpen2
			app.batch(() => {
				if (isOpen2) {
					app.complete()
					app.addOpenMenu(id)
				} else {
					app.deleteOpenMenu(id)
					app.openMenus.forEach((menuId) => {
						if (menuId.startsWith(id)) {
							app.deleteOpenMenu(menuId)
						}
					})
				}
				cb?.(isOpen2)
			})
		},
		[app, id, cb]
	)
	;(0, import_react68.useEffect)(() => {
		if (rIsOpen.current) {
			trackEvent('open-menu', { source: 'unknown', id })
			app.addOpenMenu(id)
		}
		return () => {
			if (rIsOpen.current) {
				app.deleteOpenMenu(id)
				app.openMenus.forEach((menuId) => {
					if (menuId.startsWith(id)) {
						trackEvent('close-menu', { source: 'unknown', id })
						app.deleteOpenMenu(menuId)
					}
				})
				rIsOpen.current = false
			}
		}
	}, [app, id, trackEvent])
	const isOpen = useValue('is menu open', () => app.openMenus.includes(id), [app, id])
	return [isOpen, onOpenChange]
}

// ../packages/ui/src/lib/components/primitives/DropdownMenu.tsx
var import_jsx_runtime62 = __toESM(require_jsx_runtime())
function Root({ id, children, modal = false }) {
	const [open, onOpenChange] = useMenuIsOpen(id)
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$be92b6f5f03c0fe9, {
		open,
		dir: 'ltr',
		modal,
		onOpenChange,
		children,
	})
}
function Trigger({ children, 'data-testid': dataWd }) {
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, {
		dir: 'ltr',
		'data-testid': dataWd,
		asChild: true,
		children,
	})
}
function Content({ side = 'bottom', align = 'start', sideOffset = 8, alignOffset = 8, children }) {
	const container = useContainer()
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$602eac185826482c, {
		dir: 'ltr',
		container,
		children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
			$d08ef79370b62062$export$7c6e2c02157bb7d2,
			{
				className: 'tlui-menu',
				align,
				sideOffset,
				side,
				alignOffset,
				collisionPadding: 4,
				children,
			}
		),
	})
}
function Sub({ id, children }) {
	const [open, onOpenChange] = useMenuIsOpen(id)
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$d7a01e11500dfb6f, {
		open,
		onOpenChange,
		children,
	})
}
function SubTrigger({ label, 'data-testid': dataWd, 'data-direction': dataDirection }) {
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$2ea8a7a591ac5eac, {
		dir: 'ltr',
		'data-direction': dataDirection,
		'data-testid': dataWd,
		asChild: true,
		children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Button, {
			className: 'tlui-menu__button tlui-menu__submenu__trigger',
			label,
			icon: 'chevron-right',
		}),
	})
}
function SubContent({ alignOffset = 0, sideOffset = 5, children }) {
	const container = useContainer()
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$602eac185826482c, {
		container,
		dir: 'ltr',
		children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
			$d08ef79370b62062$export$6d4de93b380beddf,
			{
				className: 'tlui-menu tlui-menu__submenu__content',
				alignOffset,
				sideOffset,
				collisionPadding: 4,
				children,
			}
		),
	})
}
function Group({ children, size = 'medium' }) {
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$eb2fcfdbd7ba97d4, {
		dir: 'ltr',
		className: 'tlui-menu__group',
		'data-size': size,
		children,
	})
}
function Item({ noClose, ...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, {
		dir: 'ltr',
		asChild: true,
		onClick: noClose || props.isChecked !== void 0 ? preventDefault : void 0,
		children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Button, {
			className: 'tlui-menu__button',
			...props,
		}),
	})
}
function CheckboxItem({ children, onSelect, ...rest }) {
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)($d08ef79370b62062$export$16ce288f89fa631c, {
		dir: 'ltr',
		className: 'tlui-button tlui-menu__button tlui-menu__checkbox-item',
		onSelect: (e2) => {
			onSelect?.(e2)
			preventDefault(e2)
		},
		...rest,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime62.jsx)('div', {
				className: 'tlui-menu__checkbox-item__check',
				style: {
					transformOrigin: '75% center',
					transform: `scale(${rest.checked ? 1 : 0.5})`,
					opacity: rest.checked ? 1 : 0.5,
				},
				children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Icon, {
					small: true,
					icon: rest.checked ? 'check' : 'checkbox-empty',
				}),
			}),
			children,
		],
	})
}
function RadioItem({ children, onSelect, ...rest }) {
	return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)($d08ef79370b62062$export$16ce288f89fa631c, {
		dir: 'ltr',
		className: 'tlui-button tlui-menu__button tlui-menu__checkbox-item',
		onSelect: (e2) => {
			onSelect?.(e2)
			preventDefault(e2)
		},
		...rest,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime62.jsx)($d08ef79370b62062$export$c3468e2714d175fa, {
				dir: 'ltr',
				className: 'tlui-menu__checkbox-item__check',
				children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Icon, { icon: 'check' }),
			}),
			children,
		],
	})
}

// ../packages/ui/src/lib/TldrawUi.tsx
init_define_process()

// ../node_modules/@radix-ui/react-toast/dist/index.module.js
init_define_process()
var import_react70 = __toESM(require_react())
var import_react_dom5 = __toESM(require_react_dom())

// ../node_modules/@radix-ui/react-visually-hidden/dist/index.module.js
init_define_process()
var import_react69 = __toESM(require_react())
var $ea1ef594cf570d83$export$439d29a4e110a164 = /* @__PURE__ */ (0, import_react69.forwardRef)(
	(props, forwardedRef) => {
		return /* @__PURE__ */ (0, import_react69.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.span,
			_extends({}, props, {
				ref: forwardedRef,
				style: {
					// See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
					position: 'absolute',
					border: 0,
					width: 1,
					height: 1,
					padding: 0,
					margin: -1,
					overflow: 'hidden',
					clip: 'rect(0, 0, 0, 0)',
					whiteSpace: 'nowrap',
					wordWrap: 'normal',
					...props.style,
				},
			})
		)
	}
)

// ../node_modules/@radix-ui/react-toast/dist/index.module.js
var $054eb8030ebde76e$var$PROVIDER_NAME = 'ToastProvider'
var [
	$054eb8030ebde76e$var$Collection,
	$054eb8030ebde76e$var$useCollection,
	$054eb8030ebde76e$var$createCollectionScope,
] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2('Toast')
var [$054eb8030ebde76e$var$createToastContext, $054eb8030ebde76e$export$8a359da18fbc9073] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1('Toast', [$054eb8030ebde76e$var$createCollectionScope])
var [$054eb8030ebde76e$var$ToastProviderProvider, $054eb8030ebde76e$var$useToastProviderContext] =
	$054eb8030ebde76e$var$createToastContext($054eb8030ebde76e$var$PROVIDER_NAME)
var $054eb8030ebde76e$export$f5d03d415824e0e = (props) => {
	const {
		__scopeToast,
		label = 'Notification',
		duration = 5e3,
		swipeDirection = 'right',
		swipeThreshold = 50,
		children,
	} = props
	const [viewport, setViewport] = (0, import_react70.useState)(null)
	const [toastCount, setToastCount] = (0, import_react70.useState)(0)
	const isFocusedToastEscapeKeyDownRef = (0, import_react70.useRef)(false)
	const isClosePausedRef = (0, import_react70.useRef)(false)
	return /* @__PURE__ */ (0, import_react70.createElement)(
		$054eb8030ebde76e$var$Collection.Provider,
		{
			scope: __scopeToast,
		},
		/* @__PURE__ */ (0, import_react70.createElement)(
			$054eb8030ebde76e$var$ToastProviderProvider,
			{
				scope: __scopeToast,
				label,
				duration,
				swipeDirection,
				swipeThreshold,
				toastCount,
				viewport,
				onViewportChange: setViewport,
				onToastAdd: (0, import_react70.useCallback)(
					() => setToastCount((prevCount) => prevCount + 1),
					[]
				),
				onToastRemove: (0, import_react70.useCallback)(
					() => setToastCount((prevCount) => prevCount - 1),
					[]
				),
				isFocusedToastEscapeKeyDownRef,
				isClosePausedRef,
			},
			children
		)
	)
}
$054eb8030ebde76e$export$f5d03d415824e0e.propTypes = {
	label(props) {
		if (props.label && typeof props.label === 'string' && !props.label.trim()) {
			const error = `Invalid prop \`label\` supplied to \`${$054eb8030ebde76e$var$PROVIDER_NAME}\`. Expected non-empty \`string\`.`
			return new Error(error)
		}
		return null
	},
}
var $054eb8030ebde76e$var$VIEWPORT_NAME = 'ToastViewport'
var $054eb8030ebde76e$var$VIEWPORT_DEFAULT_HOTKEY = ['F8']
var $054eb8030ebde76e$var$VIEWPORT_PAUSE = 'toast.viewportPause'
var $054eb8030ebde76e$var$VIEWPORT_RESUME = 'toast.viewportResume'
var $054eb8030ebde76e$export$6192c2425ecfd989 = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const {
			__scopeToast,
			hotkey = $054eb8030ebde76e$var$VIEWPORT_DEFAULT_HOTKEY,
			label = 'Notifications ({hotkey})',
			...viewportProps
		} = props
		const context = $054eb8030ebde76e$var$useToastProviderContext(
			$054eb8030ebde76e$var$VIEWPORT_NAME,
			__scopeToast
		)
		const getItems = $054eb8030ebde76e$var$useCollection(__scopeToast)
		const wrapperRef = (0, import_react70.useRef)(null)
		const headFocusProxyRef = (0, import_react70.useRef)(null)
		const tailFocusProxyRef = (0, import_react70.useRef)(null)
		const ref = (0, import_react70.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
			forwardedRef,
			ref,
			context.onViewportChange
		)
		const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '')
		const hasToasts = context.toastCount > 0
		;(0, import_react70.useEffect)(() => {
			const handleKeyDown = (event) => {
				var _ref$current
				const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key)
				if (isHotkeyPressed)
					(_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus()
			}
			document.addEventListener('keydown', handleKeyDown)
			return () => document.removeEventListener('keydown', handleKeyDown)
		}, [hotkey])
		;(0, import_react70.useEffect)(() => {
			const wrapper = wrapperRef.current
			const viewport = ref.current
			if (hasToasts && wrapper && viewport) {
				const handlePause = () => {
					if (!context.isClosePausedRef.current) {
						const pauseEvent = new CustomEvent($054eb8030ebde76e$var$VIEWPORT_PAUSE)
						viewport.dispatchEvent(pauseEvent)
						context.isClosePausedRef.current = true
					}
				}
				const handleResume = () => {
					if (context.isClosePausedRef.current) {
						const resumeEvent = new CustomEvent($054eb8030ebde76e$var$VIEWPORT_RESUME)
						viewport.dispatchEvent(resumeEvent)
						context.isClosePausedRef.current = false
					}
				}
				const handleFocusOutResume = (event) => {
					const isFocusMovingOutside = !wrapper.contains(event.relatedTarget)
					if (isFocusMovingOutside) handleResume()
				}
				const handlePointerLeaveResume = () => {
					const isFocusInside = wrapper.contains(document.activeElement)
					if (!isFocusInside) handleResume()
				}
				wrapper.addEventListener('focusin', handlePause)
				wrapper.addEventListener('focusout', handleFocusOutResume)
				wrapper.addEventListener('pointermove', handlePause)
				wrapper.addEventListener('pointerleave', handlePointerLeaveResume)
				window.addEventListener('blur', handlePause)
				window.addEventListener('focus', handleResume)
				return () => {
					wrapper.removeEventListener('focusin', handlePause)
					wrapper.removeEventListener('focusout', handleFocusOutResume)
					wrapper.removeEventListener('pointermove', handlePause)
					wrapper.removeEventListener('pointerleave', handlePointerLeaveResume)
					window.removeEventListener('blur', handlePause)
					window.removeEventListener('focus', handleResume)
				}
			}
		}, [hasToasts, context.isClosePausedRef])
		const getSortedTabbableCandidates = (0, import_react70.useCallback)(
			({ tabbingDirection }) => {
				const toastItems = getItems()
				const tabbableCandidates = toastItems.map((toastItem) => {
					const toastNode = toastItem.ref.current
					const toastTabbableCandidates = [
						toastNode,
						...$054eb8030ebde76e$var$getTabbableCandidates(toastNode),
					]
					return tabbingDirection === 'forwards'
						? toastTabbableCandidates
						: toastTabbableCandidates.reverse()
				})
				return (
					tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates
				).flat()
			},
			[getItems]
		)
		;(0, import_react70.useEffect)(() => {
			const viewport = ref.current
			if (viewport) {
				const handleKeyDown = (event) => {
					const isMetaKey = event.altKey || event.ctrlKey || event.metaKey
					const isTabKey = event.key === 'Tab' && !isMetaKey
					if (isTabKey) {
						const focusedElement = document.activeElement
						const isTabbingBackwards = event.shiftKey
						const targetIsViewport = event.target === viewport
						if (targetIsViewport && isTabbingBackwards) {
							var _headFocusProxyRef$cu
							;(_headFocusProxyRef$cu = headFocusProxyRef.current) === null ||
								_headFocusProxyRef$cu === void 0 ||
								_headFocusProxyRef$cu.focus()
							return
						}
						const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards'
						const sortedCandidates = getSortedTabbableCandidates({
							tabbingDirection,
						})
						const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement)
						if ($054eb8030ebde76e$var$focusFirst(sortedCandidates.slice(index2 + 1)))
							event.preventDefault()
						else {
							var _headFocusProxyRef$cu2, _tailFocusProxyRef$cu
							isTabbingBackwards
								? (_headFocusProxyRef$cu2 = headFocusProxyRef.current) === null ||
								  _headFocusProxyRef$cu2 === void 0 ||
								  _headFocusProxyRef$cu2.focus()
								: (_tailFocusProxyRef$cu = tailFocusProxyRef.current) === null ||
								  _tailFocusProxyRef$cu === void 0 ||
								  _tailFocusProxyRef$cu.focus()
						}
					}
				}
				viewport.addEventListener('keydown', handleKeyDown)
				return () => viewport.removeEventListener('keydown', handleKeyDown)
			}
		}, [getItems, getSortedTabbableCandidates])
		return /* @__PURE__ */ (0, import_react70.createElement)(
			$5cb92bef7577960e$export$aecb2ddcb55c95be,
			{
				ref: wrapperRef,
				role: 'region',
				'aria-label': label.replace('{hotkey}', hotkeyLabel),
				tabIndex: -1,
				style: {
					pointerEvents: hasToasts ? void 0 : 'none',
				},
			},
			hasToasts &&
				/* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$FocusProxy, {
					ref: headFocusProxyRef,
					onFocusFromOutsideViewport: () => {
						const tabbableCandidates = getSortedTabbableCandidates({
							tabbingDirection: 'forwards',
						})
						$054eb8030ebde76e$var$focusFirst(tabbableCandidates)
					},
				}),
			/* @__PURE__ */ (0, import_react70.createElement)(
				$054eb8030ebde76e$var$Collection.Slot,
				{
					scope: __scopeToast,
				},
				/* @__PURE__ */ (0, import_react70.createElement)(
					$8927f6f2acc4f386$export$250ffa63cdc0d034.ol,
					_extends(
						{
							tabIndex: -1,
						},
						viewportProps,
						{
							ref: composedRefs,
						}
					)
				)
			),
			hasToasts &&
				/* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$FocusProxy, {
					ref: tailFocusProxyRef,
					onFocusFromOutsideViewport: () => {
						const tabbableCandidates = getSortedTabbableCandidates({
							tabbingDirection: 'backwards',
						})
						$054eb8030ebde76e$var$focusFirst(tabbableCandidates)
					},
				})
		)
	}
)
var $054eb8030ebde76e$var$FOCUS_PROXY_NAME = 'ToastFocusProxy'
var $054eb8030ebde76e$var$FocusProxy = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props
		const context = $054eb8030ebde76e$var$useToastProviderContext(
			$054eb8030ebde76e$var$FOCUS_PROXY_NAME,
			__scopeToast
		)
		return /* @__PURE__ */ (0, import_react70.createElement)(
			$ea1ef594cf570d83$export$439d29a4e110a164,
			_extends(
				{
					'aria-hidden': true,
					tabIndex: 0,
				},
				proxyProps,
				{
					ref: forwardedRef,
					style: {
						position: 'fixed',
					},
					onFocus: (event) => {
						var _context$viewport
						const prevFocusedElement = event.relatedTarget
						const isFocusFromOutsideViewport = !(
							(_context$viewport = context.viewport) !== null &&
							_context$viewport !== void 0 &&
							_context$viewport.contains(prevFocusedElement)
						)
						if (isFocusFromOutsideViewport) onFocusFromOutsideViewport()
					},
				}
			)
		)
	}
)
var $054eb8030ebde76e$var$TOAST_NAME = 'Toast'
var $054eb8030ebde76e$var$TOAST_SWIPE_START = 'toast.swipeStart'
var $054eb8030ebde76e$var$TOAST_SWIPE_MOVE = 'toast.swipeMove'
var $054eb8030ebde76e$var$TOAST_SWIPE_CANCEL = 'toast.swipeCancel'
var $054eb8030ebde76e$var$TOAST_SWIPE_END = 'toast.swipeEnd'
var $054eb8030ebde76e$export$8d8dc7d5f743331b = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props
		const [open = true, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
			prop: openProp,
			defaultProp: defaultOpen,
			onChange: onOpenChange,
		})
		return /* @__PURE__ */ (0, import_react70.createElement)(
			$921a889cee6df7e8$export$99c2b779aa4e8b8b,
			{
				present: forceMount || open,
			},
			/* @__PURE__ */ (0, import_react70.createElement)(
				$054eb8030ebde76e$var$ToastImpl,
				_extends(
					{
						open,
					},
					toastProps,
					{
						ref: forwardedRef,
						onClose: () => setOpen(false),
						onPause: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(props.onPause),
						onResume: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(props.onResume),
						onSwipeStart: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeStart, (event) => {
							event.currentTarget.setAttribute('data-swipe', 'start')
						}),
						onSwipeMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeMove, (event) => {
							const { x: x3, y: y3 } = event.detail.delta
							event.currentTarget.setAttribute('data-swipe', 'move')
							event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x3}px`)
							event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y3}px`)
						}),
						onSwipeCancel: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
							props.onSwipeCancel,
							(event) => {
								event.currentTarget.setAttribute('data-swipe', 'cancel')
								event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x')
								event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y')
								event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x')
								event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y')
							}
						),
						onSwipeEnd: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeEnd, (event) => {
							const { x: x3, y: y3 } = event.detail.delta
							event.currentTarget.setAttribute('data-swipe', 'end')
							event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x')
							event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y')
							event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x3}px`)
							event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y3}px`)
							setOpen(false)
						}),
					}
				)
			)
		)
	}
)
var [
	$054eb8030ebde76e$var$ToastInteractiveProvider,
	$054eb8030ebde76e$var$useToastInteractiveContext,
] = $054eb8030ebde76e$var$createToastContext($054eb8030ebde76e$var$TOAST_NAME, {
	onClose() {},
})
var $054eb8030ebde76e$var$ToastImpl = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const {
			__scopeToast,
			type = 'foreground',
			duration: durationProp,
			open,
			onClose,
			onEscapeKeyDown,
			onPause,
			onResume,
			onSwipeStart,
			onSwipeMove,
			onSwipeCancel,
			onSwipeEnd,
			...toastProps
		} = props
		const context = $054eb8030ebde76e$var$useToastProviderContext(
			$054eb8030ebde76e$var$TOAST_NAME,
			__scopeToast
		)
		const [node1, setNode] = (0, import_react70.useState)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setNode(node)
		)
		const pointerStartRef = (0, import_react70.useRef)(null)
		const swipeDeltaRef = (0, import_react70.useRef)(null)
		const duration1 = durationProp || context.duration
		const closeTimerStartTimeRef = (0, import_react70.useRef)(0)
		const closeTimerRemainingTimeRef = (0, import_react70.useRef)(duration1)
		const closeTimerRef = (0, import_react70.useRef)(0)
		const { onToastAdd, onToastRemove } = context
		const handleClose = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(() => {
			var _context$viewport2
			const isFocusInToast =
				node1 === null || node1 === void 0 ? void 0 : node1.contains(document.activeElement)
			if (isFocusInToast)
				(_context$viewport2 = context.viewport) === null ||
					_context$viewport2 === void 0 ||
					_context$viewport2.focus()
			onClose()
		})
		const startTimer = (0, import_react70.useCallback)(
			(duration) => {
				if (!duration || duration === Infinity) return
				window.clearTimeout(closeTimerRef.current)
				closeTimerStartTimeRef.current = new Date().getTime()
				closeTimerRef.current = window.setTimeout(handleClose, duration)
			},
			[handleClose]
		)
		;(0, import_react70.useEffect)(() => {
			const viewport = context.viewport
			if (viewport) {
				const handleResume = () => {
					startTimer(closeTimerRemainingTimeRef.current)
					onResume === null || onResume === void 0 || onResume()
				}
				const handlePause = () => {
					const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current
					closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime
					window.clearTimeout(closeTimerRef.current)
					onPause === null || onPause === void 0 || onPause()
				}
				viewport.addEventListener($054eb8030ebde76e$var$VIEWPORT_PAUSE, handlePause)
				viewport.addEventListener($054eb8030ebde76e$var$VIEWPORT_RESUME, handleResume)
				return () => {
					viewport.removeEventListener($054eb8030ebde76e$var$VIEWPORT_PAUSE, handlePause)
					viewport.removeEventListener($054eb8030ebde76e$var$VIEWPORT_RESUME, handleResume)
				}
			}
		}, [context.viewport, duration1, onPause, onResume, startTimer])
		;(0, import_react70.useEffect)(() => {
			if (open && !context.isClosePausedRef.current) startTimer(duration1)
		}, [open, duration1, context.isClosePausedRef, startTimer])
		;(0, import_react70.useEffect)(() => {
			onToastAdd()
			return () => onToastRemove()
		}, [onToastAdd, onToastRemove])
		const announceTextContent = (0, import_react70.useMemo)(() => {
			return node1 ? $054eb8030ebde76e$var$getAnnounceTextContent(node1) : null
		}, [node1])
		if (!context.viewport) return null
		return /* @__PURE__ */ (0, import_react70.createElement)(
			import_react70.Fragment,
			null,
			announceTextContent &&
				/* @__PURE__ */ (0, import_react70.createElement)(
					$054eb8030ebde76e$var$ToastAnnounce,
					{
						__scopeToast,
						role: 'status',
						'aria-live': type === 'foreground' ? 'assertive' : 'polite',
						'aria-atomic': true,
					},
					announceTextContent
				),
			/* @__PURE__ */ (0, import_react70.createElement)(
				$054eb8030ebde76e$var$ToastInteractiveProvider,
				{
					scope: __scopeToast,
					onClose: handleClose,
				},
				/* @__PURE__ */ (0, import_react_dom5.createPortal)(
					/* @__PURE__ */ (0, import_react70.createElement)(
						$054eb8030ebde76e$var$Collection.ItemSlot,
						{
							scope: __scopeToast,
						},
						/* @__PURE__ */ (0, import_react70.createElement)(
							$5cb92bef7577960e$export$be92b6f5f03c0fe9,
							{
								asChild: true,
								onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEscapeKeyDown, () => {
									if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose()
									context.isFocusedToastEscapeKeyDownRef.current = false
								}),
							},
							/* @__PURE__ */ (0, import_react70.createElement)(
								$8927f6f2acc4f386$export$250ffa63cdc0d034.li,
								_extends(
									{
										// Ensure toasts are announced as status list or status when focused
										role: 'status',
										'aria-live': 'off',
										'aria-atomic': true,
										tabIndex: 0,
										'data-state': open ? 'open' : 'closed',
										'data-swipe-direction': context.swipeDirection,
									},
									toastProps,
									{
										ref: composedRefs,
										style: {
											userSelect: 'none',
											touchAction: 'none',
											...props.style,
										},
										onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
											props.onKeyDown,
											(event) => {
												if (event.key !== 'Escape') return
												onEscapeKeyDown === null ||
													onEscapeKeyDown === void 0 ||
													onEscapeKeyDown(event.nativeEvent)
												if (!event.nativeEvent.defaultPrevented) {
													context.isFocusedToastEscapeKeyDownRef.current = true
													handleClose()
												}
											}
										),
										onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
											props.onPointerDown,
											(event) => {
												if (event.button !== 0) return
												pointerStartRef.current = {
													x: event.clientX,
													y: event.clientY,
												}
											}
										),
										onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
											props.onPointerMove,
											(event) => {
												if (!pointerStartRef.current) return
												const x3 = event.clientX - pointerStartRef.current.x
												const y3 = event.clientY - pointerStartRef.current.y
												const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current)
												const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection)
												const clamp3 = ['left', 'up'].includes(context.swipeDirection)
													? Math.min
													: Math.max
												const clampedX = isHorizontalSwipe ? clamp3(0, x3) : 0
												const clampedY = !isHorizontalSwipe ? clamp3(0, y3) : 0
												const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2
												const delta = {
													x: clampedX,
													y: clampedY,
												}
												const eventDetail = {
													originalEvent: event,
													delta,
												}
												if (hasSwipeMoveStarted) {
													swipeDeltaRef.current = delta
													$054eb8030ebde76e$var$handleAndDispatchCustomEvent(
														$054eb8030ebde76e$var$TOAST_SWIPE_MOVE,
														onSwipeMove,
														eventDetail,
														{
															discrete: false,
														}
													)
												} else if (
													$054eb8030ebde76e$var$isDeltaInDirection(
														delta,
														context.swipeDirection,
														moveStartBuffer
													)
												) {
													swipeDeltaRef.current = delta
													$054eb8030ebde76e$var$handleAndDispatchCustomEvent(
														$054eb8030ebde76e$var$TOAST_SWIPE_START,
														onSwipeStart,
														eventDetail,
														{
															discrete: false,
														}
													)
													event.target.setPointerCapture(event.pointerId)
												} else if (Math.abs(x3) > moveStartBuffer || Math.abs(y3) > moveStartBuffer)
													pointerStartRef.current = null
											}
										),
										onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
											props.onPointerUp,
											(event1) => {
												const delta = swipeDeltaRef.current
												const target = event1.target
												if (target.hasPointerCapture(event1.pointerId))
													target.releasePointerCapture(event1.pointerId)
												swipeDeltaRef.current = null
												pointerStartRef.current = null
												if (delta) {
													const toast = event1.currentTarget
													const eventDetail = {
														originalEvent: event1,
														delta,
													}
													if (
														$054eb8030ebde76e$var$isDeltaInDirection(
															delta,
															context.swipeDirection,
															context.swipeThreshold
														)
													)
														$054eb8030ebde76e$var$handleAndDispatchCustomEvent(
															$054eb8030ebde76e$var$TOAST_SWIPE_END,
															onSwipeEnd,
															eventDetail,
															{
																discrete: true,
															}
														)
													else
														$054eb8030ebde76e$var$handleAndDispatchCustomEvent(
															$054eb8030ebde76e$var$TOAST_SWIPE_CANCEL,
															onSwipeCancel,
															eventDetail,
															{
																discrete: true,
															}
														)
													toast.addEventListener('click', (event) => event.preventDefault(), {
														once: true,
													})
												}
											}
										),
									}
								)
							)
						)
					),
					context.viewport
				)
			)
		)
	}
)
$054eb8030ebde76e$var$ToastImpl.propTypes = {
	type(props) {
		if (props.type && !['foreground', 'background'].includes(props.type)) {
			const error = `Invalid prop \`type\` supplied to \`${$054eb8030ebde76e$var$TOAST_NAME}\`. Expected \`foreground | background\`.`
			return new Error(error)
		}
		return null
	},
}
var $054eb8030ebde76e$var$ToastAnnounce = (props) => {
	const { __scopeToast, children, ...announceProps } = props
	const context = $054eb8030ebde76e$var$useToastProviderContext(
		$054eb8030ebde76e$var$TOAST_NAME,
		__scopeToast
	)
	const [renderAnnounceText, setRenderAnnounceText] = (0, import_react70.useState)(false)
	const [isAnnounced, setIsAnnounced] = (0, import_react70.useState)(false)
	$054eb8030ebde76e$var$useNextFrame(() => setRenderAnnounceText(true))
	;(0, import_react70.useEffect)(() => {
		const timer = window.setTimeout(() => setIsAnnounced(true), 1e3)
		return () => window.clearTimeout(timer)
	}, [])
	return isAnnounced
		? null
		: /* @__PURE__ */ (0, import_react70.createElement)(
				$f1701beae083dbae$export$602eac185826482c,
				{
					asChild: true,
				},
				/* @__PURE__ */ (0, import_react70.createElement)(
					$ea1ef594cf570d83$export$439d29a4e110a164,
					announceProps,
					renderAnnounceText &&
						/* @__PURE__ */ (0, import_react70.createElement)(
							import_react70.Fragment,
							null,
							context.label,
							' ',
							children
						)
				)
		  )
}
var $054eb8030ebde76e$export$16d42d7c29b95a4 = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeToast, ...titleProps } = props
		return /* @__PURE__ */ (0, import_react70.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
			_extends({}, titleProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $054eb8030ebde76e$export$ecddd96c53621d9a = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeToast, ...descriptionProps } = props
		return /* @__PURE__ */ (0, import_react70.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
			_extends({}, descriptionProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $054eb8030ebde76e$var$ACTION_NAME = 'ToastAction'
var $054eb8030ebde76e$export$3019feecfda683d2 = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const { altText, ...actionProps } = props
		if (!altText) return null
		return /* @__PURE__ */ (0, import_react70.createElement)(
			$054eb8030ebde76e$var$ToastAnnounceExclude,
			{
				altText,
				asChild: true,
			},
			/* @__PURE__ */ (0, import_react70.createElement)(
				$054eb8030ebde76e$export$811e70f61c205839,
				_extends({}, actionProps, {
					ref: forwardedRef,
				})
			)
		)
	}
)
$054eb8030ebde76e$export$3019feecfda683d2.propTypes = {
	altText(props) {
		if (!props.altText)
			return new Error(
				`Missing prop \`altText\` expected on \`${$054eb8030ebde76e$var$ACTION_NAME}\``
			)
		return null
	},
}
var $054eb8030ebde76e$var$CLOSE_NAME = 'ToastClose'
var $054eb8030ebde76e$export$811e70f61c205839 = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeToast, ...closeProps } = props
		const interactiveContext = $054eb8030ebde76e$var$useToastInteractiveContext(
			$054eb8030ebde76e$var$CLOSE_NAME,
			__scopeToast
		)
		return /* @__PURE__ */ (0, import_react70.createElement)(
			$054eb8030ebde76e$var$ToastAnnounceExclude,
			{
				asChild: true,
			},
			/* @__PURE__ */ (0, import_react70.createElement)(
				$8927f6f2acc4f386$export$250ffa63cdc0d034.button,
				_extends(
					{
						type: 'button',
					},
					closeProps,
					{
						ref: forwardedRef,
						onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
							props.onClick,
							interactiveContext.onClose
						),
					}
				)
			)
		)
	}
)
var $054eb8030ebde76e$var$ToastAnnounceExclude = /* @__PURE__ */ (0, import_react70.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeToast, altText, ...announceExcludeProps } = props
		return /* @__PURE__ */ (0, import_react70.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
			_extends(
				{
					'data-radix-toast-announce-exclude': '',
					'data-radix-toast-announce-alt': altText || void 0,
				},
				announceExcludeProps,
				{
					ref: forwardedRef,
				}
			)
		)
	}
)
function $054eb8030ebde76e$var$getAnnounceTextContent(container) {
	const textContent = []
	const childNodes = Array.from(container.childNodes)
	childNodes.forEach((node) => {
		if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent)
		if ($054eb8030ebde76e$var$isHTMLElement(node)) {
			const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none'
			const isExcluded = node.dataset.radixToastAnnounceExclude === ''
			if (!isHidden) {
				if (isExcluded) {
					const altText = node.dataset.radixToastAnnounceAlt
					if (altText) textContent.push(altText)
				} else textContent.push(...$054eb8030ebde76e$var$getAnnounceTextContent(node))
			}
		}
	})
	return textContent
}
function $054eb8030ebde76e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
	const currentTarget = detail.originalEvent.currentTarget
	const event = new CustomEvent(name, {
		bubbles: true,
		cancelable: true,
		detail,
	})
	if (handler)
		currentTarget.addEventListener(name, handler, {
			once: true,
		})
	if (discrete) $8927f6f2acc4f386$export$6d1a0317bde7de7f(currentTarget, event)
	else currentTarget.dispatchEvent(event)
}
var $054eb8030ebde76e$var$isDeltaInDirection = (delta, direction, threshold = 0) => {
	const deltaX = Math.abs(delta.x)
	const deltaY = Math.abs(delta.y)
	const isDeltaX = deltaX > deltaY
	if (direction === 'left' || direction === 'right') return isDeltaX && deltaX > threshold
	else return !isDeltaX && deltaY > threshold
}
function $054eb8030ebde76e$var$useNextFrame(callback = () => {}) {
	const fn = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback)
	$9f79659886946c16$export$e5c5a5f917a5871c(() => {
		let raf1 = 0
		let raf2 = 0
		raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)))
		return () => {
			window.cancelAnimationFrame(raf1)
			window.cancelAnimationFrame(raf2)
		}
	}, [fn])
}
function $054eb8030ebde76e$var$isHTMLElement(node) {
	return node.nodeType === node.ELEMENT_NODE
}
function $054eb8030ebde76e$var$getTabbableCandidates(container) {
	const nodes = []
	const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
		acceptNode: (node) => {
			const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'
			if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP
			return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
		},
	})
	while (walker.nextNode()) nodes.push(walker.currentNode)
	return nodes
}
function $054eb8030ebde76e$var$focusFirst(candidates) {
	const previouslyFocusedElement = document.activeElement
	return candidates.some((candidate) => {
		if (candidate === previouslyFocusedElement) return true
		candidate.focus()
		return document.activeElement !== previouslyFocusedElement
	})
}
var $054eb8030ebde76e$export$be92b6f5f03c0fe9 = $054eb8030ebde76e$export$8d8dc7d5f743331b
var $054eb8030ebde76e$export$f99233281efd08a0 = $054eb8030ebde76e$export$16d42d7c29b95a4
var $054eb8030ebde76e$export$393edc798c47379d = $054eb8030ebde76e$export$ecddd96c53621d9a
var $054eb8030ebde76e$export$e19cd5f9376f8cee = $054eb8030ebde76e$export$3019feecfda683d2
var $054eb8030ebde76e$export$f39c2d165cd861fe = $054eb8030ebde76e$export$811e70f61c205839

// ../packages/ui/src/lib/TldrawUi.tsx
var import_classnames20 = __toESM(require_classnames())
var import_react110 = __toESM(require_react())

// ../packages/ui/src/lib/TldrawUiContextProvider.tsx
init_define_process()

// ../packages/ui/src/lib/assetUrls.ts
init_define_process()

// ../packages/ui/src/lib/icon-types.ts
init_define_process()
var TLUiIconTypes = [
	'align-bottom-center',
	'align-bottom-left',
	'align-bottom-right',
	'align-bottom',
	'align-center-center',
	'align-center-horizontal',
	'align-center-left',
	'align-center-right',
	'align-center-vertical',
	'align-left',
	'align-right',
	'align-top-center',
	'align-top-left',
	'align-top-right',
	'align-top',
	'arrow-left',
	'arrowhead-arrow',
	'arrowhead-bar',
	'arrowhead-diamond',
	'arrowhead-dot',
	'arrowhead-none',
	'arrowhead-square',
	'arrowhead-triangle-inverted',
	'arrowhead-triangle',
	'aspect-ratio',
	'avatar',
	'blob',
	'bring-forward',
	'bring-to-front',
	'check',
	'checkbox-checked',
	'checkbox-empty',
	'chevron-down',
	'chevron-left',
	'chevron-right',
	'chevron-up',
	'chevrons-ne',
	'chevrons-sw',
	'clipboard-copied',
	'clipboard-copy',
	'code',
	'collab',
	'color',
	'comment',
	'cross-2',
	'cross',
	'dash-dashed',
	'dash-dotted',
	'dash-draw',
	'dash-solid',
	'discord',
	'distribute-horizontal',
	'distribute-vertical',
	'dot',
	'dots-horizontal',
	'dots-vertical',
	'drag-handle-dots',
	'duplicate',
	'edit',
	'external-link',
	'file',
	'fill-none',
	'fill-pattern',
	'fill-semi',
	'fill-solid',
	'follow',
	'following',
	'font-draw',
	'font-mono',
	'font-sans',
	'font-serif',
	'geo-arrow-down',
	'geo-arrow-left',
	'geo-arrow-right',
	'geo-arrow-up',
	'geo-check-box',
	'geo-diamond',
	'geo-ellipse',
	'geo-hexagon',
	'geo-octagon',
	'geo-oval',
	'geo-pentagon',
	'geo-rectangle',
	'geo-rhombus-2',
	'geo-rhombus',
	'geo-star',
	'geo-trapezoid',
	'geo-triangle',
	'geo-x-box',
	'github',
	'group',
	'hidden',
	'image',
	'info-circle',
	'leading',
	'link',
	'lock-small',
	'lock',
	'menu',
	'minus',
	'mixed',
	'pack',
	'page',
	'plus',
	'question-mark-circle',
	'question-mark',
	'redo',
	'reset-zoom',
	'rotate-ccw',
	'rotate-cw',
	'ruler',
	'search',
	'send-backward',
	'send-to-back',
	'settings-horizontal',
	'settings-vertical-1',
	'settings-vertical',
	'share-1',
	'share-2',
	'size-extra-large',
	'size-large',
	'size-medium',
	'size-small',
	'spline-cubic',
	'spline-line',
	'stack-horizontal',
	'stack-vertical',
	'stretch-horizontal',
	'stretch-vertical',
	'text-align-center',
	'text-align-justify',
	'text-align-left',
	'text-align-right',
	'tool-arrow',
	'tool-embed',
	'tool-eraser',
	'tool-frame',
	'tool-hand',
	'tool-highlighter',
	'tool-laser',
	'tool-line',
	'tool-media',
	'tool-note',
	'tool-pencil',
	'tool-pointer',
	'tool-text',
	'trash',
	'triangle-down',
	'triangle-up',
	'twitter',
	'undo',
	'ungroup',
	'unlock-small',
	'unlock',
	'vertical-align-center',
	'vertical-align-end',
	'vertical-align-start',
	'visible',
	'warning-triangle',
	'zoom-in',
	'zoom-out',
]

// ../packages/ui/src/lib/assetUrls.ts
var defaultUiAssetUrls = {
	...defaultEditorAssetUrls,
	icons: Object.fromEntries(TLUiIconTypes.map((name) => [name, `/icons/icon/${name}.svg`])),
	translations: Object.fromEntries(
		LANGUAGES2.map((lang) => [lang.locale, `/translations/${lang.locale}.json`])
	),
	embedIcons: Object.fromEntries(
		EMBED_DEFINITIONS.map((def) => [def.type, `/embed-icons/${def.type}.png`])
	),
}

// ../packages/ui/src/lib/hooks/useActions.tsx
init_define_process()
var React45 = __toESM(require_react())

// ../packages/ui/src/lib/components/EditLinkDialog.tsx
init_define_process()
var import_react71 = __toESM(require_react())

// ../packages/ui/src/lib/components/primitives/Input.tsx
init_define_process()
var import_classnames14 = __toESM(require_classnames())
var React44 = __toESM(require_react())
var import_jsx_runtime63 = __toESM(require_jsx_runtime())
var Input = React44.forwardRef(function Input2(
	{
		className,
		label,
		icon,
		iconLeft,
		autoselect = false,
		autofocus = false,
		defaultValue,
		placeholder,
		onComplete,
		onValueChange,
		onCancel,
		shouldManuallyMaintainScrollPositionWhenFocused = false,
		children,
		value,
	},
	ref
) {
	const rInputRef = React44.useRef(null)
	React44.useImperativeHandle(ref, () => rInputRef.current)
	const msg2 = useTranslation()
	const rInitialValue = React44.useRef(defaultValue ?? '')
	const rCurrentValue = React44.useRef(defaultValue ?? '')
	const [isFocused, setIsFocused] = React44.useState(false)
	const handleFocus = React44.useCallback(
		(e2) => {
			setIsFocused(true)
			const elm = e2.currentTarget
			rCurrentValue.current = elm.value
			requestAnimationFrame(() => {
				if (autoselect) {
					elm.select()
				}
			})
		},
		[autoselect]
	)
	const handleChange = React44.useCallback(
		(e2) => {
			const value2 = e2.currentTarget.value
			rCurrentValue.current = value2
			onValueChange?.(value2)
		},
		[onValueChange]
	)
	const handleKeyUp = React44.useCallback(
		(e2) => {
			switch (e2.key) {
				case 'Enter': {
					e2.currentTarget.blur()
					e2.stopPropagation()
					onComplete?.(e2.currentTarget.value)
					break
				}
				case 'Escape': {
					e2.currentTarget.value = rInitialValue.current
					e2.currentTarget.blur()
					e2.stopPropagation()
					onCancel?.(e2.currentTarget.value)
					break
				}
			}
		},
		[onComplete, onCancel]
	)
	const handleBlur = React44.useCallback(() => setIsFocused(false), [])
	React44.useEffect(() => {
		const visualViewport = window.visualViewport
		if (isFocused && shouldManuallyMaintainScrollPositionWhenFocused && visualViewport) {
			const onViewportChange = () => {
				rInputRef.current?.scrollIntoView({ block: 'center' })
			}
			visualViewport.addEventListener('resize', onViewportChange)
			visualViewport.addEventListener('scroll', onViewportChange)
			requestAnimationFrame(() => {
				rInputRef.current?.scrollIntoView({ block: 'center' })
			})
			return () => {
				visualViewport.removeEventListener('resize', onViewportChange)
				visualViewport.removeEventListener('scroll', onViewportChange)
			}
		}
	}, [isFocused, shouldManuallyMaintainScrollPositionWhenFocused])
	return /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)('div', {
		draggable: false,
		className: 'tlui-input__wrapper',
		children: [
			children,
			label && /* @__PURE__ */ (0, import_jsx_runtime63.jsx)('label', { children: msg2(label) }),
			iconLeft &&
				/* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Icon, {
					icon: iconLeft,
					className: 'tlui-icon-left',
					small: true,
				}),
			/* @__PURE__ */ (0, import_jsx_runtime63.jsx)('input', {
				ref: rInputRef,
				className: (0, import_classnames14.default)('tlui-input', className),
				type: 'text',
				defaultValue,
				onKeyUp: handleKeyUp,
				onChange: handleChange,
				onFocus: handleFocus,
				onBlur: handleBlur,
				autoFocus: autofocus,
				placeholder,
				value,
			}),
			icon && /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Icon, { icon, small: !!label }),
		],
	})
})

// ../packages/ui/src/lib/components/EditLinkDialog.tsx
var import_jsx_runtime64 = __toESM(require_jsx_runtime())
var validUrlRegex = new RegExp(
	/^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i
)
function validateUrl(url) {
	if (validUrlRegex.test(url)) return true
	if (validUrlRegex.test('https://' + url)) return 'needs protocol'
	return false
}
var EditLinkDialog = track(function EditLinkDialog2({ onClose }) {
	const app = useApp()
	const selectedShape = app.onlySelectedShape
	if (
		!(selectedShape && 'url' in selectedShape.props && typeof selectedShape.props.url === 'string')
	) {
		return null
	}
	return /* @__PURE__ */ (0,
	import_jsx_runtime64.jsx)(EditLinkDialogInner, { onClose, selectedShape })
})
var EditLinkDialogInner = track(function EditLinkDialogInner2({ onClose, selectedShape }) {
	const app = useApp()
	const msg2 = useTranslation()
	const [validState, setValid] = (0, import_react71.useState)(validateUrl(selectedShape.props.url))
	const rInitialValue = (0, import_react71.useRef)(selectedShape.props.url)
	const rValue = (0, import_react71.useRef)(selectedShape.props.url)
	const [urlValue, setUrlValue] = (0, import_react71.useState)(
		validState
			? validState === 'needs protocol'
				? 'https://' + selectedShape.props.url
				: selectedShape.props.url
			: 'https://'
	)
	const handleChange = (0, import_react71.useCallback)((rawValue) => {
		const value = rawValue.replace(/https?:\/\/(https?:\/\/)/, (_match, arg1) => {
			return arg1
		})
		setUrlValue(value)
		const validStateUrl = validateUrl(value.trim())
		setValid((s3) => (s3 === validStateUrl ? s3 : validStateUrl))
		if (validStateUrl) {
			rValue.current = value
		}
	}, [])
	const handleClear = (0, import_react71.useCallback)(() => {
		app.setProp('url', '', false)
		onClose()
	}, [app, onClose])
	const handleComplete = (0, import_react71.useCallback)(
		(value) => {
			value = value.trim()
			const validState2 = validateUrl(value)
			const shape = app.selectedShapes[0]
			if (shape && 'url' in shape.props) {
				const current = shape.props.url
				const next = validState2
					? validState2 === 'needs protocol'
						? 'https://' + value
						: value
					: app.isShapeOfType(shape, TLBookmarkUtil)
					? rInitialValue.current
					: ''
				if (current !== void 0 && current !== next) {
					app.setProp('url', next, false)
				}
			}
			onClose()
		},
		[app, onClose]
	)
	const handleCancel = (0, import_react71.useCallback)(() => {
		onClose()
	}, [onClose])
	if (!selectedShape) {
		onClose()
		return null
	}
	const isRemoving = rInitialValue.current && !validState
	return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(import_jsx_runtime64.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(Header, {
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Title, {
						children: msg2('edit-link-dialog.title'),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime64.jsx)(CloseButton, {}),
				],
			}),
			/* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Body, {
				children: /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)('div', {
					className: 'tlui-edit-link-dialog',
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Input, {
							className: 'tlui-edit-link-dialog__input',
							label: 'edit-link-dialog.url',
							autofocus: true,
							value: urlValue,
							onValueChange: handleChange,
							onComplete: handleComplete,
							onCancel: handleCancel,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime64.jsx)('div', {
							children: validState
								? msg2('edit-link-dialog.detail')
								: msg2('edit-link-dialog.invalid-url'),
						}),
					],
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(Footer, {
				className: 'tlui-dialog__footer__actions',
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Button, {
						onClick: handleCancel,
						onTouchEnd: handleCancel,
						children: msg2('edit-link-dialog.cancel'),
					}),
					isRemoving
						? /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Button, {
								type: 'danger',
								onTouchEnd: handleClear,
								onClick: handleClear,
								children: msg2('edit-link-dialog.clear'),
						  })
						: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Button, {
								type: 'primary',
								disabled: !validState,
								onTouchEnd: () => handleComplete(rValue.current),
								onClick: () => handleComplete(rValue.current),
								children: msg2('edit-link-dialog.save'),
						  }),
				],
			}),
		],
	})
})

// ../packages/ui/src/lib/components/EmbedDialog.tsx
init_define_process()
var import_react72 = __toESM(require_react())
var import_jsx_runtime65 = __toESM(require_jsx_runtime())
var EmbedDialog = track(function EmbedDialog2({ onClose }) {
	const app = useApp()
	const msg2 = useTranslation()
	const assetUrls2 = useAssetUrls()
	const [embedDefinition, setEmbedDefinition] = (0, import_react72.useState)(null)
	const [url, setUrl] = (0, import_react72.useState)('')
	const [embedInfoForUrl, setEmbedInfoForUrl] = (0, import_react72.useState)(null)
	const [showError, setShowError] = (0, import_react72.useState)(false)
	const rShowErrorTimeout = (0, import_react72.useRef)(-1)
	return /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(Header, {
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Title, {
						children: embedDefinition
							? `${msg2('embed-dialog.title')} \u2014 ${embedDefinition.title}`
							: msg2('embed-dialog.title'),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime65.jsx)(CloseButton, {}),
				],
			}),
			embedDefinition
				? /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, {
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(Body, {
								className: 'tlui-embed-dialog__enter',
								children: [
									/* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Input, {
										className: 'tlui-embed-dialog__input',
										label: 'embed-dialog.url',
										placeholder: 'http://example.com',
										autofocus: true,
										onValueChange: (value) => {
											setUrl(value)
											const embedInfo = getEmbedInfo(value)
											setEmbedInfoForUrl(
												embedInfo && embedInfo.definition.type === embedDefinition.type
													? embedInfo
													: null
											)
											setShowError(false)
											clearTimeout(rShowErrorTimeout.current)
											rShowErrorTimeout.current = setTimeout(() => setShowError(!embedInfo), 320)
										},
									}),
									url === ''
										? /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)('div', {
												className: 'tlui-embed-dialog__instruction',
												children: [
													/* @__PURE__ */ (0, import_jsx_runtime65.jsx)('span', {
														children: msg2('embed-dialog.instruction'),
													}),
													' ',
													embedDefinition.instructionLink &&
														/* @__PURE__ */ (0, import_jsx_runtime65.jsxs)('a', {
															target: '_blank',
															rel: 'noopener noreferrer',
															href: embedDefinition.instructionLink,
															className: 'tlui-embed-dialog__instruction__link',
															children: [
																'Learn more.',
																/* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Icon, {
																	icon: 'external-link',
																	small: true,
																}),
															],
														}),
												],
										  })
										: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)('div', {
												className: 'tlui-embed-dialog__warning',
												children: showError ? msg2('embed-dialog.invalid-url') : '\xA0',
										  }),
								],
							}),
							/* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(Footer, {
								className: 'tlui-dialog__footer__actions',
								children: [
									/* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Button, {
										onClick: () => {
											setEmbedDefinition(null)
											setEmbedInfoForUrl(null)
											setUrl('')
										},
										label: 'embed-dialog.back',
									}),
									/* @__PURE__ */ (0, import_jsx_runtime65.jsx)('div', {
										className: 'tlui-embed__spacer',
									}),
									/* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Button, {
										label: 'embed-dialog.cancel',
										onClick: onClose,
									}),
									/* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Button, {
										type: 'primary',
										disabled: !embedInfoForUrl,
										label: 'embed-dialog.create',
										onClick: () => {
											if (!embedInfoForUrl) return
											createEmbedShapeAtPoint(app, url, app.viewportPageCenter, {
												width: embedInfoForUrl.definition.width,
												height: embedInfoForUrl.definition.height,
												doesResize: embedInfoForUrl.definition.doesResize,
											})
											onClose()
										},
									}),
								],
							}),
						],
				  })
				: /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, {
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Body, {
								className: 'tlui-embed-dialog__list',
								children: EMBED_DEFINITIONS.map((def) => {
									return /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(
										'button',
										{
											className: 'tlui-embed-dialog__item',
											onClick: () => setEmbedDefinition(def),
											children: [
												/* @__PURE__ */ (0, import_jsx_runtime65.jsx)('div', {
													className: 'tlui-embed-dialog__item__image',
													children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)('div', {
														className: 'tlui-embed-dialog__item__image__img',
														style: {
															backgroundImage: `url(${assetUrls2.embedIcons[def.type]})`,
														},
													}),
												}),
												/* @__PURE__ */ (0, import_jsx_runtime65.jsx)('div', {
													className: 'tlui-embed-dialog__item__title',
													children: def.title,
												}),
											],
										},
										def.type
									)
								}),
							}),
							/* @__PURE__ */ (0, import_jsx_runtime65.jsx)('div', {
								className: 'tlui-dialog__scrim',
							}),
						],
				  }),
		],
	})
})

// ../packages/ui/src/lib/hooks/useClipboardEvents.ts
init_define_process()
var import_lz_string = __toESM(require_lz_string())
var import_react73 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/clipboard/pasteExcalidrawContent.ts
init_define_process()
async function pasteExcalidrawContent(app, clipboard, point2) {
	const { elements, files } = clipboard
	const tldrawContent = {
		shapes: [],
		rootShapeIds: [],
		assets: [],
		schema: app.store.schema.serialize(),
	}
	const groupShapeIdToChildren = /* @__PURE__ */ new Map()
	const rotatedElements = /* @__PURE__ */ new Map()
	const { currentPageId } = app
	const excElementIdsToTldrawShapeIds = /* @__PURE__ */ new Map()
	const rootShapeIds = []
	const skipIds = /* @__PURE__ */ new Set()
	elements.forEach((element) => {
		excElementIdsToTldrawShapeIds.set(element.id, app.createShapeId())
		if (element.boundElements !== null) {
			for (const boundElement of element.boundElements) {
				if (boundElement.type === 'text') {
					skipIds.add(boundElement.id)
				}
			}
		}
	})
	let index2 = 'a1'
	for (const element of elements) {
		if (skipIds.has(element.id)) {
			continue
		}
		const id = excElementIdsToTldrawShapeIds.get(element.id)
		const base = {
			id,
			typeName: 'shape',
			parentId: currentPageId,
			index: index2,
			x: element.x,
			y: element.y,
			rotation: 0,
			isLocked: element.locked,
		}
		if (element.angle !== 0) {
			rotatedElements.set(id, element.angle)
		}
		if (element.groupIds && element.groupIds.length > 0) {
			if (groupShapeIdToChildren.has(element.groupIds[0])) {
				groupShapeIdToChildren.get(element.groupIds[0])?.push(id)
			} else {
				groupShapeIdToChildren.set(element.groupIds[0], [id])
			}
		} else {
			rootShapeIds.push(id)
		}
		switch (element.type) {
			case 'rectangle':
			case 'ellipse':
			case 'diamond': {
				let text = ''
				let align = 'middle'
				if (element.boundElements !== null) {
					for (const boundElement of element.boundElements) {
						if (boundElement.type === 'text') {
							const labelElement = elements.find((elm) => elm.id === boundElement.id)
							if (labelElement) {
								text = labelElement.text
								align = textAlignToAlignTypes[labelElement.textAlign]
							}
						}
					}
				}
				const colorToUse =
					element.backgroundColor === 'transparent' ? element.strokeColor : element.backgroundColor
				tldrawContent.shapes.push({
					...base,
					type: 'geo',
					props: {
						geo: element.type,
						opacity: getOpacity(element.opacity),
						url: element.link ?? '',
						w: element.width,
						h: element.height,
						size: strokeWidthsToSizes[element.strokeWidth] ?? 'draw',
						color: colorsToColors[colorToUse] ?? 'black',
						text,
						align,
						dash: getDash(element),
						fill: getFill(element),
					},
				})
				break
			}
			case 'freedraw': {
				tldrawContent.shapes.push({
					...base,
					type: 'draw',
					props: {
						dash: getDash(element),
						size: strokeWidthsToSizes[element.strokeWidth],
						opacity: getOpacity(element.opacity),
						color: colorsToColors[element.strokeColor] ?? 'black',
						segments: [
							{
								type: 'free',
								points: element.points.map(([x3, y3, z2 = 0.5]) => ({
									x: x3,
									y: y3,
									z: z2,
								})),
							},
						],
					},
				})
				break
			}
			case 'line': {
				const start = element.points[0]
				const end = element.points[element.points.length - 1]
				const indices = getIndices(element.points.length)
				tldrawContent.shapes.push({
					...base,
					type: 'line',
					props: {
						dash: getDash(element),
						size: strokeWidthsToSizes[element.strokeWidth],
						opacity: getOpacity(element.opacity),
						color: colorsToColors[element.strokeColor] ?? 'black',
						spline: element.roundness ? 'cubic' : 'line',
						handles: {
							start: {
								id: 'start',
								type: 'vertex',
								index: indices[0],
								x: start[0],
								y: start[1],
							},
							end: {
								id: 'end',
								type: 'vertex',
								index: indices[indices.length - 1],
								x: end[0],
								y: end[1],
							},
							...Object.fromEntries(
								element.points.slice(1, -1).map(([x3, y3], i3) => {
									const id2 = uniqueId()
									return [
										id2,
										{
											id: id2,
											type: 'vertex',
											index: indices[i3 + 1],
											x: x3,
											y: y3,
										},
									]
								})
							),
						},
					},
				})
				break
			}
			case 'arrow': {
				let text = ''
				if (element.boundElements !== null) {
					for (const boundElement of element.boundElements) {
						if (boundElement.type === 'text') {
							const labelElement = elements.find((elm) => elm.id === boundElement.id)
							if (labelElement) {
								text = labelElement.text
							}
						}
					}
				}
				const start = element.points[0]
				const end = element.points[element.points.length - 1]
				const startTargetId = excElementIdsToTldrawShapeIds.get(element.startBinding?.elementId)
				const endTargetId = excElementIdsToTldrawShapeIds.get(element.endBinding?.elementId)
				tldrawContent.shapes.push({
					...base,
					type: 'arrow',
					props: {
						text,
						bend: getBend(element, start, end),
						dash: getDash(element),
						opacity: getOpacity(element.opacity),
						size: strokeWidthsToSizes[element.strokeWidth] ?? 'm',
						color: colorsToColors[element.strokeColor] ?? 'black',
						start: startTargetId
							? {
									type: 'binding',
									boundShapeId: startTargetId,
									normalizedAnchor: { x: 0.5, y: 0.5 },
									isExact: false,
							  }
							: {
									type: 'point',
									x: start[0],
									y: start[1],
							  },
						end: endTargetId
							? {
									type: 'binding',
									boundShapeId: endTargetId,
									normalizedAnchor: { x: 0.5, y: 0.5 },
									isExact: false,
							  }
							: {
									type: 'point',
									x: end[0],
									y: end[1],
							  },
						arrowheadEnd: arrowheadsToArrowheadTypes[element.endArrowhead] ?? 'none',
						arrowheadStart: arrowheadsToArrowheadTypes[element.startArrowhead] ?? 'none',
					},
				})
				break
			}
			case 'text': {
				const { size, scale } = getFontSizeAndScale(element.fontSize)
				tldrawContent.shapes.push({
					...base,
					type: 'text',
					props: {
						size,
						scale,
						font: fontFamilyToFontType[element.fontFamily] ?? 'draw',
						opacity: getOpacity(element.opacity),
						color: colorsToColors[element.strokeColor] ?? 'black',
						text: element.text,
						align: textAlignToAlignTypes[element.textAlign],
					},
				})
				break
			}
			case 'image': {
				const file = files[element.fileId]
				if (!file) break
				const assetId = AssetRecordType.createId()
				tldrawContent.assets.push({
					id: assetId,
					typeName: 'asset',
					type: 'image',
					props: {
						w: element.width,
						h: element.height,
						name: element.id ?? 'Untitled',
						isAnimated: false,
						mimeType: file.mimeType,
						src: file.dataURL,
					},
				})
				tldrawContent.shapes.push({
					...base,
					type: 'image',
					props: {
						opacity: getOpacity(element.opacity),
						w: element.width,
						h: element.height,
						assetId,
					},
				})
			}
		}
		index2 = getIndexAbove(index2)
	}
	const p3 = point2 ?? (app.inputs.shiftKey ? app.inputs.currentPagePoint : void 0)
	app.mark('paste')
	app.putContent(tldrawContent, {
		point: p3,
		select: false,
		preserveIds: true,
	})
	for (const groupedShapeIds of groupShapeIdToChildren.values()) {
		if (groupedShapeIds.length > 1) {
			app.groupShapes(groupedShapeIds)
			const groupShape = app.getShapeById(groupedShapeIds[0])
			if (groupShape?.parentId && isShapeId(groupShape.parentId)) {
				rootShapeIds.push(groupShape.parentId)
			}
		}
	}
	for (const [id, angle] of rotatedElements) {
		app.select(id)
		app.rotateShapesBy([id], angle)
	}
	const rootShapes = compact(rootShapeIds.map((id) => app.getShapeById(id)))
	const bounds = Box2d.Common(rootShapes.map((s3) => app.getPageBounds(s3)))
	const viewPortCenter = app.viewportPageBounds.center
	app.updateShapes(
		rootShapes.map((s3) => {
			const delta = {
				x: (s3.x ?? 0) - (bounds.x + bounds.w / 2),
				y: (s3.y ?? 0) - (bounds.y + bounds.h / 2),
			}
			return {
				id: s3.id,
				type: s3.type,
				x: viewPortCenter.x + delta.x,
				y: viewPortCenter.y + delta.y,
			}
		})
	)
	app.setSelectedIds(rootShapeIds)
}
var getOpacity = (opacity) => {
	const t4 = opacity / 100
	if (t4 < 0.2) {
		return '0.1'
	} else if (t4 < 0.4) {
		return '0.25'
	} else if (t4 < 0.6) {
		return '0.5'
	} else if (t4 < 0.8) {
		return '0.75'
	}
	return '1'
}
var strokeWidthsToSizes = {
	1: 's',
	2: 'm',
	3: 'l',
	4: 'xl',
}
var fontSizesToSizes = {
	16: 's',
	20: 'm',
	28: 'l',
	36: 'xl',
}
function getFontSizeAndScale(fontSize) {
	const size = fontSizesToSizes[fontSize]
	if (size) {
		return { size, scale: 1 }
	}
	if (fontSize < 16) {
		return { size: 's', scale: fontSize / 16 }
	}
	if (fontSize > 36) {
		return { size: 'xl', scale: fontSize / 36 }
	}
	return { size: 'm', scale: 1 }
}
var fontFamilyToFontType = {
	1: 'draw',
	2: 'sans',
	3: 'mono',
}
var colorsToColors = {
	'#ffffff': 'grey',
	// Strokes
	'#000000': 'black',
	'#343a40': 'black',
	'#495057': 'grey',
	'#c92a2a': 'red',
	'#a61e4d': 'light-red',
	'#862e9c': 'violet',
	'#5f3dc4': 'light-violet',
	'#364fc7': 'blue',
	'#1864ab': 'light-blue',
	'#0b7285': 'light-green',
	'#087f5b': 'light-green',
	'#2b8a3e': 'green',
	'#5c940d': 'light-green',
	'#e67700': 'yellow',
	'#d9480f': 'orange',
	// Backgrounds
	'#ced4da': 'grey',
	'#868e96': 'grey',
	'#fa5252': 'light-red',
	'#e64980': 'red',
	'#be4bdb': 'light-violet',
	'#7950f2': 'violet',
	'#4c6ef5': 'blue',
	'#228be6': 'light-blue',
	'#15aabf': 'light-green',
	'#12b886': 'green',
	'#40c057': 'green',
	'#82c91e': 'light-green',
	'#fab005': 'yellow',
	'#fd7e14': 'orange',
	'#212529': 'grey',
}
var strokeStylesToStrokeTypes = {
	solid: 'draw',
	dashed: 'dashed',
	dotted: 'dotted',
}
var fillStylesToFillType = {
	'cross-hatch': 'pattern',
	hachure: 'pattern',
	solid: 'solid',
}
var textAlignToAlignTypes = {
	left: 'start',
	center: 'middle',
	right: 'end',
}
var arrowheadsToArrowheadTypes = {
	arrow: 'arrow',
	dot: 'dot',
	triangle: 'triangle',
	bar: 'pipe',
}
function getBend(element, startPoint, endPoint) {
	let bend = 0
	if (element.points.length > 2) {
		const start = new Vec2d(startPoint[0], startPoint[1])
		const end = new Vec2d(endPoint[0], endPoint[1])
		const handle = new Vec2d(element.points[1][0], element.points[1][1])
		const delta = Vec2d.Sub(end, start)
		const v3 = Vec2d.Per(delta)
		const med = Vec2d.Med(end, start)
		const A2 = Vec2d.Sub(med, v3)
		const B = Vec2d.Add(med, v3)
		const point2 = Vec2d.NearestPointOnLineSegment(A2, B, handle, false)
		bend = Vec2d.Dist(point2, med)
		if (Vec2d.Clockwise(point2, end, med)) bend *= -1
	}
	return bend
}
var getDash = (element) => {
	let dash = strokeStylesToStrokeTypes[element.strokeStyle] ?? 'draw'
	if (dash === 'draw' && element.roughness === 0) {
		dash = 'solid'
	}
	return dash
}
var getFill = (element) => {
	if (element.backgroundColor === 'transparent') {
		return 'none'
	}
	return fillStylesToFillType[element.fillStyle] ?? 'solid'
}

// ../packages/ui/src/lib/hooks/clipboard/pasteFiles.ts
init_define_process()
async function pasteFiles(app, urls, point2) {
	const p3 = point2 ?? (app.inputs.shiftKey ? app.inputs.currentPagePoint : app.viewportPageCenter)
	const blobs = await Promise.all(urls.map(async (url) => await (await fetch(url)).blob()))
	const files = blobs.map(
		(blob) =>
			new File([blob], 'tldrawFile', {
				type: blob.type,
			})
	)
	app.mark('paste')
	await createShapesFromFiles(app, files, p3, false)
	urls.forEach((url) => URL.revokeObjectURL(url))
}

// ../packages/ui/src/lib/hooks/clipboard/pastePlainText.ts
init_define_process()
var rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/
function replaceTabsWithSpaces(text) {
	return text.replace(/\t/g, INDENT)
}
function stripCommonMinimumIndentation(text) {
	const lines = text.split('\n')
	while (lines[0].trim().length === 0) {
		lines.shift()
	}
	let minIndentation = Infinity
	for (const line of lines) {
		if (line.trim().length > 0) {
			const indentation = line.length - line.trimStart().length
			minIndentation = Math.min(minIndentation, indentation)
		}
	}
	return lines.map((line) => line.slice(minIndentation)).join('\n')
}
function stripTrailingWhitespace(text) {
	return text.replace(/[ \t]+$/gm, '').replace(/\n+$/, '')
}
async function pastePlainText(app, text, point2) {
	const p3 = point2 ?? (app.inputs.shiftKey ? app.inputs.currentPagePoint : app.viewportPageCenter)
	const defaultProps = app.getShapeUtil(TLTextUtil).defaultProps()
	const textToPaste = stripTrailingWhitespace(
		stripCommonMinimumIndentation(replaceTabsWithSpaces(text))
	)
	let w3
	let h3
	let autoSize
	let align = 'middle'
	const isMultiLine = textToPaste.split('\n').length > 1
	const isRtl = rtlRegex.test(textToPaste)
	if (isMultiLine) {
		align = isMultiLine ? (isRtl ? 'end' : 'start') : 'middle'
	}
	const rawSize = app.textMeasure.measureText(textToPaste, {
		...TEXT_PROPS,
		fontFamily: FONT_FAMILIES[defaultProps.font],
		fontSize: FONT_SIZES[defaultProps.size],
		width: 'fit-content',
	})
	const minWidth = Math.min(
		isMultiLine ? app.viewportPageBounds.width * 0.9 : 920,
		Math.max(200, app.viewportPageBounds.width * 0.9)
	)
	if (rawSize.w > minWidth) {
		const shrunkSize = app.textMeasure.measureText(textToPaste, {
			...TEXT_PROPS,
			fontFamily: FONT_FAMILIES[defaultProps.font],
			fontSize: FONT_SIZES[defaultProps.size],
			width: minWidth + 'px',
		})
		w3 = shrunkSize.w
		h3 = shrunkSize.h
		autoSize = false
		align = isRtl ? 'end' : 'start'
	} else {
		w3 = rawSize.w
		h3 = rawSize.h
		autoSize = true
	}
	if (p3.y - h3 / 2 < app.viewportPageBounds.minY + 40) {
		p3.y = app.viewportPageBounds.minY + 40 + h3 / 2
	}
	app.mark('paste')
	app.createShapes([
		{
			id: createShapeId(),
			type: 'text',
			x: p3.x - w3 / 2,
			y: p3.y - h3 / 2,
			props: {
				text: textToPaste,
				// if the text has more than one line, align it to the left
				align,
				autoSize,
				w: w3,
			},
		},
	])
}

// ../packages/ui/src/lib/hooks/clipboard/pasteSvgText.ts
init_define_process()
async function pasteSvgText(app, text, point2) {
	const p3 = point2 ?? (app.inputs.shiftKey ? app.inputs.currentPagePoint : app.viewportPageCenter)
	app.mark('paste')
	return await createAssetShapeAtPoint(app, text, p3)
}

// ../packages/ui/src/lib/hooks/clipboard/pasteTldrawContent.ts
init_define_process()
function pasteTldrawContent(app, clipboard, point2) {
	const p3 = point2 ?? (app.inputs.shiftKey ? app.inputs.currentPagePoint : void 0)
	app.mark('paste')
	app.putContent(clipboard, {
		point: p3,
		select: true,
	})
}

// ../packages/ui/src/lib/hooks/clipboard/pasteUrl.ts
init_define_process()
async function pasteUrl(app, url, point2) {
	const p3 = point2 ?? (app.inputs.shiftKey ? app.inputs.currentPagePoint : app.viewportPageCenter)
	try {
		const resp = await fetch(url)
		if (resp.headers.get('content-type')?.match(/^image\//)) {
			app.mark('paste')
			pasteFiles(app, [url])
			return
		}
	} catch (err) {
		if (err.message !== 'Failed to fetch') {
			console.error(err)
		}
	}
	app.mark('paste')
	const embedInfo = getEmbedInfo(url)
	if (embedInfo) {
		return await createEmbedShapeAtPoint(app, embedInfo.url, p3, embedInfo.definition)
	}
	return await createBookmarkShapeAtPoint(app, url, p3)
}

// ../packages/ui/src/lib/hooks/useAppIsFocused.ts
init_define_process()
function useAppIsFocused() {
	const app = useApp()
	return useValue('app.isFocused', () => app.isFocused, [app])
}

// ../packages/ui/src/lib/hooks/useClipboardEvents.ts
var INPUTS2 = ['input', 'select', 'textarea']
function disallowClipboardEvents(app) {
	const { activeElement } = document
	return (
		app.isMenuOpen ||
		(activeElement &&
			(activeElement.getAttribute('contenteditable') ||
				INPUTS2.indexOf(activeElement.tagName.toLowerCase()) > -1))
	)
}
async function blobAsString2(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader()
		reader.addEventListener('loadend', () => {
			const text = reader.result
			resolve(text)
		})
		reader.addEventListener('error', () => {
			reject(reader.error)
		})
		reader.readAsText(blob)
	})
}
function stripHtml(html) {
	const doc = document.implementation.createHTMLDocument('')
	doc.documentElement.innerHTML = html.trim()
	return doc.body.textContent || doc.body.innerText || ''
}
var isFile = (item) => {
	return item.types.find((i3) => i3.match(/^image\//))
}
var handleText = (app, data, point2) => {
	const validUrlList = getValidHttpURLList(data)
	if (validUrlList) {
		for (const url of validUrlList) {
			pasteUrl(app, url, point2)
		}
	} else if (isValidHttpURL(data)) {
		pasteUrl(app, data, point2)
	} else if (isSvgText(data)) {
		pasteSvgText(app, data, point2)
	} else {
		pastePlainText(app, data, point2)
	}
}
var handlePasteFromEventClipboardData = async (app, clipboardData, point2) => {
	if (app.editingId !== null) return
	if (!clipboardData) {
		throw Error('No clipboard data')
	}
	const things = []
	for (const item of Object.values(clipboardData.items)) {
		switch (item.kind) {
			case 'file': {
				things.push({
					type: 'file',
					source: new Promise((r3) => r3(item.getAsFile())),
				})
				break
			}
			case 'string': {
				if (item.type === 'text/html') {
					things.push({
						type: 'html',
						source: new Promise((r3) => item.getAsString(r3)),
					})
				} else if (item.type === 'text/plain') {
					things.push({
						type: 'text',
						source: new Promise((r3) => item.getAsString(r3)),
					})
				} else {
					things.push({ type: item.type, source: new Promise((r3) => item.getAsString(r3)) })
				}
				break
			}
		}
	}
	handleClipboardThings(app, things, point2)
}
var handlePasteFromClipboardApi = async (app, clipboardItems, point2) => {
	const things = []
	for (const item of clipboardItems) {
		if (isFile(item)) {
			for (const type of item.types) {
				if (type.match(/^image\//)) {
					things.push({ type: 'blob', source: item.getType(type) })
				}
			}
		}
		if (item.types.includes('text/html')) {
			things.push({
				type: 'html',
				source: new Promise((r3) =>
					item.getType('text/html').then((blob) => blobAsString2(blob).then(r3))
				),
			})
		}
		if (item.types.includes('text/uri-list')) {
			things.push({
				type: 'url',
				source: new Promise((r3) =>
					item.getType('text/uri-list').then((blob) => blobAsString2(blob).then(r3))
				),
			})
		}
		if (item.types.includes('text/plain')) {
			things.push({
				type: 'text',
				source: new Promise((r3) =>
					item.getType('text/plain').then((blob) => blobAsString2(blob).then(r3))
				),
			})
		}
	}
	return await handleClipboardThings(app, things, point2)
}
async function handleClipboardThings(app, things, point2) {
	const files = things.filter(
		(t4) => (t4.type === 'file' || t4.type === 'blob') && t4.source !== null
	)
	if (files.length) {
		const fileBlobs = await Promise.all(files.map((t4) => t4.source))
		const urls = fileBlobs.filter(Boolean).map((blob) => URL.createObjectURL(blob))
		return await pasteFiles(app, urls, point2)
	}
	const results = await Promise.all(
		things
			.filter((t4) => t4.type !== 'file')
			.map(
				(t4) =>
					new Promise((r3) => {
						const thing = t4
						if (thing.type === 'file') {
							r3({ type: 'error', data: null, reason: 'unexpected file' })
							return
						}
						thing.source.then((text) => {
							const tldrawHtmlComment = text.match(/<tldraw[^>]*>(.*)<\/tldraw>/)?.[1]
							if (tldrawHtmlComment) {
								try {
									const jsonComment = (0, import_lz_string.decompressFromBase64)(tldrawHtmlComment)
									if (jsonComment === null) {
										r3({
											type: 'error',
											data: jsonComment,
											reason: `found tldraw data comment but could not parse base64`,
										})
										return
									} else {
										const json = JSON.parse(jsonComment)
										if (json.type !== 'application/tldraw') {
											r3({
												type: 'error',
												data: json,
												reason: `found tldraw data comment but JSON was of a different type: ${json.type}`,
											})
										}
										if (typeof json.data === 'string') {
											r3({
												type: 'error',
												data: json,
												reason:
													'found tldraw json but data was a string instead of a TLClipboardModel object',
											})
											return
										}
										r3({ type: 'tldraw', data: json.data })
										return
									}
								} catch (e2) {
									r3({
										type: 'error',
										data: tldrawHtmlComment,
										reason:
											'found tldraw json but data was a string instead of a TLClipboardModel object',
									})
									return
								}
							} else {
								if (thing.type === 'html') {
									r3({ type: 'text', data: text, subtype: 'html' })
									return
								}
								if (thing.type === 'url') {
									r3({ type: 'text', data: text, subtype: 'url' })
									return
								}
								try {
									const json = JSON.parse(text)
									if (json.type === 'excalidraw/clipboard') {
										r3({ type: 'excalidraw', data: json })
										return
									} else {
										r3({ type: 'text', data: text, subtype: 'json' })
										return
									}
								} catch (e2) {
									r3({ type: 'text', data: text, subtype: 'text' })
									return
								}
							}
							r3({ type: 'error', data: text, reason: 'unhandled case' })
						})
					})
			)
	)
	for (const result of results) {
		if (result.type === 'tldraw') {
			pasteTldrawContent(app, result.data, point2)
			return
		}
	}
	for (const result of results) {
		if (result.type === 'excalidraw') {
			pasteExcalidrawContent(app, result.data, point2)
			return
		}
	}
	for (const result of results) {
		if (result.type === 'text' && result.subtype === 'html') {
			const rootNode = new DOMParser().parseFromString(result.data, 'text/html')
			const bodyNode = rootNode.querySelector('body')
			const isHtmlSingleLink =
				bodyNode &&
				Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 &&
				bodyNode.firstElementChild &&
				bodyNode.firstElementChild.tagName === 'A' &&
				bodyNode.firstElementChild.hasAttribute('href') &&
				bodyNode.firstElementChild.getAttribute('href') !== ''
			if (isHtmlSingleLink) {
				const href = bodyNode.firstElementChild.getAttribute('href')
				handleText(app, href, point2)
				return
			}
			if (
				!results.some((r3) => r3.type === 'text' && r3.subtype !== 'html') &&
				result.data.trim()
			) {
				handleText(app, stripHtml(result.data), point2)
				return
			}
		}
	}
	for (const result of results) {
		if (result.type === 'text' && result.subtype === 'url') {
			pasteUrl(app, result.data, point2)
			return
		}
	}
	for (const result of results) {
		if (result.type === 'text' && result.subtype === 'text' && result.data.trim()) {
			handleText(app, result.data, point2)
			return
		}
	}
}
var handleNativeOrMenuCopy = (app) => {
	const content = app.getContent()
	if (!content) {
		if (navigator && navigator.clipboard) {
			navigator.clipboard.writeText('')
		}
		return
	}
	const stringifiedClipboard = (0, import_lz_string.compressToBase64)(
		JSON.stringify({
			type: 'application/tldraw',
			kind: 'content',
			data: content,
		})
	)
	if (typeof window?.navigator !== 'undefined') {
		const textItems = content.shapes
			.map((shape) => {
				if (
					app.isShapeOfType(shape, TLTextUtil) ||
					app.isShapeOfType(shape, TLGeoUtil) ||
					app.isShapeOfType(shape, TLArrowUtil)
				) {
					return shape.props.text
				}
				if (app.isShapeOfType(shape, TLBookmarkUtil) || app.isShapeOfType(shape, TLEmbedUtil)) {
					return shape.props.url
				}
				return null
			})
			.filter(isNonNull)
		if (navigator.clipboard?.write) {
			const htmlBlob = new Blob([`<tldraw>${stringifiedClipboard}</tldraw>`], {
				type: 'text/html',
			})
			let textContent = textItems.join(' ')
			if (textContent === '') {
				textContent = ' '
			}
			navigator.clipboard.write([
				new ClipboardItem({
					'text/html': htmlBlob,
					// What is this second blob used for?
					'text/plain': new Blob([textContent], { type: 'text/plain' }),
				}),
			])
		} else if (navigator.clipboard.writeText) {
			navigator.clipboard.writeText(`<tldraw>${stringifiedClipboard}</tldraw>`)
		}
	}
}
function useMenuClipboardEvents() {
	const app = useApp()
	const trackEvent = useEvents()
	const copy = (0, import_react73.useCallback)(
		function onCopy(source) {
			if (app.selectedIds.length === 0) return
			handleNativeOrMenuCopy(app)
			trackEvent('copy', { source })
		},
		[app, trackEvent]
	)
	const cut = (0, import_react73.useCallback)(
		function onCut(source) {
			if (app.selectedIds.length === 0) return
			handleNativeOrMenuCopy(app)
			app.deleteShapes()
			trackEvent('cut', { source })
		},
		[app, trackEvent]
	)
	const paste = (0, import_react73.useCallback)(
		async function onPaste(data, source, point2) {
			if (app.editingId !== null || disallowClipboardEvents(app)) return
			if (Array.isArray(data) && data[0] instanceof ClipboardItem) {
				handlePasteFromClipboardApi(app, data, point2)
				trackEvent('paste', { source: 'menu' })
			} else {
				navigator.clipboard.read().then((clipboardItems) => {
					paste(clipboardItems, source, point2)
				})
			}
		},
		[app, trackEvent]
	)
	return {
		copy,
		cut,
		paste,
	}
}
function useNativeClipboardEvents() {
	const app = useApp()
	const trackEvent = useEvents()
	const appIsFocused = useAppIsFocused()
	;(0, import_react73.useEffect)(() => {
		if (!appIsFocused) return
		const copy = () => {
			if (app.selectedIds.length === 0 || app.editingId !== null || disallowClipboardEvents(app))
				return
			handleNativeOrMenuCopy(app)
			trackEvent('copy', { source: 'kbd' })
		}
		function cut() {
			if (app.selectedIds.length === 0 || app.editingId !== null || disallowClipboardEvents(app))
				return
			handleNativeOrMenuCopy(app)
			app.deleteShapes()
			trackEvent('cut', { source: 'kbd' })
		}
		let disablingMiddleClickPaste = false
		const pointerUpHandler = (e2) => {
			if (e2.button === 1) {
				disablingMiddleClickPaste = true
				requestAnimationFrame(() => {
					disablingMiddleClickPaste = false
				})
			}
		}
		const paste = (event) => {
			if (disablingMiddleClickPaste) {
				event.stopPropagation()
				return
			}
			if (app.editingId !== null || disallowClipboardEvents(app)) return
			if (event.clipboardData && !app.inputs.shiftKey) {
				handlePasteFromEventClipboardData(app, event.clipboardData)
			} else {
				navigator.clipboard.read().then((clipboardItems) => {
					if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
						handlePasteFromClipboardApi(app, clipboardItems, app.inputs.currentPagePoint)
					}
				})
			}
			trackEvent('paste', { source: 'kbd' })
		}
		document.addEventListener('copy', copy)
		document.addEventListener('cut', cut)
		document.addEventListener('paste', paste)
		document.addEventListener('pointerup', pointerUpHandler)
		return () => {
			document.removeEventListener('copy', copy)
			document.removeEventListener('cut', cut)
			document.removeEventListener('paste', paste)
			document.removeEventListener('pointerup', pointerUpHandler)
		}
	}, [app, trackEvent, appIsFocused])
}

// ../packages/ui/src/lib/hooks/useCopyAs.ts
init_define_process()
var import_react75 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/useToastsProvider.tsx
init_define_process()
var import_react74 = __toESM(require_react())
var import_jsx_runtime66 = __toESM(require_jsx_runtime())
var ToastsContext = (0, import_react74.createContext)({})
function ToastsProvider({ children }) {
	const [toasts, setToasts] = (0, import_react74.useState)([])
	const addToast = (0, import_react74.useCallback)((toast) => {
		const id = toast.id ?? uniqueId()
		setToasts((d3) => [...d3.filter((m3) => m3.id !== toast.id), { ...toast, id }])
		return id
	}, [])
	const removeToast = (0, import_react74.useCallback)((id) => {
		setToasts((d3) => d3.filter((m3) => m3.id !== id))
		return id
	}, [])
	const clearToasts = (0, import_react74.useCallback)(() => {
		setToasts(() => [])
	}, [])
	return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(ToastsContext.Provider, {
		value: { toasts, addToast, removeToast, clearToasts },
		children,
	})
}
function useToasts() {
	const ctx = (0, import_react74.useContext)(ToastsContext)
	if (!ctx) {
		throw new Error('useToasts must be used within a ToastsProvider')
	}
	return ctx
}

// ../packages/ui/src/lib/hooks/useCopyAs.ts
function useCopyAs() {
	const app = useApp()
	const { addToast } = useToasts()
	const msg2 = useTranslation()
	return (0, import_react75.useCallback)(
		// it's important that this function itself isn't async - we need to
		// create the relevant `ClipboardItem`s synchronously to make sure
		// safari knows that the user _wants_ to copy:
		// https://bugs.webkit.org/show_bug.cgi?id=222262
		//
		// this is fine for navigator.clipboard.write, but for fallbacks it's a
		// little awkward.
		function copyAs(ids = app.selectedIds, format = 'svg') {
			if (ids.length === 0) {
				ids = [...app.shapeIds]
			}
			if (ids.length === 0) {
				return
			}
			switch (format) {
				case 'svg': {
					if (window.navigator.clipboard) {
						if (window.navigator.clipboard.write) {
							window.navigator.clipboard.write([
								new ClipboardItem({
									'text/plain': getExportedSvgBlob(app, ids),
								}),
							])
						} else {
							fallbackWriteTextAsync(async () =>
								getSvgAsString(await getExportSvgElement(app, ids))
							)
						}
					}
					break
				}
				case 'jpeg':
				case 'png': {
					const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png'
					const blobPromise = getExportedImageBlob(app, ids, format).then((blob) => {
						if (blob) {
							if (window.navigator.clipboard) {
								return blob
							}
							throw new Error('Copy not supported')
						} else {
							addToast({
								id: 'copy-fail',
								icon: 'warning-triangle',
								title: msg2('toast.error.copy-fail.title'),
								description: msg2('toast.error.copy-fail.desc'),
							})
							throw new Error('Copy not possible')
						}
					})
					window.navigator.clipboard
						.write([
							new ClipboardItem({
								// Note: This needs to use the promise based approach for safari/ios to not bail on a permissions error.
								[mimeType]: blobPromise,
							}),
						])
						.catch((err) => {
							if (!err.toString().match(/^TypeError: DOMString not supported/)) {
								console.error(err)
							}
							blobPromise.then((blob) => {
								window.navigator.clipboard.write([
									new ClipboardItem({
										// Note: This needs to use the promise based approach for safari/ios to not bail on a permissions error.
										[mimeType]: blob,
									}),
								])
							})
						})
					break
				}
				case 'json': {
					const data = app.getContent(ids)
					if (window.navigator.clipboard) {
						const jsonStr = JSON.stringify(data)
						if (window.navigator.clipboard.write) {
							window.navigator.clipboard.write([
								new ClipboardItem({
									'text/plain': new Blob([jsonStr], { type: 'text/plain' }),
								}),
							])
						} else {
							fallbackWriteTextAsync(async () => jsonStr)
						}
					}
					break
				}
				default:
					throw new Error(`Copy type ${format} not supported.`)
			}
		},
		[app, addToast, msg2]
	)
}
async function getExportSvgElement(app, ids) {
	const svg = await app.getSvg(ids, {
		scale: 1,
		background: app.instanceState.exportBackground,
	})
	if (!svg) throw new Error('Could not construct SVG.')
	return svg
}
async function getExportedSvgBlob(app, ids) {
	return new Blob([getSvgAsString(await getExportSvgElement(app, ids))], {
		type: 'text/plain',
	})
}
async function getExportedImageBlob(app, ids, format) {
	return await getSvgAsImage(await getExportSvgElement(app, ids), {
		type: format,
		quality: 1,
		scale: 2,
	})
}
async function fallbackWriteTextAsync(getText) {
	if (!(navigator && navigator.clipboard)) return
	navigator.clipboard.writeText(await getText())
}

// ../packages/ui/src/lib/hooks/useDialogsProvider.tsx
init_define_process()
var import_react76 = __toESM(require_react())
var import_jsx_runtime67 = __toESM(require_jsx_runtime())
var DialogsContext = (0, import_react76.createContext)({})
function DialogsProvider({ children }) {
	const app = useApp()
	const trackEvent = useEvents()
	const [dialogs, setDialogs] = (0, import_react76.useState)([])
	const addDialog = (0, import_react76.useCallback)(
		(dialog) => {
			const id = dialog.id ?? uniqueId()
			setDialogs((d3) => {
				return [...d3.filter((m3) => m3.id !== dialog.id), { ...dialog, id }]
			})
			trackEvent('open-menu', { source: 'dialog', id })
			app.addOpenMenu(id)
			return id
		},
		[app, trackEvent]
	)
	const updateDialog = (0, import_react76.useCallback)(
		(id, newDialogData) => {
			setDialogs((d3) =>
				d3.map((m3) => {
					if (m3.id === id) {
						return {
							...m3,
							...newDialogData,
						}
					}
					return m3
				})
			)
			trackEvent('open-menu', { source: 'dialog', id })
			app.addOpenMenu(id)
			return id
		},
		[app, trackEvent]
	)
	const removeDialog = (0, import_react76.useCallback)(
		(id) => {
			setDialogs((d3) =>
				d3.filter((m3) => {
					if (m3.id === id) {
						m3.onClose?.()
						return false
					}
					return true
				})
			)
			trackEvent('close-menu', { source: 'dialog', id })
			app.deleteOpenMenu(id)
			return id
		},
		[app, trackEvent]
	)
	const clearDialogs = (0, import_react76.useCallback)(() => {
		setDialogs((d3) => {
			d3.forEach((m3) => {
				m3.onClose?.()
				trackEvent('close-menu', { source: 'dialog', id: m3.id })
				app.deleteOpenMenu(m3.id)
			})
			return []
		})
	}, [app, trackEvent])
	return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(DialogsContext.Provider, {
		value: { dialogs, addDialog, removeDialog, clearDialogs, updateDialog },
		children,
	})
}
function useDialogs() {
	const ctx = (0, import_react76.useContext)(DialogsContext)
	if (!ctx) {
		throw new Error('useDialogs must be used within a DialogsProvider')
	}
	return ctx
}

// ../packages/ui/src/lib/hooks/useExportAs.ts
init_define_process()
var import_react77 = __toESM(require_react())
function useExportAs() {
	const app = useApp()
	const { addToast } = useToasts()
	const msg2 = useTranslation()
	return (0, import_react77.useCallback)(
		async function exportAs(ids = app.selectedIds, format = 'png') {
			if (ids.length === 0) {
				ids = [...app.shapeIds]
			}
			if (ids.length === 0) {
				return
			}
			const svg = await app.getSvg(ids, {
				scale: 1,
				background: app.instanceState.exportBackground,
			})
			if (!svg) throw new Error('Could not construct SVG.')
			let name = 'shapes'
			if (ids.length === 1) {
				const first = app.getShapeById(ids[0])
				if (app.isShapeOfType(first, TLFrameUtil)) {
					name = first.props.name ?? 'frame'
				} else {
					name = first.id.replace(/:/, '_')
				}
			}
			switch (format) {
				case 'svg': {
					const dataURL = await getSvgAsDataUrl(svg)
					downloadDataURLAsFile(dataURL, `${name || 'shapes'}.svg`)
					return
				}
				case 'webp':
				case 'png': {
					const image = await getSvgAsImage(svg, {
						type: format,
						quality: 1,
						scale: 2,
					})
					if (!image) {
						addToast({
							id: 'export-fail',
							// icon: 'error',
							title: msg2('toast.error.export-fail.title'),
							description: msg2('toast.error.export-fail.desc'),
						})
						return
					}
					const dataURL = URL.createObjectURL(image)
					downloadDataURLAsFile(dataURL, `${name || 'shapes'}.${format}`)
					URL.revokeObjectURL(dataURL)
					return
				}
				case 'json': {
					const data = app.getContent(ids)
					const dataURL = URL.createObjectURL(
						new Blob([JSON.stringify(data, null, 4)], { type: 'application/json' })
					)
					downloadDataURLAsFile(dataURL, `${name || 'shapes'}.json`)
					URL.revokeObjectURL(dataURL)
					return
				}
				default:
					throw new Error(`Export type ${format} not supported.`)
			}
		},
		[app, addToast, msg2]
	)
}

// ../packages/ui/src/lib/hooks/useInsertMedia.ts
init_define_process()
var import_react78 = __toESM(require_react())
function useInsertMedia() {
	const app = useApp()
	const inputRef = (0, import_react78.useRef)()
	;(0, import_react78.useEffect)(() => {
		const input = window.document.createElement('input')
		input.type = 'file'
		input.accept = ACCEPTED_ASSET_TYPE
		input.multiple = true
		inputRef.current = input
		async function onchange(e2) {
			const fileList = e2.target.files
			if (!fileList || fileList.length === 0) return
			await createShapesFromFiles(app, Array.from(fileList), app.viewportPageBounds.center, false)
			input.value = ''
		}
		input.addEventListener('change', onchange)
		return () => {
			inputRef.current = void 0
			input.removeEventListener('change', onchange)
		}
	}, [app])
	return (0, import_react78.useCallback)(() => {
		inputRef.current?.click()
	}, [inputRef])
}

// ../packages/ui/src/lib/hooks/usePrint.ts
init_define_process()
var import_react79 = __toESM(require_react())
function usePrint() {
	const app = useApp()
	const prevPrintEl = (0, import_react79.useRef)(null)
	const prevStyleEl = (0, import_react79.useRef)(null)
	return (0, import_react79.useCallback)(
		async function printSelectionOrPages() {
			const el = document.createElement('div')
			const style = document.createElement('style')
			const clearElements = (printEl, styleEl) => {
				if (printEl) printEl.innerHTML = ''
				if (styleEl && document.head.contains(styleEl)) document.head.removeChild(styleEl)
				if (printEl && document.body.contains(printEl)) {
					document.body.removeChild(printEl)
				}
			}
			clearElements(prevPrintEl.current, prevStyleEl.current)
			prevPrintEl.current = el
			prevStyleEl.current = style
			const className = `tl-print-surface-${uniqueId()}`
			el.className = className
			const enableMargins = false
			const allowAllPages = false
			style.innerHTML = `
			.${className} {
				display: none;
			}

			.${className} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.${className} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${className}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${className}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${className}__item__header {
					display: none;
				}

				.${className}__item__footer {
					display: none;
					text-align: right;
				}

				.${className}__item__footer__hide {
					display: none;
				}

				${
					!enableMargins
						? ''
						: `
					/**
					 * Note: Safari doesn't support removing the page margins to remove them all!
					 */
					@page {
						margin:0;
					}

					.${className} .${className}__item__header {
						display: block;
					}

					.${className} .${className}__item__footer {
						display: block;
					}
				`
				}
			}

		`
			const beforePrintHandler = () => {
				document.head.appendChild(style)
				document.body.appendChild(el)
			}
			const afterPrintHandler = () => {
				app.once('change-history', () => {
					clearElements(el, style)
				})
			}
			window.addEventListener('beforeprint', beforePrintHandler)
			window.addEventListener('afterprint', afterPrintHandler)
			function addPageToPrint(title, footer, svg) {
				try {
					el.innerHTML += `<div class="${className}__item">
        <div class="${className}__item__header">
          ${title.replace(/</g, '&lt;').replace(/>/g, '&gt;')}
        </div>
        <div class="${className}__item__main">
          ${svg.outerHTML}
        </div>
        <div class="${className}__item__footer ${className}__item__footer__${footer ? '' : 'hide'}">
          ${footer ?? ''}
        </div>
      </div>`
				} catch (e2) {
					console.error(e2)
				}
			}
			function triggerPrint() {
				if (app.isChromeForIos) {
					beforePrintHandler()
					window.print()
				} else if (app.isSafari) {
					beforePrintHandler()
					document.execCommand('print', false)
				} else {
					window.print()
				}
			}
			const { pages, currentPageId, selectedIds } = app
			const preserveAspectRatio = 'xMidYMid meet'
			const svgOpts = {
				scale: 1,
				background: false,
				darkMode: false,
				preserveAspectRatio,
			}
			if (app.selectedIds.length > 0) {
				const svg = await app.getSvg(selectedIds, svgOpts)
				if (svg) {
					const page = pages.find((p3) => p3.id === currentPageId)
					addPageToPrint(`tldraw \u2014 ${page?.name}`, null, svg)
					triggerPrint()
				}
			} else {
				if (allowAllPages) {
					for (let i3 = 0; i3 < pages.length; i3++) {
						const page = pages[i3]
						const svg = await app.getSvg(app.getSortedChildIds(page.id), svgOpts)
						if (svg) {
							addPageToPrint(`tldraw \u2014 ${page.name}`, `${i3}/${pages.length}`, svg)
						}
					}
					triggerPrint()
				} else {
					const page = app.currentPage
					const svg = await app.getSvg(app.getSortedChildIds(page.id), svgOpts)
					if (svg) {
						addPageToPrint(`tldraw \u2014 ${page.name}`, null, svg)
						triggerPrint()
					}
				}
			}
			window.removeEventListener('beforeprint', beforePrintHandler)
			window.removeEventListener('afterprint', afterPrintHandler)
		},
		[app]
	)
}

// ../packages/ui/src/lib/hooks/useActions.tsx
var import_jsx_runtime68 = __toESM(require_jsx_runtime())
var ActionsContext = React45.createContext({})
function makeActions(actions) {
	return Object.fromEntries(actions.map((action) => [action.id, action]))
}
function ActionsProvider({ overrides, children }) {
	const app = useApp()
	const { addDialog, clearDialogs } = useDialogs()
	const { clearToasts } = useToasts()
	const insertMedia = useInsertMedia()
	const printSelectionOrPages = usePrint()
	const { cut, copy, paste } = useMenuClipboardEvents()
	const copyAs = useCopyAs()
	const exportAs = useExportAs()
	const trackEvent = useEvents()
	const actions = React45.useMemo(() => {
		const actions2 = makeActions([
			{
				id: 'edit-link',
				label: 'action.edit-link',
				icon: 'link',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('edit-link', { source })
					app.mark('edit-link')
					addDialog({ component: EditLinkDialog })
				},
			},
			{
				id: 'insert-embed',
				label: 'action.insert-embed',
				readonlyOk: false,
				kbd: '$i',
				onSelect(source) {
					trackEvent('insert-embed', { source })
					addDialog({ component: EmbedDialog })
				},
			},
			{
				id: 'insert-media',
				label: 'action.insert-media',
				kbd: '$u',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('insert-media', { source })
					insertMedia()
				},
			},
			{
				id: 'undo',
				label: 'action.undo',
				icon: 'undo',
				kbd: '$z',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('undo', { source })
					app.undo()
				},
			},
			{
				id: 'redo',
				label: 'action.redo',
				icon: 'redo',
				kbd: '$!z',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('redo', { source })
					app.redo()
				},
			},
			{
				id: 'export-as-svg',
				label: 'action.export-as-svg',
				menuLabel: 'action.export-as-svg.short',
				contextMenuLabel: 'action.export-as-svg.short',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('export-as', { format: 'svg', source })
					exportAs(app.selectedIds, 'svg')
				},
			},
			{
				id: 'export-as-png',
				label: 'action.export-as-png',
				menuLabel: 'action.export-as-png.short',
				contextMenuLabel: 'action.export-as-png.short',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('export-as', { format: 'png', source })
					exportAs(app.selectedIds, 'png')
				},
			},
			{
				id: 'export-as-json',
				label: 'action.export-as-json',
				menuLabel: 'action.export-as-json.short',
				contextMenuLabel: 'action.export-as-json.short',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('export-as', { format: 'json', source })
					exportAs(app.selectedIds, 'json')
				},
			},
			{
				id: 'copy-as-svg',
				label: 'action.copy-as-svg',
				menuLabel: 'action.copy-as-svg.short',
				contextMenuLabel: 'action.copy-as-svg.short',
				kbd: '$!c',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('copy-as', { format: 'svg', source })
					copyAs(app.selectedIds, 'svg')
				},
			},
			{
				id: 'copy-as-png',
				label: 'action.copy-as-png',
				menuLabel: 'action.copy-as-png.short',
				contextMenuLabel: 'action.copy-as-png.short',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('copy-as', { format: 'png', source })
					copyAs(app.selectedIds, 'png')
				},
			},
			{
				id: 'copy-as-json',
				label: 'action.copy-as-json',
				menuLabel: 'action.copy-as-json.short',
				contextMenuLabel: 'action.copy-as-json.short',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('copy-as', { format: 'json', source })
					copyAs(app.selectedIds, 'json')
				},
			},
			{
				id: 'toggle-auto-size',
				label: 'action.toggle-auto-size',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('toggle-auto-size', { source })
					app.mark()
					app.updateShapes(
						app.selectedShapes
							.filter(
								(shape) => app.isShapeOfType(shape, TLTextUtil) && shape.props.autoSize === false
							)
							.map((shape) => {
								return {
									id: shape.id,
									type: shape.type,
									props: {
										...shape.props,
										w: 8,
										autoSize: true,
									},
								}
							})
					)
				},
			},
			{
				id: 'open-embed-link',
				label: 'action.open-embed-link',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('open-embed-link', { source })
					const ids = app.selectedIds
					const warnMsg = 'No embed shapes selected'
					if (ids.length !== 1) {
						console.error(warnMsg)
						return
					}
					const shape = app.getShapeById(ids[0])
					if (!shape || !app.isShapeOfType(shape, TLEmbedUtil)) {
						console.error(warnMsg)
						return
					}
					openWindow(shape.props.url, '_blank')
				},
			},
			{
				id: 'convert-to-bookmark',
				label: 'action.convert-to-bookmark',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('convert-to-bookmark', { source })
					const ids = app.selectedIds
					const shapes = ids.map((id) => app.getShapeById(id))
					const createList = []
					const deleteList = []
					for (const shape of shapes) {
						if (!shape || !app.isShapeOfType(shape, TLEmbedUtil) || !shape.props.url) continue
						const newPos = new Vec2d(shape.x, shape.y)
						newPos.rot(-shape.rotation)
						newPos.add(
							new Vec2d(
								shape.props.w / 2 - DEFAULT_BOOKMARK_WIDTH / 2,
								shape.props.h / 2 - DEFAULT_BOOKMARK_HEIGHT / 2
							)
						)
						newPos.rot(shape.rotation)
						createList.push({
							id: app.createShapeId(),
							type: 'bookmark',
							rotation: shape.rotation,
							x: newPos.x,
							y: newPos.y,
							props: {
								url: shape.props.url,
								opacity: '1',
							},
						})
						deleteList.push(shape.id)
					}
					app.mark('convert shapes to bookmark')
					app.deleteShapes(deleteList)
					app.createShapes(createList)
				},
			},
			{
				id: 'convert-to-embed',
				label: 'action.convert-to-embed',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('convert-to-embed', { source })
					const ids = app.selectedIds
					const shapes = compact(ids.map((id) => app.getShapeById(id)))
					const createList = []
					const deleteList = []
					for (const shape of shapes) {
						if (!app.isShapeOfType(shape, TLBookmarkUtil)) continue
						const { url } = shape.props
						const embedInfo = getEmbedInfo(shape.props.url)
						if (!embedInfo) continue
						if (!embedInfo.definition) continue
						const { width, height, doesResize } = embedInfo.definition
						const newPos = new Vec2d(shape.x, shape.y)
						newPos.rot(-shape.rotation)
						newPos.add(new Vec2d(shape.props.w / 2 - width / 2, shape.props.h / 2 - height / 2))
						newPos.rot(shape.rotation)
						createList.push({
							id: app.createShapeId(),
							type: 'embed',
							x: newPos.x,
							y: newPos.y,
							rotation: shape.rotation,
							props: {
								url,
								w: width,
								h: height,
								doesResize,
							},
						})
						deleteList.push(shape.id)
					}
					app.mark('convert shapes to embed')
					app.deleteShapes(deleteList)
					app.createShapes(createList)
				},
			},
			{
				id: 'duplicate',
				kbd: '$d',
				label: 'action.duplicate',
				icon: 'duplicate',
				readonlyOk: false,
				onSelect(source) {
					if (app.currentToolId !== 'select') return
					trackEvent('duplicate-shapes', { source })
					const ids = app.selectedIds
					const commonBounds = Box2d.Common(compact(ids.map((id) => app.getPageBoundsById(id))))
					const offset = app.canMoveCamera
						? {
								x: commonBounds.width + 10,
								y: 0,
						  }
						: {
								x: 16 / app.zoomLevel,
								y: 16 / app.zoomLevel,
						  }
					app.mark('duplicate shapes')
					app.duplicateShapes(ids, offset)
				},
			},
			{
				id: 'ungroup',
				label: 'action.ungroup',
				kbd: '$!g',
				icon: 'ungroup',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('ungroup-shapes', { source })
					app.mark('ungroup')
					app.ungroupShapes(app.selectedIds)
				},
			},
			{
				id: 'group',
				label: 'action.group',
				kbd: '$g',
				icon: 'group',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('group-shapes', { source })
					if (app.selectedShapes.length === 1 && app.selectedShapes[0].type === 'group') {
						app.mark('ungroup')
						app.ungroupShapes(app.selectedIds)
					} else {
						app.mark('group')
						app.groupShapes(app.selectedIds)
					}
				},
			},
			{
				id: 'align-left',
				label: 'action.align-left',
				kbd: '?A',
				icon: 'align-left',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('align-shapes', { operation: 'left', source })
					app.mark('align left')
					app.alignShapes('left', app.selectedIds)
				},
			},
			{
				id: 'align-center-horizontal',
				label: 'action.align-center-horizontal',
				contextMenuLabel: 'action.align-center-horizontal.short',
				kbd: '?H',
				icon: 'align-center-horizontal',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('align-shapes', { operation: 'center-horizontal', source })
					app.mark('align center horizontal')
					app.alignShapes('center-horizontal', app.selectedIds)
				},
			},
			{
				id: 'align-right',
				label: 'action.align-right',
				kbd: '?D',
				icon: 'align-right',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('align-shapes', { operation: 'right', source })
					app.mark('align right')
					app.alignShapes('right', app.selectedIds)
				},
			},
			{
				id: 'align-center-vertical',
				label: 'action.align-center-vertical',
				contextMenuLabel: 'action.align-center-vertical.short',
				kbd: '?V',
				icon: 'align-center-vertical',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('align-shapes', { operation: 'center-vertical', source })
					app.mark('align center vertical')
					app.alignShapes('center-vertical', app.selectedIds)
				},
			},
			{
				id: 'align-top',
				label: 'action.align-top',
				icon: 'align-top',
				kbd: '?W',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('align-shapes', { operation: 'top', source })
					app.mark('align top')
					app.alignShapes('top', app.selectedIds)
				},
			},
			{
				id: 'align-bottom',
				label: 'action.align-bottom',
				icon: 'align-bottom',
				kbd: '?S',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('align-shapes', { operation: 'bottom', source })
					app.mark('align bottom')
					app.alignShapes('bottom', app.selectedIds)
				},
			},
			{
				id: 'distribute-horizontal',
				label: 'action.distribute-horizontal',
				contextMenuLabel: 'action.distribute-horizontal.short',
				icon: 'distribute-horizontal',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('distribute-shapes', { operation: 'horizontal', source })
					app.mark('distribute horizontal')
					app.distributeShapes('horizontal', app.selectedIds)
				},
			},
			{
				id: 'distribute-vertical',
				label: 'action.distribute-vertical',
				contextMenuLabel: 'action.distribute-vertical.short',
				icon: 'distribute-vertical',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('distribute-shapes', { operation: 'vertical', source })
					app.mark('distribute vertical')
					app.distributeShapes('vertical', app.selectedIds)
				},
			},
			{
				id: 'stretch-horizontal',
				label: 'action.stretch-horizontal',
				contextMenuLabel: 'action.stretch-horizontal.short',
				icon: 'stretch-horizontal',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('stretch-shapes', { operation: 'horizontal', source })
					app.mark('stretch horizontal')
					app.stretchShapes('horizontal', app.selectedIds)
				},
			},
			{
				id: 'stretch-vertical',
				label: 'action.stretch-vertical',
				contextMenuLabel: 'action.stretch-vertical.short',
				icon: 'stretch-vertical',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('stretch-shapes', { operation: 'vertical', source })
					app.mark('stretch vertical')
					app.stretchShapes('vertical', app.selectedIds)
				},
			},
			{
				id: 'flip-horizontal',
				label: 'action.flip-horizontal',
				contextMenuLabel: 'action.flip-horizontal.short',
				kbd: '!h',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('flip-shapes', { operation: 'horizontal', source })
					app.mark('flip horizontal')
					app.flipShapes('horizontal', app.selectedIds)
				},
			},
			{
				id: 'flip-vertical',
				label: 'action.flip-vertical',
				contextMenuLabel: 'action.flip-vertical.short',
				kbd: '!v',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('flip-shapes', { operation: 'vertical', source })
					app.mark('flip vertical')
					app.flipShapes('vertical', app.selectedIds)
				},
			},
			{
				id: 'pack',
				label: 'action.pack',
				icon: 'pack',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('pack-shapes', { source })
					app.mark('pack')
					app.packShapes(app.selectedIds)
				},
			},
			{
				id: 'stack-vertical',
				label: 'action.stack-vertical',
				contextMenuLabel: 'action.stack-vertical.short',
				icon: 'stack-vertical',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('stack-shapes', { operation: 'vertical', source })
					app.mark('stack-vertical')
					app.stackShapes('vertical', app.selectedIds)
				},
			},
			{
				id: 'stack-horizontal',
				label: 'action.stack-horizontal',
				contextMenuLabel: 'action.stack-horizontal.short',
				icon: 'stack-horizontal',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('stack-shapes', { operation: 'horizontal', source })
					app.mark('stack-horizontal')
					app.stackShapes('horizontal', app.selectedIds)
				},
			},
			{
				id: 'bring-to-front',
				label: 'action.bring-to-front',
				kbd: ']',
				icon: 'bring-to-front',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('reorder-shapes', { operation: 'toFront', source })
					app.mark('bring to front')
					app.bringToFront()
				},
			},
			{
				id: 'bring-forward',
				label: 'action.bring-forward',
				icon: 'bring-forward',
				kbd: '?]',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('reorder-shapes', { operation: 'forward', source })
					app.mark('bring forward')
					app.bringForward()
				},
			},
			{
				id: 'send-backward',
				label: 'action.send-backward',
				icon: 'send-backward',
				kbd: '?[',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('reorder-shapes', { operation: 'backward', source })
					app.mark('send backward')
					app.sendBackward()
				},
			},
			{
				id: 'send-to-back',
				label: 'action.send-to-back',
				icon: 'send-to-back',
				kbd: '[',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('reorder-shapes', { operation: 'toBack', source })
					app.mark('send to back')
					app.sendToBack()
				},
			},
			{
				id: 'cut',
				label: 'action.cut',
				kbd: '$x',
				readonlyOk: false,
				onSelect(source) {
					app.mark('cut')
					cut(source)
				},
			},
			{
				id: 'copy',
				label: 'action.copy',
				kbd: '$c',
				readonlyOk: true,
				onSelect(source) {
					copy(source)
				},
			},
			{
				id: 'paste',
				label: 'action.paste',
				kbd: '$v',
				readonlyOk: false,
				onSelect(source) {
					navigator.clipboard?.read().then((clipboardItems) => {
						paste(
							clipboardItems,
							source,
							source === 'context-menu' ? app.inputs.currentPagePoint : void 0
						)
					})
				},
			},
			{
				id: 'select-all',
				label: 'action.select-all',
				kbd: '$a',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('select-all-shapes', { source })
					if (app.currentToolId !== 'select') {
						app.cancel()
						app.setSelectedTool('select')
					}
					app.mark('select all kbd')
					app.selectAll()
				},
			},
			{
				id: 'select-none',
				label: 'action.select-none',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('select-none-shapes', { source })
					app.mark('select none')
					app.selectNone()
				},
			},
			{
				id: 'delete',
				label: 'action.delete',
				kbd: '\u232B',
				icon: 'trash',
				readonlyOk: false,
				onSelect(source) {
					if (app.currentToolId !== 'select') return
					trackEvent('delete-shapes', { source })
					app.mark('delete')
					app.deleteShapes()
				},
			},
			{
				id: 'rotate-cw',
				label: 'action.rotate-cw',
				icon: 'rotate-cw',
				readonlyOk: false,
				onSelect(source) {
					if (app.selectedIds.length === 0) return
					trackEvent('rotate-cw', { source })
					app.mark('rotate-cw')
					const offset = app.selectionRotation % (TAU / 2)
					const dontUseOffset = approximately(offset, 0) || approximately(offset, TAU / 2)
					app.rotateShapesBy(app.selectedIds, TAU / 2 - (dontUseOffset ? 0 : offset))
				},
			},
			{
				id: 'rotate-ccw',
				label: 'action.rotate-ccw',
				icon: 'rotate-ccw',
				readonlyOk: false,
				onSelect(source) {
					if (app.selectedIds.length === 0) return
					trackEvent('rotate-ccw', { source })
					app.mark('rotate-ccw')
					const offset = app.selectionRotation % (TAU / 2)
					const offsetCloseToZero = approximately(offset, 0)
					app.rotateShapesBy(app.selectedIds, offsetCloseToZero ? -(TAU / 2) : -offset)
				},
			},
			{
				id: 'zoom-in',
				label: 'action.zoom-in',
				kbd: '$=',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('zoom-in', { source })
					app.zoomIn(app.viewportScreenCenter, { duration: ANIMATION_MEDIUM_MS })
				},
			},
			{
				id: 'zoom-out',
				label: 'action.zoom-out',
				kbd: '$-',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('zoom-out', { source })
					app.zoomOut(app.viewportScreenCenter, { duration: ANIMATION_MEDIUM_MS })
				},
			},
			{
				id: 'zoom-to-100',
				label: 'action.zoom-to-100',
				icon: 'reset-zoom',
				kbd: '!0',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('reset-zoom', { source })
					app.resetZoom(app.viewportScreenCenter, { duration: ANIMATION_MEDIUM_MS })
				},
			},
			{
				id: 'zoom-to-fit',
				label: 'action.zoom-to-fit',
				kbd: '!1',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('zoom-to-fit', { source })
					app.zoomToFit({ duration: ANIMATION_MEDIUM_MS })
				},
			},
			{
				id: 'zoom-to-selection',
				label: 'action.zoom-to-selection',
				kbd: '!2',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('zoom-to-selection', { source })
					app.zoomToSelection({ duration: ANIMATION_MEDIUM_MS })
				},
			},
			{
				id: 'toggle-snap-mode',
				label: 'action.toggle-snap-mode',
				menuLabel: 'action.toggle-snap-mode.menu',
				readonlyOk: false,
				onSelect(source) {
					trackEvent('toggle-snap-mode', { source })
					app.setSnapMode(!app.isSnapMode)
				},
				checkbox: true,
			},
			{
				id: 'toggle-dark-mode',
				label: 'action.toggle-dark-mode',
				menuLabel: 'action.toggle-dark-mode.menu',
				kbd: '$/',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('toggle-dark-mode', { source })
					app.setDarkMode(!app.isDarkMode)
				},
				checkbox: true,
			},
			{
				id: 'toggle-transparent',
				label: 'action.toggle-transparent',
				menuLabel: 'action.toggle-transparent.menu',
				contextMenuLabel: 'action.toggle-transparent.context-menu',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('toggle-transparent', { source })
					app.updateInstanceState(
						{
							exportBackground: !app.instanceState.exportBackground,
						},
						true
					)
				},
				checkbox: true,
			},
			{
				id: 'toggle-tool-lock',
				label: 'action.toggle-tool-lock',
				menuLabel: 'action.toggle-tool-lock.menu',
				readonlyOk: false,
				kbd: 'q',
				onSelect(source) {
					trackEvent('toggle-tool-lock', { source })
					app.setToolLocked(!app.isToolLocked)
				},
				checkbox: true,
			},
			{
				id: 'toggle-focus-mode',
				label: 'action.toggle-focus-mode',
				menuLabel: 'action.toggle-focus-mode.menu',
				readonlyOk: true,
				kbd: '$.',
				checkbox: true,
				onSelect(source) {
					requestAnimationFrame(() => {
						app.batch(() => {
							trackEvent('toggle-focus-mode', { source })
							clearDialogs()
							clearToasts()
							app.setFocusMode(!app.isFocusMode)
						})
					})
				},
			},
			{
				id: 'toggle-grid',
				label: 'action.toggle-grid',
				menuLabel: 'action.toggle-grid.menu',
				readonlyOk: true,
				kbd: "$'",
				onSelect(source) {
					trackEvent('toggle-grid-mode', { source })
					app.setGridMode(!app.isGridMode)
				},
				checkbox: true,
			},
			{
				id: 'toggle-debug-mode',
				label: 'action.toggle-debug-mode',
				menuLabel: 'action.toggle-debug-mode.menu',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('toggle-debug-mode', { source })
					app.updateInstanceState(
						{
							isDebugMode: !app.instanceState.isDebugMode,
						},
						true
					)
				},
				checkbox: true,
			},
			{
				id: 'print',
				label: 'action.print',
				kbd: '$p',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('print', { source })
					printSelectionOrPages()
				},
			},
			{
				id: 'exit-pen-mode',
				label: 'action.exit-pen-mode',
				icon: 'cross-2',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('exit-pen-mode', { source })
					app.setPenMode(false)
				},
			},
			{
				id: 'stop-following',
				label: 'action.stop-following',
				icon: 'cross-2',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('stop-following', { source })
					app.stopFollowingUser()
				},
			},
			{
				id: 'back-to-content',
				label: 'action.back-to-content',
				icon: 'arrow-left',
				readonlyOk: true,
				onSelect(source) {
					trackEvent('zoom-to-content', { source })
					app.zoomToContent()
				},
			},
		])
		if (overrides) {
			return overrides(app, actions2, void 0)
		}
		return actions2
	}, [
		trackEvent,
		overrides,
		app,
		addDialog,
		insertMedia,
		exportAs,
		copyAs,
		cut,
		copy,
		paste,
		clearDialogs,
		clearToasts,
		printSelectionOrPages,
	])
	return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(ActionsContext.Provider, {
		value: asActions(actions),
		children,
	})
}
function useActions() {
	const ctx = React45.useContext(ActionsContext)
	if (!ctx) {
		throw new Error('useTools must be used within a ToolProvider')
	}
	return ctx
}
function asActions(actions) {
	return actions
}

// ../packages/ui/src/lib/hooks/useActionsMenuSchema.tsx
init_define_process()
var import_react81 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/menuHelpers.ts
init_define_process()
function compactMenuItems(arr) {
	return arr.filter((i3) => i3 !== void 0 && i3 !== null && i3 !== false)
}
function menuGroup(id, ...children) {
	const childItems = compactMenuItems(children)
	if (childItems.length === 0) return null
	return {
		id,
		type: 'group',
		checkbox: childItems.every((child) => child.type === 'item' && child.actionItem.checkbox),
		disabled: childItems.every((child) => child.disabled),
		readonlyOk: childItems.some((child) => child.readonlyOk),
		children: childItems,
	}
}
function menuSubmenu(id, label, ...children) {
	const childItems = compactMenuItems(children)
	if (childItems.length === 0) return null
	return {
		id,
		type: 'submenu',
		label,
		children: childItems,
		disabled: childItems.every((child) => child.disabled),
		readonlyOk: childItems.some((child) => child.readonlyOk),
	}
}
function menuCustom(id, opts = {}) {
	const { readonlyOk = true, disabled = false } = opts
	return {
		id,
		type: 'custom',
		disabled,
		readonlyOk,
	}
}
function menuItem(actionItem, opts = {}) {
	if (!actionItem) {
		throw Error('No action item provided to menuItem')
	}
	if (!actionItem.label) {
		throw Error("Trying to create menu item for action item that doesn't have a label")
	}
	const { checked = false, disabled = false } = opts
	return {
		id: actionItem.id,
		type: 'item',
		actionItem,
		disabled,
		checked,
		readonlyOk: actionItem.readonlyOk,
	}
}
function shapesWithUnboundArrows(app) {
	const { selectedIds } = app
	const selectedShapes = selectedIds.map((id) => {
		return app.getShapeById(id)
	})
	return selectedShapes.filter((shape) => {
		if (!shape) return false
		if (app.isShapeOfType(shape, TLArrowUtil) && shape.props.start.type === 'binding') {
			return false
		}
		if (app.isShapeOfType(shape, TLArrowUtil) && shape.props.end.type === 'binding') {
			return false
		}
		return true
	})
}
var useThreeStackableItems = () => {
	const app = useApp()
	return useValue('threeStackableItems', () => shapesWithUnboundArrows(app).length > 2, [app])
}
var useAllowGroup = () => {
	const app = useApp()
	return useValue('allowGroup', () => shapesWithUnboundArrows(app).length > 1, [app])
}
var useAllowUngroup = () => {
	const app = useApp()
	return useValue(
		'allowUngroup',
		() => app.selectedIds.some((id) => app.getShapeById(id)?.type === 'group'),
		[]
	)
}
var showMenuPaste =
	typeof window !== 'undefined' &&
	'navigator' in window &&
	Boolean(navigator.clipboard) &&
	Boolean(navigator.clipboard.read)

// ../packages/ui/src/lib/hooks/useBreakpoint.tsx
init_define_process()
var import_react80 = __toESM(require_react())

// ../packages/ui/src/lib/constants.ts
init_define_process()
var PORTRAIT_BREAKPOINTS = [0, 380, 420, 460, 580, 640, 840, 1023]

// ../packages/ui/src/lib/hooks/useBreakpoint.tsx
var import_jsx_runtime69 = __toESM(require_jsx_runtime())
var BreakpointContext = import_react80.default.createContext(0)
function BreakPointProvider({ children }) {
	const app = useApp()
	const breakpoint = useValue(
		'breakpoint',
		() => {
			const { width } = app.viewportScreenBounds
			const breakpoints = PORTRAIT_BREAKPOINTS
			for (let i3 = 0; i3 < breakpoints.length - 1; i3++) {
				if (width > breakpoints[i3] && width <= breakpoints[i3 + 1]) {
					return i3
				}
			}
			return breakpoints.length
		},
		[app]
	)
	return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(BreakpointContext.Provider, {
		value: breakpoint,
		children,
	})
}
function useBreakpoint() {
	let breakpoint = (0, import_react80.useContext)(BreakpointContext)
	const layoutQuery = new URL(window.location.href).searchParams.get('layout')
	if (layoutQuery === 'desktop') {
		breakpoint = 7
	} else if (layoutQuery === 'mobile') {
		breakpoint = 1
	}
	return breakpoint
}

// ../packages/ui/src/lib/hooks/useHasLinkShapeSelected.ts
init_define_process()
function useHasLinkShapeSelected() {
	const app = useApp()
	return useValue(
		'hasLinkShapeSelected',
		() => {
			const { selectedShapes } = app
			return (
				selectedShapes.length === 1 &&
				'url' in selectedShapes[0].props &&
				selectedShapes[0].type !== 'embed'
			)
		},
		[app]
	)
}

// ../packages/ui/src/lib/hooks/useActionsMenuSchema.tsx
var import_jsx_runtime70 = __toESM(require_jsx_runtime())
var ActionsMenuSchemaContext = import_react81.default.createContext({})
var ActionsMenuSchemaProvider = track(function ActionsMenuSchemaProvider2({ overrides, children }) {
	const app = useApp()
	const actions = useActions()
	const selectedCount = app.selectedIds.length
	const oneSelected = selectedCount > 0
	const twoSelected = selectedCount > 1
	const threeSelected = selectedCount > 2
	const threeStackableItems = useThreeStackableItems()
	const allowGroup = useAllowGroup()
	const allowUngroup = useAllowUngroup()
	const showEditLink = useHasLinkShapeSelected()
	const breakpoint = useBreakpoint()
	const isZoomedTo100 = app.zoomLevel === 1
	const actionMenuSchema = (0, import_react81.useMemo)(() => {
		const results = [
			menuItem(actions['align-left'], { disabled: !twoSelected }),
			menuItem(actions['align-center-horizontal'], { disabled: !twoSelected }),
			menuItem(actions['align-right'], { disabled: !twoSelected }),
			menuItem(actions['stretch-horizontal'], { disabled: !twoSelected }),
			menuItem(actions['align-top'], { disabled: !twoSelected }),
			menuItem(actions['align-center-vertical'], { disabled: !twoSelected }),
			menuItem(actions['align-bottom'], { disabled: !twoSelected }),
			menuItem(actions['stretch-vertical'], { disabled: !twoSelected }),
			menuItem(actions['distribute-horizontal'], { disabled: !threeSelected }),
			menuItem(actions['distribute-vertical'], { disabled: !threeSelected }),
			menuItem(actions['stack-horizontal'], { disabled: !threeStackableItems }),
			menuItem(actions['stack-vertical'], { disabled: !threeStackableItems }),
			menuItem(actions['send-to-back'], { disabled: !oneSelected }),
			menuItem(actions['send-backward'], { disabled: !oneSelected }),
			menuItem(actions['bring-forward'], { disabled: !oneSelected }),
			menuItem(actions['bring-to-front'], { disabled: !oneSelected }),
			breakpoint < 5
				? menuItem(actions['zoom-to-100'], { disabled: !!isZoomedTo100 })
				: menuItem(actions['rotate-ccw'], { disabled: !oneSelected }),
			menuItem(actions['rotate-cw'], { disabled: !oneSelected }),
			menuItem(actions['edit-link'], { disabled: !showEditLink }),
			allowGroup
				? menuItem(actions['group'], { disabled: !twoSelected })
				: allowUngroup
				? menuItem(actions['ungroup'])
				: menuItem(actions['group'], { disabled: !twoSelected }),
		]
		if (overrides) {
			return overrides(app, results, { actions, oneSelected, twoSelected, threeSelected })
		}
		return results
	}, [
		app,
		isZoomedTo100,
		allowGroup,
		overrides,
		actions,
		oneSelected,
		twoSelected,
		threeSelected,
		threeStackableItems,
		allowUngroup,
		showEditLink,
		breakpoint,
	])
	return /* @__PURE__ */ (0,
	import_jsx_runtime70.jsx)(ActionsMenuSchemaContext.Provider, { value: actionMenuSchema, children })
})
function useActionsMenuSchema() {
	const ctx = import_react81.default.useContext(ActionsMenuSchemaContext)
	if (!ctx) {
		throw new Error('useActionsMenuSchema must be used inside of a ActionsMenuSchemaProvider.')
	}
	return ctx
}

// ../packages/ui/src/lib/hooks/useContextMenuSchema.tsx
init_define_process()
var import_react82 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/useOnlyFlippableShape.ts
init_define_process()
function useOnlyFlippableShape() {
	const app = useApp()
	return useValue(
		'onlyFlippableShape',
		() => {
			const { selectedShapes } = app
			return (
				selectedShapes.length === 1 &&
				selectedShapes.every((shape) => shape.type === 'group' || isShapeWithHandles(shape))
			)
		},
		[app]
	)
}

// ../packages/ui/src/lib/hooks/useShowAutoSizeToggle.ts
init_define_process()
function useShowAutoSizeToggle() {
	const app = useApp()
	return useValue(
		'showAutoSizeToggle',
		() => {
			const { selectedShapes } = app
			return (
				selectedShapes.length === 1 &&
				app.isShapeOfType(selectedShapes[0], TLTextUtil) &&
				selectedShapes[0].props.autoSize === false
			)
		},
		[app]
	)
}

// ../packages/ui/src/lib/hooks/useContextMenuSchema.tsx
var import_jsx_runtime71 = __toESM(require_jsx_runtime())
var ContextMenuSchemaContext = import_react82.default.createContext({})
var ContextMenuSchemaProvider = track(function ContextMenuSchemaProvider2({ overrides, children }) {
	const app = useApp()
	const actions = useActions()
	const showAutoSizeToggle = useShowAutoSizeToggle()
	const onlyFlippableShapeSelected = useOnlyFlippableShape()
	const selectedCount = app.selectedIds.length
	const oneSelected = selectedCount > 0
	const oneEmbedSelected = useValue(
		'oneEmbedSelected',
		() => {
			if (app.selectedIds.length !== 1) return false
			return app.selectedIds.some((selectedId) => {
				const shape = app.getShapeById(selectedId)
				return shape && app.isShapeOfType(shape, TLEmbedUtil) && shape.props.url
			})
		},
		[]
	)
	const oneEmbeddableBookmarkSelected = useValue(
		'oneEmbeddableBookmarkSelected',
		() => {
			if (app.selectedIds.length !== 1) return false
			return app.selectedIds.some((selectedId) => {
				const shape = app.getShapeById(selectedId)
				return shape && app.isShapeOfType(shape, TLBookmarkUtil) && getEmbedInfo(shape.props.url)
			})
		},
		[]
	)
	const twoSelected = selectedCount > 1
	const threeSelected = selectedCount > 2
	const threeStackableItems = useThreeStackableItems()
	const atLeastOneShapeOnPage = useValue('atLeastOneShapeOnPage', () => app.shapeIds.size > 0, [])
	const isTransparentBg = useValue('isTransparentBg', () => app.instanceState.exportBackground, [])
	const allowGroup = useAllowGroup()
	const allowUngroup = useAllowUngroup()
	const hasClipboardWrite = Boolean(window.navigator.clipboard?.write)
	const showEditLink = useHasLinkShapeSelected()
	const contextMenuSchema = (0, import_react82.useMemo)(() => {
		let contextMenuSchema2 = compactMenuItems([
			menuGroup(
				'selection',
				oneEmbedSelected && menuItem(actions['open-embed-link']),
				oneEmbedSelected && menuItem(actions['convert-to-bookmark']),
				oneEmbeddableBookmarkSelected && menuItem(actions['convert-to-embed']),
				showAutoSizeToggle && menuItem(actions['toggle-auto-size']),
				showEditLink && menuItem(actions['edit-link']),
				oneSelected && menuItem(actions['duplicate']),
				allowGroup && menuItem(actions['group']),
				allowUngroup && menuItem(actions['ungroup'])
			),
			menuGroup(
				'modify',
				(twoSelected || onlyFlippableShapeSelected) &&
					menuSubmenu(
						'arrange',
						'context-menu.arrange',
						twoSelected &&
							menuGroup(
								'align',
								menuItem(actions['align-left']),
								menuItem(actions['align-center-horizontal']),
								menuItem(actions['align-right']),
								menuItem(actions['align-top']),
								menuItem(actions['align-center-vertical']),
								menuItem(actions['align-bottom'])
							),
						threeSelected &&
							menuGroup(
								'distribute',
								menuItem(actions['distribute-horizontal']),
								menuItem(actions['distribute-vertical'])
							),
						twoSelected &&
							menuGroup(
								'stretch',
								menuItem(actions['stretch-horizontal']),
								menuItem(actions['stretch-vertical'])
							),
						onlyFlippableShapeSelected &&
							menuGroup(
								'flip',
								menuItem(actions['flip-horizontal']),
								menuItem(actions['flip-vertical'])
							),
						twoSelected &&
							menuGroup(
								'order',
								menuItem(actions['pack'], { disabled: !twoSelected }),
								threeStackableItems && menuItem(actions['stack-vertical']),
								threeStackableItems && menuItem(actions['stack-horizontal'])
							)
					),
				oneSelected &&
					menuSubmenu(
						'reorder',
						'context-menu.reorder',
						menuGroup(
							'reorder',
							menuItem(actions['bring-to-front']),
							menuItem(actions['bring-forward']),
							menuItem(actions['send-backward']),
							menuItem(actions['send-to-back'])
						)
					),
				oneSelected && menuCustom('MOVE_TO_PAGE_MENU', { readonlyOk: false })
			),
			menuGroup(
				'clipboard-group',
				oneSelected && menuItem(actions['cut']),
				oneSelected && menuItem(actions['copy']),
				showMenuPaste && menuItem(actions['paste'])
			),
			atLeastOneShapeOnPage &&
				menuGroup(
					'conversions',
					menuSubmenu(
						'copy-as',
						'context-menu.copy-as',
						menuGroup(
							'copy-as-group',
							menuItem(actions['copy-as-svg']),
							hasClipboardWrite && menuItem(actions['copy-as-png']),
							menuItem(actions['copy-as-json'])
						),
						menuGroup(
							'export-bg',
							menuItem(actions['toggle-transparent'], { checked: !isTransparentBg })
						)
					),
					menuSubmenu(
						'export-as',
						'context-menu.export-as',
						menuGroup(
							'export-as-group',
							menuItem(actions['export-as-svg']),
							menuItem(actions['export-as-png']),
							menuItem(actions['export-as-json'])
						),
						menuGroup(
							'export-bg,',
							menuItem(actions['toggle-transparent'], { checked: !isTransparentBg })
						)
					)
				),
			atLeastOneShapeOnPage &&
				menuGroup(
					'set-selection-group',
					menuItem(actions['select-all']),
					oneSelected && menuItem(actions['select-none'])
				),
			oneSelected && menuGroup('delete-group', menuItem(actions['delete'])),
		])
		if (overrides) {
			contextMenuSchema2 = overrides(app, contextMenuSchema2, {
				actions,
				oneSelected,
				twoSelected,
				threeSelected,
				showAutoSizeToggle,
				showUngroup: allowUngroup,
				onlyFlippableShapeSelected,
			})
		}
		return contextMenuSchema2
	}, [
		app,
		overrides,
		actions,
		oneSelected,
		twoSelected,
		threeSelected,
		showAutoSizeToggle,
		onlyFlippableShapeSelected,
		atLeastOneShapeOnPage,
		threeStackableItems,
		allowGroup,
		allowUngroup,
		hasClipboardWrite,
		showEditLink,
		oneEmbedSelected,
		oneEmbeddableBookmarkSelected,
		isTransparentBg,
	])
	return /* @__PURE__ */ (0,
	import_jsx_runtime71.jsx)(ContextMenuSchemaContext.Provider, { value: contextMenuSchema, children })
})
function useContextMenuSchema() {
	const ctx = import_react82.default.useContext(ContextMenuSchemaContext)
	if (!ctx) {
		throw new Error('useContextMenuSchema must be used inside of a ContextMenuSchemaProvider.')
	}
	return ctx
}

// ../packages/ui/src/lib/hooks/useHelpMenuSchema.tsx
init_define_process()
var import_react84 = __toESM(require_react())

// ../packages/ui/src/lib/components/KeyboardShortcutsDialog.tsx
init_define_process()

// ../packages/ui/src/lib/hooks/useKeyboardShortcutsSchema.tsx
init_define_process()
var import_react83 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/useTools.tsx
init_define_process()
var React49 = __toESM(require_react())
var import_jsx_runtime72 = __toESM(require_jsx_runtime())
var ToolsContext = React49.createContext({})
function ToolsProvider({ overrides, children }) {
	const app = useApp()
	const trackEvent = useEvents()
	const { addDialog } = useDialogs()
	const insertMedia = useInsertMedia()
	const tools = React49.useMemo(() => {
		const tools2 = makeTools([
			{
				id: 'select',
				label: 'tool.select',
				icon: 'tool-pointer',
				kbd: 'v',
				readonlyOk: true,
				onSelect(source) {
					app.setSelectedTool('select')
					trackEvent('select-tool', { source, id: 'select' })
				},
			},
			{
				id: 'hand',
				label: 'tool.hand',
				icon: 'tool-hand',
				kbd: 'h',
				readonlyOk: true,
				onSelect(source) {
					app.setSelectedTool('hand')
					trackEvent('select-tool', { source, id: 'hand' })
				},
			},
			{
				id: 'eraser',
				label: 'tool.eraser',
				icon: 'tool-eraser',
				kbd: 'e',
				readonlyOk: false,
				onSelect(source) {
					app.setSelectedTool('eraser')
					trackEvent('select-tool', { source, id: 'eraser' })
				},
			},
			{
				id: 'draw',
				label: 'tool.draw',
				readonlyOk: false,
				icon: 'tool-pencil',
				kbd: 'd,b,x',
				onSelect(source) {
					app.setSelectedTool('draw')
					trackEvent('select-tool', { source, id: 'draw' })
				},
			},
			...[...TL_GEO_TYPES].map((id) => ({
				id,
				label: `tool.${id}`,
				readonlyOk: false,
				meta: {
					geo: id,
				},
				kbd: id === 'rectangle' ? 'r' : id === 'ellipse' ? 'o' : void 0,
				icon: 'geo-' + id,
				onSelect(source) {
					app.batch(() => {
						app.updateInstanceState(
							{ propsForNextShape: { ...app.instanceState.propsForNextShape, geo: id } },
							true
						)
						app.setSelectedTool('geo')
						trackEvent('select-tool', { source, id: `geo-${id}` })
					})
				},
			})),
			{
				id: 'arrow',
				label: 'tool.arrow',
				readonlyOk: false,
				icon: 'tool-arrow',
				kbd: 'a',
				onSelect(source) {
					app.setSelectedTool('arrow')
					trackEvent('select-tool', { source, id: 'arrow' })
				},
			},
			{
				id: 'line',
				label: 'tool.line',
				readonlyOk: false,
				icon: 'tool-line',
				kbd: 'l',
				onSelect(source) {
					app.setSelectedTool('line')
					trackEvent('select-tool', { source, id: 'line' })
				},
			},
			{
				id: 'frame',
				label: 'tool.frame',
				readonlyOk: false,
				icon: 'tool-frame',
				kbd: 'f',
				onSelect(source) {
					app.setSelectedTool('frame')
					trackEvent('select-tool', { source, id: 'frame' })
				},
			},
			{
				id: 'text',
				label: 'tool.text',
				readonlyOk: false,
				icon: 'tool-text',
				kbd: 't',
				onSelect(source) {
					app.setSelectedTool('text')
					trackEvent('select-tool', { source, id: 'text' })
				},
			},
			{
				id: 'asset',
				label: 'tool.asset',
				readonlyOk: false,
				icon: 'tool-media',
				kbd: '$u',
				onSelect(source) {
					insertMedia()
					trackEvent('select-tool', { source, id: 'media' })
				},
			},
			{
				id: 'note',
				label: 'tool.note',
				readonlyOk: false,
				icon: 'tool-note',
				kbd: 'n',
				onSelect(source) {
					app.setSelectedTool('note')
					trackEvent('select-tool', { source, id: 'note' })
				},
			},
			{
				id: 'laser',
				label: 'tool.laser',
				readonlyOk: true,
				icon: 'tool-laser',
				kbd: 'k',
				onSelect(source) {
					app.setSelectedTool('laser')
					trackEvent('select-tool', { source, id: 'laser' })
				},
			},
			{
				id: 'embed',
				label: 'tool.embed',
				readonlyOk: false,
				icon: 'tool-embed',
				onSelect(source) {
					addDialog({ component: EmbedDialog })
					trackEvent('select-tool', { source, id: 'embed' })
				},
			},
		])
		if (overrides) {
			return overrides(app, tools2, { insertMedia })
		}
		return tools2
	}, [app, trackEvent, overrides, insertMedia, addDialog])
	return /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(ToolsContext.Provider, {
		value: tools,
		children,
	})
}
function makeTools(tools) {
	return Object.fromEntries(tools.map((t4) => [t4.id, t4]))
}
function useTools() {
	const ctx = React49.useContext(ToolsContext)
	if (!ctx) {
		throw new Error('useTools must be used within a ToolProvider')
	}
	return ctx
}

// ../packages/ui/src/lib/hooks/useKeyboardShortcutsSchema.tsx
var import_jsx_runtime73 = __toESM(require_jsx_runtime())
var KeyboardShortcutsSchemaContext = import_react83.default.createContext({})
var KeyboardShortcutsSchemaProvider = track(function KeyboardShortcutsSchemaProvider2({
	overrides,
	children,
}) {
	const app = useApp()
	const tools = useTools()
	const actions = useActions()
	const keyboardShortcutsSchema = (0, import_react83.useMemo)(() => {
		const keyboardShortcutsSchema2 = compact([
			menuGroup(
				'shortcuts-dialog.tools',
				menuItem(actions['toggle-tool-lock']),
				menuItem(tools['select']),
				menuItem(tools['draw']),
				menuItem(tools['eraser']),
				menuItem(tools['hand']),
				menuItem(tools['rectangle']),
				menuItem(tools['ellipse']),
				menuItem(tools['arrow']),
				menuItem(tools['line']),
				menuItem(tools['text']),
				menuItem(tools['frame']),
				menuItem(tools['note']),
				menuItem(tools['laser'])
			),
			menuGroup(
				'shortcuts-dialog.file',
				menuItem(actions['insert-media']),
				menuItem(actions['print'])
			),
			menuGroup(
				'shortcuts-dialog.preferences',
				menuItem(actions['toggle-dark-mode']),
				menuItem(actions['toggle-focus-mode']),
				menuItem(actions['toggle-grid'])
			),
			menuGroup(
				'shortcuts-dialog.edit',
				menuItem(actions['undo']),
				menuItem(actions['redo']),
				menuItem(actions['cut']),
				menuItem(actions['copy']),
				menuItem(actions['paste']),
				menuItem(actions['select-all']),
				menuItem(actions['delete']),
				menuItem(actions['duplicate']),
				menuItem(actions['export-as-svg']),
				menuItem(actions['export-as-png'])
			),
			menuGroup(
				'shortcuts-dialog.view',
				menuItem(actions['zoom-in']),
				menuItem(actions['zoom-out']),
				menuItem(actions['zoom-to-100']),
				menuItem(actions['zoom-to-fit']),
				menuItem(actions['zoom-to-selection'])
			),
			menuGroup(
				'shortcuts-dialog.transform',
				menuItem(actions['bring-to-front']),
				menuItem(actions['bring-forward']),
				menuItem(actions['send-backward']),
				menuItem(actions['send-to-back']),
				menuItem(actions['group']),
				menuItem(actions['ungroup']),
				menuItem(actions['flip-horizontal']),
				menuItem(actions['flip-vertical']),
				menuItem(actions['align-top']),
				menuItem(actions['align-center-vertical']),
				menuItem(actions['align-bottom']),
				menuItem(actions['align-left']),
				menuItem(actions['align-center-horizontal']),
				menuItem(actions['align-right'])
			),
		])
		if (overrides) {
			return overrides(app, keyboardShortcutsSchema2, { tools, actions })
		}
		return keyboardShortcutsSchema2
	}, [app, overrides, actions, tools])
	return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(KeyboardShortcutsSchemaContext.Provider, {
		value: keyboardShortcutsSchema,
		children,
	})
})
function useKeyboardShortcutsSchema() {
	const ctx = import_react83.default.useContext(KeyboardShortcutsSchemaContext)
	if (!ctx) {
		throw new Error('Shortcuts must be used inside of a ShortcutsProvider.')
	}
	return ctx
}

// ../packages/ui/src/lib/hooks/useReadonly.ts
init_define_process()
function useReadonly() {
	const app = useApp()
	return useValue('isReadOnlyMode', () => app.isReadOnly, [app])
}

// ../packages/ui/src/lib/components/KeyboardShortcutsDialog.tsx
var import_jsx_runtime74 = __toESM(require_jsx_runtime())
var KeyboardShortcutsDialog = () => {
	const msg2 = useTranslation()
	const isReadonly = useReadonly()
	const shortcutsItems = useKeyboardShortcutsSchema()
	function getKeyboardShortcutItem(item) {
		if (isReadonly && !item.readonlyOk) return null
		switch (item.type) {
			case 'group': {
				return /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)(
					'div',
					{
						className: 'tlui-shortcuts-dialog__group',
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime74.jsx)('h2', {
								className: 'tlui-shortcuts-dialog__group__title',
								children: msg2(item.id),
							}),
							/* @__PURE__ */ (0, import_jsx_runtime74.jsx)('div', {
								className: 'tlui-shortcuts-dialog__group__content',
								children: item.children
									.filter((item2) => item2.type === 'item' && item2.actionItem.kbd)
									.map(getKeyboardShortcutItem),
							}),
						],
					},
					item.id
				)
			}
			case 'item': {
				const { id, label, shortcutsLabel, kbd: kbd2 } = item.actionItem
				return /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)(
					'div',
					{
						className: 'tlui-shortcuts-dialog__key-pair',
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime74.jsx)('div', {
								className: 'tlui-shortcuts-dialog__key-pair__key',
								children: msg2(shortcutsLabel ?? label),
							}),
							/* @__PURE__ */ (0, import_jsx_runtime74.jsx)('div', {
								className: 'tlui-shortcuts-dialog__key-pair__value',
								children: /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(Kbd, { children: kbd2 }),
							}),
						],
					},
					id
				)
			}
		}
	}
	return /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)(import_jsx_runtime74.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime74.jsxs)(Header, {
				className: 'tlui-shortcuts-dialog__header',
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime74.jsx)(Title, {
						children: msg2('shortcuts-dialog.title'),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime74.jsx)(CloseButton, {}),
				],
			}),
			/* @__PURE__ */ (0, import_jsx_runtime74.jsx)(Body, {
				className: 'tlui-shortcuts-dialog__body',
				children: shortcutsItems.map(getKeyboardShortcutItem),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime74.jsx)('div', { className: 'tlui-dialog__scrim' }),
		],
	})
}

// ../packages/ui/src/lib/hooks/useTranslation/useLanguages.tsx
init_define_process()
function useLanguages() {
	const app = useApp()
	return { languages: LANGUAGES2, currentLanguage: app.locale }
}

// ../packages/ui/src/lib/hooks/useHelpMenuSchema.tsx
var import_jsx_runtime75 = __toESM(require_jsx_runtime())
var HelpMenuSchemaContext = import_react84.default.createContext({})
var HelpMenuSchemaProvider = track(function HelpMenuSchemaProvider2({ overrides, children }) {
	const app = useApp()
	const actions = useActions()
	const selectedCount = app.selectedIds.length
	const oneSelected = selectedCount > 0
	const twoSelected = selectedCount > 1
	const threeSelected = selectedCount > 2
	const { languages, currentLanguage } = useLanguages()
	const { addDialog } = useDialogs()
	const helpMenuSchema = (0, import_react84.useMemo)(() => {
		const helpMenuSchema2 = compact([
			menuGroup(
				'top',
				menuCustom('LANGUAGE_MENU', { readonlyOk: true }),
				menuItem({
					id: 'keyboard-shortcuts',
					label: 'help-menu.keyboard-shortcuts',
					readonlyOk: true,
					onSelect() {
						addDialog({ component: KeyboardShortcutsDialog })
					},
				})
			),
		])
		if (overrides) {
			return overrides(app, helpMenuSchema2, {
				actions,
				currentLanguage,
				languages,
				oneSelected,
				twoSelected,
				threeSelected,
			})
		}
		return helpMenuSchema2
	}, [
		app,
		overrides,
		languages,
		actions,
		oneSelected,
		twoSelected,
		threeSelected,
		currentLanguage,
		addDialog,
	])
	return /* @__PURE__ */ (0,
	import_jsx_runtime75.jsx)(HelpMenuSchemaContext.Provider, { value: helpMenuSchema, children })
})
function useHelpMenuSchema() {
	const ctx = import_react84.default.useContext(HelpMenuSchemaContext)
	if (!ctx) {
		throw new Error('useHelpMenuSchema must be used inside of a helpMenuSchemaProvider.')
	}
	return ctx
}

// ../packages/ui/src/lib/hooks/useMenuSchema.tsx
init_define_process()
var import_react85 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/useCanRedo.ts
init_define_process()
function useCanRedo() {
	const app = useApp()
	return useValue('useCanRedo', () => app.canRedo, [app])
}

// ../packages/ui/src/lib/hooks/useCanUndo.ts
init_define_process()
function useCanUndo() {
	const app = useApp()
	return useValue('useCanUndo', () => app.canUndo, [app])
}

// ../packages/ui/src/lib/hooks/useMenuSchema.tsx
var import_jsx_runtime76 = __toESM(require_jsx_runtime())
var MenuSchemaContext = import_react85.default.createContext({})
function MenuSchemaProvider({ overrides, children }) {
	const app = useApp()
	const actions = useActions()
	const breakpoint = useBreakpoint()
	const isMobile = breakpoint < 5
	const isDarkMode = useValue('isDarkMode', () => app.isDarkMode, [app])
	const isGridMode = useValue('isGridMode', () => app.userDocumentSettings.isGridMode, [app])
	const isSnapMode = useValue('isSnapMode', () => app.userDocumentSettings.isSnapMode, [app])
	const isToolLock = useValue('isToolLock', () => app.instanceState.isToolLocked, [app])
	const isFocusMode = useValue('isFocusMode', () => app.instanceState.isFocusMode, [app])
	const isDebugMode = useValue('isDebugMode', () => app.instanceState.isDebugMode, [app])
	const exportBackground = useValue('exportBackground', () => app.instanceState.exportBackground, [
		app,
	])
	const emptyPage = useValue('emptyPage', () => app.shapeIds.size === 0, [app])
	const selectedCount = useValue('selectedCount', () => app.selectedIds.length, [app])
	const noneSelected = selectedCount === 0
	const oneSelected = selectedCount > 0
	const twoSelected = selectedCount > 1
	const threeSelected = selectedCount > 2
	const hasClipboardWrite = Boolean(window.navigator.clipboard?.write)
	const showEditLink = useHasLinkShapeSelected()
	const showAutoSizeToggle = useShowAutoSizeToggle()
	const allowGroup = useAllowGroup()
	const allowUngroup = useAllowUngroup()
	const canUndo = useCanUndo()
	const canRedo = useCanRedo()
	const isZoomedTo100 = useValue('isZoomedTo100', () => app.zoomLevel === 1, [app])
	const menuSchema = (0, import_react85.useMemo)(() => {
		const menuSchema2 = compact([
			menuGroup(
				'menu',
				menuSubmenu(
					'file',
					'menu.file',
					menuGroup('print', menuItem(actions['print'], { disabled: emptyPage }))
				),
				menuSubmenu(
					'edit',
					'menu.edit',
					menuGroup(
						'undo-actions',
						menuItem(actions['undo'], { disabled: !canUndo }),
						menuItem(actions['redo'], { disabled: !canRedo })
					),
					menuGroup(
						'clipboard-actions',
						menuItem(actions['cut'], { disabled: noneSelected }),
						menuItem(actions['copy'], { disabled: noneSelected }),
						menuItem(actions['paste'], { disabled: !showMenuPaste })
					),
					menuGroup(
						'conversions',
						menuSubmenu(
							'copy-as',
							'menu.copy-as',
							menuGroup(
								'copy-as-group',
								menuItem(actions['copy-as-svg'], { disabled: emptyPage }),
								menuItem(actions['copy-as-png'], { disabled: emptyPage || !hasClipboardWrite }),
								menuItem(actions['copy-as-json'], { disabled: emptyPage })
							),
							menuGroup(
								'export-bg',
								menuItem(actions['toggle-transparent'], { checked: !exportBackground })
							)
						),
						menuSubmenu(
							'export-as',
							'menu.export-as',
							menuGroup(
								'export-as-group',
								menuItem(actions['export-as-svg'], { disabled: emptyPage }),
								menuItem(actions['export-as-png'], { disabled: emptyPage }),
								menuItem(actions['export-as-json'], { disabled: emptyPage })
							),
							menuGroup(
								'export-bg',
								menuItem(actions['toggle-transparent'], { checked: !exportBackground })
							)
						)
					),
					menuGroup(
						'set-selection-group',
						menuItem(actions['select-all'], { disabled: emptyPage }),
						menuItem(actions['select-none'], { disabled: !oneSelected })
					),
					menuGroup(
						'selection',
						showAutoSizeToggle && menuItem(actions['toggle-auto-size']),
						showEditLink && menuItem(actions['edit-link']),
						menuItem(actions['duplicate'], { disabled: !oneSelected }),
						allowGroup && menuItem(actions['group']),
						allowUngroup && menuItem(actions['ungroup'])
					),
					menuGroup('delete-group', menuItem(actions['delete'], { disabled: !oneSelected }))
				),
				menuSubmenu(
					'view',
					'menu.view',
					menuGroup(
						'view-actions',
						menuItem(actions['zoom-in']),
						menuItem(actions['zoom-out']),
						menuItem(actions['zoom-to-100'], { disabled: isZoomedTo100 }),
						menuItem(actions['zoom-to-fit'], { disabled: emptyPage }),
						menuItem(actions['zoom-to-selection'], { disabled: emptyPage || !oneSelected })
					)
				)
			),
			menuGroup('extras', menuItem(actions['insert-embed']), menuItem(actions['insert-media'])),
			menuGroup(
				'preferences',
				menuSubmenu(
					'preferences',
					'menu.preferences',
					menuGroup(
						'preferences-actions',
						menuItem(actions['toggle-snap-mode'], { checked: isSnapMode }),
						menuItem(actions['toggle-tool-lock'], { checked: isToolLock }),
						menuItem(actions['toggle-grid'], { checked: isGridMode }),
						menuItem(actions['toggle-dark-mode'], { checked: isDarkMode }),
						menuItem(actions['toggle-focus-mode'], { checked: isFocusMode }),
						menuItem(actions['toggle-debug-mode'], { checked: isDebugMode })
					)
				),
				isMobile && menuCustom('LANGUAGE_MENU', { readonlyOk: true })
			),
		])
		if (overrides) {
			return overrides(app, menuSchema2, {
				actions,
				noneSelected,
				oneSelected,
				twoSelected,
				threeSelected,
			})
		}
		return menuSchema2
	}, [
		app,
		overrides,
		actions,
		oneSelected,
		twoSelected,
		threeSelected,
		emptyPage,
		isMobile,
		allowGroup,
		allowUngroup,
		showEditLink,
		hasClipboardWrite,
		showAutoSizeToggle,
		noneSelected,
		canUndo,
		canRedo,
		isDarkMode,
		isGridMode,
		isSnapMode,
		isToolLock,
		isFocusMode,
		exportBackground,
		isDebugMode,
		isZoomedTo100,
	])
	return /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(MenuSchemaContext.Provider, {
		value: menuSchema,
		children,
	})
}
function useMenuSchema() {
	const ctx = import_react85.default.useContext(MenuSchemaContext)
	if (!ctx) {
		throw new Error('useMenuSchema must be used inside of a MenuSchemaProvider.')
	}
	return ctx
}

// ../packages/ui/src/lib/hooks/useToolbarSchema.tsx
init_define_process()
var import_react86 = __toESM(require_react())
var import_jsx_runtime77 = __toESM(require_jsx_runtime())
function toolbarItem(toolItem) {
	return {
		id: toolItem.id,
		type: 'item',
		readonlyOk: toolItem.readonlyOk,
		toolItem,
	}
}
var ToolbarSchemaContext = import_react86.default.createContext([])
function ToolbarSchemaProvider({ overrides, children }) {
	const app = useApp()
	const tools = useTools()
	const toolbarSchema = import_react86.default.useMemo(() => {
		const schema = [
			toolbarItem(tools.select),
			toolbarItem(tools.hand),
			toolbarItem(tools.draw),
			toolbarItem(tools.eraser),
			toolbarItem(tools.arrow),
			toolbarItem(tools.text),
			toolbarItem(tools.note),
			toolbarItem(tools.asset),
			toolbarItem(tools['rectangle']),
			toolbarItem(tools['ellipse']),
			toolbarItem(tools['diamond']),
			toolbarItem(tools['triangle']),
			toolbarItem(tools['trapezoid']),
			toolbarItem(tools['rhombus']),
			toolbarItem(tools['pentagon']),
			toolbarItem(tools['hexagon']),
			toolbarItem(tools['octagon']),
			toolbarItem(tools['star']),
			toolbarItem(tools['oval']),
			toolbarItem(tools.line),
			toolbarItem(tools['arrow-right']),
			toolbarItem(tools['arrow-left']),
			toolbarItem(tools['arrow-up']),
			toolbarItem(tools['arrow-down']),
			toolbarItem(tools['x-box']),
			toolbarItem(tools['check-box']),
			toolbarItem(tools.frame),
			toolbarItem(tools.laser),
		]
		if (overrides) {
			return overrides(app, schema, { tools })
		}
		return schema
	}, [app, overrides, tools])
	return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(ToolbarSchemaContext.Provider, {
		value: toolbarSchema,
		children,
	})
}
function useToolbarSchema() {
	const ctx = import_react86.default.useContext(ToolbarSchemaContext)
	if (!ctx) {
		throw new Error('useToolbarSchema must be used within a ToolbarSchemaProvider')
	}
	return ctx
}

// ../packages/ui/src/lib/overrides.ts
init_define_process()
var import_react87 = __toESM(require_react())
function useDefaultHelpers() {
	const { addToast, removeToast, clearToasts } = useToasts()
	const { addDialog, clearDialogs, removeDialog, updateDialog } = useDialogs()
	const breakpoint = useBreakpoint()
	const isMobile = breakpoint < 5
	const msg2 = useTranslation()
	return (0, import_react87.useMemo)(
		() => ({
			addToast,
			removeToast,
			clearToasts,
			addDialog,
			clearDialogs,
			removeDialog,
			updateDialog,
			msg: msg2,
			isMobile,
		}),
		[
			addDialog,
			addToast,
			clearDialogs,
			clearToasts,
			msg2,
			removeDialog,
			removeToast,
			updateDialog,
			isMobile,
		]
	)
}
function mergeOverrides(overrides, defaultHelpers) {
	const mergedTranslations = {}
	for (const override of overrides) {
		if (override.translations) {
			for (const [key, value] of objectMapEntries(override.translations)) {
				let strings = mergedTranslations[key]
				if (!strings) {
					strings = mergedTranslations[key] = {}
				}
				Object.assign(strings, value)
			}
		}
	}
	return {
		actionsMenu: (app, schema, helpers) => {
			for (const override of overrides) {
				if (override.actionsMenu) {
					schema = override.actionsMenu(app, schema, { ...defaultHelpers, ...helpers })
				}
			}
			return schema
		},
		actions: (app, schema) => {
			for (const override of overrides) {
				if (override.actions) {
					schema = override.actions(app, schema, defaultHelpers)
				}
			}
			return schema
		},
		contextMenu: (app, schema, helpers) => {
			for (const override of overrides) {
				if (override.contextMenu) {
					schema = override.contextMenu(app, schema, { ...defaultHelpers, ...helpers })
				}
			}
			return schema
		},
		helpMenu: (app, schema, helpers) => {
			for (const override of overrides) {
				if (override.helpMenu) {
					schema = override.helpMenu(app, schema, { ...defaultHelpers, ...helpers })
				}
			}
			return schema
		},
		menu: (app, schema, helpers) => {
			for (const override of overrides) {
				if (override.menu) {
					schema = override.menu(app, schema, { ...defaultHelpers, ...helpers })
				}
			}
			return schema
		},
		toolbar: (app, schema, helpers) => {
			for (const override of overrides) {
				if (override.toolbar) {
					schema = override.toolbar(app, schema, { ...defaultHelpers, ...helpers })
				}
			}
			return schema
		},
		keyboardShortcutsMenu: (app, schema, helpers) => {
			for (const override of overrides) {
				if (override.keyboardShortcutsMenu) {
					schema = override.keyboardShortcutsMenu(app, schema, { ...defaultHelpers, ...helpers })
				}
			}
			return schema
		},
		tools: (app, schema, helpers) => {
			for (const override of overrides) {
				if (override.tools) {
					schema = override.tools(app, schema, { ...defaultHelpers, ...helpers })
				}
			}
			return schema
		},
		translations: mergedTranslations,
	}
}
function useShallowArrayEquality(array2) {
	return (0, import_react87.useMemo)(() => array2, array2)
}
function useMergedTranslationOverrides(overrides) {
	const overridesArray = useShallowArrayEquality(
		overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
	)
	return (0, import_react87.useMemo)(() => {
		const mergedTranslations = {}
		for (const override of overridesArray) {
			if (override.translations) {
				for (const [key, value] of objectMapEntries(override.translations)) {
					let strings = mergedTranslations[key]
					if (!strings) {
						strings = mergedTranslations[key] = {}
					}
					Object.assign(strings, value)
				}
			}
		}
		return mergedTranslations
	}, [overridesArray])
}
function useMergedOverrides(overrides) {
	const defaultHelpers = useDefaultHelpers()
	const overridesArray = useShallowArrayEquality(
		overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
	)
	return (0, import_react87.useMemo)(
		() => mergeOverrides(overridesArray, defaultHelpers),
		[overridesArray, defaultHelpers]
	)
}

// ../packages/ui/src/lib/TldrawUiContextProvider.tsx
var import_jsx_runtime78 = __toESM(require_jsx_runtime())
function TldrawUiContextProvider({ overrides, assetUrls: assetUrls2, onUiEvent, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(AssetUrlsProvider, {
		assetUrls: assetUrls2 ?? defaultUiAssetUrls,
		children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(TranslationProvider, {
			overrides: useMergedTranslationOverrides(overrides),
			children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(EventsProvider, {
				onEvent: onUiEvent,
				children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ToastsProvider, {
					children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(DialogsProvider, {
						children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(BreakPointProvider, {
							children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(InternalProviders, {
								overrides,
								children,
							}),
						}),
					}),
				}),
			}),
		}),
	})
}
function InternalProviders({ overrides, children }) {
	const mergedOverrides = useMergedOverrides(overrides)
	return /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ActionsProvider, {
		overrides: mergedOverrides.actions,
		children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ToolsProvider, {
			overrides: mergedOverrides.tools,
			children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ToolbarSchemaProvider, {
				overrides: mergedOverrides.toolbar,
				children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ActionsMenuSchemaProvider, {
					overrides: mergedOverrides.actionsMenu,
					children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(KeyboardShortcutsSchemaProvider, {
						overrides: mergedOverrides.keyboardShortcutsMenu,
						children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ContextMenuSchemaProvider, {
							overrides: mergedOverrides.contextMenu,
							children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(HelpMenuSchemaProvider, {
								overrides: mergedOverrides.helpMenu,
								children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(MenuSchemaProvider, {
									overrides: mergedOverrides.menu,
									children,
								}),
							}),
						}),
					}),
				}),
			}),
		}),
	})
}

// ../packages/ui/src/lib/components/BackToContent.tsx
init_define_process()
var import_react88 = __toESM(require_react())
var import_jsx_runtime79 = __toESM(require_jsx_runtime())
function BackToContent() {
	const app = useApp()
	const actions = useActions()
	const action = actions['back-to-content']
	const [showBackToContent, setShowBackToContent] = (0, import_react88.useState)(false)
	;(0, import_react88.useEffect)(() => {
		let showBackToContentPrev = false
		const interval = setInterval(() => {
			const { renderingShapes } = app
			const visibleShapes = renderingShapes.filter((s3) => s3.isInViewport)
			const showBackToContentNow = visibleShapes.length === 0 && app.shapesArray.length > 0
			if (showBackToContentPrev !== showBackToContentNow) {
				setShowBackToContent(showBackToContentNow)
				showBackToContentPrev = showBackToContentNow
			}
		}, 1e3)
		return () => {
			clearInterval(interval)
		}
	}, [app])
	if (!showBackToContent) return null
	return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(Button, {
		iconLeft: action.icon,
		label: action.label,
		onClick: () => {
			action.onSelect('helper-buttons')
			setShowBackToContent(false)
		},
	})
}

// ../packages/ui/src/lib/components/DebugPanel.tsx
init_define_process()
var React54 = __toESM(require_react())
var import_jsx_runtime80 = __toESM(require_jsx_runtime())
var t3 = 0
function createNShapes(app, n3) {
	const shapesToCreate = Array(n3)
	const cols = Math.floor(Math.sqrt(n3))
	for (let i3 = 0; i3 < n3; i3++) {
		t3++
		shapesToCreate[i3] = {
			id: app.createShapeId('box' + t3),
			type: 'geo',
			x: (i3 % cols) * 132,
			y: Math.floor(i3 / cols) * 132,
		}
	}
	app.batch(() => {
		app.createShapes(shapesToCreate).setSelectedIds(shapesToCreate.map((s3) => s3.id))
	})
}
var DebugPanel = React54.memo(function DebugPanel2({ renderDebugMenuItems }) {
	const msg2 = useTranslation()
	return /* @__PURE__ */ (0,
	import_jsx_runtime80.jsxs)('div', { className: 'tlui-debug-panel', children: [/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(CurrentState, {}), /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(ShapeCount, {}), /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(Root, { id: 'debug', children: [/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Trigger, { children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Button, { icon: 'dots-horizontal', title: msg2('debug-panel.more') }) }), /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Content, { side: 'top', align: 'end', alignOffset: 0, children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(DebugMenuContent, { renderDebugMenuItems }) })] })] })
})
var CurrentState = track(function CurrentState2() {
	const app = useApp()
	return /* @__PURE__ */ (0,
	import_jsx_runtime80.jsx)('div', { className: 'tlui-debug-panel__current-state', children: app.root.path.value })
})
var ShapeCount = function ShapeCount2() {
	const app = useApp()
	const count = useValue('rendering shapes count', () => app.renderingShapes.length, [app])
	return /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)('div', { children: [count, ' Shapes'] })
}
function DebugMenuContent({ renderDebugMenuItems }) {
	const app = useApp()
	const { addToast } = useToasts()
	const { addDialog } = useDialogs()
	const [error, setError] = React54.useState(false)
	return /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(import_jsx_runtime80.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(Group, {
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => {
							addToast({
								id: uniqueId(),
								title: 'Something happened',
								description: 'Hey, attend to this thing over here. It might be important!',
								// icon?: string
								// title?: string
								// description?: string
								// actions?: TLToastAction[]
							})
						},
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: 'Show toast',
						}),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => {
							addDialog({
								component: ({ onClose }) =>
									/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(ExampleDialog, {
										displayDontShowAgain: true,
										onCancel: () => {
											onClose()
										},
										onContinue: () => {
											onClose()
										},
									}),
								onClose: () => {},
							})
						},
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: 'Show dialog',
						}),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => createNShapes(app, 100),
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: 'Create 100 shapes',
						}),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => {
							function countDescendants({ children }) {
								let count = 0
								if (!children.length) return 0
								for (const el of [...children]) {
									count++
									count += countDescendants(el)
								}
								return count
							}
							const { selectedShapes } = app
							const shapes = selectedShapes.length === 0 ? app.renderingShapes : selectedShapes
							const elms = shapes.map((shape) => document.getElementById(shape.id).parentElement)
							let descendants = elms.length
							for (const elm of elms) {
								descendants += countDescendants(elm)
							}
							window.alert(`Shapes ${shapes.length}, DOM nodes:${descendants}`)
						},
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: 'Count shapes and nodes',
						}),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => {
							if (!debugFlags.debugCursors.value) {
								debugFlags.debugCursors.set(true)
								const MAX_COLUMNS = 5
								const partials = CURSOR_NAMES.map((name, i3) => {
									return {
										id: app.createShapeId(),
										type: 'geo',
										x: (i3 % MAX_COLUMNS) * 175,
										y: Math.floor(i3 / MAX_COLUMNS) * 175,
										props: {
											text: name,
											w: 150,
											h: 150,
											fill: 'semi',
										},
									}
								})
								app.createShapes(partials)
							} else {
								debugFlags.debugCursors.set(false)
							}
						},
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: debugFlags.debugCursors.value ? 'Debug cursors \u2713' : 'Debug cursors',
						}),
					}),
					(() => {
						if (error) throw Error('oh no!')
					})(),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => {
							setError(true)
						},
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: 'Throw error',
						}),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => {
							hardResetApp()
						},
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: 'Hard reset',
						}),
					}),
				],
			}),
			/* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(Group, {
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => {
							debugFlags.peopleMenu.set(!debugFlags.peopleMenu.value)
							window.location.reload()
						},
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: 'Toggle people menu',
						}),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Item, {
						onClick: () => {
							app.setReadOnly(!app.isReadOnly)
						},
						children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)('span', {
							children: 'Toggle read-only',
						}),
					}),
				],
			}),
			renderDebugMenuItems?.(),
		],
	})
}
var CURSOR_NAMES = [
	'none',
	'default',
	'pointer',
	'cross',
	'move',
	'grab',
	'grabbing',
	'text',
	'resize-edge',
	'resize-corner',
	'ew-resize',
	'ns-resize',
	'nesw-resize',
	'nwse-resize',
	'rotate',
	'nwse-rotate',
	'nesw-rotate',
	'senw-rotate',
	'swne-rotate',
	'zoom-in',
	'zoom-out',
]
function ExampleDialog({
	title = 'title',
	body = 'hello hello hello',
	cancel = 'Cancel',
	confirm = 'Continue',
	displayDontShowAgain = false,
	onCancel,
	onContinue,
}) {
	const [dontShowAgain, setDontShowAgain] = React54.useState(false)
	return /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(import_jsx_runtime80.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(Header, {
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Title, { children: title }),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(CloseButton, {}),
				],
			}),
			/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Body, {
				style: { maxWidth: 350 },
				children: body,
			}),
			/* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(Footer, {
				className: 'tlui-dialog__footer__actions',
				children: [
					displayDontShowAgain &&
						/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Button, {
							onClick: () => setDontShowAgain(!dontShowAgain),
							iconLeft: dontShowAgain ? 'checkbox-checked' : 'checkbox-empty',
							style: { marginRight: 'auto' },
							children: `Don't show again`,
						}),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Button, {
						onClick: onCancel,
						children: cancel,
					}),
					/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(Button, {
						type: 'primary',
						onClick: async () => onContinue(),
						children: confirm,
					}),
				],
			}),
		],
	})
}

// ../packages/ui/src/lib/components/Dialogs.tsx
init_define_process()
var import_react89 = __toESM(require_react())
var import_jsx_runtime81 = __toESM(require_jsx_runtime())
var Dialog = ({ id, component: ModalContent, onClose }) => {
	const { removeDialog } = useDialogs()
	const container = useContainer()
	const handleOpenChange = (0, import_react89.useCallback)(
		(isOpen) => {
			if (!isOpen) {
				if (onClose) {
					try {
						onClose()
					} catch (err) {
						console.warn(err)
					}
				}
				removeDialog(id)
			}
		},
		[id, onClose, removeDialog]
	)
	return /* @__PURE__ */ (0, import_jsx_runtime81.jsx)($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, {
		onOpenChange: handleOpenChange,
		defaultOpen: true,
		children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
			$5d3850c4d0b4e6c7$export$602eac185826482c,
			{
				container,
				children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
					$5d3850c4d0b4e6c7$export$c6fdb837b070b4ff,
					{
						dir: 'ltr',
						className: 'tlui-dialog__overlay',
						children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
							$5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2,
							{
								dir: 'ltr',
								className: 'tlui-dialog__content',
								children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(ModalContent, {
									onClose: () => handleOpenChange(false),
								}),
							}
						),
					}
				),
			}
		),
	})
}
function _Dialogs() {
	const { dialogs } = useDialogs()
	return /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(import_jsx_runtime81.Fragment, {
		children: dialogs.map((dialog) =>
			/* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Dialog, { ...dialog }, dialog.id)
		),
	})
}
var Dialogs = import_react89.default.memo(_Dialogs)

// ../packages/ui/src/lib/components/FollowingIndicator.tsx
init_define_process()
var import_jsx_runtime82 = __toESM(require_jsx_runtime())
function FollowingIndicator() {
	const app = useApp()
	const followingUserId = useValue('follow', () => app.instanceState.followingUserId, [app])
	if (!followingUserId) return null
	return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(FollowingIndicatorInner, {
		userId: followingUserId,
	})
}
function FollowingIndicatorInner({ userId }) {
	const presence = usePresence(userId)
	if (!presence) return null
	return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)('div', {
		className: 'tlui-following',
		style: { borderColor: presence.color },
	})
}

// ../packages/ui/src/lib/components/HelpMenu.tsx
init_define_process()
var React56 = __toESM(require_react())

// ../packages/ui/src/lib/components/LanguageMenu.tsx
init_define_process()
var import_react90 = __toESM(require_react())
var import_jsx_runtime83 = __toESM(require_jsx_runtime())
function LanguageMenu() {
	const app = useApp()
	const { languages, currentLanguage } = useLanguages()
	const handleLanguageSelect = (0, import_react90.useCallback)(
		(locale) => app.setLocale(locale),
		[app]
	)
	return /* @__PURE__ */ (0, import_jsx_runtime83.jsxs)(Sub, {
		id: 'help menu language',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime83.jsx)(SubTrigger, {
				label: 'menu.language',
				'data-direction': 'left',
			}),
			/* @__PURE__ */ (0, import_jsx_runtime83.jsx)(SubContent, {
				sideOffset: -4,
				children: /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(Group, {
					children: languages.map(({ locale, label }) =>
						/* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
							RadioItem,
							{
								title: locale,
								checked: locale === currentLanguage,
								onSelect: () => handleLanguageSelect(locale),
								children: /* @__PURE__ */ (0, import_jsx_runtime83.jsx)('span', {
									children: label,
								}),
							},
							locale
						)
					),
				}),
			}),
		],
	})
}

// ../packages/ui/src/lib/components/HelpMenu.tsx
var import_jsx_runtime84 = __toESM(require_jsx_runtime())
var HelpMenu = React56.memo(function HelpMenu2() {
	const container = useContainer()
	const msg2 = useTranslation()
	const [isOpen, onOpenChange] = useMenuIsOpen('help menu')
	return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)('div', {
		className: 'tlui-help-menu',
		children: /* @__PURE__ */ (0, import_jsx_runtime84.jsxs)(
			$d08ef79370b62062$export$be92b6f5f03c0fe9,
			{
				dir: 'ltr',
				open: isOpen,
				onOpenChange,
				modal: false,
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime84.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, {
						className: 'tlui-button tlui-help-menu__button',
						dir: 'ltr',
						title: msg2('help-menu.title'),
						children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(Icon, {
							icon: 'question-mark',
						}),
					}),
					/* @__PURE__ */ (0, import_jsx_runtime84.jsx)($d08ef79370b62062$export$602eac185826482c, {
						container,
						dir: 'ltr',
						children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(
							$d08ef79370b62062$export$7c6e2c02157bb7d2,
							{
								className: 'tlui-menu',
								side: 'top',
								sideOffset: 8,
								align: 'end',
								alignOffset: 0,
								collisionPadding: 4,
								children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(HelpMenuContent, {}),
							}
						),
					}),
				],
			}
		),
	})
})
function HelpMenuContent() {
	const menuSchema = useHelpMenuSchema()
	const isReadonly = useReadonly()
	function getHelpMenuItem(item) {
		if (isReadonly && !item.readonlyOk) return null
		switch (item.type) {
			case 'custom': {
				if (item.id === 'LANGUAGE_MENU') {
					return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(LanguageMenu, {}, 'item')
				}
				break
			}
			case 'group': {
				return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(
					Group,
					{ size: 'small', children: item.children.map(getHelpMenuItem) },
					item.id
				)
			}
			case 'submenu': {
				return /* @__PURE__ */ (0, import_jsx_runtime84.jsxs)(
					Sub,
					{
						id: `help menu ${item.id}`,
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime84.jsx)(SubTrigger, { label: item.label }),
							/* @__PURE__ */ (0, import_jsx_runtime84.jsx)(SubContent, {
								children: item.children.map(getHelpMenuItem),
							}),
						],
					},
					item.id
				)
			}
			case 'item': {
				const { id, kbd: kbd2, label, onSelect, icon } = item.actionItem
				return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(
					Item,
					{
						kbd: kbd2,
						label,
						onClick: () => onSelect('help-menu'),
						iconLeft: icon,
					},
					id
				)
			}
		}
	}
	return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(import_jsx_runtime84.Fragment, {
		children: menuSchema.map(getHelpMenuItem),
	})
}

// ../packages/ui/src/lib/components/MenuZone.tsx
init_define_process()

// ../packages/ui/src/lib/components/ActionsMenu.tsx
init_define_process()

// ../node_modules/@radix-ui/react-popover/dist/index.module.js
init_define_process()
var import_react92 = __toESM(require_react())

// ../node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-popper/dist/index.module.js
init_define_process()
var import_react91 = __toESM(require_react())
var $cf1ac5d9fe0e8206$var$POPPER_NAME2 = 'Popper'
var [$cf1ac5d9fe0e8206$var$createPopperContext2, $cf1ac5d9fe0e8206$export$722aac194ae9232] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME2)
var [$cf1ac5d9fe0e8206$var$PopperProvider2, $cf1ac5d9fe0e8206$var$usePopperContext2] =
	$cf1ac5d9fe0e8206$var$createPopperContext2($cf1ac5d9fe0e8206$var$POPPER_NAME2)
var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf92 = (props) => {
	const { __scopePopper, children } = props
	const [anchor, setAnchor] = (0, import_react91.useState)(null)
	return /* @__PURE__ */ (0, import_react91.createElement)(
		$cf1ac5d9fe0e8206$var$PopperProvider2,
		{
			scope: __scopePopper,
			anchor,
			onAnchorChange: setAnchor,
		},
		children
	)
}
var $cf1ac5d9fe0e8206$var$ANCHOR_NAME2 = 'PopperAnchor'
var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d2 = /* @__PURE__ */ (0, import_react91.forwardRef)(
	(props, forwardedRef) => {
		const { __scopePopper, virtualRef, ...anchorProps } = props
		const context = $cf1ac5d9fe0e8206$var$usePopperContext2(
			$cf1ac5d9fe0e8206$var$ANCHOR_NAME2,
			__scopePopper
		)
		const ref = (0, import_react91.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		;(0, import_react91.useEffect)(() => {
			context.onAnchorChange(
				(virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current
			)
		})
		return virtualRef
			? null
			: /* @__PURE__ */ (0, import_react91.createElement)(
					$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
					_extends({}, anchorProps, {
						ref: composedRefs,
					})
			  )
	}
)
var $cf1ac5d9fe0e8206$var$CONTENT_NAME2 = 'PopperContent'
var [$cf1ac5d9fe0e8206$var$PopperContentProvider2, $cf1ac5d9fe0e8206$var$useContentContext2] =
	$cf1ac5d9fe0e8206$var$createPopperContext2($cf1ac5d9fe0e8206$var$CONTENT_NAME2)
var [$cf1ac5d9fe0e8206$var$PositionContextProvider2, $cf1ac5d9fe0e8206$var$usePositionContext2] =
	$cf1ac5d9fe0e8206$var$createPopperContext2($cf1ac5d9fe0e8206$var$CONTENT_NAME2, {
		hasParent: false,
		positionUpdateFns: /* @__PURE__ */ new Set(),
	})
var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc2 = /* @__PURE__ */ (0, import_react91.forwardRef)(
	(props, forwardedRef) => {
		var _arrowSize$width,
			_arrowSize$height,
			_middlewareData$arrow,
			_middlewareData$arrow2,
			_middlewareData$arrow3,
			_middlewareData$hide,
			_middlewareData$trans,
			_middlewareData$trans2
		const {
			__scopePopper,
			side = 'bottom',
			sideOffset = 0,
			align = 'center',
			alignOffset = 0,
			arrowPadding = 0,
			collisionBoundary = [],
			collisionPadding: collisionPaddingProp = 0,
			sticky = 'partial',
			hideWhenDetached = false,
			avoidCollisions = true,
			onPlaced,
			...contentProps
		} = props
		const context = $cf1ac5d9fe0e8206$var$usePopperContext2(
			$cf1ac5d9fe0e8206$var$CONTENT_NAME2,
			__scopePopper
		)
		const [content, setContent] = (0, import_react91.useState)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setContent(node)
		)
		const [arrow2, setArrow] = (0, import_react91.useState)(null)
		const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2)
		const arrowWidth =
			(_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !==
				null && _arrowSize$width !== void 0
				? _arrowSize$width
				: 0
		const arrowHeight =
			(_arrowSize$height =
				arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null &&
			_arrowSize$height !== void 0
				? _arrowSize$height
				: 0
		const desiredPlacement = side + (align !== 'center' ? '-' + align : '')
		const collisionPadding =
			typeof collisionPaddingProp === 'number'
				? collisionPaddingProp
				: {
						top: 0,
						right: 0,
						bottom: 0,
						left: 0,
						...collisionPaddingProp,
				  }
		const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary]
		const hasExplicitBoundaries = boundary.length > 0
		const detectOverflowOptions = {
			padding: collisionPadding,
			boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull2),
			// with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
			altBoundary: hasExplicitBoundaries,
		}
		const {
			reference,
			floating,
			strategy,
			x: x3,
			y: y3,
			placement,
			middlewareData,
			update,
		} = useFloating({
			// default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
			strategy: 'fixed',
			placement: desiredPlacement,
			whileElementsMounted: N,
			middleware: [
				T({
					mainAxis: sideOffset + arrowHeight,
					alignmentAxis: alignOffset,
				}),
				avoidCollisions
					? D({
							mainAxis: true,
							crossAxis: false,
							limiter: sticky === 'partial' ? L() : void 0,
							...detectOverflowOptions,
					  })
					: void 0,
				avoidCollisions
					? b({
							...detectOverflowOptions,
					  })
					: void 0,
				k({
					...detectOverflowOptions,
					apply: ({ elements, rects, availableWidth, availableHeight }) => {
						const { width: anchorWidth, height: anchorHeight } = rects.reference
						const contentStyle = elements.floating.style
						contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`)
						contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`)
						contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`)
						contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`)
					},
				}),
				arrow2
					? arrow({
							element: arrow2,
							padding: arrowPadding,
					  })
					: void 0,
				$cf1ac5d9fe0e8206$var$transformOrigin2({
					arrowWidth,
					arrowHeight,
				}),
				hideWhenDetached
					? P({
							strategy: 'referenceHidden',
					  })
					: void 0,
			].filter($cf1ac5d9fe0e8206$var$isDefined2),
		})
		$9f79659886946c16$export$e5c5a5f917a5871c(() => {
			reference(context.anchor)
		}, [reference, context.anchor])
		const isPlaced = x3 !== null && y3 !== null
		const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement)
		const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced)
		$9f79659886946c16$export$e5c5a5f917a5871c(() => {
			if (isPlaced) handlePlaced === null || handlePlaced === void 0 || handlePlaced()
		}, [isPlaced, handlePlaced])
		const arrowX =
			(_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0
				? void 0
				: _middlewareData$arrow.x
		const arrowY =
			(_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0
				? void 0
				: _middlewareData$arrow2.y
		const cannotCenterArrow =
			((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0
				? void 0
				: _middlewareData$arrow3.centerOffset) !== 0
		const [contentZIndex, setContentZIndex] = (0, import_react91.useState)()
		$9f79659886946c16$export$e5c5a5f917a5871c(() => {
			if (content) setContentZIndex(window.getComputedStyle(content).zIndex)
		}, [content])
		const { hasParent, positionUpdateFns } = $cf1ac5d9fe0e8206$var$usePositionContext2(
			$cf1ac5d9fe0e8206$var$CONTENT_NAME2,
			__scopePopper
		)
		const isRoot = !hasParent
		;(0, import_react91.useLayoutEffect)(() => {
			if (!isRoot) {
				positionUpdateFns.add(update)
				return () => {
					positionUpdateFns.delete(update)
				}
			}
		}, [isRoot, positionUpdateFns, update])
		$9f79659886946c16$export$e5c5a5f917a5871c(() => {
			if (isRoot && isPlaced)
				Array.from(positionUpdateFns)
					.reverse()
					.forEach((fn) => requestAnimationFrame(fn))
		}, [isRoot, isPlaced, positionUpdateFns])
		const commonProps = {
			'data-side': placedSide,
			'data-align': placedAlign,
			...contentProps,
			ref: composedRefs,
			style: {
				...contentProps.style,
				// if the PopperContent hasn't been placed yet (not all measurements done)
				// we prevent animations so that users's animation don't kick in too early referring wrong sides
				animation: !isPlaced ? 'none' : void 0,
				// hide the content if using the hide middleware and should be hidden
				opacity:
					(_middlewareData$hide = middlewareData.hide) !== null &&
					_middlewareData$hide !== void 0 &&
					_middlewareData$hide.referenceHidden
						? 0
						: void 0,
			},
		}
		return /* @__PURE__ */ (0, import_react91.createElement)(
			'div',
			{
				ref: floating,
				'data-radix-popper-content-wrapper': '',
				style: {
					position: strategy,
					left: 0,
					top: 0,
					transform: isPlaced
						? `translate3d(${Math.round(x3)}px, ${Math.round(y3)}px, 0)`
						: 'translate3d(0, -200%, 0)',
					// keep off the page when measuring
					minWidth: 'max-content',
					zIndex: contentZIndex,
					['--radix-popper-transform-origin']: [
						(_middlewareData$trans = middlewareData.transformOrigin) === null ||
						_middlewareData$trans === void 0
							? void 0
							: _middlewareData$trans.x,
						(_middlewareData$trans2 = middlewareData.transformOrigin) === null ||
						_middlewareData$trans2 === void 0
							? void 0
							: _middlewareData$trans2.y,
					].join(' '),
				},
				dir: props.dir,
			},
			/* @__PURE__ */ (0, import_react91.createElement)(
				$cf1ac5d9fe0e8206$var$PopperContentProvider2,
				{
					scope: __scopePopper,
					placedSide,
					onArrowChange: setArrow,
					arrowX,
					arrowY,
					shouldHideArrow: cannotCenterArrow,
				},
				isRoot
					? /* @__PURE__ */ (0, import_react91.createElement)(
							$cf1ac5d9fe0e8206$var$PositionContextProvider2,
							{
								scope: __scopePopper,
								hasParent: true,
								positionUpdateFns,
							},
							/* @__PURE__ */ (0, import_react91.createElement)(
								$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
								commonProps
							)
					  )
					: /* @__PURE__ */ (0, import_react91.createElement)(
							$8927f6f2acc4f386$export$250ffa63cdc0d034.div,
							commonProps
					  )
			)
		)
	}
)
function $cf1ac5d9fe0e8206$var$isDefined2(value) {
	return value !== void 0
}
function $cf1ac5d9fe0e8206$var$isNotNull2(value) {
	return value !== null
}
var $cf1ac5d9fe0e8206$var$transformOrigin2 = (options) => ({
	name: 'transformOrigin',
	options,
	fn(data) {
		var _middlewareData$arrow4,
			_middlewareData$arrow5,
			_middlewareData$arrow6,
			_middlewareData$arrow7,
			_middlewareData$arrow8
		const { placement, rects, middlewareData } = data
		const cannotCenterArrow =
			((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0
				? void 0
				: _middlewareData$arrow4.centerOffset) !== 0
		const isArrowHidden = cannotCenterArrow
		const arrowWidth = isArrowHidden ? 0 : options.arrowWidth
		const arrowHeight = isArrowHidden ? 0 : options.arrowHeight
		const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement)
		const noArrowAlign = {
			start: '0%',
			center: '50%',
			end: '100%',
		}[placedAlign]
		const arrowXCenter =
			((_middlewareData$arrow5 =
				(_middlewareData$arrow6 = middlewareData.arrow) === null ||
				_middlewareData$arrow6 === void 0
					? void 0
					: _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0
				? _middlewareData$arrow5
				: 0) +
			arrowWidth / 2
		const arrowYCenter =
			((_middlewareData$arrow7 =
				(_middlewareData$arrow8 = middlewareData.arrow) === null ||
				_middlewareData$arrow8 === void 0
					? void 0
					: _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0
				? _middlewareData$arrow7
				: 0) +
			arrowHeight / 2
		let x3 = ''
		let y3 = ''
		if (placedSide === 'bottom') {
			x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`
			y3 = `${-arrowHeight}px`
		} else if (placedSide === 'top') {
			x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`
			y3 = `${rects.floating.height + arrowHeight}px`
		} else if (placedSide === 'right') {
			x3 = `${-arrowHeight}px`
			y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`
		} else if (placedSide === 'left') {
			x3 = `${rects.floating.width + arrowHeight}px`
			y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`
		}
		return {
			data: {
				x: x3,
				y: y3,
			},
		}
	},
})
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement) {
	const [side, align = 'center'] = placement.split('-')
	return [side, align]
}
var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe92 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf92
var $cf1ac5d9fe0e8206$export$b688253958b8dfe72 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d2
var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d22 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc2

// ../node_modules/@radix-ui/react-popover/dist/index.module.js
var $cb5cc270b50c6fcd$var$POPOVER_NAME = 'Popover'
var [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
		$cf1ac5d9fe0e8206$export$722aac194ae9232,
	])
var $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae9232()
var [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] =
	$cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME)
var $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
	const {
		__scopePopover,
		children,
		open: openProp,
		defaultOpen,
		onOpenChange,
		modal = false,
	} = props
	const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover)
	const triggerRef = (0, import_react92.useRef)(null)
	const [hasCustomAnchor, setHasCustomAnchor] = (0, import_react92.useState)(false)
	const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
		prop: openProp,
		defaultProp: defaultOpen,
		onChange: onOpenChange,
	})
	return /* @__PURE__ */ (0, import_react92.createElement)(
		$cf1ac5d9fe0e8206$export$be92b6f5f03c0fe92,
		popperScope,
		/* @__PURE__ */ (0, import_react92.createElement)(
			$cb5cc270b50c6fcd$var$PopoverProvider,
			{
				scope: __scopePopover,
				contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
				triggerRef,
				open,
				onOpenChange: setOpen,
				onOpenToggle: (0, import_react92.useCallback)(
					() => setOpen((prevOpen) => !prevOpen),
					[setOpen]
				),
				hasCustomAnchor,
				onCustomAnchorAdd: (0, import_react92.useCallback)(() => setHasCustomAnchor(true), []),
				onCustomAnchorRemove: (0, import_react92.useCallback)(() => setHasCustomAnchor(false), []),
				modal,
			},
			children
		)
	)
}
var $cb5cc270b50c6fcd$var$TRIGGER_NAME = 'PopoverTrigger'
var $cb5cc270b50c6fcd$export$7dacb05d26466c3 = /* @__PURE__ */ (0, import_react92.forwardRef)(
	(props, forwardedRef) => {
		const { __scopePopover, ...triggerProps } = props
		const context = $cb5cc270b50c6fcd$var$usePopoverContext(
			$cb5cc270b50c6fcd$var$TRIGGER_NAME,
			__scopePopover
		)
		const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover)
		const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
			forwardedRef,
			context.triggerRef
		)
		const trigger2 = /* @__PURE__ */ (0, import_react92.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.button,
			_extends(
				{
					type: 'button',
					'aria-haspopup': 'dialog',
					'aria-expanded': context.open,
					'aria-controls': context.contentId,
					'data-state': $cb5cc270b50c6fcd$var$getState(context.open),
				},
				triggerProps,
				{
					ref: composedTriggerRef,
					onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle),
				}
			)
		)
		return context.hasCustomAnchor
			? trigger2
			: /* @__PURE__ */ (0, import_react92.createElement)(
					$cf1ac5d9fe0e8206$export$b688253958b8dfe72,
					_extends(
						{
							asChild: true,
						},
						popperScope
					),
					trigger2
			  )
	}
)
var $cb5cc270b50c6fcd$var$PORTAL_NAME = 'PopoverPortal'
var [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] =
	$cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
		forceMount: void 0,
	})
var $cb5cc270b50c6fcd$export$dd679ffb4362d2d4 = (props) => {
	const { __scopePopover, forceMount, children, container } = props
	const context = $cb5cc270b50c6fcd$var$usePopoverContext(
		$cb5cc270b50c6fcd$var$PORTAL_NAME,
		__scopePopover
	)
	return /* @__PURE__ */ (0, import_react92.createElement)(
		$cb5cc270b50c6fcd$var$PortalProvider,
		{
			scope: __scopePopover,
			forceMount,
		},
		/* @__PURE__ */ (0, import_react92.createElement)(
			$921a889cee6df7e8$export$99c2b779aa4e8b8b,
			{
				present: forceMount || context.open,
			},
			/* @__PURE__ */ (0, import_react92.createElement)(
				$f1701beae083dbae$export$602eac185826482c,
				{
					asChild: true,
					container,
				},
				children
			)
		)
	)
}
var $cb5cc270b50c6fcd$var$CONTENT_NAME = 'PopoverContent'
var $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ (0, import_react92.forwardRef)(
	(props, forwardedRef) => {
		const portalContext = $cb5cc270b50c6fcd$var$usePortalContext(
			$cb5cc270b50c6fcd$var$CONTENT_NAME,
			props.__scopePopover
		)
		const { forceMount = portalContext.forceMount, ...contentProps } = props
		const context = $cb5cc270b50c6fcd$var$usePopoverContext(
			$cb5cc270b50c6fcd$var$CONTENT_NAME,
			props.__scopePopover
		)
		return /* @__PURE__ */ (0, import_react92.createElement)(
			$921a889cee6df7e8$export$99c2b779aa4e8b8b,
			{
				present: forceMount || context.open,
			},
			context.modal
				? /* @__PURE__ */ (0, import_react92.createElement)(
						$cb5cc270b50c6fcd$var$PopoverContentModal,
						_extends({}, contentProps, {
							ref: forwardedRef,
						})
				  )
				: /* @__PURE__ */ (0, import_react92.createElement)(
						$cb5cc270b50c6fcd$var$PopoverContentNonModal,
						_extends({}, contentProps, {
							ref: forwardedRef,
						})
				  )
		)
	}
)
var $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ (0, import_react92.forwardRef)(
	(props, forwardedRef) => {
		const context = $cb5cc270b50c6fcd$var$usePopoverContext(
			$cb5cc270b50c6fcd$var$CONTENT_NAME,
			props.__scopePopover
		)
		const contentRef = (0, import_react92.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef)
		const isRightClickOutsideRef = (0, import_react92.useRef)(false)
		;(0, import_react92.useEffect)(() => {
			const content = contentRef.current
			if (content) return hideOthers(content)
		}, [])
		return /* @__PURE__ */ (0, import_react92.createElement)(
			Combination_default,
			{
				as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
				allowPinchZoom: true,
			},
			/* @__PURE__ */ (0, import_react92.createElement)(
				$cb5cc270b50c6fcd$var$PopoverContentImpl,
				_extends({}, props, {
					ref: composedRefs,
					trapFocus: context.open,
					disableOutsidePointerEvents: true,
					onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
						props.onCloseAutoFocus,
						(event) => {
							var _context$triggerRef$c
							event.preventDefault()
							if (!isRightClickOutsideRef.current)
								(_context$triggerRef$c = context.triggerRef.current) === null ||
									_context$triggerRef$c === void 0 ||
									_context$triggerRef$c.focus()
						}
					),
					onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
						props.onPointerDownOutside,
						(event) => {
							const originalEvent = event.detail.originalEvent
							const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true
							const isRightClick = originalEvent.button === 2 || ctrlLeftClick
							isRightClickOutsideRef.current = isRightClick
						},
						{
							checkForDefaultPrevented: false,
						}
					),
					onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
						props.onFocusOutside,
						(event) => event.preventDefault(),
						{
							checkForDefaultPrevented: false,
						}
					),
				})
			)
		)
	}
)
var $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ (0, import_react92.forwardRef)(
	(props, forwardedRef) => {
		const context = $cb5cc270b50c6fcd$var$usePopoverContext(
			$cb5cc270b50c6fcd$var$CONTENT_NAME,
			props.__scopePopover
		)
		const hasInteractedOutsideRef = (0, import_react92.useRef)(false)
		const hasPointerDownOutsideRef = (0, import_react92.useRef)(false)
		return /* @__PURE__ */ (0, import_react92.createElement)(
			$cb5cc270b50c6fcd$var$PopoverContentImpl,
			_extends({}, props, {
				ref: forwardedRef,
				trapFocus: false,
				disableOutsidePointerEvents: false,
				onCloseAutoFocus: (event) => {
					var _props$onCloseAutoFoc
					;(_props$onCloseAutoFoc = props.onCloseAutoFocus) === null ||
						_props$onCloseAutoFoc === void 0 ||
						_props$onCloseAutoFoc.call(props, event)
					if (!event.defaultPrevented) {
						var _context$triggerRef$c2
						if (!hasInteractedOutsideRef.current)
							(_context$triggerRef$c2 = context.triggerRef.current) === null ||
								_context$triggerRef$c2 === void 0 ||
								_context$triggerRef$c2.focus()
						event.preventDefault()
					}
					hasInteractedOutsideRef.current = false
					hasPointerDownOutsideRef.current = false
				},
				onInteractOutside: (event) => {
					var _props$onInteractOuts, _context$triggerRef$c3
					;(_props$onInteractOuts = props.onInteractOutside) === null ||
						_props$onInteractOuts === void 0 ||
						_props$onInteractOuts.call(props, event)
					if (!event.defaultPrevented) {
						hasInteractedOutsideRef.current = true
						if (event.detail.originalEvent.type === 'pointerdown')
							hasPointerDownOutsideRef.current = true
					}
					const target = event.target
					const targetIsTrigger =
						(_context$triggerRef$c3 = context.triggerRef.current) === null ||
						_context$triggerRef$c3 === void 0
							? void 0
							: _context$triggerRef$c3.contains(target)
					if (targetIsTrigger) event.preventDefault()
					if (event.detail.originalEvent.type === 'focusin' && hasPointerDownOutsideRef.current)
						event.preventDefault()
				},
			})
		)
	}
)
var $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ (0, import_react92.forwardRef)(
	(props, forwardedRef) => {
		const {
			__scopePopover,
			trapFocus,
			onOpenAutoFocus,
			onCloseAutoFocus,
			disableOutsidePointerEvents,
			onEscapeKeyDown,
			onPointerDownOutside,
			onFocusOutside,
			onInteractOutside,
			...contentProps
		} = props
		const context = $cb5cc270b50c6fcd$var$usePopoverContext(
			$cb5cc270b50c6fcd$var$CONTENT_NAME,
			__scopePopover
		)
		const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover)
		$3db38b7d1fb3fe6a$export$b7ece24a22aeda8c()
		return /* @__PURE__ */ (0, import_react92.createElement)(
			$d3863c46a17e8a28$export$20e40289641fbbb6,
			{
				asChild: true,
				loop: true,
				trapped: trapFocus,
				onMountAutoFocus: onOpenAutoFocus,
				onUnmountAutoFocus: onCloseAutoFocus,
			},
			/* @__PURE__ */ (0, import_react92.createElement)(
				$5cb92bef7577960e$export$177fb62ff3ec1f22,
				{
					asChild: true,
					disableOutsidePointerEvents,
					onInteractOutside,
					onEscapeKeyDown,
					onPointerDownOutside,
					onFocusOutside,
					onDismiss: () => context.onOpenChange(false),
				},
				/* @__PURE__ */ (0, import_react92.createElement)(
					$cf1ac5d9fe0e8206$export$7c6e2c02157bb7d22,
					_extends(
						{
							'data-state': $cb5cc270b50c6fcd$var$getState(context.open),
							role: 'dialog',
							id: context.contentId,
						},
						popperScope,
						contentProps,
						{
							ref: forwardedRef,
							style: {
								...contentProps.style,
								'--radix-popover-content-transform-origin': 'var(--radix-popper-transform-origin)',
								'--radix-popover-content-available-width': 'var(--radix-popper-available-width)',
								'--radix-popover-content-available-height': 'var(--radix-popper-available-height)',
								'--radix-popover-trigger-width': 'var(--radix-popper-anchor-width)',
								'--radix-popover-trigger-height': 'var(--radix-popper-anchor-height)',
							},
						}
					)
				)
			)
		)
	}
)
function $cb5cc270b50c6fcd$var$getState(open) {
	return open ? 'open' : 'closed'
}
var $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d
var $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3
var $cb5cc270b50c6fcd$export$602eac185826482c = $cb5cc270b50c6fcd$export$dd679ffb4362d2d4
var $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff

// ../packages/ui/src/lib/components/ActionsMenu.tsx
var import_react93 = __toESM(require_react())

// ../packages/ui/src/lib/components/primitives/Popover.tsx
init_define_process()
var import_jsx_runtime85 = __toESM(require_jsx_runtime())
var Popover = ({ id, children, onOpenChange }) => {
	const [isOpen, handleOpenChange] = useMenuIsOpen(id, onOpenChange)
	return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, {
		onOpenChange: handleOpenChange,
		open: isOpen,
		children: /* @__PURE__ */ (0, import_jsx_runtime85.jsx)('div', {
			className: 'tlui-popover',
			children,
		}),
	})
}
var PopoverTrigger = ({ children, disabled, 'data-testid': dataWd }) => {
	return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)($cb5cc270b50c6fcd$export$41fb9f06171c75f4, {
		'data-testid': dataWd,
		disabled,
		asChild: true,
		dir: 'ltr',
		children,
	})
}
var PopoverContent = ({ side, children, align = 'center', sideOffset = 8, alignOffset = 0 }) => {
	const container = useContainer()
	return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, {
		dir: 'ltr',
		container,
		children: /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(
			$cb5cc270b50c6fcd$export$7c6e2c02157bb7d2,
			{
				className: 'tlui-popover__content',
				side,
				sideOffset,
				align,
				alignOffset,
				dir: 'ltr',
				children,
			}
		),
	})
}

// ../packages/ui/src/lib/components/ActionsMenu.tsx
var import_jsx_runtime86 = __toESM(require_jsx_runtime())
var ActionsMenu = (0, import_react93.memo)(function ActionsMenu2() {
	const msg2 = useTranslation()
	const container = useContainer()
	const menuSchema = useActionsMenuSchema()
	const isReadonly = useReadonly()
	function getActionMenuItem(item) {
		if (isReadonly && !item.readonlyOk) return null
		switch (item.type) {
			case 'item': {
				const { id, icon, label, kbd: kbd2, onSelect } = item.actionItem
				return /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(
					Button,
					{
						className: 'tlui-button-grid__button',
						'data-testid': `menu-item.${item.id}`,
						icon,
						title: label
							? kbd2
								? `${msg2(label)} ${kbdStr(kbd2)}`
								: `${msg2(label)}`
							: kbd2
							? `${kbdStr(kbd2)}`
							: '',
						onClick: () => onSelect('actions-menu'),
						disabled: item.disabled,
					},
					id
				)
			}
		}
	}
	return /* @__PURE__ */ (0, import_jsx_runtime86.jsxs)(Popover, {
		id: 'actions menu',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime86.jsx)(PopoverTrigger, {
				children: /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(Button, {
					className: 'tlui-menu__trigger',
					'data-testid': 'main.action-menu',
					icon: 'dots-vertical',
					title: msg2('actions-menu.title'),
					smallIcon: true,
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime86.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, {
				dir: 'ltr',
				container,
				children: /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(
					$cb5cc270b50c6fcd$export$7c6e2c02157bb7d2,
					{
						className: 'tlui-popover__content',
						side: 'bottom',
						dir: 'ltr',
						sideOffset: 6,
						children: /* @__PURE__ */ (0, import_jsx_runtime86.jsx)('div', {
							className: 'tlui-actions-menu tlui-button-grid__four',
							children: menuSchema.map(getActionMenuItem),
						}),
					}
				),
			}),
		],
	})
})

// ../packages/ui/src/lib/components/DuplicateButton.tsx
init_define_process()
var import_jsx_runtime87 = __toESM(require_jsx_runtime())
var DuplicateButton = track(function DuplicateButton2() {
	const app = useApp()
	const actions = useActions()
	const msg2 = useTranslation()
	const action = actions['duplicate']
	const noSelected = app.selectedIds.length <= 0
	return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(Button, {
		icon: action.icon,
		onClick: () => action.onSelect('quick-actions'),
		disabled: noSelected,
		title: `${msg2(action.label)} ${kbdStr(action.kbd)}`,
		smallIcon: true,
	})
})

// ../packages/ui/src/lib/components/Menu.tsx
init_define_process()
var React57 = __toESM(require_react())
var import_jsx_runtime88 = __toESM(require_jsx_runtime())
var Menu = React57.memo(function Menu2() {
	const msg2 = useTranslation()
	return /* @__PURE__ */ (0, import_jsx_runtime88.jsxs)(Root, {
		id: 'main menu',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Trigger, {
				children: /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Button, {
					className: 'tlui-menu__trigger',
					'data-testid': 'main.menu',
					title: msg2('menu.title'),
					icon: 'menu',
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Content, {
				alignOffset: 0,
				sideOffset: 6,
				children: /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(MenuContent, {}),
			}),
		],
	})
})
function MenuContent() {
	const app = useApp()
	const msg2 = useTranslation()
	const menuSchema = useMenuSchema()
	const breakpoint = useBreakpoint()
	const isReadonly = useReadonly()
	function getMenuItem(app2, item, parent, depth) {
		switch (item.type) {
			case 'custom': {
				if (isReadonly && !item.readonlyOk) return null
				if (item.id === 'LANGUAGE_MENU') {
					return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(LanguageMenu, {}, 'item')
				}
				return null
			}
			case 'group': {
				if (isReadonly && !item.readonlyOk) return null
				return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
					Group,
					{
						size:
							depth <= 1
								? 'medium'
								: breakpoint < 3 || (parent?.type === 'submenu' && depth > 2)
								? 'tiny'
								: 'medium',
						children: item.children.map((child) => getMenuItem(app2, child, item, depth + 1)),
					},
					item.id
				)
			}
			case 'submenu': {
				if (isReadonly && !item.readonlyOk) return null
				return /* @__PURE__ */ (0, import_jsx_runtime88.jsxs)(
					Sub,
					{
						id: `main menu ${parent ? parent.id + ' ' : ''}${item.id}`,
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime88.jsx)(SubTrigger, {
								label: item.label,
								'data-testid': `menu-item.${item.id}`,
							}),
							/* @__PURE__ */ (0, import_jsx_runtime88.jsx)(SubContent, {
								sideOffset: -4,
								alignOffset: -1,
								children: item.children.map((child) => getMenuItem(app2, child, item, depth + 1)),
							}),
						],
					},
					item.id
				)
			}
			case 'item': {
				if (isReadonly && !item.readonlyOk) return null
				const { id, checkbox, menuLabel, label, onSelect, kbd: kbd2 } = item.actionItem
				const labelToUse = menuLabel ?? label
				const labelStr = labelToUse ? msg2(labelToUse) : void 0
				if (checkbox) {
					return /* @__PURE__ */ (0, import_jsx_runtime88.jsxs)(
						CheckboxItem,
						{
							onSelect: () => onSelect('menu'),
							title: labelStr ? labelStr : '',
							checked: item.checked,
							disabled: item.disabled,
							children: [
								labelStr &&
									/* @__PURE__ */ (0, import_jsx_runtime88.jsx)('span', { children: labelStr }),
								kbd2 && /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Kbd, { children: kbd2 }),
							],
						},
						id
					)
				}
				return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
					Item,
					{
						'data-testid': `menu-item.${item.id}`,
						kbd: kbd2,
						label: labelToUse,
						onClick: () => onSelect('menu'),
						disabled: item.disabled,
					},
					id
				)
			}
		}
	}
	return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(import_jsx_runtime88.Fragment, {
		children: menuSchema.map((item) => getMenuItem(app, item, null, 0)),
	})
}

// ../packages/ui/src/lib/components/PageMenu/PageMenu.tsx
init_define_process()
var import_react96 = __toESM(require_react())

// ../packages/ui/src/lib/components/PageMenu/PageItemInput.tsx
init_define_process()
var import_react94 = __toESM(require_react())
var import_jsx_runtime89 = __toESM(require_jsx_runtime())
var PageItemInput = function PageItemInput2({ name, id, isCurrentPage }) {
	const app = useApp()
	const rInput = (0, import_react94.useRef)(null)
	const handleChange = (0, import_react94.useCallback)(
		(value) => {
			app.renamePage(id, value ? value : 'New Page', true)
		},
		[app, id]
	)
	const handleComplete = (0, import_react94.useCallback)(
		(value) => {
			app.mark('rename page')
			app.renamePage(id, value || 'New Page', false)
		},
		[app, id]
	)
	return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(Input, {
		className: 'tlui-page-menu__item__input',
		ref: (el) => (rInput.current = el),
		defaultValue: name,
		onValueChange: handleChange,
		onComplete: handleComplete,
		onCancel: handleComplete,
		shouldManuallyMaintainScrollPositionWhenFocused: true,
		autofocus: isCurrentPage,
		autoselect: true,
	})
}

// ../packages/ui/src/lib/components/PageMenu/PageItemSubmenu.tsx
init_define_process()
var import_react95 = __toESM(require_react())

// ../packages/ui/src/lib/components/PageMenu/edit-pages-shared.ts
init_define_process()
var onMovePage = (app, id, from, to) => {
	let index2
	const pages = app.pages
	const below = from > to ? pages[to - 1] : pages[to]
	const above = from > to ? pages[to] : pages[to + 1]
	if (below && !above) {
		index2 = getIndexAbove(below.index)
	} else if (!below && above) {
		index2 = getIndexBelow(pages[0].index)
	} else {
		index2 = getIndexBetween(below.index, above.index)
	}
	if (index2 !== pages[from].index) {
		app.mark('moving page')
		app.updatePage({
			id,
			index: index2,
		})
	}
}

// ../packages/ui/src/lib/components/PageMenu/PageItemSubmenu.tsx
var import_jsx_runtime90 = __toESM(require_jsx_runtime())
var PageItemSubmenu = track(function PageItemSubmenu2({ index: index2, listSize, item, onRename }) {
	const app = useApp()
	const msg2 = useTranslation()
	const pages = app.pages
	const onDuplicate = (0, import_react95.useCallback)(() => {
		app.mark('creating page')
		const newId = PageRecordType.createId()
		app.duplicatePage(item.id, newId)
	}, [app, item])
	const onMoveUp = (0, import_react95.useCallback)(() => {
		onMovePage(app, item.id, index2, index2 - 1)
	}, [app, item, index2])
	const onMoveDown = (0, import_react95.useCallback)(() => {
		onMovePage(app, item.id, index2, index2 + 1)
	}, [app, item, index2])
	const onDelete = (0, import_react95.useCallback)(() => {
		app.mark('deleting page')
		app.deletePage(item.id)
	}, [app, item])
	return /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(Root, {
		id: `page item submenu ${index2}`,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Trigger, {
				children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, {
					title: msg2('page-menu.submenu.title'),
					icon: 'dots-vertical',
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(Content, {
				alignOffset: 0,
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(Group, {
						children: [
							onRename &&
								/* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
									$d08ef79370b62062$export$6d08773d2e66f8f2,
									{
										dir: 'ltr',
										onSelect: onRename,
										asChild: true,
										children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, {
											className: 'tlui-menu__button',
											label: 'page-menu.submenu.rename',
										}),
									}
								),
							/* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
								$d08ef79370b62062$export$6d08773d2e66f8f2,
								{
									dir: 'ltr',
									onSelect: onDuplicate,
									disabled: pages.length >= MAX_PAGES,
									asChild: true,
									children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, {
										className: 'tlui-menu__button',
										label: 'page-menu.submenu.duplicate-page',
									}),
								}
							),
							index2 > 0 &&
								/* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
									$d08ef79370b62062$export$6d08773d2e66f8f2,
									{
										dir: 'ltr',
										onSelect: onMoveUp,
										asChild: true,
										children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, {
											className: 'tlui-menu__button',
											label: 'page-menu.submenu.move-up',
										}),
									}
								),
							index2 < listSize - 1 &&
								/* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
									$d08ef79370b62062$export$6d08773d2e66f8f2,
									{
										dir: 'ltr',
										onSelect: onMoveDown,
										asChild: true,
										children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, {
											className: 'tlui-menu__button',
											label: 'page-menu.submenu.move-down',
										}),
									}
								),
						],
					}),
					listSize > 1 &&
						/* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Group, {
							children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
								$d08ef79370b62062$export$6d08773d2e66f8f2,
								{
									dir: 'ltr',
									onSelect: onDelete,
									asChild: true,
									children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, {
										className: 'tlui-menu__button',
										label: 'page-menu.submenu.delete',
									}),
								}
							),
						}),
				],
			}),
		],
	})
})

// ../packages/ui/src/lib/components/PageMenu/PageMenu.tsx
var import_jsx_runtime91 = __toESM(require_jsx_runtime())
var PageMenu = function PageMenu2() {
	const app = useApp()
	const msg2 = useTranslation()
	const breakpoint = useBreakpoint()
	const handleOpenChange = (0, import_react96.useCallback)(() => setIsEditing(false), [])
	const [isOpen, onOpenChange] = useMenuIsOpen('page-menu', handleOpenChange)
	const ITEM_HEIGHT = breakpoint < 5 ? 36 : 40
	const rSortableContainer = (0, import_react96.useRef)(null)
	const pages = useValue('pages', () => app.pages, [app])
	const currentPage = useValue('currentPage', () => app.currentPage, [app])
	const isReadonlyMode = useValue('isReadonlyMode', () => app.isReadOnly, [app])
	const maxPageCountReached = useValue('maxPageCountReached', () => app.pages.length >= MAX_PAGES, [
		app,
	])
	const isCoarsePointer = useValue('isCoarsePointer', () => app.isCoarsePointer, [app])
	const [isEditing, setIsEditing] = (0, import_react96.useState)(false)
	const toggleEditing = (0, import_react96.useCallback)(() => {
		if (isReadonlyMode) return
		setIsEditing((s3) => !s3)
	}, [isReadonlyMode])
	const rMutables = (0, import_react96.useRef)({
		isPointing: false,
		status: 'idle',
		pointing: null,
		startY: 0,
		startIndex: 0,
		dragIndex: 0,
	})
	const [sortablePositionItems, setSortablePositionItems] = (0, import_react96.useState)(
		Object.fromEntries(
			pages.map((page, i3) => [page.id, { y: i3 * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
		)
	)
	;(0, import_react96.useLayoutEffect)(() => {
		setSortablePositionItems(
			Object.fromEntries(
				pages.map((page, i3) => [page.id, { y: i3 * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
			)
		)
	}, [ITEM_HEIGHT, pages])
	;(0, import_react96.useEffect)(() => {
		if (!isOpen) return
		requestAnimationFrame(() => {
			const elm = document.querySelector(`[data-testid="page-menu-item-${currentPage.id}"]`)
			if (elm) {
				const container = rSortableContainer.current
				if (!container) return
				const elmTopPosition = elm.offsetTop
				const containerScrollTopPosition = container.scrollTop
				if (elmTopPosition < containerScrollTopPosition) {
					container.scrollTo({ top: elmTopPosition })
				}
				const elmBottomPosition = elmTopPosition + ITEM_HEIGHT
				const containerScrollBottomPosition = container.scrollTop + container.offsetHeight
				if (elmBottomPosition > containerScrollBottomPosition) {
					container.scrollTo({ top: elmBottomPosition - container.offsetHeight })
				}
			}
		})
	}, [ITEM_HEIGHT, currentPage, isOpen])
	const handlePointerDown = (0, import_react96.useCallback)(
		(e2) => {
			const { clientY, currentTarget } = e2
			const {
				dataset: { id, index: index2 },
			} = currentTarget
			if (!id || !index2) return
			const mut = rMutables.current
			e2.currentTarget.setPointerCapture(e2.pointerId)
			mut.status = 'pointing'
			mut.pointing = { id, index: +index2 }
			const current = sortablePositionItems[id]
			const dragY = current.y
			mut.startY = clientY
			mut.startIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1))
		},
		[ITEM_HEIGHT, pages.length, sortablePositionItems]
	)
	const handlePointerMove = (0, import_react96.useCallback)(
		(e2) => {
			const mut = rMutables.current
			if (mut.status === 'pointing') {
				const { clientY } = e2
				const offset = clientY - mut.startY
				if (Math.abs(offset) > 5) {
					mut.status = 'dragging'
				}
			}
			if (mut.status === 'dragging') {
				const { clientY } = e2
				const offsetY = clientY - mut.startY
				const current = sortablePositionItems[mut.pointing.id]
				const { startIndex, pointing } = mut
				const dragY = current.y + offsetY
				const dragIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1))
				const next = { ...sortablePositionItems }
				next[pointing.id] = {
					y: current.y,
					offsetY,
					isSelected: true,
				}
				if (dragIndex !== mut.dragIndex) {
					mut.dragIndex = dragIndex
					for (let i3 = 0; i3 < pages.length; i3++) {
						const item = pages[i3]
						if (item.id === mut.pointing.id) {
							continue
						}
						let { y: y3 } = next[item.id]
						if (dragIndex === startIndex) {
							y3 = i3 * ITEM_HEIGHT
						} else if (dragIndex < startIndex) {
							if (dragIndex <= i3 && i3 < startIndex) {
								y3 = (i3 + 1) * ITEM_HEIGHT
							} else {
								y3 = i3 * ITEM_HEIGHT
							}
						} else if (dragIndex > startIndex) {
							if (dragIndex >= i3 && i3 > startIndex) {
								y3 = (i3 - 1) * ITEM_HEIGHT
							} else {
								y3 = i3 * ITEM_HEIGHT
							}
						}
						if (y3 !== next[item.id].y) {
							next[item.id] = { y: y3, offsetY: 0, isSelected: true }
						}
					}
				}
				setSortablePositionItems(next)
			}
		},
		[ITEM_HEIGHT, pages, sortablePositionItems]
	)
	const handlePointerUp = (0, import_react96.useCallback)(
		(e2) => {
			const mut = rMutables.current
			if (mut.status === 'dragging') {
				const { id, index: index2 } = mut.pointing
				onMovePage(app, id, index2, mut.dragIndex)
			}
			e2.currentTarget.releasePointerCapture(e2.pointerId)
			mut.status = 'idle'
		},
		[app]
	)
	const handleKeyDown = (0, import_react96.useCallback)(
		(e2) => {
			const mut = rMutables.current
			if (e2.key === 'Escape') {
				if (mut.status === 'dragging') {
					setSortablePositionItems(
						Object.fromEntries(
							pages.map((page, i3) => [
								page.id,
								{ y: i3 * ITEM_HEIGHT, offsetY: 0, isSelected: false },
							])
						)
					)
				}
				mut.status = 'idle'
			}
		},
		[ITEM_HEIGHT, pages]
	)
	const handleCreatePageClick = (0, import_react96.useCallback)(() => {
		if (isReadonlyMode) return
		app.mark('creating page')
		const newPageId = PageRecordType.createId()
		app.createPage(msg2('page-menu.new-page-initial-name'), newPageId)
		setIsEditing(true)
	}, [app, msg2, isReadonlyMode])
	return /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(Popover, {
		id: 'page menu',
		onOpenChange,
		open: isOpen,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime91.jsx)(PopoverTrigger, {
				children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Button, {
					className: 'tlui-page-menu__trigger tlui-menu__trigger',
					'data-testid': 'main.page-menu',
					icon: 'chevron-down',
					title: currentPage.name,
					children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)('div', {
						className: 'tlui-page-menu__name',
						children: currentPage.name,
					}),
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime91.jsx)(PopoverContent, {
				side: 'bottom',
				align: 'start',
				sideOffset: 6,
				children: /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)('div', {
					className: 'tlui-page-menu__wrapper',
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime91.jsxs)('div', {
							className: 'tlui-page-menu__header',
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime91.jsx)('div', {
									className: 'tlui-page-menu__header__title',
									children: msg2('page-menu.title'),
								}),
								!isReadonlyMode &&
									/* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(import_jsx_runtime91.Fragment, {
										children: [
											/* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Button, {
												'data-testid': 'page-menu.edit',
												title: msg2(isEditing ? 'page-menu.edit-done' : 'page-menu.edit-start'),
												icon: isEditing ? 'check' : 'edit',
												onClick: toggleEditing,
											}),
											/* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Button, {
												'data-testid': 'page-menu.create',
												icon: 'plus',
												title: msg2(
													maxPageCountReached
														? 'page-menu.max-page-count-reached'
														: 'page-menu.create-new-page'
												),
												disabled: maxPageCountReached,
												onClick: handleCreatePageClick,
											}),
										],
									}),
							],
						}),
						/* @__PURE__ */ (0, import_jsx_runtime91.jsx)('div', {
							className: 'tlui-page-menu__list tlui-menu__group',
							style: { height: ITEM_HEIGHT * pages.length + 4 },
							ref: rSortableContainer,
							children: pages.map((page, index2) => {
								const position = sortablePositionItems[page.id] ?? {
									position: index2 * 40,
									offsetY: 0,
								}
								return isEditing
									? /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(
											'div',
											{
												'data-testid': `page-menu-item-${page.id}`,
												className: 'tlui-page_menu__item__sortable',
												style: {
													zIndex: page.id === currentPage.id ? 888 : index2,
													transform: `translate(0px, ${position.y + position.offsetY}px)`,
												},
												children: [
													/* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Button, {
														tabIndex: -1,
														className: 'tlui-page_menu__item__sortable__handle',
														icon: 'drag-handle-dots',
														onPointerDown: handlePointerDown,
														onPointerUp: handlePointerUp,
														onPointerMove: handlePointerMove,
														onKeyDown: handleKeyDown,
														'data-id': page.id,
														'data-index': index2,
													}),
													breakpoint < 5 && isCoarsePointer
														? // sigh, this is a workaround for iOS Safari
														  // because the device and the radix popover seem
														  // to be fighting over scroll position. Nothing
														  // else seems to work!
														  /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Button, {
																className: 'tlui-page-menu__item__button',
																onClick: () => {
																	const name = window.prompt('Rename page', page.name)
																	if (name && name !== page.name) {
																		app.renamePage(page.id, name)
																	}
																},
																onDoubleClick: toggleEditing,
																isChecked: page.id === currentPage.id,
																children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)('span', {
																	children: page.name,
																}),
														  })
														: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)('div', {
																id: `page-menu-item-${page.id}`,
																'data-testid': `page-menu-item-${page.id}`,
																className: 'tlui-page_menu__item__sortable__title',
																style: { height: ITEM_HEIGHT },
																children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
																	PageItemInput,
																	{
																		id: page.id,
																		name: page.name,
																		isCurrentPage: page.id === currentPage.id,
																	}
																),
														  }),
													!isReadonlyMode &&
														/* @__PURE__ */ (0, import_jsx_runtime91.jsx)('div', {
															className: 'tlui-page_menu__item__submenu',
															'data-isediting': isEditing,
															children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
																PageItemSubmenu,
																{ index: index2, item: page, listSize: pages.length }
															),
														}),
												],
											},
											page.id + '_editing'
									  )
									: /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(
											'div',
											{
												'data-testid': `page-menu-item-${page.id}`,
												className: 'tlui-page-menu__item',
												children: [
													/* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(Button, {
														className:
															'tlui-page-menu__item__button tlui-page-menu__item__button__checkbox',
														onClick: () => app.setCurrentPageId(page.id),
														onDoubleClick: toggleEditing,
														isChecked: page.id === currentPage.id,
														title: msg2('page-menu.go-to-page'),
														children: [
															/* @__PURE__ */ (0, import_jsx_runtime91.jsx)('div', {
																className: 'tlui-page-menu__item__button__check',
																children:
																	page.id === currentPage.id &&
																	/* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Icon, {
																		icon: 'check',
																	}),
															}),
															/* @__PURE__ */ (0, import_jsx_runtime91.jsx)('span', {
																children: page.name,
															}),
														],
													}),
													!isReadonlyMode &&
														/* @__PURE__ */ (0, import_jsx_runtime91.jsx)('div', {
															className: 'tlui-page_menu__item__submenu',
															children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
																PageItemSubmenu,
																{
																	index: index2,
																	item: page,
																	listSize: pages.length,
																	onRename: () => {
																		if (app.isIos) {
																			const name = window.prompt('Rename page', page.name)
																			if (name && name !== page.name) {
																				app.renamePage(page.id, name)
																			}
																		} else {
																			setIsEditing(true)
																			app.setCurrentPageId(page.id)
																		}
																	},
																}
															),
														}),
												],
											},
											page.id
									  )
							}),
						}),
					],
				}),
			}),
		],
	})
}

// ../packages/ui/src/lib/components/RedoButton.tsx
init_define_process()
var import_react97 = __toESM(require_react())
var import_jsx_runtime92 = __toESM(require_jsx_runtime())
var RedoButton = (0, import_react97.memo)(function RedoButton2() {
	const msg2 = useTranslation()
	const canRedo = useCanRedo()
	const actions = useActions()
	const redo = actions['redo']
	return /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(Button, {
		'data-testid': 'main.redo',
		icon: redo.icon,
		title: `${msg2(redo.label)} ${kbdStr(redo.kbd)}`,
		disabled: !canRedo,
		onClick: () => redo.onSelect('quick-actions'),
		smallIcon: true,
	})
})

// ../packages/ui/src/lib/components/TrashButton.tsx
init_define_process()
var import_jsx_runtime93 = __toESM(require_jsx_runtime())
var TrashButton = track(function TrashButton2() {
	const app = useApp()
	const actions = useActions()
	const msg2 = useTranslation()
	const action = actions['delete']
	const isReadonly = useReadonly()
	if (isReadonly) return null
	const noSelected = app.selectedIds.length <= 0
	return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(Button, {
		icon: action.icon,
		onClick: () => action.onSelect('quick-actions'),
		disabled: noSelected,
		title: `${msg2(action.label)} ${kbdStr(action.kbd)}`,
		smallIcon: true,
	})
})

// ../packages/ui/src/lib/components/UndoButton.tsx
init_define_process()
var import_react98 = __toESM(require_react())
var import_jsx_runtime94 = __toESM(require_jsx_runtime())
var UndoButton = (0, import_react98.memo)(function UndoButton2() {
	const msg2 = useTranslation()
	const canUndo = useCanUndo()
	const actions = useActions()
	const undo = actions['undo']
	return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(Button, {
		'data-testid': 'main.undo',
		icon: undo.icon,
		title: `${msg2(undo.label)} ${kbdStr(undo.kbd)}`,
		disabled: !canUndo,
		onClick: () => undo.onSelect('quick-actions'),
		smallIcon: true,
	})
})

// ../packages/ui/src/lib/components/MenuZone.tsx
var import_jsx_runtime95 = __toESM(require_jsx_runtime())
var MenuZone = track(function MenuZone2() {
	const app = useApp()
	const breakpoint = useBreakpoint()
	const isReadonly = useReadonly()
	const showQuickActions = !isReadonly && !app.isInAny('hand', 'zoom', 'eraser')
	return /* @__PURE__ */ (0,
	import_jsx_runtime95.jsx)('div', { className: 'tlui-menu-zone', children: /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)('div', { className: 'tlui-menu-zone__controls', children: [/* @__PURE__ */ (0, import_jsx_runtime95.jsx)(Menu, {}), /* @__PURE__ */ (0, import_jsx_runtime95.jsx)('div', { className: 'tlui-menu-zone__divider' }), /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(PageMenu, {}), breakpoint >= 5 && showQuickActions && /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)(import_jsx_runtime95.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime95.jsx)('div', { className: 'tlui-menu-zone__divider' }), /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(UndoButton, {}), /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(RedoButton, {}), /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(TrashButton, {}), /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(DuplicateButton, {}), /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(ActionsMenu, {})] })] }) })
})

// ../packages/ui/src/lib/components/NavigationZone/NavigationZone.tsx
init_define_process()
var import_react100 = __toESM(require_react())

// ../packages/ui/src/lib/hooks/useLocalStorageState.ts
init_define_process()
var import_react99 = __toESM(require_react())
function useLocalStorageState(key, defaultValue) {
	const [state, setState] = import_react99.default.useState(defaultValue)
	import_react99.default.useLayoutEffect(() => {
		const value = localStorage.getItem(key)
		if (value) {
			try {
				setState(JSON.parse(value))
			} catch (e2) {
				console.error(`Could not restore value ${key} from local storage.`)
			}
		}
	}, [key])
	const updateValue = import_react99.default.useCallback(
		(setter) => {
			setState((s3) => {
				const value = typeof setter === 'function' ? setter(s3) : setter
				localStorage.setItem(key, JSON.stringify(value))
				return value
			})
		},
		[key]
	)
	return [state, updateValue]
}

// ../packages/ui/src/lib/components/NavigationZone/Minimap.tsx
init_define_process()
var React59 = __toESM(require_react())

// ../packages/ui/src/lib/components/NavigationZone/MinimapManager.ts
init_define_process()
var MinimapManager = class {
	constructor(app, dpr) {
		this.app = app
		this.dpr = dpr
	}
	colors = {
		shapeFill: 'rgba(144, 144, 144, .1)',
		selectFill: '#2f80ed',
		viewportFill: 'rgba(144, 144, 144, .1)',
	}
	id = uniqueId()
	cvs = null
	pageBounds = []
	collaborators = []
	canvasScreenBounds = new Box2d()
	canvasPageBounds = new Box2d()
	contentPageBounds = new Box2d()
	contentScreenBounds = new Box2d()
	originPagePoint = new Vec2d()
	originPageCenter = new Vec2d()
	isInViewport = false
	debug = false
	setDpr(dpr) {
		this.dpr = +dpr.toFixed(2)
	}
	updateContentScreenBounds = () => {
		const { contentScreenBounds, contentPageBounds: content, canvasScreenBounds: canvas } = this
		let { x: x3, y: y3, w: w3, h: h3 } = contentScreenBounds
		if (content.w > content.h) {
			const sh = canvas.w / (content.w / content.h)
			if (sh > canvas.h) {
				x3 = (canvas.w - canvas.w * (canvas.h / sh)) / 2
				y3 = 0
				w3 = canvas.w * (canvas.h / sh)
				h3 = canvas.h
			} else {
				x3 = 0
				y3 = (canvas.h - sh) / 2
				w3 = canvas.w
				h3 = sh
			}
		} else if (content.w < content.h) {
			const sw = canvas.h / (content.h / content.w)
			x3 = (canvas.w - sw) / 2
			y3 = 0
			w3 = sw
			h3 = canvas.h
		} else {
			x3 = canvas.h / 2
			y3 = 0
			w3 = canvas.h
			h3 = canvas.h
		}
		contentScreenBounds.set(x3, y3, w3, h3)
	}
	/** Get the canvas's true bounds converted to page bounds. */
	updateCanvasPageBounds = () => {
		const { canvasPageBounds, canvasScreenBounds, contentPageBounds, contentScreenBounds } = this
		canvasPageBounds.set(
			0,
			0,
			contentPageBounds.width / (contentScreenBounds.width / canvasScreenBounds.width),
			contentPageBounds.height / (contentScreenBounds.height / canvasScreenBounds.height)
		)
		canvasPageBounds.center = contentPageBounds.center
	}
	getScreenPoint = (x3, y3) => {
		const { canvasScreenBounds } = this
		const screenX = (x3 - canvasScreenBounds.minX) * this.dpr
		const screenY = (y3 - canvasScreenBounds.minY) * this.dpr
		return { x: screenX, y: screenY }
	}
	getPagePoint = (x3, y3) => {
		const { contentPageBounds, contentScreenBounds, canvasPageBounds } = this
		const { x: screenX, y: screenY } = this.getScreenPoint(x3, y3)
		return {
			x: canvasPageBounds.minX + (screenX * contentPageBounds.width) / contentScreenBounds.width,
			y: canvasPageBounds.minY + (screenY * contentPageBounds.height) / contentScreenBounds.height,
			z: 1,
		}
	}
	minimapScreenPointToPagePoint = (x3, y3, shiftKey = false, clampToBounds = false) => {
		const { app } = this
		const { viewportPageBounds } = app
		let { x: px, y: py } = this.getPagePoint(x3, y3)
		if (clampToBounds) {
			const shapesPageBounds = this.app.allShapesCommonBounds
			const vpPageBounds = viewportPageBounds
			const minX = (shapesPageBounds?.minX ?? 0) - vpPageBounds.width / 2
			const maxX = (shapesPageBounds?.maxX ?? 0) + vpPageBounds.width / 2
			const minY = (shapesPageBounds?.minY ?? 0) - vpPageBounds.height / 2
			const maxY = (shapesPageBounds?.maxY ?? 0) + vpPageBounds.height / 2
			const lx = Math.max(0, minX + vpPageBounds.width - px)
			const rx = Math.max(0, -(maxX - vpPageBounds.width - px))
			const ly = Math.max(0, minY + vpPageBounds.height - py)
			const ry = Math.max(0, -(maxY - vpPageBounds.height - py))
			const ql = Math.max(0, lx - rx)
			const qr = Math.max(0, rx - lx)
			const qt = Math.max(0, ly - ry)
			const qb = Math.max(0, ry - ly)
			if (ql && ql > qr) {
				px += ql / 2
			} else if (qr) {
				px -= qr / 2
			}
			if (qt && qt > qb) {
				py += qt / 2
			} else if (qb) {
				py -= qb / 2
			}
			px = clamp(px, minX, maxX)
			py = clamp(py, minY, maxY)
		}
		if (shiftKey) {
			const { originPagePoint } = this
			const dx = Math.abs(px - originPagePoint.x)
			const dy = Math.abs(py - originPagePoint.y)
			if (dx > dy) {
				py = originPagePoint.y
			} else {
				px = originPagePoint.x
			}
		}
		return { x: px, y: py }
	}
	render = () => {
		const { cvs, pageBounds } = this
		this.updateCanvasPageBounds()
		const { app, canvasScreenBounds, canvasPageBounds, contentPageBounds, contentScreenBounds } =
			this
		const { width: cw, height: ch } = canvasScreenBounds
		const { viewportPageBounds, selectedIds } = app
		if (!cvs || !pageBounds) {
			return
		}
		const ctx = cvs.getContext('2d')
		if (!ctx) {
			throw new Error('Minimap (shapes): Could not get context')
		}
		ctx.resetTransform()
		ctx.globalAlpha = 1
		ctx.clearRect(0, 0, cw, ch)
		const sx = contentScreenBounds.width / contentPageBounds.width
		const sy = contentScreenBounds.height / contentPageBounds.height
		ctx.translate((cw - contentScreenBounds.width) / 2, (ch - contentScreenBounds.height) / 2)
		ctx.scale(sx, sy)
		ctx.translate(-contentPageBounds.minX, -contentPageBounds.minY)
		const rx = 8 / sx
		const ry = 8 / sx
		const ax = 1 / sx
		const ay = 1 / sx
		const bx = rx / 4
		const by = ry / 4
		const shapesPath = new Path2D()
		const selectedPath = new Path2D()
		const { shapeFill, selectFill, viewportFill } = this.colors
		let pb
		for (let i3 = 0, n3 = pageBounds.length; i3 < n3; i3++) {
			pb = pageBounds[i3]
			MinimapManager.roundedRect(
				selectedIds.includes(pb.id) ? selectedPath : shapesPath,
				pb.minX,
				pb.minY,
				pb.width,
				pb.height,
				clamp(rx, ax, pb.width / bx),
				clamp(ry, ay, pb.height / by)
			)
		}
		ctx.fillStyle = shapeFill
		ctx.fill(shapesPath)
		ctx.fillStyle = selectFill
		ctx.fill(selectedPath)
		if (this.debug) {
			const commonBounds = Box2d.Common(pageBounds)
			const { minX, minY, width, height } = commonBounds
			ctx.strokeStyle = 'green'
			ctx.lineWidth = 2 / sx
			ctx.strokeRect(minX + 1 / sx, minY + 1 / sy, width - 2 / sx, height - 2 / sy)
		}
		{
			const { brush } = app
			if (brush) {
				const { x: x3, y: y3, w: w3, h: h3 } = brush
				ctx.beginPath()
				MinimapManager.sharpRect(ctx, x3, y3, w3, h3)
				ctx.closePath()
				ctx.fillStyle = viewportFill
				ctx.fill()
			}
		}
		{
			const { minX, minY, width, height } = viewportPageBounds
			ctx.beginPath()
			const rx2 = 12 / sx
			const ry2 = 12 / sx
			MinimapManager.roundedRect(
				ctx,
				minX,
				minY,
				width,
				height,
				Math.min(width / 4, rx2),
				Math.min(height / 4, ry2)
			)
			ctx.closePath()
			ctx.fillStyle = viewportFill
			ctx.fill()
			if (this.debug) {
				ctx.strokeStyle = 'orange'
				ctx.strokeRect(minX + 1 / sx, minY + 1 / sy, width - 2 / sx, height - 2 / sy)
			}
		}
		const px = 2.5 / sx
		const py = 2.5 / sy
		const { currentPageId } = app
		let collaborator
		for (let i3 = 0; i3 < this.collaborators.length; i3++) {
			collaborator = this.collaborators[i3]
			if (collaborator.currentPageId !== currentPageId) {
				continue
			}
			ctx.beginPath()
			ctx.ellipse(
				clamp(collaborator.cursor.x, canvasPageBounds.minX + px, canvasPageBounds.maxX - px),
				clamp(collaborator.cursor.y, canvasPageBounds.minY + py, canvasPageBounds.maxY - py),
				5 / sx,
				5 / sy,
				0,
				0,
				PI2
			)
			ctx.fillStyle = collaborator.color
			ctx.fill()
		}
		if (this.debug) {
			ctx.lineWidth = 2 / sx
			{
				const { minX, minY, width, height } = contentPageBounds
				ctx.strokeStyle = 'red'
				ctx.strokeRect(minX + 1 / sx, minY + 1 / sy, width - 2 / sx, height - 2 / sy)
			}
			{
				const { minX, minY, width, height } = canvasPageBounds
				ctx.strokeStyle = 'blue'
				ctx.strokeRect(minX + 1 / sx, minY + 1 / sy, width - 2 / sx, height - 2 / sy)
			}
		}
	}
	static roundedRect(ctx, x3, y3, width, height, rx, ry) {
		if (rx < 1 && ry < 1) {
			ctx.rect(x3, y3, width, height)
			return
		}
		ctx.moveTo(x3 + rx, y3)
		ctx.lineTo(x3 + width - rx, y3)
		ctx.quadraticCurveTo(x3 + width, y3, x3 + width, y3 + ry)
		ctx.lineTo(x3 + width, y3 + height - ry)
		ctx.quadraticCurveTo(x3 + width, y3 + height, x3 + width - rx, y3 + height)
		ctx.lineTo(x3 + rx, y3 + height)
		ctx.quadraticCurveTo(x3, y3 + height, x3, y3 + height - ry)
		ctx.lineTo(x3, y3 + ry)
		ctx.quadraticCurveTo(x3, y3, x3 + rx, y3)
	}
	static sharpRect(ctx, x3, y3, width, height, _rx, _ry) {
		ctx.rect(x3, y3, width, height)
	}
}

// ../packages/ui/src/lib/components/NavigationZone/Minimap.tsx
var import_jsx_runtime96 = __toESM(require_jsx_runtime())
var Minimap = track(function Minimap2({ shapeFill, selectFill, viewportFill }) {
	const app = useApp()
	const rCanvas = React59.useRef(null)
	const container = useContainer()
	const rPointing = React59.useRef(false)
	const minimap = React59.useMemo(() => new MinimapManager(app, app.devicePixelRatio), [app])
	const isDarkMode = app.isDarkMode
	React59.useEffect(() => {
		const raf2 = requestAnimationFrame(() => {
			const style = getComputedStyle(container)
			minimap.colors = {
				shapeFill: style.getPropertyValue(shapeFill).trim(),
				selectFill: style.getPropertyValue(selectFill).trim(),
				viewportFill: style.getPropertyValue(viewportFill).trim(),
			}
			minimap.render()
		})
		return () => {
			cancelAnimationFrame(raf2)
		}
	}, [container, selectFill, shapeFill, viewportFill, minimap, isDarkMode])
	const onDoubleClick = React59.useCallback(
		(e2) => {
			if (!app.shapeIds.size) return
			const { x: x3, y: y3 } = minimap.minimapScreenPointToPagePoint(
				e2.clientX,
				e2.clientY,
				false,
				false
			)
			const clampedPoint = minimap.minimapScreenPointToPagePoint(
				e2.clientX,
				e2.clientY,
				false,
				true
			)
			minimap.originPagePoint.setTo(clampedPoint)
			minimap.originPageCenter.setTo(app.viewportPageBounds.center)
			app.centerOnPoint(x3, y3, { duration: ANIMATION_MEDIUM_MS })
		},
		[app, minimap]
	)
	const onPointerDown = React59.useCallback(
		(e2) => {
			e2.currentTarget.setPointerCapture(e2.pointerId)
			if (!app.shapeIds.size) return
			rPointing.current = true
			minimap.isInViewport = false
			const { x: x3, y: y3 } = minimap.minimapScreenPointToPagePoint(
				e2.clientX,
				e2.clientY,
				false,
				false
			)
			const clampedPoint = minimap.minimapScreenPointToPagePoint(
				e2.clientX,
				e2.clientY,
				false,
				true
			)
			const _vpPageBounds = app.viewportPageBounds
			minimap.originPagePoint.setTo(clampedPoint)
			minimap.originPageCenter.setTo(_vpPageBounds.center)
			minimap.isInViewport = _vpPageBounds.containsPoint(clampedPoint)
			if (!minimap.isInViewport) {
				app.centerOnPoint(x3, y3, { duration: ANIMATION_MEDIUM_MS })
			}
		},
		[app, minimap]
	)
	const onPointerMove = React59.useCallback(
		(e2) => {
			if (rPointing.current) {
				const { x: x3, y: y3 } = minimap.minimapScreenPointToPagePoint(
					e2.clientX,
					e2.clientY,
					e2.shiftKey,
					true
				)
				if (minimap.isInViewport) {
					const delta = Vec2d.Sub({ x: x3, y: y3 }, minimap.originPagePoint)
					const center = Vec2d.Add(minimap.originPageCenter, delta)
					app.centerOnPoint(center.x, center.y)
					return
				}
				app.centerOnPoint(x3, y3)
			}
			const pagePoint = minimap.getPagePoint(e2.clientX, e2.clientY)
			const screenPoint = app.pageToScreen(pagePoint.x, pagePoint.y)
			const info = {
				type: 'pointer',
				target: 'canvas',
				name: 'pointer_move',
				...getPointerInfo2(e2),
				point: screenPoint,
				isPen: app.isPenMode,
			}
			app.dispatch(info)
		},
		[app, minimap]
	)
	const onPointerUp = React59.useCallback((_e) => {
		rPointing.current = false
	}, [])
	const onWheel = React59.useCallback(
		(e2) => {
			const offset = normalizeWheel(e2)
			app.dispatch({
				type: 'wheel',
				name: 'wheel',
				delta: offset,
				shiftKey: e2.shiftKey,
				altKey: e2.altKey,
				ctrlKey: e2.metaKey || e2.ctrlKey,
			})
		},
		[app]
	)
	useQuickReactor(
		'update dpr',
		() => {
			const { devicePixelRatio } = app
			minimap.setDpr(devicePixelRatio)
			const canvas = rCanvas.current
			const rect = canvas.getBoundingClientRect()
			const width = rect.width * devicePixelRatio
			const height = rect.height * devicePixelRatio
			canvas.width = width
			canvas.height = height
			minimap.canvasScreenBounds.set(rect.x, rect.y, width, height)
			minimap.cvs = rCanvas.current
		},
		[app, minimap]
	)
	const presences = React59.useMemo(() => {
		return app.store.query.records('instance_presence')
	}, [app])
	useQuickReactor(
		'minimap render when pagebounds or collaborators changes',
		() => {
			const { devicePixelRatio, viewportPageBounds, allShapesCommonBounds } = app
			devicePixelRatio
			minimap.contentPageBounds = allShapesCommonBounds
				? Box2d.Expand(allShapesCommonBounds, viewportPageBounds)
				: viewportPageBounds
			minimap.updateContentScreenBounds()
			const allShapeBounds = []
			app.shapeIds.forEach((id) => {
				let pageBounds = app.getPageBoundsById(id)
				const pageMask = app.getPageMaskById(id)
				if (pageMask) {
					const intersection = intersectPolygonPolygon(pageMask, pageBounds.corners)
					if (!intersection) {
						return
					}
					pageBounds = Box2d.FromPoints(intersection)
				}
				if (pageBounds) {
					pageBounds.id = id
					allShapeBounds.push(pageBounds)
				}
			})
			minimap.pageBounds = allShapeBounds
			minimap.collaborators = presences.value
			minimap.render()
		},
		[app, minimap]
	)
	return /* @__PURE__ */ (0, import_jsx_runtime96.jsx)('div', {
		className: 'tlui-minimap',
		children: /* @__PURE__ */ (0, import_jsx_runtime96.jsx)('canvas', {
			ref: rCanvas,
			className: 'tlui-minimap__canvas',
			onDoubleClick,
			onPointerMove,
			onPointerDown,
			onPointerUp,
			onWheel,
		}),
	})
})
function getPointerInfo2(e2) {
	e2.isKilled = true
	return {
		point: {
			x: e2.clientX,
			y: e2.clientY,
			z: e2.pressure,
		},
		shiftKey: e2.shiftKey,
		altKey: e2.altKey,
		ctrlKey: e2.metaKey || e2.ctrlKey,
		pointerId: e2.pointerId,
		button: e2.button,
		isPen: e2.pointerType === 'pen',
	}
}

// ../packages/ui/src/lib/components/NavigationZone/ZoomMenu.tsx
init_define_process()
var React60 = __toESM(require_react())
var import_jsx_runtime97 = __toESM(require_jsx_runtime())
var ZoomMenu = track(function ZoomMenu2() {
	const app = useApp()
	const msg2 = useTranslation()
	const breakpoint = useBreakpoint()
	const zoom = app.zoomLevel
	const hasShapes = app.shapeIds.size > 0
	const hasSelected = app.selectedIds.length > 0
	const isZoomedTo100 = app.zoomLevel === 1
	const handleDoubleClick = React60.useCallback(() => {
		app.resetZoom(app.viewportScreenCenter, { duration: ANIMATION_MEDIUM_MS })
	}, [app])
	return /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(Root, {
		id: 'zoom',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Trigger, {
				children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Button, {
					title: `${msg2('navigation-zone.zoom')}`,
					'data-testid': 'minimap.zoom-menu',
					className: breakpoint < 5 ? 'tlui-zoom-menu__button' : 'tlui-zoom-menu__button__pct',
					onDoubleClick: handleDoubleClick,
					icon: breakpoint < 4 ? 'zoom-in' : void 0,
					children:
						breakpoint < 4
							? null
							: /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)('span', {
									style: { flexGrow: 0, textAlign: 'center' },
									children: [Math.floor(zoom * 100), '%'],
							  }),
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Content, {
				side: 'top',
				align: 'start',
				alignOffset: 0,
				children: /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(Group, {
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ZoomMenuItem, {
							action: 'zoom-in',
							'data-testid': 'minimap.zoom-menu.zoom-in',
							noClose: true,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ZoomMenuItem, {
							action: 'zoom-out',
							'data-testid': 'minimap.zoom-menu.zoom-out',
							noClose: true,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ZoomMenuItem, {
							action: 'zoom-to-100',
							'data-testid': 'minimap.zoom-menu.zoom-to-100',
							noClose: true,
							disabled: isZoomedTo100,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ZoomMenuItem, {
							action: 'zoom-to-fit',
							disabled: !hasShapes,
							'data-testid': 'minimap.zoom-menu.zoom-to-fit',
							noClose: true,
						}),
						/* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ZoomMenuItem, {
							action: 'zoom-to-selection',
							disabled: !hasSelected,
							'data-testid': 'minimap.zoom-menu.zoom-to-selection',
							noClose: true,
						}),
					],
				}),
			}),
		],
	})
})
function ZoomMenuItem(props) {
	const { action, disabled = false, noClose = false } = props
	const actions = useActions()
	return /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Item, {
		label: actions[action].label,
		kbd: actions[action].kbd,
		'data-testid': props['data-testid'],
		onClick: () => actions[action].onSelect('zoom-menu'),
		noClose,
		disabled,
	})
}

// ../packages/ui/src/lib/components/NavigationZone/NavigationZone.tsx
var import_jsx_runtime98 = __toESM(require_jsx_runtime())
var NavigationZone = (0, import_react100.memo)(function NavigationZone2() {
	const actions = useActions()
	const msg2 = useTranslation()
	const breakpoint = useBreakpoint()
	const [collapsed, setCollapsed] = useLocalStorageState('minimap', true)
	const toggleMinimap = (0, import_react100.useCallback)(() => {
		setCollapsed((s3) => !s3)
	}, [setCollapsed])
	if (breakpoint < 4) {
		return null
	}
	return /* @__PURE__ */ (0, import_jsx_runtime98.jsxs)('div', {
		className: 'tlui-navigation-zone',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime98.jsx)('div', {
				className: 'tlui-navigation-zone__controls',
				children:
					breakpoint < 6
						? /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(ZoomMenu, {})
						: collapsed
						? /* @__PURE__ */ (0, import_jsx_runtime98.jsxs)(import_jsx_runtime98.Fragment, {
								children: [
									/* @__PURE__ */ (0, import_jsx_runtime98.jsx)(ZoomMenu, {}),
									/* @__PURE__ */ (0, import_jsx_runtime98.jsx)(Button, {
										title: msg2('navigation-zone.toggle-minimap'),
										className: 'tlui-navigation-zone__toggle',
										'data-testid': 'minimap.toggle',
										onClick: toggleMinimap,
										icon: collapsed ? 'chevrons-ne' : 'chevrons-sw',
									}),
								],
						  })
						: /* @__PURE__ */ (0, import_jsx_runtime98.jsxs)(import_jsx_runtime98.Fragment, {
								children: [
									/* @__PURE__ */ (0, import_jsx_runtime98.jsx)(Button, {
										icon: 'minus',
										'data-testid': 'minimap.zoom-out',
										title: `${msg2(actions['zoom-out'].label)} ${kbdStr(actions['zoom-out'].kbd)}`,
										onClick: () => actions['zoom-out'].onSelect('navigation-zone'),
									}),
									/* @__PURE__ */ (0, import_jsx_runtime98.jsx)(ZoomMenu, {}),
									/* @__PURE__ */ (0, import_jsx_runtime98.jsx)(Button, {
										icon: 'plus',
										'data-testid': 'minimap.zoom-in',
										title: `${msg2(actions['zoom-in'].label)} ${kbdStr(actions['zoom-in'].kbd)}`,
										onClick: () => actions['zoom-in'].onSelect('navigation-zone'),
									}),
									/* @__PURE__ */ (0, import_jsx_runtime98.jsx)(Button, {
										title: msg2('navigation-zone.toggle-minimap'),
										className: 'tlui-navigation-zone__toggle',
										onClick: toggleMinimap,
										icon: collapsed ? 'chevrons-ne' : 'chevrons-sw',
									}),
								],
						  }),
			}),
			breakpoint >= 6 &&
				!collapsed &&
				/* @__PURE__ */ (0, import_jsx_runtime98.jsx)(Minimap, {
					viewportFill: '--color-muted-1',
					selectFill: '--color-selected',
					shapeFill: '--color-text-3',
				}),
		],
	})
})

// ../packages/ui/src/lib/components/PenModeToggle.tsx
init_define_process()
var import_jsx_runtime99 = __toESM(require_jsx_runtime())
var ExitPenMode = track(function ExitPenMode2() {
	const app = useApp()
	const isPenMode = app.isPenMode
	const actions = useActions()
	if (!isPenMode) return null
	const action = actions['exit-pen-mode']
	return /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(Button, {
		label: action.label,
		iconLeft: action.icon,
		onClick: () => action.onSelect('helper-buttons'),
	})
})

// ../packages/ui/src/lib/components/StopFollowing.tsx
init_define_process()
var import_jsx_runtime100 = __toESM(require_jsx_runtime())
var StopFollowing = track(function ExitPenMode3() {
	const app = useApp()
	const actions = useActions()
	if (!app.instanceState.followingUserId) {
		return null
	}
	const action = actions['stop-following']
	return /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(Button, {
		label: action.label,
		iconLeft: action.icon,
		onClick: () => action.onSelect('people-menu'),
	})
})

// ../packages/ui/src/lib/components/StylePanel/StylePanel.tsx
init_define_process()
var import_react105 = __toESM(require_react())

// ../packages/ui/src/lib/components/primitives/ButtonPicker.tsx
init_define_process()
var import_classnames15 = __toESM(require_classnames())
var React61 = __toESM(require_react())
var import_react101 = __toESM(require_react())
var import_jsx_runtime101 = __toESM(require_jsx_runtime())
function _ButtonPicker(props) {
	const {
		items,
		title,
		styleType,
		value = null,
		onValueChange,
		columns = clamp(items.length, 2, 4),
	} = props
	const app = useApp()
	const msg2 = useTranslation()
	const rPointing = (0, import_react101.useRef)(false)
	const {
		handleButtonClick,
		handleButtonPointerDown,
		handleButtonPointerEnter,
		handleButtonPointerUp,
	} = React61.useMemo(() => {
		const handlePointerUp = () => {
			rPointing.current = false
			window.removeEventListener('pointerup', handlePointerUp)
		}
		const handleButtonClick2 = (e2) => {
			const { id } = e2.currentTarget.dataset
			if (value === id) return
			app.mark('point picker item')
			onValueChange(
				items.find((i3) => i3.id === id),
				false
			)
		}
		const handleButtonPointerDown2 = (e2) => {
			const { id } = e2.currentTarget.dataset
			app.mark('point picker item')
			onValueChange(
				items.find((i3) => i3.id === id),
				true
			)
			rPointing.current = true
			window.addEventListener('pointerup', handlePointerUp)
		}
		const handleButtonPointerEnter2 = (e2) => {
			if (!rPointing.current) return
			const { id } = e2.currentTarget.dataset
			onValueChange(
				items.find((i3) => i3.id === id),
				true
			)
		}
		const handleButtonPointerUp2 = (e2) => {
			const { id } = e2.currentTarget.dataset
			onValueChange(
				items.find((i3) => i3.id === id),
				false
			)
		}
		return {
			handleButtonClick: handleButtonClick2,
			handleButtonPointerDown: handleButtonPointerDown2,
			handleButtonPointerEnter: handleButtonPointerEnter2,
			handleButtonPointerUp: handleButtonPointerUp2,
		}
	}, [app, value, onValueChange, items])
	return /* @__PURE__ */ (0, import_jsx_runtime101.jsx)('div', {
		className: (0, import_classnames15.default)('tlui-button-grid', {
			'tlui-button-grid__two': columns === 2,
			'tlui-button-grid__three': columns === 3,
			'tlui-button-grid__four': columns === 4,
		}),
		children: items.map((item) =>
			/* @__PURE__ */ (0, import_jsx_runtime101.jsx)(
				Button,
				{
					'data-id': item.id,
					'data-testid': `${props['data-testid']}.${item.id}`,
					'aria-label': item.id,
					'data-state': value === item.id ? 'hinted' : void 0,
					title: title + ' \u2014 ' + msg2(`${styleType}-style.${item.id}`),
					className: (0, import_classnames15.default)('tlui-button-grid__button'),
					style: item.type === 'color' ? { color: `var(--palette-${item.id})` } : void 0,
					onPointerEnter: handleButtonPointerEnter,
					onPointerDown: handleButtonPointerDown,
					onPointerUp: handleButtonPointerUp,
					onClick: handleButtonClick,
					icon: item.icon,
				},
				item.id
			)
		),
	})
}
var ButtonPicker = React61.memo(_ButtonPicker)

// ../packages/ui/src/lib/components/primitives/Slider.tsx
init_define_process()

// ../node_modules/@radix-ui/react-slider/dist/index.module.js
init_define_process()
var import_react103 = __toESM(require_react())

// ../node_modules/@radix-ui/number/dist/index.module.js
init_define_process()
function $ae6933e535247d3d$export$7d15b64cf5a3a4c4(value, [min2, max]) {
	return Math.min(max, Math.max(min2, value))
}

// ../node_modules/@radix-ui/react-use-previous/dist/index.module.js
init_define_process()
var import_react102 = __toESM(require_react())
function $010c2913dbd2fe3d$export$5cae361ad82dce8b(value) {
	const ref = (0, import_react102.useRef)({
		value,
		previous: value,
	})
	return (0, import_react102.useMemo)(() => {
		if (ref.current.value !== value) {
			ref.current.previous = ref.current.value
			ref.current.value = value
		}
		return ref.current.previous
	}, [value])
}

// ../node_modules/@radix-ui/react-slider/dist/index.module.js
var $faa2e61a3361514f$var$PAGE_KEYS = ['PageUp', 'PageDown']
var $faa2e61a3361514f$var$ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight']
var $faa2e61a3361514f$var$BACK_KEYS = {
	'from-left': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],
	'from-right': ['Home', 'PageDown', 'ArrowDown', 'ArrowRight'],
	'from-bottom': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],
	'from-top': ['Home', 'PageDown', 'ArrowUp', 'ArrowLeft'],
}
var $faa2e61a3361514f$var$SLIDER_NAME = 'Slider'
var [
	$faa2e61a3361514f$var$Collection,
	$faa2e61a3361514f$var$useCollection,
	$faa2e61a3361514f$var$createCollectionScope,
] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($faa2e61a3361514f$var$SLIDER_NAME)
var [$faa2e61a3361514f$var$createSliderContext, $faa2e61a3361514f$export$ef72632d7b901f97] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1($faa2e61a3361514f$var$SLIDER_NAME, [
		$faa2e61a3361514f$var$createCollectionScope,
	])
var [$faa2e61a3361514f$var$SliderProvider, $faa2e61a3361514f$var$useSliderContext] =
	$faa2e61a3361514f$var$createSliderContext($faa2e61a3361514f$var$SLIDER_NAME)
var $faa2e61a3361514f$export$472062a354075cee = /* @__PURE__ */ (0, import_react103.forwardRef)(
	(props, forwardedRef) => {
		const {
			name,
			min: min2 = 0,
			max = 100,
			step = 1,
			orientation = 'horizontal',
			disabled = false,
			minStepsBetweenThumbs = 0,
			defaultValue = [min2],
			value: value1,
			onValueChange = () => {},
			onValueCommit = () => {},
			inverted = false,
			...sliderProps
		} = props
		const [slider, setSlider] = (0, import_react103.useState)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setSlider(node)
		)
		const thumbRefs = (0, import_react103.useRef)(/* @__PURE__ */ new Set())
		const valueIndexToChangeRef = (0, import_react103.useRef)(0)
		const isHorizontal = orientation === 'horizontal'
		const isFormControl = slider ? Boolean(slider.closest('form')) : true
		const SliderOrientation = isHorizontal
			? $faa2e61a3361514f$var$SliderHorizontal
			: $faa2e61a3361514f$var$SliderVertical
		const [values = [], setValues] = $71cd76cc60e0454e$export$6f32135080cb4c3({
			prop: value1,
			defaultProp: defaultValue,
			onChange: (value) => {
				var _thumbs$valueIndexToC
				const thumbs = [...thumbRefs.current]
				;(_thumbs$valueIndexToC = thumbs[valueIndexToChangeRef.current]) === null ||
					_thumbs$valueIndexToC === void 0 ||
					_thumbs$valueIndexToC.focus()
				onValueChange(value)
			},
		})
		const valuesBeforeSlideStartRef = (0, import_react103.useRef)(values)
		function handleSlideStart(value) {
			const closestIndex = $faa2e61a3361514f$var$getClosestValueIndex(values, value)
			updateValues(value, closestIndex)
		}
		function handleSlideMove(value) {
			updateValues(value, valueIndexToChangeRef.current)
		}
		function handleSlideEnd() {
			const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current]
			const nextValue = values[valueIndexToChangeRef.current]
			const hasChanged = nextValue !== prevValue
			if (hasChanged) onValueCommit(values)
		}
		function updateValues(
			value,
			atIndex,
			{ commit } = {
				commit: false,
			}
		) {
			const decimalCount = $faa2e61a3361514f$var$getDecimalCount(step)
			const snapToStep = $faa2e61a3361514f$var$roundValue(
				Math.round((value - min2) / step) * step + min2,
				decimalCount
			)
			const nextValue = $ae6933e535247d3d$export$7d15b64cf5a3a4c4(snapToStep, [min2, max])
			setValues((prevValues = []) => {
				const nextValues = $faa2e61a3361514f$var$getNextSortedValues(prevValues, nextValue, atIndex)
				if (
					$faa2e61a3361514f$var$hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)
				) {
					valueIndexToChangeRef.current = nextValues.indexOf(nextValue)
					const hasChanged = String(nextValues) !== String(prevValues)
					if (hasChanged && commit) onValueCommit(nextValues)
					return hasChanged ? nextValues : prevValues
				} else return prevValues
			})
		}
		return /* @__PURE__ */ (0, import_react103.createElement)(
			$faa2e61a3361514f$var$SliderProvider,
			{
				scope: props.__scopeSlider,
				disabled,
				min: min2,
				max,
				valueIndexToChangeRef,
				thumbs: thumbRefs.current,
				values,
				orientation,
			},
			/* @__PURE__ */ (0, import_react103.createElement)(
				$faa2e61a3361514f$var$Collection.Provider,
				{
					scope: props.__scopeSlider,
				},
				/* @__PURE__ */ (0, import_react103.createElement)(
					$faa2e61a3361514f$var$Collection.Slot,
					{
						scope: props.__scopeSlider,
					},
					/* @__PURE__ */ (0, import_react103.createElement)(
						SliderOrientation,
						_extends(
							{
								'aria-disabled': disabled,
								'data-disabled': disabled ? '' : void 0,
							},
							sliderProps,
							{
								ref: composedRefs,
								onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
									sliderProps.onPointerDown,
									() => {
										if (!disabled) valuesBeforeSlideStartRef.current = values
									}
								),
								min: min2,
								max,
								inverted,
								onSlideStart: disabled ? void 0 : handleSlideStart,
								onSlideMove: disabled ? void 0 : handleSlideMove,
								onSlideEnd: disabled ? void 0 : handleSlideEnd,
								onHomeKeyDown: () =>
									!disabled &&
									updateValues(min2, 0, {
										commit: true,
									}),
								onEndKeyDown: () =>
									!disabled &&
									updateValues(max, values.length - 1, {
										commit: true,
									}),
								onStepKeyDown: ({ event, direction: stepDirection }) => {
									if (!disabled) {
										const isPageKey = $faa2e61a3361514f$var$PAGE_KEYS.includes(event.key)
										const isSkipKey =
											isPageKey ||
											(event.shiftKey && $faa2e61a3361514f$var$ARROW_KEYS.includes(event.key))
										const multiplier = isSkipKey ? 10 : 1
										const atIndex = valueIndexToChangeRef.current
										const value = values[atIndex]
										const stepInDirection = step * multiplier * stepDirection
										updateValues(value + stepInDirection, atIndex, {
											commit: true,
										})
									}
								},
							}
						)
					)
				)
			),
			isFormControl &&
				values.map((value, index2) =>
					/* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$BubbleInput, {
						key: index2,
						name: name ? name + (values.length > 1 ? '[]' : '') : void 0,
						value,
					})
				)
		)
	}
)
var [
	$faa2e61a3361514f$var$SliderOrientationProvider,
	$faa2e61a3361514f$var$useSliderOrientationContext,
] = $faa2e61a3361514f$var$createSliderContext($faa2e61a3361514f$var$SLIDER_NAME, {
	startEdge: 'left',
	endEdge: 'right',
	size: 'width',
	direction: 1,
})
var $faa2e61a3361514f$var$SliderHorizontal = /* @__PURE__ */ (0, import_react103.forwardRef)(
	(props, forwardedRef) => {
		const {
			min: min2,
			max,
			dir,
			inverted,
			onSlideStart,
			onSlideMove,
			onSlideEnd,
			onStepKeyDown,
			...sliderProps
		} = props
		const [slider, setSlider] = (0, import_react103.useState)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setSlider(node)
		)
		const rectRef = (0, import_react103.useRef)()
		const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir)
		const isDirectionLTR = direction === 'ltr'
		const isSlidingFromLeft = (isDirectionLTR && !inverted) || (!isDirectionLTR && inverted)
		function getValueFromPointer(pointerPosition) {
			const rect = rectRef.current || slider.getBoundingClientRect()
			const input = [0, rect.width]
			const output = isSlidingFromLeft ? [min2, max] : [max, min2]
			const value = $faa2e61a3361514f$var$linearScale(input, output)
			rectRef.current = rect
			return value(pointerPosition - rect.left)
		}
		return /* @__PURE__ */ (0, import_react103.createElement)(
			$faa2e61a3361514f$var$SliderOrientationProvider,
			{
				scope: props.__scopeSlider,
				startEdge: isSlidingFromLeft ? 'left' : 'right',
				endEdge: isSlidingFromLeft ? 'right' : 'left',
				direction: isSlidingFromLeft ? 1 : -1,
				size: 'width',
			},
			/* @__PURE__ */ (0, import_react103.createElement)(
				$faa2e61a3361514f$var$SliderImpl,
				_extends(
					{
						dir: direction,
						'data-orientation': 'horizontal',
					},
					sliderProps,
					{
						ref: composedRefs,
						style: {
							...sliderProps.style,
							['--radix-slider-thumb-transform']: 'translateX(-50%)',
						},
						onSlideStart: (event) => {
							const value = getValueFromPointer(event.clientX)
							onSlideStart === null || onSlideStart === void 0 || onSlideStart(value)
						},
						onSlideMove: (event) => {
							const value = getValueFromPointer(event.clientX)
							onSlideMove === null || onSlideMove === void 0 || onSlideMove(value)
						},
						onSlideEnd: () => {
							rectRef.current = void 0
							onSlideEnd === null || onSlideEnd === void 0 || onSlideEnd()
						},
						onStepKeyDown: (event) => {
							const slideDirection = isSlidingFromLeft ? 'from-left' : 'from-right'
							const isBackKey = $faa2e61a3361514f$var$BACK_KEYS[slideDirection].includes(event.key)
							onStepKeyDown === null ||
								onStepKeyDown === void 0 ||
								onStepKeyDown({
									event,
									direction: isBackKey ? -1 : 1,
								})
						},
					}
				)
			)
		)
	}
)
var $faa2e61a3361514f$var$SliderVertical = /* @__PURE__ */ (0, import_react103.forwardRef)(
	(props, forwardedRef) => {
		const {
			min: min2,
			max,
			inverted,
			onSlideStart,
			onSlideMove,
			onSlideEnd,
			onStepKeyDown,
			...sliderProps
		} = props
		const sliderRef = (0, import_react103.useRef)(null)
		const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, sliderRef)
		const rectRef = (0, import_react103.useRef)()
		const isSlidingFromBottom = !inverted
		function getValueFromPointer(pointerPosition) {
			const rect = rectRef.current || sliderRef.current.getBoundingClientRect()
			const input = [0, rect.height]
			const output = isSlidingFromBottom ? [max, min2] : [min2, max]
			const value = $faa2e61a3361514f$var$linearScale(input, output)
			rectRef.current = rect
			return value(pointerPosition - rect.top)
		}
		return /* @__PURE__ */ (0, import_react103.createElement)(
			$faa2e61a3361514f$var$SliderOrientationProvider,
			{
				scope: props.__scopeSlider,
				startEdge: isSlidingFromBottom ? 'bottom' : 'top',
				endEdge: isSlidingFromBottom ? 'top' : 'bottom',
				size: 'height',
				direction: isSlidingFromBottom ? 1 : -1,
			},
			/* @__PURE__ */ (0, import_react103.createElement)(
				$faa2e61a3361514f$var$SliderImpl,
				_extends(
					{
						'data-orientation': 'vertical',
					},
					sliderProps,
					{
						ref,
						style: {
							...sliderProps.style,
							['--radix-slider-thumb-transform']: 'translateY(50%)',
						},
						onSlideStart: (event) => {
							const value = getValueFromPointer(event.clientY)
							onSlideStart === null || onSlideStart === void 0 || onSlideStart(value)
						},
						onSlideMove: (event) => {
							const value = getValueFromPointer(event.clientY)
							onSlideMove === null || onSlideMove === void 0 || onSlideMove(value)
						},
						onSlideEnd: () => {
							rectRef.current = void 0
							onSlideEnd === null || onSlideEnd === void 0 || onSlideEnd()
						},
						onStepKeyDown: (event) => {
							const slideDirection = isSlidingFromBottom ? 'from-bottom' : 'from-top'
							const isBackKey = $faa2e61a3361514f$var$BACK_KEYS[slideDirection].includes(event.key)
							onStepKeyDown === null ||
								onStepKeyDown === void 0 ||
								onStepKeyDown({
									event,
									direction: isBackKey ? -1 : 1,
								})
						},
					}
				)
			)
		)
	}
)
var $faa2e61a3361514f$var$SliderImpl = /* @__PURE__ */ (0, import_react103.forwardRef)(
	(props, forwardedRef) => {
		const {
			__scopeSlider,
			onSlideStart,
			onSlideMove,
			onSlideEnd,
			onHomeKeyDown,
			onEndKeyDown,
			onStepKeyDown,
			...sliderProps
		} = props
		const context = $faa2e61a3361514f$var$useSliderContext(
			$faa2e61a3361514f$var$SLIDER_NAME,
			__scopeSlider
		)
		return /* @__PURE__ */ (0, import_react103.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.span,
			_extends({}, sliderProps, {
				ref: forwardedRef,
				onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
					if (event.key === 'Home') {
						onHomeKeyDown(event)
						event.preventDefault()
					} else if (event.key === 'End') {
						onEndKeyDown(event)
						event.preventDefault()
					} else if (
						$faa2e61a3361514f$var$PAGE_KEYS
							.concat($faa2e61a3361514f$var$ARROW_KEYS)
							.includes(event.key)
					) {
						onStepKeyDown(event)
						event.preventDefault()
					}
				}),
				onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
					const target = event.target
					target.setPointerCapture(event.pointerId)
					event.preventDefault()
					if (context.thumbs.has(target)) target.focus()
					else onSlideStart(event)
				}),
				onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event) => {
					const target = event.target
					if (target.hasPointerCapture(event.pointerId)) onSlideMove(event)
				}),
				onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
					const target = event.target
					if (target.hasPointerCapture(event.pointerId)) {
						target.releasePointerCapture(event.pointerId)
						onSlideEnd(event)
					}
				}),
			})
		)
	}
)
var $faa2e61a3361514f$var$TRACK_NAME = 'SliderTrack'
var $faa2e61a3361514f$export$105594979f116971 = /* @__PURE__ */ (0, import_react103.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeSlider, ...trackProps } = props
		const context = $faa2e61a3361514f$var$useSliderContext(
			$faa2e61a3361514f$var$TRACK_NAME,
			__scopeSlider
		)
		return /* @__PURE__ */ (0, import_react103.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.span,
			_extends(
				{
					'data-disabled': context.disabled ? '' : void 0,
					'data-orientation': context.orientation,
				},
				trackProps,
				{
					ref: forwardedRef,
				}
			)
		)
	}
)
var $faa2e61a3361514f$var$RANGE_NAME = 'SliderRange'
var $faa2e61a3361514f$export$a5cf38a7a000fe77 = /* @__PURE__ */ (0, import_react103.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeSlider, ...rangeProps } = props
		const context = $faa2e61a3361514f$var$useSliderContext(
			$faa2e61a3361514f$var$RANGE_NAME,
			__scopeSlider
		)
		const orientation = $faa2e61a3361514f$var$useSliderOrientationContext(
			$faa2e61a3361514f$var$RANGE_NAME,
			__scopeSlider
		)
		const ref = (0, import_react103.useRef)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref)
		const valuesCount = context.values.length
		const percentages = context.values.map((value) =>
			$faa2e61a3361514f$var$convertValueToPercentage(value, context.min, context.max)
		)
		const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0
		const offsetEnd = 100 - Math.max(...percentages)
		return /* @__PURE__ */ (0, import_react103.createElement)(
			$8927f6f2acc4f386$export$250ffa63cdc0d034.span,
			_extends(
				{
					'data-orientation': context.orientation,
					'data-disabled': context.disabled ? '' : void 0,
				},
				rangeProps,
				{
					ref: composedRefs,
					style: {
						...props.style,
						[orientation.startEdge]: offsetStart + '%',
						[orientation.endEdge]: offsetEnd + '%',
					},
				}
			)
		)
	}
)
var $faa2e61a3361514f$var$THUMB_NAME = 'SliderThumb'
var $faa2e61a3361514f$export$2c1b491743890dec = /* @__PURE__ */ (0, import_react103.forwardRef)(
	(props, forwardedRef) => {
		const getItems = $faa2e61a3361514f$var$useCollection(props.__scopeSlider)
		const [thumb, setThumb] = (0, import_react103.useState)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setThumb(node)
		)
		const index2 = (0, import_react103.useMemo)(
			() => (thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1),
			[getItems, thumb]
		)
		return /* @__PURE__ */ (0, import_react103.createElement)(
			$faa2e61a3361514f$var$SliderThumbImpl,
			_extends({}, props, {
				ref: composedRefs,
				index: index2,
			})
		)
	}
)
var $faa2e61a3361514f$var$SliderThumbImpl = /* @__PURE__ */ (0, import_react103.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeSlider, index: index2, ...thumbProps } = props
		const context = $faa2e61a3361514f$var$useSliderContext(
			$faa2e61a3361514f$var$THUMB_NAME,
			__scopeSlider
		)
		const orientation = $faa2e61a3361514f$var$useSliderOrientationContext(
			$faa2e61a3361514f$var$THUMB_NAME,
			__scopeSlider
		)
		const [thumb, setThumb] = (0, import_react103.useState)(null)
		const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node) =>
			setThumb(node)
		)
		const size = $db6c3485150b8e66$export$1ab7ae714698c4b8(thumb)
		const value = context.values[index2]
		const percent =
			value === void 0
				? 0
				: $faa2e61a3361514f$var$convertValueToPercentage(value, context.min, context.max)
		const label = $faa2e61a3361514f$var$getLabel(index2, context.values.length)
		const orientationSize = size === null || size === void 0 ? void 0 : size[orientation.size]
		const thumbInBoundsOffset = orientationSize
			? $faa2e61a3361514f$var$getThumbInBoundsOffset(
					orientationSize,
					percent,
					orientation.direction
			  )
			: 0
		;(0, import_react103.useEffect)(() => {
			if (thumb) {
				context.thumbs.add(thumb)
				return () => {
					context.thumbs.delete(thumb)
				}
			}
		}, [thumb, context.thumbs])
		return /* @__PURE__ */ (0, import_react103.createElement)(
			'span',
			{
				style: {
					transform: 'var(--radix-slider-thumb-transform)',
					position: 'absolute',
					[orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,
				},
			},
			/* @__PURE__ */ (0, import_react103.createElement)(
				$faa2e61a3361514f$var$Collection.ItemSlot,
				{
					scope: props.__scopeSlider,
				},
				/* @__PURE__ */ (0, import_react103.createElement)(
					$8927f6f2acc4f386$export$250ffa63cdc0d034.span,
					_extends(
						{
							role: 'slider',
							'aria-label': props['aria-label'] || label,
							'aria-valuemin': context.min,
							'aria-valuenow': value,
							'aria-valuemax': context.max,
							'aria-orientation': context.orientation,
							'data-orientation': context.orientation,
							'data-disabled': context.disabled ? '' : void 0,
							tabIndex: context.disabled ? void 0 : 0,
						},
						thumbProps,
						{
							ref: composedRefs,
							style:
								value === void 0
									? {
											display: 'none',
									  }
									: props.style,
							onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
								context.valueIndexToChangeRef.current = index2
							}),
						}
					)
				)
			)
		)
	}
)
var $faa2e61a3361514f$var$BubbleInput = (props) => {
	const { value, ...inputProps } = props
	const ref = (0, import_react103.useRef)(null)
	const prevValue = $010c2913dbd2fe3d$export$5cae361ad82dce8b(value)
	;(0, import_react103.useEffect)(() => {
		const input = ref.current
		const inputProto = window.HTMLInputElement.prototype
		const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value')
		const setValue = descriptor.set
		if (prevValue !== value && setValue) {
			const event = new Event('input', {
				bubbles: true,
			})
			setValue.call(input, value)
			input.dispatchEvent(event)
		}
	}, [prevValue, value])
	return /* @__PURE__ */ (0, import_react103.createElement)(
		'input',
		_extends(
			{
				style: {
					display: 'none',
				},
			},
			inputProps,
			{
				ref,
				defaultValue: value,
			}
		)
	)
}
function $faa2e61a3361514f$var$getNextSortedValues(prevValues = [], nextValue, atIndex) {
	const nextValues = [...prevValues]
	nextValues[atIndex] = nextValue
	return nextValues.sort((a3, b3) => a3 - b3)
}
function $faa2e61a3361514f$var$convertValueToPercentage(value, min2, max) {
	const maxSteps = max - min2
	const percentPerStep = 100 / maxSteps
	return percentPerStep * (value - min2)
}
function $faa2e61a3361514f$var$getLabel(index2, totalValues) {
	if (totalValues > 2) return `Value ${index2 + 1} of ${totalValues}`
	else if (totalValues === 2) return ['Minimum', 'Maximum'][index2]
	else return void 0
}
function $faa2e61a3361514f$var$getClosestValueIndex(values, nextValue) {
	if (values.length === 1) return 0
	const distances = values.map((value) => Math.abs(value - nextValue))
	const closestDistance = Math.min(...distances)
	return distances.indexOf(closestDistance)
}
function $faa2e61a3361514f$var$getThumbInBoundsOffset(width, left, direction) {
	const halfWidth = width / 2
	const halfPercent = 50
	const offset = $faa2e61a3361514f$var$linearScale([0, halfPercent], [0, halfWidth])
	return (halfWidth - offset(left) * direction) * direction
}
function $faa2e61a3361514f$var$getStepsBetweenValues(values) {
	return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value)
}
function $faa2e61a3361514f$var$hasMinStepsBetweenValues(values, minStepsBetweenValues) {
	if (minStepsBetweenValues > 0) {
		const stepsBetweenValues = $faa2e61a3361514f$var$getStepsBetweenValues(values)
		const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues)
		return actualMinStepsBetweenValues >= minStepsBetweenValues
	}
	return true
}
function $faa2e61a3361514f$var$linearScale(input, output) {
	return (value) => {
		if (input[0] === input[1] || output[0] === output[1]) return output[0]
		const ratio = (output[1] - output[0]) / (input[1] - input[0])
		return output[0] + ratio * (value - input[0])
	}
}
function $faa2e61a3361514f$var$getDecimalCount(value) {
	return (String(value).split('.')[1] || '').length
}
function $faa2e61a3361514f$var$roundValue(value, decimalCount) {
	const rounder = Math.pow(10, decimalCount)
	return Math.round(value * rounder) / rounder
}
var $faa2e61a3361514f$export$be92b6f5f03c0fe9 = $faa2e61a3361514f$export$472062a354075cee
var $faa2e61a3361514f$export$13921ac0cc260818 = $faa2e61a3361514f$export$105594979f116971
var $faa2e61a3361514f$export$9a58ef0d7ad3278c = $faa2e61a3361514f$export$a5cf38a7a000fe77
var $faa2e61a3361514f$export$6521433ed15a34db = $faa2e61a3361514f$export$2c1b491743890dec

// ../packages/ui/src/lib/components/primitives/Slider.tsx
var import_react104 = __toESM(require_react())
var import_jsx_runtime102 = __toESM(require_jsx_runtime())
function Slider(props) {
	const { title, steps, value, label, onValueChange } = props
	const app = useApp()
	const msg2 = useTranslation()
	const handleValueChange = (0, import_react104.useCallback)(
		(value2) => {
			onValueChange(value2[0], true)
		},
		[onValueChange]
	)
	const handlePointerDown = (0, import_react104.useCallback)(() => {
		app.mark('click slider')
	}, [app])
	const handlePointerUp = (0, import_react104.useCallback)(() => {
		if (!value) return
		onValueChange(value, false)
	}, [value, onValueChange])
	return /* @__PURE__ */ (0, import_jsx_runtime102.jsx)('div', {
		className: 'tlui-slider__container',
		children: /* @__PURE__ */ (0, import_jsx_runtime102.jsxs)(
			$faa2e61a3361514f$export$be92b6f5f03c0fe9,
			{
				'data-testid': props['data-testid'],
				className: 'tlui-slider',
				'area-label': 'Opacity',
				dir: 'ltr',
				min: 0,
				max: steps,
				step: 1,
				value: value ? [value] : void 0,
				onPointerDown: handlePointerDown,
				onValueChange: handleValueChange,
				onPointerUp: handlePointerUp,
				title: title + ' \u2014 ' + msg2(label),
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
						$faa2e61a3361514f$export$13921ac0cc260818,
						{
							className: 'tlui-slider__track',
							dir: 'ltr',
							children:
								value !== null &&
								/* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
									$faa2e61a3361514f$export$9a58ef0d7ad3278c,
									{ className: 'tlui-slider__range', dir: 'ltr' }
								),
						}
					),
					value !== null &&
						/* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
							$faa2e61a3361514f$export$6521433ed15a34db,
							{ className: 'tlui-slider__thumb', dir: 'ltr' }
						),
				],
			}
		),
	})
}

// ../packages/ui/src/lib/components/StylePanel/DoubleDropdownPicker.tsx
init_define_process()
var import_classnames16 = __toESM(require_classnames())
var React62 = __toESM(require_react())
var import_jsx_runtime103 = __toESM(require_jsx_runtime())
var DoubleDropdownPicker = React62.memo(function DoubleDropdownPicker2({
	'data-testid': dataWd,
	label,
	labelA,
	labelB,
	itemsA,
	itemsB,
	styleTypeA,
	styleTypeB,
	valueA,
	valueB,
	onValueChange,
}) {
	const msg2 = useTranslation()
	const iconA = React62.useMemo(
		() => itemsA.find((item) => item.id === valueA)?.icon ?? 'mixed',
		[itemsA, valueA]
	)
	const iconB = React62.useMemo(
		() => itemsB.find((item) => item.id === valueB)?.icon ?? 'mixed',
		[itemsB, valueB]
	)
	if (valueA === void 0 && valueB === void 0) return null
	const startWdPrefix = `${dataWd}.start`
	const endWdPrefix = `${dataWd}.end`
	return /* @__PURE__ */ (0, import_jsx_runtime103.jsxs)('div', {
		className: 'tlui-style-panel__double-select-picker',
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime103.jsx)('div', {
				title: msg2(label),
				className: 'tlui-style-panel__double-select-picker-label',
				children: msg2(label),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime103.jsxs)(Root, {
				id: `style panel ${styleTypeA}`,
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
						$d08ef79370b62062$export$41fb9f06171c75f4,
						{
							asChild: true,
							children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(Button, {
								'data-testid': startWdPrefix,
								title:
									msg2(labelA) +
									' \u2014 ' +
									(valueA === null
										? msg2('style-panel.mixed')
										: msg2(`${styleTypeA}-style.${valueA}`)),
								icon: iconA,
								invertIcon: true,
								smallIcon: true,
							}),
						}
					),
					/* @__PURE__ */ (0, import_jsx_runtime103.jsx)(Content, {
						side: 'bottom',
						align: 'end',
						sideOffset: 0,
						alignOffset: -2,
						children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)('div', {
							className: (0, import_classnames16.default)('tlui-button-grid', {
								'tlui-button-grid__two': itemsA.length < 4,
								'tlui-button-grid__four': itemsA.length >= 4,
							}),
							children: itemsA.map((item) => {
								return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
									Item,
									{
										className: 'tlui-button-grid__button',
										title: msg2(labelA) + ' \u2014 ' + msg2(`${styleTypeA}-style.${item.id}`),
										'data-testid': `${startWdPrefix}.${item.id}`,
										icon: item.icon,
										onClick: () => onValueChange(item, false),
										invertIcon: true,
									},
									item.id
								)
							}),
						}),
					}),
				],
			}),
			/* @__PURE__ */ (0, import_jsx_runtime103.jsxs)(Root, {
				id: `style panel ${styleTypeB}`,
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
						$d08ef79370b62062$export$41fb9f06171c75f4,
						{
							asChild: true,
							children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(Button, {
								'data-testid': endWdPrefix,
								title:
									msg2(labelB) +
									' \u2014 ' +
									(valueB === null
										? msg2('style-panel.mixed')
										: msg2(`${styleTypeB}-style.${valueB}`)),
								icon: iconB,
								smallIcon: true,
							}),
						}
					),
					/* @__PURE__ */ (0, import_jsx_runtime103.jsx)(Content, {
						side: 'bottom',
						align: 'end',
						sideOffset: 0,
						alignOffset: -2,
						children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)('div', {
							className: (0, import_classnames16.default)('tlui-button-grid', {
								'tlui-button-grid__two': itemsA.length < 4,
								'tlui-button-grid__four': itemsA.length >= 4,
							}),
							children: itemsB.map((item) => {
								return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
									Item,
									{
										className: 'tlui-button-grid__button',
										title: msg2(labelB) + ' \u2014 ' + msg2(`${styleTypeB}-style.${item.id}`),
										'data-testid': `${endWdPrefix}.${item.id}`,
										icon: item.icon,
										onClick: () => onValueChange(item, false),
									},
									item.id
								)
							}),
						}),
					}),
				],
			}),
		],
	})
})

// ../packages/ui/src/lib/components/StylePanel/DropdownPicker.tsx
init_define_process()
var import_classnames17 = __toESM(require_classnames())
var React63 = __toESM(require_react())
var import_jsx_runtime104 = __toESM(require_jsx_runtime())
var DropdownPicker = React63.memo(function DropdownPicker2({
	id,
	items,
	styleType,
	label,
	value,
	onValueChange,
	'data-testid': dataWd,
}) {
	const msg2 = useTranslation()
	const icon = React63.useMemo(() => items.find((item) => item.id === value)?.icon, [items, value])
	return /* @__PURE__ */ (0, import_jsx_runtime104.jsxs)(Root, {
		id: `style panel ${id}`,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime104.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, {
				asChild: true,
				children: /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(Button, {
					'data-testid': dataWd,
					title: value === null ? msg2('style-panel.mixed') : msg2(`${styleType}-style.${value}`),
					label,
					icon: icon ?? 'mixed',
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime104.jsx)(Content, {
				side: 'left',
				align: 'center',
				alignOffset: 0,
				children: /* @__PURE__ */ (0, import_jsx_runtime104.jsx)('div', {
					className: (0, import_classnames17.default)('tlui-button-grid', {
						'tlui-button-grid__two': items.length < 3,
						'tlui-button-grid__three': items.length == 3,
						'tlui-button-grid__four': items.length >= 4,
					}),
					children: items.map((item) => {
						return /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
							Item,
							{
								className: 'tlui-button-grid__button',
								'data-testid': `${dataWd}.${item.id}`,
								title: msg2(`${styleType}-style.${item.id}`),
								icon: item.icon,
								onClick: () => onValueChange(item, false),
							},
							item.id
						)
					}),
				}),
			}),
		],
	})
})

// ../packages/ui/src/lib/components/StylePanel/StylePanel.tsx
var import_jsx_runtime105 = __toESM(require_jsx_runtime())
var StylePanel = function StylePanel2({ isMobile }) {
	const app = useApp()
	const props = useValue('props', () => app.props, [app])
	const handlePointerOut = (0, import_react105.useCallback)(() => {
		if (!isMobile) {
			app.isChangingStyle = false
		}
	}, [app, isMobile])
	if (!props) return null
	const { geo, arrowheadEnd, arrowheadStart, spline, font } = props
	const hideGeo = geo === void 0
	const hideArrowHeads = arrowheadEnd === void 0 && arrowheadStart === void 0
	const hideSpline = spline === void 0
	const hideText = font === void 0
	return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)('div', {
		className: 'tlui-style-panel',
		'data-ismobile': isMobile,
		onPointerLeave: handlePointerOut,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime105.jsx)(CommonStylePickerSet, { props }),
			!hideText && /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(TextStylePickerSet, { props }),
			!(hideGeo && hideArrowHeads && hideSpline) &&
				/* @__PURE__ */ (0, import_jsx_runtime105.jsxs)('div', {
					className: 'tlui-style-panel__section',
					'aria-label': 'style panel styles',
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime105.jsx)(GeoStylePickerSet, { props }),
						/* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ArrowheadStylePickerSet, { props }),
						/* @__PURE__ */ (0, import_jsx_runtime105.jsx)(SplineStylePickerSet, { props }),
					],
				}),
		],
	})
}
var { styles } = App
function useStyleChangeCallback() {
	const app = useApp()
	return import_react105.default.useCallback(
		(item, squashing) => {
			app.batch(() => {
				app.setProp(item.type, item.id, false, squashing)
				app.isChangingStyle = true
			})
		},
		[app]
	)
}
function CommonStylePickerSet({ props }) {
	const app = useApp()
	const msg2 = useTranslation()
	const handleValueChange = useStyleChangeCallback()
	const handleOpacityValueChange = import_react105.default.useCallback(
		(value, ephemeral) => {
			const item = styles.opacity[value]
			app.setProp(item.type, item.id, ephemeral)
			app.isChangingStyle = true
		},
		[app]
	)
	const { color, fill, dash, size, opacity } = props
	if (
		color === void 0 &&
		fill === void 0 &&
		dash === void 0 &&
		size === void 0 &&
		opacity === void 0
	) {
		return null
	}
	const showPickers = fill || dash || size
	const opacityIndex = styles.opacity.findIndex((s3) => s3.id === opacity)
	return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)(import_jsx_runtime105.Fragment, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime105.jsxs)('div', {
				className: 'tlui-style-panel__section__common',
				'aria-label': 'style panel styles',
				children: [
					color === void 0
						? null
						: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ButtonPicker, {
								title: msg2('style-panel.color'),
								styleType: 'color',
								'data-testid': 'style.color',
								items: styles.color,
								value: color,
								onValueChange: handleValueChange,
						  }),
					opacity === void 0
						? null
						: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(Slider, {
								'data-testid': 'style.opacity',
								value: opacityIndex >= 0 ? opacityIndex : styles.opacity.length - 1,
								label: opacity ? `opacity-style.${opacity}` : 'style-panel.mixed',
								onValueChange: handleOpacityValueChange,
								steps: styles.opacity.length - 1,
								title: msg2('style-panel.opacity'),
						  }),
				],
			}),
			showPickers &&
				/* @__PURE__ */ (0, import_jsx_runtime105.jsxs)('div', {
					className: 'tlui-style-panel__section',
					'aria-label': 'style panel styles',
					children: [
						fill === void 0
							? null
							: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ButtonPicker, {
									title: msg2('style-panel.fill'),
									styleType: 'fill',
									'data-testid': 'style.fill',
									items: styles.fill,
									value: fill,
									onValueChange: handleValueChange,
							  }),
						dash === void 0
							? null
							: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ButtonPicker, {
									title: msg2('style-panel.dash'),
									styleType: 'dash',
									'data-testid': 'style.dash',
									items: styles.dash,
									value: dash,
									onValueChange: handleValueChange,
							  }),
						size === void 0
							? null
							: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ButtonPicker, {
									title: msg2('style-panel.size'),
									styleType: 'size',
									'data-testid': 'style.size',
									items: styles.size,
									value: size,
									onValueChange: handleValueChange,
							  }),
					],
				}),
		],
	})
}
function TextStylePickerSet({ props }) {
	const msg2 = useTranslation()
	const handleValueChange = useStyleChangeCallback()
	const { font, align, verticalAlign } = props
	if (font === void 0 && align === void 0) {
		return null
	}
	return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)('div', {
		className: 'tlui-style-panel__section',
		'aria-label': 'style panel text',
		children: [
			font === void 0
				? null
				: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ButtonPicker, {
						title: msg2('style-panel.font'),
						styleType: 'font',
						'data-testid': 'font',
						items: styles.font,
						value: font,
						onValueChange: handleValueChange,
				  }),
			align === void 0
				? null
				: /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)('div', {
						className: 'tlui-style-panel__row',
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ButtonPicker, {
								title: msg2('style-panel.align'),
								styleType: 'align',
								'data-testid': 'align',
								items: styles.align,
								value: align,
								onValueChange: handleValueChange,
							}),
							verticalAlign === void 0
								? /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(Button, {
										title: msg2('style-panel.vertical-align'),
										'data-testid': 'vertical-align',
										icon: 'vertical-align-center',
										disabled: true,
								  })
								: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(DropdownPicker, {
										id: 'geo-vertical-alignment',
										styleType: 'verticalAlign',
										'data-testid': 'style-panel.geo-vertical-align',
										items: styles.verticalAlign,
										value: verticalAlign,
										onValueChange: handleValueChange,
								  }),
						],
				  }),
		],
	})
}
function GeoStylePickerSet({ props }) {
	const handleValueChange = useStyleChangeCallback()
	const { geo } = props
	if (geo === void 0) {
		return null
	}
	return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(DropdownPicker, {
		id: 'geo',
		label: 'style-panel.geo',
		styleType: 'geo',
		'data-testid': 'style-panel.geo',
		items: styles.geo,
		value: geo,
		onValueChange: handleValueChange,
	})
}
function SplineStylePickerSet({ props }) {
	const handleValueChange = useStyleChangeCallback()
	const { spline } = props
	if (spline === void 0) {
		return null
	}
	return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(DropdownPicker, {
		id: 'spline',
		label: 'style-panel.spline',
		styleType: 'spline',
		'data-testid': 'style.spline',
		items: styles.spline,
		value: spline,
		onValueChange: handleValueChange,
	})
}
function ArrowheadStylePickerSet({ props }) {
	const handleValueChange = useStyleChangeCallback()
	const { arrowheadEnd, arrowheadStart } = props
	if (arrowheadEnd === void 0 && arrowheadStart === void 0) {
		return null
	}
	return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(DoubleDropdownPicker, {
		label: 'style-panel.arrowheads',
		styleTypeA: 'arrowheadStart',
		'data-testid': 'style.arrowheads',
		itemsA: styles.arrowheadStart,
		valueA: arrowheadStart,
		styleTypeB: 'arrowheadEnd',
		itemsB: styles.arrowheadEnd,
		valueB: arrowheadEnd,
		onValueChange: handleValueChange,
		labelA: 'style-panel.arrowhead-start',
		labelB: 'style-panel.arrowhead-end',
	})
}

// ../packages/ui/src/lib/components/Toasts.tsx
init_define_process()
var React65 = __toESM(require_react())
var import_jsx_runtime106 = __toESM(require_jsx_runtime())
function Toast({ toast }) {
	const { removeToast } = useToasts()
	const msg2 = useTranslation()
	const onOpenChange = (isOpen) => {
		if (!isOpen) {
			removeToast(toast.id)
		}
	}
	const hasActions = toast.actions && toast.actions.length > 0
	return /* @__PURE__ */ (0, import_jsx_runtime106.jsxs)(
		$054eb8030ebde76e$export$be92b6f5f03c0fe9,
		{
			onOpenChange,
			className: 'tlui-toast__container',
			duration: toast.keepOpen ? Infinity : 5e3,
			children: [
				toast.icon &&
					/* @__PURE__ */ (0, import_jsx_runtime106.jsx)('div', {
						className: 'tlui-toast__icon',
						children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Icon, { icon: toast.icon }),
					}),
				/* @__PURE__ */ (0, import_jsx_runtime106.jsxs)('div', {
					className: 'tlui-toast__main',
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime106.jsxs)('div', {
							className: 'tlui-toast__content',
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
									$054eb8030ebde76e$export$f99233281efd08a0,
									{ className: 'tlui-toast__title', children: toast.title }
								),
								/* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
									$054eb8030ebde76e$export$393edc798c47379d,
									{ className: 'tlui-toast__description', children: toast.description }
								),
							],
						}),
						toast.actions &&
							/* @__PURE__ */ (0, import_jsx_runtime106.jsxs)('div', {
								className: 'tlui-toast__actions',
								children: [
									toast.actions.map((action, i3) =>
										/* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
											$054eb8030ebde76e$export$e19cd5f9376f8cee,
											{
												altText: action.label,
												asChild: true,
												onClick: action.onClick,
												children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Button, {
													className:
														action.type === 'warn'
															? 'tlui-button__warning'
															: 'tlui-button__primary',
													children: action.label,
												}),
											},
											i3
										)
									),
									hasActions &&
										/* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
											$054eb8030ebde76e$export$f39c2d165cd861fe,
											{
												asChild: true,
												children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Button, {
													className: 'tlui-toast__close',
													style: { marginLeft: 'auto' },
													children: toast.closeLabel ?? msg2('toast.close'),
												}),
											}
										),
								],
							}),
					],
				}),
				!hasActions &&
					/* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
						$054eb8030ebde76e$export$f39c2d165cd861fe,
						{
							asChild: true,
							children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Button, {
								className: 'tlui-toast__close',
								children: toast.closeLabel ?? msg2('toast.close'),
							}),
						}
					),
			],
		}
	)
}
function _Toasts() {
	const { toasts } = useToasts()
	return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(import_jsx_runtime106.Fragment, {
		children: toasts.map((toast) =>
			/* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Toast, { toast }, toast.id)
		),
	})
}
var Toasts = React65.memo(_Toasts)
function ToastViewport() {
	const { toasts } = useToasts()
	const [hasToasts, setHasToasts] = React65.useState(false)
	React65.useEffect(() => {
		let cancelled = false
		if (toasts.length) {
			setHasToasts(true)
		} else {
			setTimeout(() => {
				if (!cancelled) {
					setHasToasts(false)
				}
			}, 1e3)
		}
		return () => {
			cancelled = true
		}
	}, [toasts.length, setHasToasts])
	if (!hasToasts) return null
	return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)($054eb8030ebde76e$export$6192c2425ecfd989, {
		className: 'tlui-toast__viewport',
	})
}

// ../packages/ui/src/lib/components/Toolbar/Toolbar.tsx
init_define_process()
var import_classnames19 = __toESM(require_classnames())
var import_react107 = __toESM(require_react())

// ../packages/ui/src/lib/components/MobileStylePanel.tsx
init_define_process()
var import_react106 = __toESM(require_react())
var import_jsx_runtime107 = __toESM(require_jsx_runtime())
function MobileStylePanel() {
	const app = useApp()
	const msg2 = useTranslation()
	const currentColor = useValue(
		'current color',
		() => {
			const { props } = app
			return props ? (props.color ? app.getCssColor(props.color) : null) : 'var(--color-muted-1)'
		},
		[app]
	)
	const disableStylePanel = useValue(
		'isHandOrEraserToolActive',
		() => app.isInAny('hand', 'zoom', 'eraser'),
		[app]
	)
	const handleStylesOpenChange = (0, import_react106.useCallback)(
		(isOpen) => {
			if (!isOpen) {
				app.isChangingStyle = false
			}
		},
		[app]
	)
	return /* @__PURE__ */ (0, import_jsx_runtime107.jsxs)(Popover, {
		id: 'style menu',
		onOpenChange: handleStylesOpenChange,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime107.jsx)(PopoverTrigger, {
				disabled: disableStylePanel,
				children: /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(Button, {
					className: 'tlui-toolbar__tools__button tlui-toolbar__styles__button',
					'data-testid': 'mobile.styles',
					style: { color: currentColor ?? 'var(--color-text)' },
					title: msg2('style-panel.title'),
					children: /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(Icon, {
						icon: currentColor ? 'blob' : 'mixed',
					}),
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime107.jsx)(PopoverContent, {
				side: 'top',
				align: 'end',
				children: /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(StylePanel, { isMobile: true }),
			}),
		],
	})
}

// ../packages/ui/src/lib/components/Toolbar/ToggleToolLockedButton.tsx
init_define_process()
var import_classnames18 = __toESM(require_classnames())
var import_jsx_runtime108 = __toESM(require_jsx_runtime())
var NOT_LOCKABLE_TOOLS = ['select', 'hand', 'draw', 'eraser', 'text', 'zoom', 'laser']
function ToggleToolLockedButton({ activeToolId }) {
	const app = useApp()
	const breakpoint = useBreakpoint()
	const msg2 = useTranslation()
	const isToolLocked = useValue('is tool locked', () => app.instanceState.isToolLocked, [app])
	if (!activeToolId || NOT_LOCKABLE_TOOLS.includes(activeToolId)) return null
	return /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(Button, {
		title: msg2('action.toggle-tool-lock'),
		className: (0, import_classnames18.default)('tlui-toolbar__lock-button', {
			'tlui-toolbar__lock-button__mobile': breakpoint < 5,
		}),
		icon: isToolLocked ? 'lock' : 'unlock',
		onClick: () => app.updateInstanceState({ isToolLocked: !isToolLocked }),
		smallIcon: true,
	})
}

// ../packages/ui/src/lib/components/Toolbar/Toolbar.tsx
var import_jsx_runtime109 = __toESM(require_jsx_runtime())
var Toolbar = function Toolbar2() {
	const app = useApp()
	const msg2 = useTranslation()
	const breakpoint = useBreakpoint()
	const rMostRecentlyActiveDropdownItem = import_react107.default.useRef(void 0)
	const isReadOnly = useReadonly()
	const toolbarItems = useToolbarSchema()
	const laserTool = toolbarItems.find((item) => item.toolItem.id === 'laser')
	const activeToolId = useValue('current tool id', () => app.currentToolId, [app])
	const isHandTool = activeToolId === 'hand'
	const geoState = useValue('geo', () => (app.props ? app.props.geo : void 0), [app])
	const showEditingTools = !isReadOnly
	const showExtraActions = !(isReadOnly || isHandTool)
	const getTitle = (item) =>
		item.label ? `${msg2(item.label)} ${item.kbd ? kbdStr(item.kbd) : ''}` : ''
	const activeToolbarItem = toolbarItems.find((item) => {
		return isActiveToolItem(item.toolItem, activeToolId, geoState)
	})
	const { itemsInPanel, itemsInDropdown, dropdownFirstItem } =
		import_react107.default.useMemo(() => {
			const itemsInPanel2 = []
			const itemsInDropdown2 = []
			let dropdownFirstItem2
			const overflowIndex = Math.min(8, 5 + breakpoint)
			for (let i3 = 4; i3 < toolbarItems.length; i3++) {
				const item = toolbarItems[i3]
				if (i3 < overflowIndex) {
					itemsInPanel2.push(item)
				} else {
					if (item === activeToolbarItem) {
						dropdownFirstItem2 = item
					}
					itemsInDropdown2.push(item)
				}
			}
			if (dropdownFirstItem2) {
			} else {
				if (!rMostRecentlyActiveDropdownItem.current) {
					rMostRecentlyActiveDropdownItem.current = itemsInDropdown2[0]
				}
				dropdownFirstItem2 = rMostRecentlyActiveDropdownItem.current
				if (!itemsInDropdown2.includes(dropdownFirstItem2)) {
					dropdownFirstItem2 = itemsInDropdown2[0]
				}
			}
			rMostRecentlyActiveDropdownItem.current = dropdownFirstItem2
			if (itemsInDropdown2.length <= 2) {
				itemsInPanel2.push(...itemsInDropdown2)
				itemsInDropdown2.length = 0
			}
			return {
				itemsInPanel: itemsInPanel2,
				itemsInDropdown: itemsInDropdown2,
				dropdownFirstItem: dropdownFirstItem2,
			}
		}, [toolbarItems, activeToolbarItem, breakpoint])
	return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)('div', {
		className: 'tlui-toolbar',
		children: /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)('div', {
			className: 'tlui-toolbar__inner',
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime109.jsxs)('div', {
					className: 'tlui-toolbar__left',
					children: [
						!isReadOnly &&
							/* @__PURE__ */ (0, import_jsx_runtime109.jsxs)('div', {
								className: (0, import_classnames19.default)('tlui-toolbar__extras', {
									'tlui-toolbar__extras__hidden': !showExtraActions,
								}),
								children: [
									breakpoint < 5 &&
										/* @__PURE__ */ (0, import_jsx_runtime109.jsxs)('div', {
											className: 'tlui-toolbar__extras__controls',
											children: [
												/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(UndoButton, {}),
												/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(RedoButton, {}),
												/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(TrashButton, {}),
												/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(DuplicateButton, {}),
												/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(ActionsMenu, {}),
											],
										}),
									/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(ToggleToolLockedButton, {
										activeToolId,
									}),
								],
							}),
						/* @__PURE__ */ (0, import_jsx_runtime109.jsxs)('div', {
							className: (0, import_classnames19.default)('tlui-toolbar__tools', {
								'tlui-toolbar__tools__mobile': breakpoint < 5,
							}),
							children: [
								toolbarItems.slice(0, 2).map(({ toolItem }) => {
									return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
										ToolbarButton,
										{
											item: toolItem,
											title: getTitle(toolItem),
											isSelected: isActiveToolItem(toolItem, activeToolId, geoState),
										},
										toolItem.id
									)
								}),
								isReadOnly &&
									laserTool &&
									/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
										ToolbarButton,
										{
											item: laserTool.toolItem,
											title: getTitle(laserTool.toolItem),
											isSelected: isActiveToolItem(laserTool.toolItem, activeToolId, geoState),
										},
										laserTool.toolItem.id
									),
								showEditingTools &&
									/* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(import_jsx_runtime109.Fragment, {
										children: [
											/* @__PURE__ */ (0, import_jsx_runtime109.jsx)('div', {
												className: 'tlui-toolbar__divider',
											}),
											toolbarItems.slice(2, 4).map(({ toolItem }) =>
												/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
													ToolbarButton,
													{
														item: toolItem,
														title: getTitle(toolItem),
														isSelected: isActiveToolItem(toolItem, activeToolId, geoState),
													},
													toolItem.id
												)
											),
											/* @__PURE__ */ (0, import_jsx_runtime109.jsx)('div', {
												className: 'tlui-toolbar__divider',
											}),
											itemsInPanel.map(({ toolItem }) =>
												/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
													ToolbarButton,
													{
														item: toolItem,
														title: getTitle(toolItem),
														isSelected: isActiveToolItem(toolItem, activeToolId, geoState),
													},
													toolItem.id
												)
											),
											itemsInDropdown.length
												? /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(
														import_jsx_runtime109.Fragment,
														{
															children: [
																/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
																	ToolbarButton,
																	{
																		item: dropdownFirstItem.toolItem,
																		title: getTitle(dropdownFirstItem.toolItem),
																		isSelected: isActiveToolItem(
																			dropdownFirstItem.toolItem,
																			activeToolId,
																			geoState
																		),
																	},
																	dropdownFirstItem.toolItem.id
																),
																/* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(Root, {
																	id: 'toolbar overflow',
																	modal: false,
																	children: [
																		/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(Trigger, {
																			children: /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
																				Button,
																				{
																					className:
																						'tlui-toolbar__tools__button tlui-toolbar__overflow',
																					icon: 'chevron-up',
																					'data-testid': 'tools.more',
																					title: msg2('tool-panel.more'),
																				}
																			),
																		}),
																		/* @__PURE__ */ (0, import_jsx_runtime109.jsx)(Content, {
																			side: 'top',
																			align: 'center',
																			children: /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
																				OverflowToolsContent,
																				{ toolbarItems: itemsInDropdown }
																			),
																		}),
																	],
																}),
															],
														}
												  )
												: null,
										],
									}),
							],
						}),
					],
				}),
				breakpoint < 5 &&
					!isReadOnly &&
					/* @__PURE__ */ (0, import_jsx_runtime109.jsx)('div', {
						className: 'tlui-toolbar__tools',
						children: /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(MobileStylePanel, {}),
					}),
			],
		}),
	})
}
var OverflowToolsContent = track(function OverflowToolsContent2({ toolbarItems }) {
	const msg2 = useTranslation()
	return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)('div', {
		className: 'tlui-button-grid__four tlui-button-grid__reverse',
		children: toolbarItems.map(({ toolItem: { id, meta, kbd: kbd2, label, onSelect, icon } }) => {
			return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
				Item,
				{
					className: 'tlui-button-grid__button',
					'data-testid': `tools.${id}`,
					'data-tool': id,
					'data-geo': meta?.geo ?? '',
					'aria-label': label,
					onClick: () => onSelect('toolbar'),
					title: label ? `${msg2(label)} ${kbd2 ? kbdStr(kbd2) : ''}` : '',
					icon,
				},
				id
			)
		}),
	})
})
function ToolbarButton({ item, title, isSelected }) {
	return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(Button, {
		className: 'tlui-toolbar__tools__button',
		'data-testid': `tools.${item.id}`,
		'data-tool': item.id,
		'data-geo': item.meta?.geo ?? '',
		'aria-label': item.label,
		title,
		icon: item.icon,
		'data-state': isSelected ? 'selected' : void 0,
		onClick: () => item.onSelect('toolbar'),
		onTouchStart: (e2) => {
			preventDefault(e2)
			item.onSelect('toolbar')
		},
	})
}
var isActiveToolItem = (item, activeToolId, geoState) => {
	return item.meta?.geo
		? activeToolId === 'geo' && geoState === item.meta?.geo
		: activeToolId === item.id
}

// ../packages/ui/src/lib/hooks/useAppEvents.ts
init_define_process()
var import_react108 = __toESM(require_react())
function useAppEvents() {
	const app = useApp()
	const { addToast } = useToasts()
	;(0, import_react108.useEffect)(() => {
		function handleMaxShapes({ name, count }) {
			addToast({
				title: 'Maximum Shapes Reached',
				description: `You've reached the maximum number of shapes allowed on ${name} (${count}). Please delete some shapes or move to a different page to continue.`,
			})
		}
		app.addListener('max-shapes', handleMaxShapes)
		return () => {
			app.removeListener('max-shapes', handleMaxShapes)
		}
	}, [app, addToast])
}

// ../packages/ui/src/lib/hooks/useKeyboardShortcuts.ts
init_define_process()

// ../node_modules/hotkeys-js/dist/hotkeys.esm.js
init_define_process()
var isff =
	typeof navigator !== 'undefined'
		? navigator.userAgent.toLowerCase().indexOf('firefox') > 0
		: false
function addEvent(object2, event, method, useCapture) {
	if (object2.addEventListener) {
		object2.addEventListener(event, method, useCapture)
	} else if (object2.attachEvent) {
		object2.attachEvent('on'.concat(event), function () {
			method(window.event)
		})
	}
}
function getMods(modifier, key) {
	var mods = key.slice(0, key.length - 1)
	for (var i3 = 0; i3 < mods.length; i3++) {
		mods[i3] = modifier[mods[i3].toLowerCase()]
	}
	return mods
}
function getKeys(key) {
	if (typeof key !== 'string') key = ''
	key = key.replace(/\s/g, '')
	var keys = key.split(',')
	var index2 = keys.lastIndexOf('')
	for (; index2 >= 0; ) {
		keys[index2 - 1] += ','
		keys.splice(index2, 1)
		index2 = keys.lastIndexOf('')
	}
	return keys
}
function compareArray(a1, a22) {
	var arr1 = a1.length >= a22.length ? a1 : a22
	var arr2 = a1.length >= a22.length ? a22 : a1
	var isIndex = true
	for (var i3 = 0; i3 < arr1.length; i3++) {
		if (arr2.indexOf(arr1[i3]) === -1) isIndex = false
	}
	return isIndex
}
var _keyMap = {
	backspace: 8,
	'\u232B': 8,
	tab: 9,
	clear: 12,
	enter: 13,
	'\u21A9': 13,
	return: 13,
	esc: 27,
	escape: 27,
	space: 32,
	left: 37,
	up: 38,
	right: 39,
	down: 40,
	del: 46,
	delete: 46,
	ins: 45,
	insert: 45,
	home: 36,
	end: 35,
	pageup: 33,
	pagedown: 34,
	capslock: 20,
	num_0: 96,
	num_1: 97,
	num_2: 98,
	num_3: 99,
	num_4: 100,
	num_5: 101,
	num_6: 102,
	num_7: 103,
	num_8: 104,
	num_9: 105,
	num_multiply: 106,
	num_add: 107,
	num_enter: 108,
	num_subtract: 109,
	num_decimal: 110,
	num_divide: 111,
	'\u21EA': 20,
	',': 188,
	'.': 190,
	'/': 191,
	'`': 192,
	'-': isff ? 173 : 189,
	'=': isff ? 61 : 187,
	';': isff ? 59 : 186,
	"'": 222,
	'[': 219,
	']': 221,
	'\\': 220,
}
var _modifier = {
	// shiftKey
	'\u21E7': 16,
	shift: 16,
	// altKey
	'\u2325': 18,
	alt: 18,
	option: 18,
	// ctrlKey
	'\u2303': 17,
	ctrl: 17,
	control: 17,
	// metaKey
	'\u2318': 91,
	cmd: 91,
	command: 91,
}
var modifierMap = {
	16: 'shiftKey',
	18: 'altKey',
	17: 'ctrlKey',
	91: 'metaKey',
	shiftKey: 16,
	ctrlKey: 17,
	altKey: 18,
	metaKey: 91,
}
var _mods = {
	16: false,
	18: false,
	17: false,
	91: false,
}
var _handlers = {}
for (k2 = 1; k2 < 20; k2++) {
	_keyMap['f'.concat(k2)] = 111 + k2
}
var k2
var _downKeys = []
var winListendFocus = false
var _scope = 'all'
var elementHasBindEvent = []
var code = function code2(x3) {
	return _keyMap[x3.toLowerCase()] || _modifier[x3.toLowerCase()] || x3.toUpperCase().charCodeAt(0)
}
var getKey = function getKey2(x3) {
	return Object.keys(_keyMap).find(function (k2) {
		return _keyMap[k2] === x3
	})
}
var getModifier = function getModifier2(x3) {
	return Object.keys(_modifier).find(function (k2) {
		return _modifier[k2] === x3
	})
}
function setScope(scope) {
	_scope = scope || 'all'
}
function getScope() {
	return _scope || 'all'
}
function getPressedKeyCodes() {
	return _downKeys.slice(0)
}
function getPressedKeyString() {
	return _downKeys.map(function (c3) {
		return getKey(c3) || getModifier(c3) || String.fromCharCode(c3)
	})
}
function filter(event) {
	var target = event.target || event.srcElement
	var tagName = target.tagName
	var flag = true
	if (
		target.isContentEditable ||
		((tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly)
	) {
		flag = false
	}
	return flag
}
function isPressed(keyCode) {
	if (typeof keyCode === 'string') {
		keyCode = code(keyCode)
	}
	return _downKeys.indexOf(keyCode) !== -1
}
function deleteScope(scope, newScope) {
	var handlers
	var i3
	if (!scope) scope = getScope()
	for (var key in _handlers) {
		if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
			handlers = _handlers[key]
			for (i3 = 0; i3 < handlers.length; ) {
				if (handlers[i3].scope === scope) handlers.splice(i3, 1)
				else i3++
			}
		}
	}
	if (getScope() === scope) setScope(newScope || 'all')
}
function clearModifier(event) {
	var key = event.keyCode || event.which || event.charCode
	var i3 = _downKeys.indexOf(key)
	if (i3 >= 0) {
		_downKeys.splice(i3, 1)
	}
	if (event.key && event.key.toLowerCase() === 'meta') {
		_downKeys.splice(0, _downKeys.length)
	}
	if (key === 93 || key === 224) key = 91
	if (key in _mods) {
		_mods[key] = false
		for (var k2 in _modifier) {
			if (_modifier[k2] === key) hotkeys[k2] = false
		}
	}
}
function unbind(keysInfo) {
	if (typeof keysInfo === 'undefined') {
		Object.keys(_handlers).forEach(function (key) {
			return delete _handlers[key]
		})
	} else if (Array.isArray(keysInfo)) {
		keysInfo.forEach(function (info) {
			if (info.key) eachUnbind(info)
		})
	} else if (typeof keysInfo === 'object') {
		if (keysInfo.key) eachUnbind(keysInfo)
	} else if (typeof keysInfo === 'string') {
		for (
			var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
			_key < _len;
			_key++
		) {
			args[_key - 1] = arguments[_key]
		}
		var scope = args[0],
			method = args[1]
		if (typeof scope === 'function') {
			method = scope
			scope = ''
		}
		eachUnbind({
			key: keysInfo,
			scope,
			method,
			splitKey: '+',
		})
	}
}
var eachUnbind = function eachUnbind2(_ref) {
	var key = _ref.key,
		scope = _ref.scope,
		method = _ref.method,
		_ref$splitKey = _ref.splitKey,
		splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey
	var multipleKeys = getKeys(key)
	multipleKeys.forEach(function (originKey) {
		var unbindKeys = originKey.split(splitKey)
		var len = unbindKeys.length
		var lastKey = unbindKeys[len - 1]
		var keyCode = lastKey === '*' ? '*' : code(lastKey)
		if (!_handlers[keyCode]) return
		if (!scope) scope = getScope()
		var mods = len > 1 ? getMods(_modifier, unbindKeys) : []
		_handlers[keyCode] = _handlers[keyCode].filter(function (record) {
			var isMatchingMethod = method ? record.method === method : true
			return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods))
		})
	})
}
function eventHandler(event, handler, scope, element) {
	if (handler.element !== element) {
		return
	}
	var modifiersMatch
	if (handler.scope === scope || handler.scope === 'all') {
		modifiersMatch = handler.mods.length > 0
		for (var y3 in _mods) {
			if (Object.prototype.hasOwnProperty.call(_mods, y3)) {
				if (
					(!_mods[y3] && handler.mods.indexOf(+y3) > -1) ||
					(_mods[y3] && handler.mods.indexOf(+y3) === -1)
				) {
					modifiersMatch = false
				}
			}
		}
		if (
			(handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) ||
			modifiersMatch ||
			handler.shortcut === '*'
		) {
			if (handler.method(event, handler) === false) {
				if (event.preventDefault) event.preventDefault()
				else event.returnValue = false
				if (event.stopPropagation) event.stopPropagation()
				if (event.cancelBubble) event.cancelBubble = true
			}
		}
	}
}
function dispatch(event, element) {
	var asterisk = _handlers['*']
	var key = event.keyCode || event.which || event.charCode
	if (!hotkeys.filter.call(this, event)) return
	if (key === 93 || key === 224) key = 91
	if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key)
	;['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {
		var keyNum = modifierMap[keyName]
		if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
			_downKeys.push(keyNum)
		} else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
			_downKeys.splice(_downKeys.indexOf(keyNum), 1)
		} else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {
			if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
				_downKeys = _downKeys.slice(_downKeys.indexOf(keyNum))
			}
		}
	})
	if (key in _mods) {
		_mods[key] = true
		for (var k2 in _modifier) {
			if (_modifier[k2] === key) hotkeys[k2] = true
		}
		if (!asterisk) return
	}
	for (var e2 in _mods) {
		if (Object.prototype.hasOwnProperty.call(_mods, e2)) {
			_mods[e2] = event[modifierMap[e2]]
		}
	}
	if (
		event.getModifierState &&
		!(event.altKey && !event.ctrlKey) &&
		event.getModifierState('AltGraph')
	) {
		if (_downKeys.indexOf(17) === -1) {
			_downKeys.push(17)
		}
		if (_downKeys.indexOf(18) === -1) {
			_downKeys.push(18)
		}
		_mods[17] = true
		_mods[18] = true
	}
	var scope = getScope()
	if (asterisk) {
		for (var i3 = 0; i3 < asterisk.length; i3++) {
			if (
				asterisk[i3].scope === scope &&
				((event.type === 'keydown' && asterisk[i3].keydown) ||
					(event.type === 'keyup' && asterisk[i3].keyup))
			) {
				eventHandler(event, asterisk[i3], scope, element)
			}
		}
	}
	if (!(key in _handlers)) return
	for (var _i = 0; _i < _handlers[key].length; _i++) {
		if (
			(event.type === 'keydown' && _handlers[key][_i].keydown) ||
			(event.type === 'keyup' && _handlers[key][_i].keyup)
		) {
			if (_handlers[key][_i].key) {
				var record = _handlers[key][_i]
				var splitKey = record.splitKey
				var keyShortcut = record.key.split(splitKey)
				var _downKeysCurrent = []
				for (var a3 = 0; a3 < keyShortcut.length; a3++) {
					_downKeysCurrent.push(code(keyShortcut[a3]))
				}
				if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {
					eventHandler(event, record, scope, element)
				}
			}
		}
	}
}
function isElementBind(element) {
	return elementHasBindEvent.indexOf(element) > -1
}
function hotkeys(key, option, method) {
	_downKeys = []
	var keys = getKeys(key)
	var mods = []
	var scope = 'all'
	var element = document
	var i3 = 0
	var keyup = false
	var keydown = true
	var splitKey = '+'
	var capture = false
	if (method === void 0 && typeof option === 'function') {
		method = option
	}
	if (Object.prototype.toString.call(option) === '[object Object]') {
		if (option.scope) scope = option.scope
		if (option.element) element = option.element
		if (option.keyup) keyup = option.keyup
		if (option.keydown !== void 0) keydown = option.keydown
		if (option.capture !== void 0) capture = option.capture
		if (typeof option.splitKey === 'string') splitKey = option.splitKey
	}
	if (typeof option === 'string') scope = option
	for (; i3 < keys.length; i3++) {
		key = keys[i3].split(splitKey)
		mods = []
		if (key.length > 1) mods = getMods(_modifier, key)
		key = key[key.length - 1]
		key = key === '*' ? '*' : code(key)
		if (!(key in _handlers)) _handlers[key] = []
		_handlers[key].push({
			keyup,
			keydown,
			scope,
			mods,
			shortcut: keys[i3],
			method,
			key: keys[i3],
			splitKey,
			element,
		})
	}
	if (typeof element !== 'undefined' && !isElementBind(element) && window) {
		elementHasBindEvent.push(element)
		addEvent(
			element,
			'keydown',
			function (e2) {
				dispatch(e2, element)
			},
			capture
		)
		if (!winListendFocus) {
			winListendFocus = true
			addEvent(
				window,
				'focus',
				function () {
					_downKeys = []
				},
				capture
			)
		}
		addEvent(
			element,
			'keyup',
			function (e2) {
				dispatch(e2, element)
				clearModifier(e2)
			},
			capture
		)
	}
}
function trigger(shortcut) {
	var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'all'
	Object.keys(_handlers).forEach(function (key) {
		var dataList = _handlers[key].filter(function (item) {
			return item.scope === scope && item.shortcut === shortcut
		})
		dataList.forEach(function (data) {
			if (data && data.method) {
				data.method()
			}
		})
	})
}
var _api = {
	getPressedKeyString,
	setScope,
	getScope,
	deleteScope,
	getPressedKeyCodes,
	isPressed,
	filter,
	trigger,
	unbind,
	keyMap: _keyMap,
	modifier: _modifier,
	modifierMap,
}
for (a3 in _api) {
	if (Object.prototype.hasOwnProperty.call(_api, a3)) {
		hotkeys[a3] = _api[a3]
	}
}
var a3
if (typeof window !== 'undefined') {
	_hotkeys = window.hotkeys
	hotkeys.noConflict = function (deep) {
		if (deep && window.hotkeys === hotkeys) {
			window.hotkeys = _hotkeys
		}
		return hotkeys
	}
	window.hotkeys = hotkeys
}
var _hotkeys

// ../packages/ui/src/lib/hooks/useKeyboardShortcuts.ts
var import_react109 = __toESM(require_react())
var SKIP_KBDS = [
	// we set these in useNativeClipboardEvents instead
	'copy',
	'cut',
	'paste',
	'delete',
	// There's also an upload asset action, so we don't want to set the kbd twice
	'asset',
]
function useKeyboardShortcuts() {
	const app = useApp()
	const appIsFocused = useAppIsFocused()
	const isReadonly = useReadonly()
	const actions = useActions()
	const tools = useTools()
	;(0, import_react109.useEffect)(() => {
		if (!appIsFocused) return
		const container = app.getContainer()
		const hot = (keys, callback) => {
			hotkeys(keys, { element: container, scope: app.instanceId }, callback)
		}
		const areShortcutsDisabled = () => app.isMenuOpen || app.editingId !== null || app.crashingError
		for (const action of Object.values(actions)) {
			if (!action.kbd) continue
			if (isReadonly && !action.readonlyOk) continue
			if (SKIP_KBDS.includes(action.id)) continue
			hot(getHotkeysStringFromKbd(action.kbd), (event) => {
				if (areShortcutsDisabled()) return
				preventDefault(event)
				action.onSelect('kbd')
			})
		}
		for (const tool of Object.values(tools)) {
			if (!tool.kbd || (!tool.readonlyOk && app.isReadOnly)) continue
			if (SKIP_KBDS.includes(tool.id)) continue
			hot(getHotkeysStringFromKbd(tool.kbd), (event) => {
				if (areShortcutsDisabled()) return
				preventDefault(event)
				tool.onSelect('kbd')
			})
		}
		hot('g', () => {
			if (areShortcutsDisabled() || app.isReadOnly) return
			app.setSelectedTool('geo')
		})
		hot('del,backspace', () => {
			if (areShortcutsDisabled()) return
			actions['delete'].onSelect('kbd')
		})
		hot('=', () => {
			if (areShortcutsDisabled()) return
			actions['zoom-in'].onSelect('kbd')
		})
		hot('-', () => {
			if (areShortcutsDisabled()) return
			actions['zoom-out'].onSelect('kbd')
		})
		hotkeys.setScope(app.instanceId)
		return () => {
			hotkeys.deleteScope(app.instanceId)
		}
	}, [actions, tools, isReadonly, app, appIsFocused])
}
function getHotkeysStringFromKbd(kbd2) {
	let str = ''
	const chars = kbd2.split('')
	if (chars.length === 1) {
		str = chars[0]
	} else {
		if (chars[0] === '!') {
			str = `shift+${chars[1]}`
		} else if (chars[0] === '?') {
			str = `alt+${chars[1]}`
		} else if (chars[0] === '$') {
			if (chars[1] === '!') {
				str = `cmd+shift+${chars[2]},ctrl+shift+${chars[2]}`
			} else if (chars[1] === '?') {
				str = `cmd+\u2325+${chars[2]},ctrl+alt+${chars[2]}`
			} else {
				str = `cmd+${chars[1]},ctrl+${chars[1]}`
			}
		} else {
			str = kbd2
		}
	}
	return str
}

// ../packages/ui/src/lib/TldrawUi.tsx
var import_jsx_runtime110 = __toESM(require_jsx_runtime())
var TldrawUi = import_react110.default.memo(function TldrawUi2({
	shareZone,
	renderDebugMenuItems,
	children,
	hideUi,
	...rest
}) {
	return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TldrawUiContextProvider, {
		...rest,
		children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TldrawUiInner, {
			hideUi,
			shareZone,
			renderDebugMenuItems,
			children,
		}),
	})
})
var TldrawUiInner = import_react110.default.memo(function TldrawUiInner2({
	children,
	hideUi,
	...rest
}) {
	return /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)(import_jsx_runtime110.Fragment, {
		children: [
			children,
			hideUi ? null : /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TldrawUiContent, { ...rest }),
		],
	})
})
var TldrawUiContent = import_react110.default.memo(function TldrawUI({
	shareZone,
	renderDebugMenuItems,
}) {
	const app = useApp()
	const msg2 = useTranslation()
	const breakpoint = useBreakpoint()
	const isReadonlyMode = useValue('isReadOnlyMode', () => app.isReadOnly, [app])
	const isFocusMode = useValue('focus', () => app.instanceState.isFocusMode, [app])
	const isDebugMode = useValue('debug', () => app.instanceState.isDebugMode, [app])
	useKeyboardShortcuts()
	useNativeClipboardEvents()
	useAppEvents()
	const { 'toggle-focus-mode': toggleFocus } = useActions()
	return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)($054eb8030ebde76e$export$f5d03d415824e0e, {
		children: /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)('main', {
			'data-tldraw-area': 'active-drawing',
			className: (0, import_classnames20.default)('tlui-layout', {
				'tlui-layout__mobile': breakpoint < 5,
			}),
			children: [
				isFocusMode
					? /* @__PURE__ */ (0, import_jsx_runtime110.jsx)('div', {
							className: 'tlui-layout__top',
							children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Button, {
								className: 'tlui-focus-button',
								title: `${msg2('focus-mode.toggle-focus-mode')}`,
								icon: 'dot',
								onClick: () => toggleFocus.onSelect('menu'),
							}),
					  })
					: /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)(import_jsx_runtime110.Fragment, {
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime110.jsxs)('div', {
									className: 'tlui-layout__top',
									children: [
										/* @__PURE__ */ (0, import_jsx_runtime110.jsxs)('div', {
											className: 'tlui-layout__top__left',
											children: [
												/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(MenuZone, {}),
												/* @__PURE__ */ (0, import_jsx_runtime110.jsxs)('div', {
													className: 'tlui-helper-buttons',
													children: [
														/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(ExitPenMode, {}),
														/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(BackToContent, {}),
														/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(StopFollowing, {}),
													],
												}),
											],
										}),
										/* @__PURE__ */ (0, import_jsx_runtime110.jsxs)('div', {
											className: 'tlui-layout__top__right',
											children: [
												shareZone &&
													/* @__PURE__ */ (0, import_jsx_runtime110.jsx)('div', {
														className: 'tlui-share-zone',
														draggable: false,
														children: shareZone,
													}),
												breakpoint >= 5 &&
													!isReadonlyMode &&
													/* @__PURE__ */ (0, import_jsx_runtime110.jsx)('div', {
														className: 'tlui-style-panel__wrapper',
														children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
															StylePanel,
															{}
														),
													}),
											],
										}),
									],
								}),
								/* @__PURE__ */ (0, import_jsx_runtime110.jsxs)('div', {
									className: 'tlui-layout__bottom',
									children: [
										/* @__PURE__ */ (0, import_jsx_runtime110.jsxs)('div', {
											className: 'tlui-layout__bottom__main',
											children: [
												/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(NavigationZone, {}),
												/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Toolbar, {}),
												breakpoint >= 4 &&
													/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(HelpMenu, {}),
											],
										}),
										isDebugMode &&
											/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(DebugPanel, {
												renderDebugMenuItems: renderDebugMenuItems ?? null,
											}),
									],
								}),
							],
					  }),
				/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Toasts, {}),
				/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Dialogs, {}),
				/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(ToastViewport, {}),
				/* @__PURE__ */ (0, import_jsx_runtime110.jsx)(FollowingIndicator, {}),
			],
		}),
	})
})

// ../packages/ui/src/lib/components/ContextMenu.tsx
init_define_process()

// ../node_modules/@radix-ui/react-context-menu/dist/index.module.js
init_define_process()
var import_react111 = __toESM(require_react())
var $1b0217ee4a91d156$var$CONTEXT_MENU_NAME = 'ContextMenu'
var [$1b0217ee4a91d156$var$createContextMenuContext, $1b0217ee4a91d156$export$1059331f43ddcc82] =
	$c512c27ab02ef895$export$50c7b4e9d9f19c1($1b0217ee4a91d156$var$CONTEXT_MENU_NAME, [
		$6cc32821e9371a1c$export$4027731b685e72eb,
	])
var $1b0217ee4a91d156$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb()
var [$1b0217ee4a91d156$var$ContextMenuProvider, $1b0217ee4a91d156$var$useContextMenuContext] =
	$1b0217ee4a91d156$var$createContextMenuContext($1b0217ee4a91d156$var$CONTEXT_MENU_NAME)
var $1b0217ee4a91d156$export$8dc6765e8be191c7 = (props) => {
	const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props
	const [open1, setOpen] = (0, import_react111.useState)(false)
	const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
	const handleOpenChangeProp = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange)
	const handleOpenChange = (0, import_react111.useCallback)(
		(open) => {
			setOpen(open)
			handleOpenChangeProp(open)
		},
		[handleOpenChangeProp]
	)
	return /* @__PURE__ */ (0, import_react111.createElement)(
		$1b0217ee4a91d156$var$ContextMenuProvider,
		{
			scope: __scopeContextMenu,
			open: open1,
			onOpenChange: handleOpenChange,
			modal,
		},
		/* @__PURE__ */ (0, import_react111.createElement)(
			$6cc32821e9371a1c$export$be92b6f5f03c0fe9,
			_extends({}, menuScope, {
				dir,
				open: open1,
				onOpenChange: handleOpenChange,
				modal,
			}),
			children
		)
	)
}
var $1b0217ee4a91d156$var$TRIGGER_NAME = 'ContextMenuTrigger'
var $1b0217ee4a91d156$export$be6fc7b1d5b0beb9 = /* @__PURE__ */ (0, import_react111.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeContextMenu, disabled = false, ...triggerProps } = props
		const context = $1b0217ee4a91d156$var$useContextMenuContext(
			$1b0217ee4a91d156$var$TRIGGER_NAME,
			__scopeContextMenu
		)
		const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
		const pointRef = (0, import_react111.useRef)({
			x: 0,
			y: 0,
		})
		const virtualRef = (0, import_react111.useRef)({
			getBoundingClientRect: () =>
				DOMRect.fromRect({
					width: 0,
					height: 0,
					...pointRef.current,
				}),
		})
		const longPressTimerRef = (0, import_react111.useRef)(0)
		const clearLongPress = (0, import_react111.useCallback)(
			() => window.clearTimeout(longPressTimerRef.current),
			[]
		)
		const handleOpen = (event) => {
			pointRef.current = {
				x: event.clientX,
				y: event.clientY,
			}
			context.onOpenChange(true)
		}
		;(0, import_react111.useEffect)(() => clearLongPress, [clearLongPress])
		;(0, import_react111.useEffect)(
			() => void (disabled && clearLongPress()),
			[disabled, clearLongPress]
		)
		return /* @__PURE__ */ (0, import_react111.createElement)(
			import_react111.Fragment,
			null,
			/* @__PURE__ */ (0, import_react111.createElement)(
				$6cc32821e9371a1c$export$b688253958b8dfe7,
				_extends({}, menuScope, {
					virtualRef,
				})
			),
			/* @__PURE__ */ (0, import_react111.createElement)(
				$8927f6f2acc4f386$export$250ffa63cdc0d034.span,
				_extends(
					{
						'data-state': context.open ? 'open' : 'closed',
						'data-disabled': disabled ? '' : void 0,
					},
					triggerProps,
					{
						ref: forwardedRef,
						style: {
							WebkitTouchCallout: 'none',
							...props.style,
						},
						onContextMenu: disabled
							? props.onContextMenu
							: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onContextMenu, (event) => {
									clearLongPress()
									handleOpen(event)
									event.preventDefault()
							  }),
						onPointerDown: disabled
							? props.onPointerDown
							: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
									props.onPointerDown,
									$1b0217ee4a91d156$var$whenTouchOrPen((event) => {
										clearLongPress()
										longPressTimerRef.current = window.setTimeout(() => handleOpen(event), 700)
									})
							  ),
						onPointerMove: disabled
							? props.onPointerMove
							: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
									props.onPointerMove,
									$1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)
							  ),
						onPointerCancel: disabled
							? props.onPointerCancel
							: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
									props.onPointerCancel,
									$1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)
							  ),
						onPointerUp: disabled
							? props.onPointerUp
							: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
									props.onPointerUp,
									$1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)
							  ),
					}
				)
			)
		)
	}
)
var $1b0217ee4a91d156$export$14afd0be83e45060 = (props) => {
	const { __scopeContextMenu, ...portalProps } = props
	const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
	return /* @__PURE__ */ (0, import_react111.createElement)(
		$6cc32821e9371a1c$export$602eac185826482c,
		_extends({}, menuScope, portalProps)
	)
}
var $1b0217ee4a91d156$var$CONTENT_NAME = 'ContextMenuContent'
var $1b0217ee4a91d156$export$572205900c9369e = /* @__PURE__ */ (0, import_react111.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeContextMenu, ...contentProps } = props
		const context = $1b0217ee4a91d156$var$useContextMenuContext(
			$1b0217ee4a91d156$var$CONTENT_NAME,
			__scopeContextMenu
		)
		const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
		const hasInteractedOutsideRef = (0, import_react111.useRef)(false)
		return /* @__PURE__ */ (0, import_react111.createElement)(
			$6cc32821e9371a1c$export$7c6e2c02157bb7d2,
			_extends({}, menuScope, contentProps, {
				ref: forwardedRef,
				side: 'right',
				sideOffset: 2,
				align: 'start',
				onCloseAutoFocus: (event) => {
					var _props$onCloseAutoFoc
					;(_props$onCloseAutoFoc = props.onCloseAutoFocus) === null ||
						_props$onCloseAutoFoc === void 0 ||
						_props$onCloseAutoFoc.call(props, event)
					if (!event.defaultPrevented && hasInteractedOutsideRef.current) event.preventDefault()
					hasInteractedOutsideRef.current = false
				},
				onInteractOutside: (event) => {
					var _props$onInteractOuts
					;(_props$onInteractOuts = props.onInteractOutside) === null ||
						_props$onInteractOuts === void 0 ||
						_props$onInteractOuts.call(props, event)
					if (!event.defaultPrevented && !context.modal) hasInteractedOutsideRef.current = true
				},
				style: {
					...props.style,
					'--radix-context-menu-content-transform-origin': 'var(--radix-popper-transform-origin)',
					'--radix-context-menu-content-available-width': 'var(--radix-popper-available-width)',
					'--radix-context-menu-content-available-height': 'var(--radix-popper-available-height)',
					'--radix-context-menu-trigger-width': 'var(--radix-popper-anchor-width)',
					'--radix-context-menu-trigger-height': 'var(--radix-popper-anchor-height)',
				},
			})
		)
	}
)
var $1b0217ee4a91d156$export$9860523b0fcdd664 = /* @__PURE__ */ (0, import_react111.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeContextMenu, ...groupProps } = props
		const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
		return /* @__PURE__ */ (0, import_react111.createElement)(
			$6cc32821e9371a1c$export$eb2fcfdbd7ba97d4,
			_extends({}, menuScope, groupProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $1b0217ee4a91d156$export$16a26dc176a49100 = /* @__PURE__ */ (0, import_react111.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeContextMenu, ...itemProps } = props
		const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
		return /* @__PURE__ */ (0, import_react111.createElement)(
			$6cc32821e9371a1c$export$6d08773d2e66f8f2,
			_extends({}, menuScope, itemProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $1b0217ee4a91d156$export$b6adbe51d5d8b7ec = /* @__PURE__ */ (0, import_react111.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeContextMenu, ...checkboxItemProps } = props
		const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
		return /* @__PURE__ */ (0, import_react111.createElement)(
			$6cc32821e9371a1c$export$16ce288f89fa631c,
			_extends({}, menuScope, checkboxItemProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $1b0217ee4a91d156$export$5bc21d1c00c4b201 = (props) => {
	const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props
	const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
	const [open, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
		prop: openProp,
		defaultProp: defaultOpen,
		onChange: onOpenChange,
	})
	return /* @__PURE__ */ (0, import_react111.createElement)(
		$6cc32821e9371a1c$export$d7a01e11500dfb6f,
		_extends({}, menuScope, {
			open,
			onOpenChange: setOpen,
		}),
		children
	)
}
var $1b0217ee4a91d156$export$30b2b5c64556d316 = /* @__PURE__ */ (0, import_react111.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeContextMenu, ...triggerItemProps } = props
		const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
		return /* @__PURE__ */ (0, import_react111.createElement)(
			$6cc32821e9371a1c$export$2ea8a7a591ac5eac,
			_extends({}, menuScope, triggerItemProps, {
				ref: forwardedRef,
			})
		)
	}
)
var $1b0217ee4a91d156$export$2c967063bd2dc512 = /* @__PURE__ */ (0, import_react111.forwardRef)(
	(props, forwardedRef) => {
		const { __scopeContextMenu, ...subContentProps } = props
		const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu)
		return /* @__PURE__ */ (0, import_react111.createElement)(
			$6cc32821e9371a1c$export$6d4de93b380beddf,
			_extends({}, menuScope, subContentProps, {
				ref: forwardedRef,
				style: {
					...props.style,
					'--radix-context-menu-content-transform-origin': 'var(--radix-popper-transform-origin)',
					'--radix-context-menu-content-available-width': 'var(--radix-popper-available-width)',
					'--radix-context-menu-content-available-height': 'var(--radix-popper-available-height)',
					'--radix-context-menu-trigger-width': 'var(--radix-popper-anchor-width)',
					'--radix-context-menu-trigger-height': 'var(--radix-popper-anchor-height)',
				},
			})
		)
	}
)
function $1b0217ee4a91d156$var$whenTouchOrPen(handler) {
	return (event) => (event.pointerType !== 'mouse' ? handler(event) : void 0)
}
var $1b0217ee4a91d156$export$be92b6f5f03c0fe9 = $1b0217ee4a91d156$export$8dc6765e8be191c7
var $1b0217ee4a91d156$export$41fb9f06171c75f4 = $1b0217ee4a91d156$export$be6fc7b1d5b0beb9
var $1b0217ee4a91d156$export$602eac185826482c = $1b0217ee4a91d156$export$14afd0be83e45060
var $1b0217ee4a91d156$export$7c6e2c02157bb7d2 = $1b0217ee4a91d156$export$572205900c9369e
var $1b0217ee4a91d156$export$eb2fcfdbd7ba97d4 = $1b0217ee4a91d156$export$9860523b0fcdd664
var $1b0217ee4a91d156$export$6d08773d2e66f8f2 = $1b0217ee4a91d156$export$16a26dc176a49100
var $1b0217ee4a91d156$export$16ce288f89fa631c = $1b0217ee4a91d156$export$b6adbe51d5d8b7ec
var $1b0217ee4a91d156$export$d7a01e11500dfb6f = $1b0217ee4a91d156$export$5bc21d1c00c4b201
var $1b0217ee4a91d156$export$2ea8a7a591ac5eac = $1b0217ee4a91d156$export$30b2b5c64556d316
var $1b0217ee4a91d156$export$6d4de93b380beddf = $1b0217ee4a91d156$export$2c967063bd2dc512

// ../packages/ui/src/lib/components/ContextMenu.tsx
var import_classnames21 = __toESM(require_classnames())
var React68 = __toESM(require_react())

// ../packages/ui/src/lib/components/MoveToPageMenu.tsx
init_define_process()
var import_jsx_runtime111 = __toESM(require_jsx_runtime())
var MoveToPageMenu = track(function MoveToPageMenu2() {
	const app = useApp()
	const container = useContainer()
	const pages = app.pages
	const currentPageId = app.currentPageId
	const msg2 = useTranslation()
	const { addToast } = useToasts()
	return /* @__PURE__ */ (0,
	import_jsx_runtime111.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, {
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime111.jsx)($1b0217ee4a91d156$export$2ea8a7a591ac5eac, {
				dir: 'ltr',
				asChild: true,
				children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Button, {
					className: 'tlui-menu__button',
					label: 'context-menu.move-to-page',
					'data-testid': 'menu-item.move-to-page',
					icon: 'chevron-right',
				}),
			}),
			/* @__PURE__ */ (0, import_jsx_runtime111.jsx)($1b0217ee4a91d156$export$602eac185826482c, {
				container,
				dir: 'ltr',
				children: /* @__PURE__ */ (0, import_jsx_runtime111.jsxs)(
					$1b0217ee4a91d156$export$6d4de93b380beddf,
					{
						className: 'tlui-menu',
						sideOffset: -4,
						collisionPadding: 4,
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
								$1b0217ee4a91d156$export$eb2fcfdbd7ba97d4,
								{
									dir: 'ltr',
									className: 'tlui-menu__group',
									'data-testid': `menu-item.pages`,
									children: pages.map((page) =>
										/* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
											$1b0217ee4a91d156$export$6d08773d2e66f8f2,
											{
												disabled: currentPageId === page.id,
												onSelect: () => {
													app.mark('move_shapes_to_page')
													app.moveShapesToPage(app.selectedIds, page.id)
													const toPage = app.getPageById(page.id)
													if (toPage) {
														addToast({
															title: 'Changed Page',
															description: `Moved to ${toPage.name}.`,
															actions: [
																{
																	label: 'Go Back',
																	type: 'primary',
																	onClick: () => {
																		app.mark('change-page')
																		app.setCurrentPageId(currentPageId)
																	},
																},
															],
														})
													}
												},
												asChild: true,
												children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Button, {
													title: page.name,
													className: 'tlui-menu__button tlui-context-menu__move-to-page__name',
													children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)('span', {
														children: page.name,
													}),
												}),
											},
											page.id
										)
									),
								},
								'pages'
							),
							/* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
								$1b0217ee4a91d156$export$eb2fcfdbd7ba97d4,
								{
									dir: 'ltr',
									className: 'tlui-menu__group',
									'data-testid': `menu-item.new-page`,
									children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
										$1b0217ee4a91d156$export$6d08773d2e66f8f2,
										{
											onSelect: () => {
												app.mark('move_shapes_to_page')
												const newPageId = PageRecordType.createId()
												const ids = app.selectedIds
												const oldPageId = app.currentPageId
												app.batch(() => {
													app.createPage('Page 1', newPageId)
													app.setCurrentPageId(oldPageId)
													app.moveShapesToPage(ids, newPageId)
												})
											},
											asChild: true,
											children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Button, {
												title: msg2('context.pages.new-page'),
												className: 'tlui-menu__button tlui-context-menu__move-to-page__name',
												children: msg2('context.pages.new-page'),
											}),
										},
										'new-page'
									),
								},
								'new-page'
							),
						],
					}
				),
			}),
		],
	})
})

// ../packages/ui/src/lib/components/ContextMenu.tsx
var import_jsx_runtime112 = __toESM(require_jsx_runtime())
var ContextMenu = function ContextMenu2({ children }) {
	const app = useApp()
	const contextMenuSchema = useContextMenuSchema()
	const [_, handleOpenChange] = useMenuIsOpen('context menu')
	const isReadonly = useReadonly()
	const noItemsToShow =
		contextMenuSchema.length === 0 ||
		(isReadonly && contextMenuSchema.every((item) => !item.readonlyOk))
	const selectToolActive = useValue('isSelectToolActive', () => app.currentToolId === 'select', [
		app,
	])
	const disabled = !selectToolActive || noItemsToShow
	return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)(
		$1b0217ee4a91d156$export$be92b6f5f03c0fe9,
		{
			dir: 'ltr',
			onOpenChange: handleOpenChange,
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime112.jsx)($1b0217ee4a91d156$export$41fb9f06171c75f4, {
					onContextMenu: disabled ? preventDefault : void 0,
					dir: 'ltr',
					disabled,
					children,
				}),
				/* @__PURE__ */ (0, import_jsx_runtime112.jsx)(ContextMenuContent, {}),
			],
		}
	)
}
function ContextMenuContent() {
	const app = useApp()
	const msg2 = useTranslation()
	const menuSchema = useContextMenuSchema()
	const [_, handleSubOpenChange] = useMenuIsOpen('context menu sub')
	const isReadonly = useReadonly()
	const breakpoint = useBreakpoint()
	const container = useContainer()
	const [disableClicks, setDisableClicks] = React68.useState(false)
	function getContextMenuItem(app2, item, parent, depth) {
		if (isReadonly && !item.readonlyOk) return null
		switch (item.type) {
			case 'custom': {
				switch (item.id) {
					case 'MOVE_TO_PAGE_MENU': {
						return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(MoveToPageMenu, {}, item.id)
					}
				}
				break
			}
			case 'group': {
				return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
					$1b0217ee4a91d156$export$eb2fcfdbd7ba97d4,
					{
						dir: 'ltr',
						className: (0, import_classnames21.default)('tlui-menu__group', {
							'tlui-menu__group__small': parent?.type === 'submenu',
						}),
						'data-testid': `menu-item.${item.id}`,
						children: item.children.map((child) =>
							getContextMenuItem(app2, child, item, depth + 1)
						),
					},
					item.id
				)
			}
			case 'submenu': {
				return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)(
					$1b0217ee4a91d156$export$d7a01e11500dfb6f,
					{
						onOpenChange: handleSubOpenChange,
						children: [
							/* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
								$1b0217ee4a91d156$export$2ea8a7a591ac5eac,
								{
									dir: 'ltr',
									disabled: item.disabled,
									asChild: true,
									children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(Button, {
										className: 'tlui-menu__button',
										label: item.label,
										'data-testid': `menu-item.${item.id}`,
										icon: 'chevron-right',
									}),
								}
							),
							/* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
								$1b0217ee4a91d156$export$602eac185826482c,
								{
									container,
									dir: 'ltr',
									children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
										$1b0217ee4a91d156$export$6d4de93b380beddf,
										{
											className: 'tlui-menu',
											sideOffset: -4,
											collisionPadding: 4,
											children: item.children.map((child) =>
												getContextMenuItem(app2, child, item, depth + 1)
											),
										}
									),
								}
							),
						],
					},
					item.id
				)
			}
			case 'item': {
				if (isReadonly && !item.readonlyOk) return null
				const { id, checkbox, contextMenuLabel, label, onSelect, kbd: kbd2, icon } = item.actionItem
				const labelToUse = contextMenuLabel ?? label
				const labelStr = labelToUse ? msg2(labelToUse) : void 0
				if (checkbox) {
					return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)(
						$1b0217ee4a91d156$export$16ce288f89fa631c,
						{
							className: 'tlui-button tlui-menu__button tlui-menu__checkbox-item',
							dir: 'ltr',
							disabled: item.disabled,
							onSelect: (e2) => {
								onSelect('context-menu')
								preventDefault(e2)
							},
							title: labelStr ? labelStr : void 0,
							checked: item.checked,
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime112.jsx)('div', {
									className: 'tlui-menu__checkbox-item__check',
									style: {
										transformOrigin: '75% center',
										transform: `scale(${item.checked ? 1 : 0.5})`,
										opacity: item.checked ? 1 : 0.5,
									},
									children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(Icon, {
										small: true,
										icon: item.checked ? 'check' : 'checkbox-empty',
									}),
								}),
								labelStr &&
									/* @__PURE__ */ (0, import_jsx_runtime112.jsx)('span', { children: labelStr }),
								kbd2 && /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(Kbd, { children: kbd2 }),
							],
						},
						id
					)
				}
				return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
					$1b0217ee4a91d156$export$6d08773d2e66f8f2,
					{
						dir: 'ltr',
						asChild: true,
						children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(Button, {
							className: 'tlui-menu__button',
							'data-testid': `menu-item.${id}`,
							kbd: kbd2,
							label: labelToUse,
							disabled: item.disabled,
							iconLeft: breakpoint < 3 && depth > 2 ? icon : void 0,
							onClick: () => {
								if (disableClicks) {
									setDisableClicks(false)
								} else {
									onSelect('context-menu')
								}
							},
						}),
					},
					id
				)
			}
		}
	}
	return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)($1b0217ee4a91d156$export$602eac185826482c, {
		dir: 'ltr',
		container,
		children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
			$1b0217ee4a91d156$export$7c6e2c02157bb7d2,
			{
				className: 'tlui-menu scrollable',
				alignOffset: -4,
				collisionPadding: 4,
				onContextMenu: preventDefault,
				children: menuSchema.map((item) => getContextMenuItem(app, item, null, 0)),
			}
		),
	})
}

// ../packages/ui/src/lib/components/HTMLCanvas.tsx
init_define_process()
var React69 = __toESM(require_react())
var import_jsx_runtime113 = __toESM(require_jsx_runtime())
var HTMLCanvas = track(function HTMLCanvas2() {
	const app = useApp()
	const rCanvas = React69.useRef(null)
	const camera = app.camera
	const shapes = app.shapesArray
	if (rCanvas.current) {
		const cvs = rCanvas.current
		const ctx = cvs.getContext('2d')
		ctx.resetTransform()
		ctx.clearRect(0, 0, cvs.width, cvs.height)
		const path = new Path2D()
		ctx.translate(camera.x, camera.y)
		for (const shape of shapes) {
			const bounds = app.getPageBounds(shape)
			path.rect(bounds.minX, bounds.minY, bounds.width, bounds.height)
		}
		ctx.fillStyle = '#cccccc'
		ctx.fill(path)
		for (const shape of shapes) {
			ctx.save()
			const corners = app.getPageCorners(shape)
			corners.forEach((corner) => dot(ctx, corner.x, corner.y, 'red'))
			ctx.restore()
		}
	}
	return /* @__PURE__ */ (0, import_jsx_runtime113.jsx)('canvas', {
		ref: rCanvas,
		width: app.viewportScreenBounds.width,
		height: app.viewportScreenBounds.height,
		style: { width: '100%', height: '100%' },
	})
})
function dot(ctx, x3, y3, color = '#000') {
	ctx.save()
	ctx.beginPath()
	ctx.ellipse(x3, y3, 4, 4, 0, 0, Math.PI * 2)
	ctx.fillStyle = color
	ctx.fill()
	ctx.restore()
}

// ../packages/ui/src/lib/hooks/useHighDpiCanvas.ts
init_define_process()
var import_react112 = __toESM(require_react())

// ../packages/tldraw/src/lib/Tldraw.tsx
init_define_process()
var import_react113 = __toESM(require_react())
var import_jsx_runtime114 = __toESM(require_jsx_runtime())
function Tldraw(props) {
	const {
		config,
		children,
		persistenceKey = DEFAULT_DOCUMENT_NAME,
		instanceId = TAB_ID,
		...rest
	} = props
	const _config = (0, import_react113.useMemo)(() => config ?? new TldrawEditorConfig(), [config])
	const syncedStore = useLocalSyncClient({
		instanceId,
		config: _config,
		universalPersistenceKey: persistenceKey,
	})
	return /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(TldrawEditor, {
		...rest,
		instanceId,
		store: syncedStore,
		config: _config,
		children: /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)(TldrawUi, {
			...rest,
			children: [
				/* @__PURE__ */ (0, import_jsx_runtime114.jsx)(ContextMenu, {
					children: /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(Canvas, {}),
				}),
				children,
			],
		}),
	})
}

// src/index.tsx
var import_react114 = __toESM(require_react())
var import_client = __toESM(require_client())

// ../packages/assets/imports.js
init_define_process()

// ../packages/assets/embed-icons/codepen.png
var codepen_default = './codepen-F75FYE3V.png'

// ../packages/assets/embed-icons/codesandbox.png
var codesandbox_default = './codesandbox-XTXJ37KO.png'

// ../packages/assets/embed-icons/excalidraw.png
var excalidraw_default = './excalidraw-XL4NHOJW.png'

// ../packages/assets/embed-icons/felt.png
var felt_default = './felt-YAXTMYRP.png'

// ../packages/assets/embed-icons/figma.png
var figma_default = './figma-YEX4AS3Y.png'

// ../packages/assets/embed-icons/github_gist.png
var github_gist_default = './github_gist-J3DR2ZDJ.png'

// ../packages/assets/embed-icons/google_calendar.png
var google_calendar_default = './google_calendar-VTOZMTEN.png'

// ../packages/assets/embed-icons/google_maps.png
var google_maps_default = './google_maps-HALB726N.png'

// ../packages/assets/embed-icons/google_slides.png
var google_slides_default = './google_slides-RNWJX3XY.png'

// ../packages/assets/embed-icons/observable.png
var observable_default = './observable-ZMVDXS6P.png'

// ../packages/assets/embed-icons/replit.png
var replit_default = './replit-AW7ECK7S.png'

// ../packages/assets/embed-icons/scratch.png
var scratch_default = './scratch-OEIUFB7O.png'

// ../packages/assets/embed-icons/spotify.png
var spotify_default = './spotify-NDV5KDHT.png'

// ../packages/assets/embed-icons/tldraw.png
var tldraw_default = './tldraw-DTFBW7TG.png'

// ../packages/assets/embed-icons/vimeo.png
var vimeo_default = './vimeo-XELEUQDY.png'

// ../packages/assets/embed-icons/youtube.png
var youtube_default = './youtube-WXNPHK6F.png'

// ../packages/assets/fonts/IBMPlexMono-Medium.woff2
var IBMPlexMono_Medium_default = './IBMPlexMono-Medium-F25QH4RB.woff2'

// ../packages/assets/fonts/IBMPlexSans-Medium.woff2
var IBMPlexSans_Medium_default = './IBMPlexSans-Medium-ZIYEN5TL.woff2'

// ../packages/assets/fonts/IBMPlexSerif-Medium.woff2
var IBMPlexSerif_Medium_default = './IBMPlexSerif-Medium-JE3RFW2A.woff2'

// ../packages/assets/fonts/Shantell_Sans-Normal-SemiBold.woff2
var Shantell_Sans_Normal_SemiBold_default = './Shantell_Sans-Normal-SemiBold-D22BEFL4.woff2'

// ../packages/assets/icons/icon/align-bottom-center.svg
var align_bottom_center_default = './align-bottom-center-CSBP6QTZ.svg'

// ../packages/assets/icons/icon/align-bottom-left.svg
var align_bottom_left_default = './align-bottom-left-AHNIB445.svg'

// ../packages/assets/icons/icon/align-bottom-right.svg
var align_bottom_right_default = './align-bottom-right-IHPBZBXI.svg'

// ../packages/assets/icons/icon/align-bottom.svg
var align_bottom_default = './align-bottom-R257ONEK.svg'

// ../packages/assets/icons/icon/align-center-center.svg
var align_center_center_default = './align-center-center-VCLNOO2W.svg'

// ../packages/assets/icons/icon/align-center-horizontal.svg
var align_center_horizontal_default = './align-center-horizontal-5VHTDUMJ.svg'

// ../packages/assets/icons/icon/align-center-left.svg
var align_center_left_default = './align-center-left-42VN7ECS.svg'

// ../packages/assets/icons/icon/align-center-right.svg
var align_center_right_default = './align-center-right-4FGKFC5X.svg'

// ../packages/assets/icons/icon/align-center-vertical.svg
var align_center_vertical_default = './align-center-vertical-GMWASLGB.svg'

// ../packages/assets/icons/icon/align-left.svg
var align_left_default = './align-left-5HEFCE7W.svg'

// ../packages/assets/icons/icon/align-right.svg
var align_right_default = './align-right-72DPSEA4.svg'

// ../packages/assets/icons/icon/align-top-center.svg
var align_top_center_default = './align-top-center-GCY6SXO6.svg'

// ../packages/assets/icons/icon/align-top-left.svg
var align_top_left_default = './align-top-left-QX3PPIRZ.svg'

// ../packages/assets/icons/icon/align-top-right.svg
var align_top_right_default = './align-top-right-KZH6VKZS.svg'

// ../packages/assets/icons/icon/align-top.svg
var align_top_default = './align-top-EGCVQVP7.svg'

// ../packages/assets/icons/icon/arrow-left.svg
var arrow_left_default = './arrow-left-WXBKOZZ3.svg'

// ../packages/assets/icons/icon/arrowhead-arrow.svg
var arrowhead_arrow_default = './arrowhead-arrow-HVXKBQ5X.svg'

// ../packages/assets/icons/icon/arrowhead-bar.svg
var arrowhead_bar_default = './arrowhead-bar-3CTU5K5M.svg'

// ../packages/assets/icons/icon/arrowhead-diamond.svg
var arrowhead_diamond_default = './arrowhead-diamond-NK2JB2H3.svg'

// ../packages/assets/icons/icon/arrowhead-dot.svg
var arrowhead_dot_default = './arrowhead-dot-EZWTRDT6.svg'

// ../packages/assets/icons/icon/arrowhead-none.svg
var arrowhead_none_default = './arrowhead-none-V2X57KDJ.svg'

// ../packages/assets/icons/icon/arrowhead-square.svg
var arrowhead_square_default = './arrowhead-square-YRMYHYGM.svg'

// ../packages/assets/icons/icon/arrowhead-triangle-inverted.svg
var arrowhead_triangle_inverted_default = './arrowhead-triangle-inverted-K4DOKJE3.svg'

// ../packages/assets/icons/icon/arrowhead-triangle.svg
var arrowhead_triangle_default = './arrowhead-triangle-KBOFPZWU.svg'

// ../packages/assets/icons/icon/aspect-ratio.svg
var aspect_ratio_default = './aspect-ratio-TLDHMBOA.svg'

// ../packages/assets/icons/icon/avatar.svg
var avatar_default = './avatar-SR2HBC7K.svg'

// ../packages/assets/icons/icon/blob.svg
var blob_default = './blob-SNMNIYW3.svg'

// ../packages/assets/icons/icon/bring-forward.svg
var bring_forward_default = './bring-forward-ORK5HVGK.svg'

// ../packages/assets/icons/icon/bring-to-front.svg
var bring_to_front_default = './bring-to-front-6GSLYX2K.svg'

// ../packages/assets/icons/icon/check.svg
var check_default = './check-MJKLH5SR.svg'

// ../packages/assets/icons/icon/checkbox-checked.svg
var checkbox_checked_default = './checkbox-checked-5PBUY3Y7.svg'

// ../packages/assets/icons/icon/checkbox-empty.svg
var checkbox_empty_default = './checkbox-empty-TQVZAZ6A.svg'

// ../packages/assets/icons/icon/chevron-down.svg
var chevron_down_default = './chevron-down-AEDWWYCO.svg'

// ../packages/assets/icons/icon/chevron-left.svg
var chevron_left_default = './chevron-left-YCK4SACI.svg'

// ../packages/assets/icons/icon/chevron-right.svg
var chevron_right_default = './chevron-right-EFDMDQQM.svg'

// ../packages/assets/icons/icon/chevron-up.svg
var chevron_up_default = './chevron-up-Y35TAHPL.svg'

// ../packages/assets/icons/icon/chevrons-ne.svg
var chevrons_ne_default = './chevrons-ne-S5YHLDEF.svg'

// ../packages/assets/icons/icon/chevrons-sw.svg
var chevrons_sw_default = './chevrons-sw-AS5SQCAQ.svg'

// ../packages/assets/icons/icon/clipboard-copied.svg
var clipboard_copied_default = './clipboard-copied-NRCIIFUH.svg'

// ../packages/assets/icons/icon/clipboard-copy.svg
var clipboard_copy_default = './clipboard-copy-IDTLWT5R.svg'

// ../packages/assets/icons/icon/code.svg
var code_default = './code-PAX667R5.svg'

// ../packages/assets/icons/icon/collab.svg
var collab_default = './collab-AWBOOTTN.svg'

// ../packages/assets/icons/icon/color.svg
var color_default = './color-C2MERTHH.svg'

// ../packages/assets/icons/icon/comment.svg
var comment_default = './comment-PZLNENXF.svg'

// ../packages/assets/icons/icon/cross-2.svg
var cross_2_default = './cross-2-WTELNK2S.svg'

// ../packages/assets/icons/icon/cross.svg
var cross_default = './cross-XALPFMSI.svg'

// ../packages/assets/icons/icon/dash-dashed.svg
var dash_dashed_default = './dash-dashed-T4FQN6V6.svg'

// ../packages/assets/icons/icon/dash-dotted.svg
var dash_dotted_default = './dash-dotted-S6I3OK6V.svg'

// ../packages/assets/icons/icon/dash-draw.svg
var dash_draw_default = './dash-draw-J433ABMT.svg'

// ../packages/assets/icons/icon/dash-solid.svg
var dash_solid_default = './dash-solid-A2CYPN3Y.svg'

// ../packages/assets/icons/icon/discord.svg
var discord_default = './discord-GTFVFCES.svg'

// ../packages/assets/icons/icon/distribute-horizontal.svg
var distribute_horizontal_default = './distribute-horizontal-VVKJEIWP.svg'

// ../packages/assets/icons/icon/distribute-vertical.svg
var distribute_vertical_default = './distribute-vertical-KIBWN6LC.svg'

// ../packages/assets/icons/icon/dot.svg
var dot_default = './dot-JIBX5YKB.svg'

// ../packages/assets/icons/icon/dots-horizontal.svg
var dots_horizontal_default = './dots-horizontal-TJ5CT2HQ.svg'

// ../packages/assets/icons/icon/dots-vertical.svg
var dots_vertical_default = './dots-vertical-HFP5CX3R.svg'

// ../packages/assets/icons/icon/drag-handle-dots.svg
var drag_handle_dots_default = './drag-handle-dots-5SIPN6GZ.svg'

// ../packages/assets/icons/icon/duplicate.svg
var duplicate_default = './duplicate-7PYPTSEE.svg'

// ../packages/assets/icons/icon/edit.svg
var edit_default = './edit-UMAZLCJY.svg'

// ../packages/assets/icons/icon/external-link.svg
var external_link_default = './external-link-BMQKUVXV.svg'

// ../packages/assets/icons/icon/file.svg
var file_default = './file-LTENAHJE.svg'

// ../packages/assets/icons/icon/fill-none.svg
var fill_none_default = './fill-none-QXN252XI.svg'

// ../packages/assets/icons/icon/fill-pattern.svg
var fill_pattern_default = './fill-pattern-ZQVGLBIQ.svg'

// ../packages/assets/icons/icon/fill-semi.svg
var fill_semi_default = './fill-semi-3TBWK7BX.svg'

// ../packages/assets/icons/icon/fill-solid.svg
var fill_solid_default = './fill-solid-CM3AOVVJ.svg'

// ../packages/assets/icons/icon/follow.svg
var follow_default = './follow-SO6ZXSIY.svg'

// ../packages/assets/icons/icon/following.svg
var following_default = './following-3XSTNMGV.svg'

// ../packages/assets/icons/icon/font-draw.svg
var font_draw_default = './font-draw-3A77N2BF.svg'

// ../packages/assets/icons/icon/font-mono.svg
var font_mono_default = './font-mono-ZGMLFTH2.svg'

// ../packages/assets/icons/icon/font-sans.svg
var font_sans_default = './font-sans-IBKENC3S.svg'

// ../packages/assets/icons/icon/font-serif.svg
var font_serif_default = './font-serif-H5DCWABA.svg'

// ../packages/assets/icons/icon/geo-arrow-down.svg
var geo_arrow_down_default = './geo-arrow-down-MKGVU75B.svg'

// ../packages/assets/icons/icon/geo-arrow-left.svg
var geo_arrow_left_default = './geo-arrow-left-PIJP74PH.svg'

// ../packages/assets/icons/icon/geo-arrow-right.svg
var geo_arrow_right_default = './geo-arrow-right-M65DKF6Q.svg'

// ../packages/assets/icons/icon/geo-arrow-up.svg
var geo_arrow_up_default = './geo-arrow-up-5IN7Z4LD.svg'

// ../packages/assets/icons/icon/geo-check-box.svg
var geo_check_box_default = './geo-check-box-IL7YZFE5.svg'

// ../packages/assets/icons/icon/geo-diamond.svg
var geo_diamond_default = './geo-diamond-4TYP6MOF.svg'

// ../packages/assets/icons/icon/geo-ellipse.svg
var geo_ellipse_default = './geo-ellipse-Q23XPT2V.svg'

// ../packages/assets/icons/icon/geo-hexagon.svg
var geo_hexagon_default = './geo-hexagon-XMFBQVVM.svg'

// ../packages/assets/icons/icon/geo-octagon.svg
var geo_octagon_default = './geo-octagon-YJ44SLUA.svg'

// ../packages/assets/icons/icon/geo-oval.svg
var geo_oval_default = './geo-oval-SYOXXWFS.svg'

// ../packages/assets/icons/icon/geo-pentagon.svg
var geo_pentagon_default = './geo-pentagon-43OK57W2.svg'

// ../packages/assets/icons/icon/geo-rectangle.svg
var geo_rectangle_default = './geo-rectangle-FI77PTXK.svg'

// ../packages/assets/icons/icon/geo-rhombus-2.svg
var geo_rhombus_2_default = './geo-rhombus-2-CPKCBYZS.svg'

// ../packages/assets/icons/icon/geo-rhombus.svg
var geo_rhombus_default = './geo-rhombus-V3CIWP3W.svg'

// ../packages/assets/icons/icon/geo-star.svg
var geo_star_default = './geo-star-RJCHP24Q.svg'

// ../packages/assets/icons/icon/geo-trapezoid.svg
var geo_trapezoid_default = './geo-trapezoid-KQL3QW3P.svg'

// ../packages/assets/icons/icon/geo-triangle.svg
var geo_triangle_default = './geo-triangle-XQNOYI6T.svg'

// ../packages/assets/icons/icon/geo-x-box.svg
var geo_x_box_default = './geo-x-box-HGEG6XBE.svg'

// ../packages/assets/icons/icon/github.svg
var github_default = './github-RDJM6DMJ.svg'

// ../packages/assets/icons/icon/group.svg
var group_default = './group-JGT3FVEG.svg'

// ../packages/assets/icons/icon/hidden.svg
var hidden_default = './hidden-EADDQTOH.svg'

// ../packages/assets/icons/icon/image.svg
var image_default = './image-EUCUCPPZ.svg'

// ../packages/assets/icons/icon/info-circle.svg
var info_circle_default = './info-circle-P6JHAA4T.svg'

// ../packages/assets/icons/icon/leading.svg
var leading_default = './leading-MBFJWTTL.svg'

// ../packages/assets/icons/icon/link.svg
var link_default = './link-52VYRTL2.svg'

// ../packages/assets/icons/icon/lock-small.svg
var lock_small_default = './lock-small-2MVIZCHG.svg'

// ../packages/assets/icons/icon/lock.svg
var lock_default = './lock-SW5QRVCW.svg'

// ../packages/assets/icons/icon/menu.svg
var menu_default = './menu-CPW3VEJN.svg'

// ../packages/assets/icons/icon/minus.svg
var minus_default = './minus-6LPEEEM3.svg'

// ../packages/assets/icons/icon/mixed.svg
var mixed_default = './mixed-AHWYMJE7.svg'

// ../packages/assets/icons/icon/pack.svg
var pack_default = './pack-EIZVYEVQ.svg'

// ../packages/assets/icons/icon/page.svg
var page_default = './page-ZUNLFK67.svg'

// ../packages/assets/icons/icon/plus.svg
var plus_default = './plus-EPRFWZ4V.svg'

// ../packages/assets/icons/icon/question-mark-circle.svg
var question_mark_circle_default = './question-mark-circle-XHRXDOE6.svg'

// ../packages/assets/icons/icon/question-mark.svg
var question_mark_default = './question-mark-W645ZCFD.svg'

// ../packages/assets/icons/icon/redo.svg
var redo_default = './redo-K6YZSD6B.svg'

// ../packages/assets/icons/icon/reset-zoom.svg
var reset_zoom_default = './reset-zoom-ZLHUIWNH.svg'

// ../packages/assets/icons/icon/rotate-ccw.svg
var rotate_ccw_default = './rotate-ccw-FU4E7RON.svg'

// ../packages/assets/icons/icon/rotate-cw.svg
var rotate_cw_default = './rotate-cw-BJSZSRHL.svg'

// ../packages/assets/icons/icon/ruler.svg
var ruler_default = './ruler-NYH6HO34.svg'

// ../packages/assets/icons/icon/search.svg
var search_default = './search-NXQFUKLM.svg'

// ../packages/assets/icons/icon/send-backward.svg
var send_backward_default = './send-backward-EACD3M2B.svg'

// ../packages/assets/icons/icon/send-to-back.svg
var send_to_back_default = './send-to-back-EJSAMA6K.svg'

// ../packages/assets/icons/icon/settings-horizontal.svg
var settings_horizontal_default = './settings-horizontal-PU4HGHHB.svg'

// ../packages/assets/icons/icon/settings-vertical-1.svg
var settings_vertical_1_default = './settings-vertical-1-24HP5CDI.svg'

// ../packages/assets/icons/icon/settings-vertical.svg
var settings_vertical_default = './settings-vertical-BPYUUUAQ.svg'

// ../packages/assets/icons/icon/share-1.svg
var share_1_default = './share-1-G7XIMHPX.svg'

// ../packages/assets/icons/icon/share-2.svg
var share_2_default = './share-2-LB4XZCZM.svg'

// ../packages/assets/icons/icon/size-extra-large.svg
var size_extra_large_default = './size-extra-large-L4T2H4MR.svg'

// ../packages/assets/icons/icon/size-large.svg
var size_large_default = './size-large-W4KDQJNO.svg'

// ../packages/assets/icons/icon/size-medium.svg
var size_medium_default = './size-medium-I7S2MCK6.svg'

// ../packages/assets/icons/icon/size-small.svg
var size_small_default = './size-small-RNHTL6ZK.svg'

// ../packages/assets/icons/icon/spline-cubic.svg
var spline_cubic_default = './spline-cubic-UXHEP6GI.svg'

// ../packages/assets/icons/icon/spline-line.svg
var spline_line_default = './spline-line-EH2NJTGI.svg'

// ../packages/assets/icons/icon/stack-horizontal.svg
var stack_horizontal_default = './stack-horizontal-KHHCBUXI.svg'

// ../packages/assets/icons/icon/stack-vertical.svg
var stack_vertical_default = './stack-vertical-K3UYO556.svg'

// ../packages/assets/icons/icon/stretch-horizontal.svg
var stretch_horizontal_default = './stretch-horizontal-O4PJOCNI.svg'

// ../packages/assets/icons/icon/stretch-vertical.svg
var stretch_vertical_default = './stretch-vertical-NFU642RD.svg'

// ../packages/assets/icons/icon/text-align-center.svg
var text_align_center_default = './text-align-center-NW5IGQZD.svg'

// ../packages/assets/icons/icon/text-align-justify.svg
var text_align_justify_default = './text-align-justify-6B4B3UTH.svg'

// ../packages/assets/icons/icon/text-align-left.svg
var text_align_left_default = './text-align-left-QJDWTFIL.svg'

// ../packages/assets/icons/icon/text-align-right.svg
var text_align_right_default = './text-align-right-AWHH4ZWF.svg'

// ../packages/assets/icons/icon/tool-arrow.svg
var tool_arrow_default = './tool-arrow-OWX4B7S3.svg'

// ../packages/assets/icons/icon/tool-embed.svg
var tool_embed_default = './tool-embed-BGTKSDSH.svg'

// ../packages/assets/icons/icon/tool-eraser.svg
var tool_eraser_default = './tool-eraser-6MM27NOP.svg'

// ../packages/assets/icons/icon/tool-frame.svg
var tool_frame_default = './tool-frame-XDCS2VOF.svg'

// ../packages/assets/icons/icon/tool-hand.svg
var tool_hand_default = './tool-hand-EAE5EAA2.svg'

// ../packages/assets/icons/icon/tool-highlighter.svg
var tool_highlighter_default = './tool-highlighter-AIZKI5CN.svg'

// ../packages/assets/icons/icon/tool-laser.svg
var tool_laser_default = './tool-laser-E6IA4G5X.svg'

// ../packages/assets/icons/icon/tool-line.svg
var tool_line_default = './tool-line-UTQVG34M.svg'

// ../packages/assets/icons/icon/tool-media.svg
var tool_media_default = './tool-media-EUCUCPPZ.svg'

// ../packages/assets/icons/icon/tool-note.svg
var tool_note_default = './tool-note-QJOEKCF3.svg'

// ../packages/assets/icons/icon/tool-pencil.svg
var tool_pencil_default = './tool-pencil-BSFYMW7W.svg'

// ../packages/assets/icons/icon/tool-pointer.svg
var tool_pointer_default = './tool-pointer-YPWFLMHG.svg'

// ../packages/assets/icons/icon/tool-text.svg
var tool_text_default = './tool-text-23UD26ZV.svg'

// ../packages/assets/icons/icon/trash.svg
var trash_default = './trash-2SG6GG6P.svg'

// ../packages/assets/icons/icon/triangle-down.svg
var triangle_down_default = './triangle-down-WWGDWHTE.svg'

// ../packages/assets/icons/icon/triangle-up.svg
var triangle_up_default = './triangle-up-W2RPUBB3.svg'

// ../packages/assets/icons/icon/twitter.svg
var twitter_default = './twitter-LG52VQSV.svg'

// ../packages/assets/icons/icon/undo.svg
var undo_default = './undo-3DFGMHOZ.svg'

// ../packages/assets/icons/icon/ungroup.svg
var ungroup_default = './ungroup-LF5HAADT.svg'

// ../packages/assets/icons/icon/unlock-small.svg
var unlock_small_default = './unlock-small-5TT2XZKU.svg'

// ../packages/assets/icons/icon/unlock.svg
var unlock_default = './unlock-4QZDZP67.svg'

// ../packages/assets/icons/icon/vertical-align-center.svg
var vertical_align_center_default = './vertical-align-center-OSBAQASY.svg'

// ../packages/assets/icons/icon/vertical-align-end.svg
var vertical_align_end_default = './vertical-align-end-BLJIO4IT.svg'

// ../packages/assets/icons/icon/vertical-align-start.svg
var vertical_align_start_default = './vertical-align-start-EI6TNDC2.svg'

// ../packages/assets/icons/icon/visible.svg
var visible_default = './visible-2VDOMDS5.svg'

// ../packages/assets/icons/icon/warning-triangle.svg
var warning_triangle_default = './warning-triangle-XMI6G2GK.svg'

// ../packages/assets/icons/icon/zoom-in.svg
var zoom_in_default = './zoom-in-LZHUWGO6.svg'

// ../packages/assets/icons/icon/zoom-out.svg
var zoom_out_default = './zoom-out-WIBPXGGZ.svg'

// ../packages/assets/translations/ar.json
var ar_default = './ar-VOSRY4W4.json'

// ../packages/assets/translations/ca.json
var ca_default = './ca-NZIXUUUM.json'

// ../packages/assets/translations/da.json
var da_default = './da-LPPYLI6B.json'

// ../packages/assets/translations/de.json
var de_default = './de-5BD6WGEY.json'

// ../packages/assets/translations/en.json
var en_default = './en-PVCBWCM4.json'

// ../packages/assets/translations/es.json
var es_default = './es-JLD5SLUL.json'

// ../packages/assets/translations/fa.json
var fa_default = './fa-XJUTEWT7.json'

// ../packages/assets/translations/fi.json
var fi_default = './fi-5XD6N2AX.json'

// ../packages/assets/translations/fr.json
var fr_default = './fr-T7Y7TWDV.json'

// ../packages/assets/translations/gl.json
var gl_default = './gl-R7SP2OGE.json'

// ../packages/assets/translations/he.json
var he_default = './he-EOVECWK2.json'

// ../packages/assets/translations/hi-in.json
var hi_in_default = './hi-in-TPBLGCVY.json'

// ../packages/assets/translations/hu.json
var hu_default = './hu-RWQGTMFT.json'

// ../packages/assets/translations/it.json
var it_default = './it-4PH4C55E.json'

// ../packages/assets/translations/ja.json
var ja_default = './ja-LNIENWNB.json'

// ../packages/assets/translations/ko-kr.json
var ko_kr_default = './ko-kr-KR4STE5N.json'

// ../packages/assets/translations/ku.json
var ku_default = './ku-YDV2MT34.json'

// ../packages/assets/translations/languages.json
var languages_default = './languages-W42A3KLE.json'

// ../packages/assets/translations/main.json
var main_default = './main-YZSLS6WO.json'

// ../packages/assets/translations/my.json
var my_default = './my-F6IIYM24.json'

// ../packages/assets/translations/ne.json
var ne_default = './ne-GQHITCAM.json'

// ../packages/assets/translations/no.json
var no_default = './no-IAKVOKY6.json'

// ../packages/assets/translations/pl.json
var pl_default = './pl-AC4KFR3W.json'

// ../packages/assets/translations/pt-br.json
var pt_br_default = './pt-br-RXGTOYMH.json'

// ../packages/assets/translations/pt-pt.json
var pt_pt_default = './pt-pt-K2243WHY.json'

// ../packages/assets/translations/ro.json
var ro_default = './ro-5ZHBLSMT.json'

// ../packages/assets/translations/ru.json
var ru_default = './ru-LKXK7C3F.json'

// ../packages/assets/translations/sv.json
var sv_default = './sv-EDIPKQSY.json'

// ../packages/assets/translations/te.json
var te_default = './te-AJVYJ424.json'

// ../packages/assets/translations/th.json
var th_default = './th-TNSAMBXT.json'

// ../packages/assets/translations/tr.json
var tr_default = './tr-KR4RQMSL.json'

// ../packages/assets/translations/uk.json
var uk_default = './uk-NUOI6P36.json'

// ../packages/assets/translations/vi.json
var vi_default = './vi-4JSRDEJ5.json'

// ../packages/assets/translations/zh-cn.json
var zh_cn_default = './zh-cn-BHBINMCV.json'

// ../packages/assets/translations/zh-tw.json
var zh_tw_default = './zh-tw-DFQP5PF3.json'

// ../packages/assets/imports.js
function formatAssetUrl(assetUrl, format = {}) {
	const assetUrlString = typeof assetUrl === 'string' ? assetUrl : assetUrl.src
	if (typeof format === 'function') return format(assetUrlString)
	const { baseUrl = '' } = format
	if (assetUrlString.startsWith('data:')) return assetUrlString
	if (assetUrlString.match(/^https?:\/\//)) return assetUrlString
	return `${baseUrl.replace(/\/$/, '')}/${assetUrlString.replace(/^\.?\//, '')}`
}
function getAssetUrlsByImport(opts) {
	return {
		fonts: {
			monospace: formatAssetUrl(IBMPlexMono_Medium_default, opts),
			sansSerif: formatAssetUrl(IBMPlexSans_Medium_default, opts),
			serif: formatAssetUrl(IBMPlexSerif_Medium_default, opts),
			draw: formatAssetUrl(Shantell_Sans_Normal_SemiBold_default, opts),
		},
		icons: {
			'align-bottom-center': formatAssetUrl(align_bottom_center_default, opts),
			'align-bottom-left': formatAssetUrl(align_bottom_left_default, opts),
			'align-bottom-right': formatAssetUrl(align_bottom_right_default, opts),
			'align-bottom': formatAssetUrl(align_bottom_default, opts),
			'align-center-center': formatAssetUrl(align_center_center_default, opts),
			'align-center-horizontal': formatAssetUrl(align_center_horizontal_default, opts),
			'align-center-left': formatAssetUrl(align_center_left_default, opts),
			'align-center-right': formatAssetUrl(align_center_right_default, opts),
			'align-center-vertical': formatAssetUrl(align_center_vertical_default, opts),
			'align-left': formatAssetUrl(align_left_default, opts),
			'align-right': formatAssetUrl(align_right_default, opts),
			'align-top-center': formatAssetUrl(align_top_center_default, opts),
			'align-top-left': formatAssetUrl(align_top_left_default, opts),
			'align-top-right': formatAssetUrl(align_top_right_default, opts),
			'align-top': formatAssetUrl(align_top_default, opts),
			'arrow-left': formatAssetUrl(arrow_left_default, opts),
			'arrowhead-arrow': formatAssetUrl(arrowhead_arrow_default, opts),
			'arrowhead-bar': formatAssetUrl(arrowhead_bar_default, opts),
			'arrowhead-diamond': formatAssetUrl(arrowhead_diamond_default, opts),
			'arrowhead-dot': formatAssetUrl(arrowhead_dot_default, opts),
			'arrowhead-none': formatAssetUrl(arrowhead_none_default, opts),
			'arrowhead-square': formatAssetUrl(arrowhead_square_default, opts),
			'arrowhead-triangle-inverted': formatAssetUrl(arrowhead_triangle_inverted_default, opts),
			'arrowhead-triangle': formatAssetUrl(arrowhead_triangle_default, opts),
			'aspect-ratio': formatAssetUrl(aspect_ratio_default, opts),
			avatar: formatAssetUrl(avatar_default, opts),
			blob: formatAssetUrl(blob_default, opts),
			'bring-forward': formatAssetUrl(bring_forward_default, opts),
			'bring-to-front': formatAssetUrl(bring_to_front_default, opts),
			check: formatAssetUrl(check_default, opts),
			'checkbox-checked': formatAssetUrl(checkbox_checked_default, opts),
			'checkbox-empty': formatAssetUrl(checkbox_empty_default, opts),
			'chevron-down': formatAssetUrl(chevron_down_default, opts),
			'chevron-left': formatAssetUrl(chevron_left_default, opts),
			'chevron-right': formatAssetUrl(chevron_right_default, opts),
			'chevron-up': formatAssetUrl(chevron_up_default, opts),
			'chevrons-ne': formatAssetUrl(chevrons_ne_default, opts),
			'chevrons-sw': formatAssetUrl(chevrons_sw_default, opts),
			'clipboard-copied': formatAssetUrl(clipboard_copied_default, opts),
			'clipboard-copy': formatAssetUrl(clipboard_copy_default, opts),
			code: formatAssetUrl(code_default, opts),
			collab: formatAssetUrl(collab_default, opts),
			color: formatAssetUrl(color_default, opts),
			comment: formatAssetUrl(comment_default, opts),
			'cross-2': formatAssetUrl(cross_2_default, opts),
			cross: formatAssetUrl(cross_default, opts),
			'dash-dashed': formatAssetUrl(dash_dashed_default, opts),
			'dash-dotted': formatAssetUrl(dash_dotted_default, opts),
			'dash-draw': formatAssetUrl(dash_draw_default, opts),
			'dash-solid': formatAssetUrl(dash_solid_default, opts),
			discord: formatAssetUrl(discord_default, opts),
			'distribute-horizontal': formatAssetUrl(distribute_horizontal_default, opts),
			'distribute-vertical': formatAssetUrl(distribute_vertical_default, opts),
			dot: formatAssetUrl(dot_default, opts),
			'dots-horizontal': formatAssetUrl(dots_horizontal_default, opts),
			'dots-vertical': formatAssetUrl(dots_vertical_default, opts),
			'drag-handle-dots': formatAssetUrl(drag_handle_dots_default, opts),
			duplicate: formatAssetUrl(duplicate_default, opts),
			edit: formatAssetUrl(edit_default, opts),
			'external-link': formatAssetUrl(external_link_default, opts),
			file: formatAssetUrl(file_default, opts),
			'fill-none': formatAssetUrl(fill_none_default, opts),
			'fill-pattern': formatAssetUrl(fill_pattern_default, opts),
			'fill-semi': formatAssetUrl(fill_semi_default, opts),
			'fill-solid': formatAssetUrl(fill_solid_default, opts),
			follow: formatAssetUrl(follow_default, opts),
			following: formatAssetUrl(following_default, opts),
			'font-draw': formatAssetUrl(font_draw_default, opts),
			'font-mono': formatAssetUrl(font_mono_default, opts),
			'font-sans': formatAssetUrl(font_sans_default, opts),
			'font-serif': formatAssetUrl(font_serif_default, opts),
			'geo-arrow-down': formatAssetUrl(geo_arrow_down_default, opts),
			'geo-arrow-left': formatAssetUrl(geo_arrow_left_default, opts),
			'geo-arrow-right': formatAssetUrl(geo_arrow_right_default, opts),
			'geo-arrow-up': formatAssetUrl(geo_arrow_up_default, opts),
			'geo-check-box': formatAssetUrl(geo_check_box_default, opts),
			'geo-diamond': formatAssetUrl(geo_diamond_default, opts),
			'geo-ellipse': formatAssetUrl(geo_ellipse_default, opts),
			'geo-hexagon': formatAssetUrl(geo_hexagon_default, opts),
			'geo-octagon': formatAssetUrl(geo_octagon_default, opts),
			'geo-oval': formatAssetUrl(geo_oval_default, opts),
			'geo-pentagon': formatAssetUrl(geo_pentagon_default, opts),
			'geo-rectangle': formatAssetUrl(geo_rectangle_default, opts),
			'geo-rhombus-2': formatAssetUrl(geo_rhombus_2_default, opts),
			'geo-rhombus': formatAssetUrl(geo_rhombus_default, opts),
			'geo-star': formatAssetUrl(geo_star_default, opts),
			'geo-trapezoid': formatAssetUrl(geo_trapezoid_default, opts),
			'geo-triangle': formatAssetUrl(geo_triangle_default, opts),
			'geo-x-box': formatAssetUrl(geo_x_box_default, opts),
			github: formatAssetUrl(github_default, opts),
			group: formatAssetUrl(group_default, opts),
			hidden: formatAssetUrl(hidden_default, opts),
			image: formatAssetUrl(image_default, opts),
			'info-circle': formatAssetUrl(info_circle_default, opts),
			leading: formatAssetUrl(leading_default, opts),
			link: formatAssetUrl(link_default, opts),
			'lock-small': formatAssetUrl(lock_small_default, opts),
			lock: formatAssetUrl(lock_default, opts),
			menu: formatAssetUrl(menu_default, opts),
			minus: formatAssetUrl(minus_default, opts),
			mixed: formatAssetUrl(mixed_default, opts),
			pack: formatAssetUrl(pack_default, opts),
			page: formatAssetUrl(page_default, opts),
			plus: formatAssetUrl(plus_default, opts),
			'question-mark-circle': formatAssetUrl(question_mark_circle_default, opts),
			'question-mark': formatAssetUrl(question_mark_default, opts),
			redo: formatAssetUrl(redo_default, opts),
			'reset-zoom': formatAssetUrl(reset_zoom_default, opts),
			'rotate-ccw': formatAssetUrl(rotate_ccw_default, opts),
			'rotate-cw': formatAssetUrl(rotate_cw_default, opts),
			ruler: formatAssetUrl(ruler_default, opts),
			search: formatAssetUrl(search_default, opts),
			'send-backward': formatAssetUrl(send_backward_default, opts),
			'send-to-back': formatAssetUrl(send_to_back_default, opts),
			'settings-horizontal': formatAssetUrl(settings_horizontal_default, opts),
			'settings-vertical-1': formatAssetUrl(settings_vertical_1_default, opts),
			'settings-vertical': formatAssetUrl(settings_vertical_default, opts),
			'share-1': formatAssetUrl(share_1_default, opts),
			'share-2': formatAssetUrl(share_2_default, opts),
			'size-extra-large': formatAssetUrl(size_extra_large_default, opts),
			'size-large': formatAssetUrl(size_large_default, opts),
			'size-medium': formatAssetUrl(size_medium_default, opts),
			'size-small': formatAssetUrl(size_small_default, opts),
			'spline-cubic': formatAssetUrl(spline_cubic_default, opts),
			'spline-line': formatAssetUrl(spline_line_default, opts),
			'stack-horizontal': formatAssetUrl(stack_horizontal_default, opts),
			'stack-vertical': formatAssetUrl(stack_vertical_default, opts),
			'stretch-horizontal': formatAssetUrl(stretch_horizontal_default, opts),
			'stretch-vertical': formatAssetUrl(stretch_vertical_default, opts),
			'text-align-center': formatAssetUrl(text_align_center_default, opts),
			'text-align-justify': formatAssetUrl(text_align_justify_default, opts),
			'text-align-left': formatAssetUrl(text_align_left_default, opts),
			'text-align-right': formatAssetUrl(text_align_right_default, opts),
			'tool-arrow': formatAssetUrl(tool_arrow_default, opts),
			'tool-embed': formatAssetUrl(tool_embed_default, opts),
			'tool-eraser': formatAssetUrl(tool_eraser_default, opts),
			'tool-frame': formatAssetUrl(tool_frame_default, opts),
			'tool-hand': formatAssetUrl(tool_hand_default, opts),
			'tool-highlighter': formatAssetUrl(tool_highlighter_default, opts),
			'tool-laser': formatAssetUrl(tool_laser_default, opts),
			'tool-line': formatAssetUrl(tool_line_default, opts),
			'tool-media': formatAssetUrl(tool_media_default, opts),
			'tool-note': formatAssetUrl(tool_note_default, opts),
			'tool-pencil': formatAssetUrl(tool_pencil_default, opts),
			'tool-pointer': formatAssetUrl(tool_pointer_default, opts),
			'tool-text': formatAssetUrl(tool_text_default, opts),
			trash: formatAssetUrl(trash_default, opts),
			'triangle-down': formatAssetUrl(triangle_down_default, opts),
			'triangle-up': formatAssetUrl(triangle_up_default, opts),
			twitter: formatAssetUrl(twitter_default, opts),
			undo: formatAssetUrl(undo_default, opts),
			ungroup: formatAssetUrl(ungroup_default, opts),
			'unlock-small': formatAssetUrl(unlock_small_default, opts),
			unlock: formatAssetUrl(unlock_default, opts),
			'vertical-align-center': formatAssetUrl(vertical_align_center_default, opts),
			'vertical-align-end': formatAssetUrl(vertical_align_end_default, opts),
			'vertical-align-start': formatAssetUrl(vertical_align_start_default, opts),
			visible: formatAssetUrl(visible_default, opts),
			'warning-triangle': formatAssetUrl(warning_triangle_default, opts),
			'zoom-in': formatAssetUrl(zoom_in_default, opts),
			'zoom-out': formatAssetUrl(zoom_out_default, opts),
		},
		translations: {
			ar: formatAssetUrl(ar_default, opts),
			ca: formatAssetUrl(ca_default, opts),
			da: formatAssetUrl(da_default, opts),
			de: formatAssetUrl(de_default, opts),
			en: formatAssetUrl(en_default, opts),
			es: formatAssetUrl(es_default, opts),
			fa: formatAssetUrl(fa_default, opts),
			fi: formatAssetUrl(fi_default, opts),
			fr: formatAssetUrl(fr_default, opts),
			gl: formatAssetUrl(gl_default, opts),
			he: formatAssetUrl(he_default, opts),
			'hi-in': formatAssetUrl(hi_in_default, opts),
			hu: formatAssetUrl(hu_default, opts),
			it: formatAssetUrl(it_default, opts),
			ja: formatAssetUrl(ja_default, opts),
			'ko-kr': formatAssetUrl(ko_kr_default, opts),
			ku: formatAssetUrl(ku_default, opts),
			languages: formatAssetUrl(languages_default, opts),
			main: formatAssetUrl(main_default, opts),
			my: formatAssetUrl(my_default, opts),
			ne: formatAssetUrl(ne_default, opts),
			no: formatAssetUrl(no_default, opts),
			pl: formatAssetUrl(pl_default, opts),
			'pt-br': formatAssetUrl(pt_br_default, opts),
			'pt-pt': formatAssetUrl(pt_pt_default, opts),
			ro: formatAssetUrl(ro_default, opts),
			ru: formatAssetUrl(ru_default, opts),
			sv: formatAssetUrl(sv_default, opts),
			te: formatAssetUrl(te_default, opts),
			th: formatAssetUrl(th_default, opts),
			tr: formatAssetUrl(tr_default, opts),
			uk: formatAssetUrl(uk_default, opts),
			vi: formatAssetUrl(vi_default, opts),
			'zh-cn': formatAssetUrl(zh_cn_default, opts),
			'zh-tw': formatAssetUrl(zh_tw_default, opts),
		},
		embedIcons: {
			codepen: formatAssetUrl(codepen_default, opts),
			codesandbox: formatAssetUrl(codesandbox_default, opts),
			excalidraw: formatAssetUrl(excalidraw_default, opts),
			felt: formatAssetUrl(felt_default, opts),
			figma: formatAssetUrl(figma_default, opts),
			github_gist: formatAssetUrl(github_gist_default, opts),
			google_calendar: formatAssetUrl(google_calendar_default, opts),
			google_maps: formatAssetUrl(google_maps_default, opts),
			google_slides: formatAssetUrl(google_slides_default, opts),
			observable: formatAssetUrl(observable_default, opts),
			replit: formatAssetUrl(replit_default, opts),
			scratch: formatAssetUrl(scratch_default, opts),
			spotify: formatAssetUrl(spotify_default, opts),
			tldraw: formatAssetUrl(tldraw_default, opts),
			vimeo: formatAssetUrl(vimeo_default, opts),
			youtube: formatAssetUrl(youtube_default, opts),
		},
	}
}

// src/index.tsx
var import_jsx_runtime115 = __toESM(require_jsx_runtime())
var assetUrls = getAssetUrlsByImport()
function Example() {
	const [instanceKey, setInstanceKey] = (0, import_react114.useState)(0)
	;(0, import_react114.useEffect)(() => {
		window.hardReset = () => {
			hardReset({ shouldReload: false })
			setInstanceKey(instanceKey + 1)
		}
	}, [instanceKey])
	return /* @__PURE__ */ (0, import_jsx_runtime115.jsx)('div', {
		className: 'tldraw__editor',
		children: /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(
			Tldraw,
			{ assetUrls, autoFocus: true },
			instanceKey
		),
	})
}
var rootElement = document.getElementById('root')
var root = (0, import_client.createRoot)(rootElement)
root.render(
	/* @__PURE__ */ (0, import_jsx_runtime115.jsx)(import_react114.StrictMode, {
		children: /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(ErrorBoundary, {
			fallback: (error) =>
				/* @__PURE__ */ (0, import_jsx_runtime115.jsx)(DefaultErrorFallback, { error }),
			onError: (error) => console.error(error),
			children: /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(Example, {}),
		}),
	})
)
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=index.js.map
