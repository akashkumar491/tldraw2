## API Report File for "@tldraw/primitives"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Box2dModel } from '@tldraw/tlschema';
import { Vec2dModel } from '@tldraw/tlschema';

// @public
export function angleDelta(a0: number, a1: number): number;

// @public
export function approximately(a: number, b: number, precision?: number): boolean;

// @public
export function areAnglesCompatible(a: number, b: number): boolean;

// @public (undocumented)
export class Box2d {
    constructor(x?: number, y?: number, w?: number, h?: number);
    // (undocumented)
    get aspectRatio(): number;
    // (undocumented)
    get center(): Vec2d;
    set center(v: Vec2d);
    // (undocumented)
    clone(): Box2d;
    // (undocumented)
    static Collides: (A: Box2d, B: Box2d) => boolean;
    // (undocumented)
    collides(B: Box2d): boolean;
    // (undocumented)
    static Common: (boxes: Box2d[]) => Box2d;
    // (undocumented)
    static Contains: (A: Box2d, B: Box2d) => boolean;
    // (undocumented)
    contains(B: Box2d): boolean;
    // (undocumented)
    static ContainsPoint: (A: Box2d, B: number | VecLike, y?: number) => boolean;
    // (undocumented)
    containsPoint(V: number | VecLike, y?: number): boolean;
    // (undocumented)
    get corners(): Vec2d[];
    // (undocumented)
    static Equals(a: Box2d | Box2dModel, b: Box2d | Box2dModel): boolean;
    // (undocumented)
    equals(other: Box2d | Box2dModel): boolean;
    // (undocumented)
    static Expand(A: Box2d, B: Box2d): Box2d;
    // (undocumented)
    expand(A: Box2d): this;
    // (undocumented)
    static ExpandBy(A: Box2d, n: number): Box2d;
    // (undocumented)
    expandBy(n: number): this;
    // (undocumented)
    static From(box: Box2dModel): Box2d;
    // (undocumented)
    static FromPoints(points: VecLike[]): Box2d;
    // (undocumented)
    getHandlePoint(handle: SelectionCorner | SelectionEdge): Vec2d;
    // (undocumented)
    h: number;
    // (undocumented)
    get height(): number;
    set height(n: number);
    // (undocumented)
    static Includes: (A: Box2d, B: Box2d) => boolean;
    // (undocumented)
    includes(B: Box2d): boolean;
    // (undocumented)
    get maxX(): number;
    // (undocumented)
    get maxY(): number;
    // (undocumented)
    get midX(): number;
    // (undocumented)
    get midY(): number;
    // (undocumented)
    get minX(): number;
    set minX(n: number);
    // (undocumented)
    get minY(): number;
    set minY(n: number);
    // (undocumented)
    get point(): Vec2d;
    set point(val: Vec2d);
    // (undocumented)
    static Resize(box: Box2d, handle: SelectionCorner | SelectionEdge | string, dx: number, dy: number, isAspectRatioLocked?: boolean): {
        box: Box2d;
        scaleX: number;
        scaleY: number;
    };
    // (undocumented)
    resize(handle: SelectionCorner | SelectionEdge | string, dx: number, dy: number): void;
    // (undocumented)
    scale(n: number): this;
    // (undocumented)
    set(x?: number, y?: number, w?: number, h?: number): this;
    // (undocumented)
    setTo(B: Box2d): this;
    // (undocumented)
    static Sides: (A: Box2d, inset?: number) => Vec2d[][];
    // (undocumented)
    get sides(): Array<[Vec2d, Vec2d]>;
    // (undocumented)
    get size(): Vec2d;
    // (undocumented)
    get snapPoints(): Vec2d[];
    // (undocumented)
    snapToGrid(size: number): void;
    // (undocumented)
    toFixed(): this;
    // (undocumented)
    toJson(): Box2dModel;
    // (undocumented)
    translate(delta: VecLike): this;
    // (undocumented)
    union(box: Box2dModel): this;
    // (undocumented)
    w: number;
    // (undocumented)
    get width(): number;
    set width(n: number);
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export function canolicalizeRotation(a: number): number;

// @public
export function clamp(n: number, min: number): number;

// @public
export function clamp(n: number, min: number, max: number): number;

// @public
export function clampRadians(r: number): number;

// @public (undocumented)
export class CubicSegment2d extends BaseSegment2d<CubicSegment2dModel> {
    // (undocumented)
    [Symbol.iterator]: (this: InstanceType<typeof CubicSegment2d>) => Generator<VecLike, void, undefined>;
    constructor(a: VecLike, b: VecLike, c: VecLike, d: VecLike, p?: number);
    // (undocumented)
    getPath(head?: boolean): string;
    // (undocumented)
    getPoint(t: number): Vec2d;
    // (undocumented)
    getX(t: number): number;
    // (undocumented)
    getY(t: number): number;
}

// @public (undocumented)
export interface CubicSegment2dModel {
    // (undocumented)
    a: VecLike;
    // (undocumented)
    b: VecLike;
    // (undocumented)
    c: VecLike;
    // (undocumented)
    d: VecLike;
    // (undocumented)
    p: number;
}

// @public (undocumented)
export class CubicSpline2d extends BaseSpline2d<CubicSegment2dModel> {
    constructor(points: VecLike[], k?: number, p?: number);
    // (undocumented)
    static FromPoints(points: Vec2d[]): CubicSpline2d;
    // (undocumented)
    getSegmentsFromPoints(points: VecLike[], k?: number, p?: number): CubicSegment2d[];
    // (undocumented)
    segments: CubicSegment2d[];
}

// @public (undocumented)
export function decomposeMatrix2d(m: MatLike): {
    x: number;
    y: number;
    scaleX: number;
    scaleY: number;
    rotation: number;
};

// @public
export function degreesToRadians(d: number): number;

// @public (undocumented)
export const EASINGS: {
    readonly linear: (t: number) => number;
    readonly easeInQuad: (t: number) => number;
    readonly easeOutQuad: (t: number) => number;
    readonly easeInOutQuad: (t: number) => number;
    readonly easeInCubic: (t: number) => number;
    readonly easeOutCubic: (t: number) => number;
    readonly easeInOutCubic: (t: number) => number;
    readonly easeInQuart: (t: number) => number;
    readonly easeOutQuart: (t: number) => number;
    readonly easeInOutQuart: (t: number) => number;
    readonly easeInQuint: (t: number) => number;
    readonly easeOutQuint: (t: number) => number;
    readonly easeInOutQuint: (t: number) => number;
    readonly easeInSine: (t: number) => number;
    readonly easeOutSine: (t: number) => number;
    readonly easeInOutSine: (t: number) => number;
    readonly easeInExpo: (t: number) => number;
    readonly easeOutExpo: (t: number) => number;
    readonly easeInOutExpo: (t: number) => number;
};

// @public (undocumented)
export type EasingType = keyof typeof EASINGS;

// @public (undocumented)
export const EPSILON: number;

// @public (undocumented)
export function flipSelectionHandleX(handle: SelectionHandle): "bottom_left" | "bottom_right" | "bottom" | "left" | "right" | "top_left" | "top_right" | "top";

// @public (undocumented)
export function flipSelectionHandleY(handle: SelectionHandle): "bottom_left" | "bottom_right" | "bottom" | "left" | "right" | "top_left" | "top_right" | "top";

// @public
export function getArcLength(C: VecLike, r: number, A: VecLike, B: VecLike): number;

// @public (undocumented)
export function getDrawLinePathData(id: string, outline: VecLike[], strokeWidth: number): string[];

// @public (undocumented)
export function getHeight(pts: VecLike[]): number;

// @public (undocumented)
export function getMaxX(pts: VecLike[]): number;

// @public (undocumented)
export function getMaxY(pts: VecLike[]): number;

// @public (undocumented)
export function getMidX(pts: VecLike[]): number;

// @public (undocumented)
export function getMidY(pts: VecLike[]): number;

// @public (undocumented)
export function getMinX(pts: VecLike[]): number;

// @public (undocumented)
export function getMinY(pts: VecLike[]): number;

// @public
export function getPointOnCircle(cx: number, cy: number, r: number, a: number): Vec2d;

// @public (undocumented)
export function getPolygonVertices(width: number, height: number, sides: number): Vec2d[];

// @public (undocumented)
export function getRoundedInkyPolygonPath(points: VecLike[]): string;

// @public (undocumented)
export function getRoundedPolygonPoints(id: string, outline: VecLike[], offset: number, roundness: number, passes: number): VecLike[];

// @public
export const getStarBounds: (sides: number, w: number, h: number) => Box2d;

// @public
export function getStroke(points: VecLike[], options?: StrokeOptions): Vec2d[];

// @public
export function getStrokeOutlinePoints(strokePoints: StrokePoint[], options?: StrokeOptions): Vec2d[];

// @public
export function getStrokePoints(rawInputPoints: VecLike[], options?: StrokeOptions): StrokePoint[];

// @public
export function getSweep(C: VecLike, A: VecLike, B: VecLike): number;

// @public (undocumented)
export function getWidth(pts: VecLike[]): number;

// @public
export function intersectCircleCircle(c1: VecLike, r1: number, c2: VecLike, r2: number): Vec2d[];

// @public
export function intersectCirclePolygon(c: VecLike, r: number, points: VecLike[]): null | VecLike[];

// @public
export function intersectCirclePolyline(c: VecLike, r: number, points: VecLike[]): null | VecLike[];

// @public
export function intersectLineSegmentCircle(a1: VecLike, a2: VecLike, c: VecLike, r: number): null | VecLike[];

// @public
export function intersectLineSegmentLineSegment(a1: VecLike, a2: VecLike, b1: VecLike, b2: VecLike): null | Vec2d;

// @public
export function intersectLineSegmentPolygon(a1: VecLike, a2: VecLike, points: VecLike[]): null | VecLike[];

// @public
export function intersectLineSegmentPolyline(a1: VecLike, a2: VecLike, points: VecLike[]): null | VecLike[];

// @public
export function intersectPolygonBounds(points: VecLike[], bounds: Box2d): null | VecLike[];

// @public
export function intersectPolygonPolygon(polygonA: VecLike[], polygonB: VecLike[]): null | VecLike[];

// @public
export function isAngleBetween(a: number, b: number, c: number): boolean;

// @public (undocumented)
export function isSelectionCorner(selection: string): selection is SelectionCorner;

// @public
export function lerpAngles(a0: number, a1: number, t: number): number;

// @public (undocumented)
export class LineSegment2d extends BaseSegment2d<LineSegment2dModel> {
    constructor(a: VecLike, b: VecLike, p?: number);
    // (undocumented)
    a: VecLike;
    // (undocumented)
    static Angle(A: LineSegment2d): number;
    // (undocumented)
    get angle(): number;
    // (undocumented)
    b: VecLike;
    // (undocumented)
    get bounds(): Box2d;
    getClosestPointTo(point: VecLike): {
        point: Vec2d;
        distance: number;
    };
    // (undocumented)
    getNormal(): Vec2d;
    // (undocumented)
    getPath(head?: boolean): string;
    // (undocumented)
    getPoint(t: number): Vec2d;
    // (undocumented)
    getX(t: number): number;
    // (undocumented)
    getY(t: number): number;
    // (undocumented)
    static Length(A: LineSegment2d): number;
    // (undocumented)
    get length(): number;
    // (undocumented)
    static Tangent(A: LineSegment2d): Vec2d;
    // (undocumented)
    get tangent(): Vec2d;
}

// @public (undocumented)
export interface LineSegment2dModel {
    // (undocumented)
    a: VecLike;
    // (undocumented)
    b: VecLike;
    // (undocumented)
    p: number;
}

// @public (undocumented)
export function linesIntersect(A: VecLike, B: VecLike, C: VecLike, D: VecLike): boolean;

// @public
export function longAngleDist(a0: number, a1: number): number;

// @public (undocumented)
export type MatLike = Matrix2d | Matrix2dModel;

// @public (undocumented)
export class Matrix2d {
    constructor(a: number, b: number, c: number, d: number, e: number, f: number);
    // (undocumented)
    a: number;
    // (undocumented)
    static Absolute(m: MatLike): Matrix2dModel;
    // (undocumented)
    static applyToBounds(m: MatLike, box: Box2d): Box2d;
    // (undocumented)
    applyToPoint(point: VecLike): Vec2d;
    // (undocumented)
    static applyToPoint(m: MatLike, point: VecLike): Vec2d;
    // (undocumented)
    applyToPoints(points: VecLike[]): Vec2d[];
    // (undocumented)
    static applyToPoints(m: MatLike, points: VecLike[]): Vec2d[];
    // (undocumented)
    static applyToXY(m: MatLike, x: number, y: number): number[];
    // (undocumented)
    b: number;
    // (undocumented)
    c: number;
    // (undocumented)
    clone(): Matrix2d;
    // (undocumented)
    static Compose(...matrices: MatLike[]): Matrix2d;
    // (undocumented)
    d: number;
    // (undocumented)
    static Decompose(m: MatLike): MatrixInfo;
    // (undocumented)
    decompose(): MatrixInfo;
    // (undocumented)
    decomposed(): MatrixInfo;
    // (undocumented)
    e: number;
    // (undocumented)
    equals(m: Matrix2d | Matrix2dModel): boolean;
    // (undocumented)
    f: number;
    // (undocumented)
    static From(m: MatLike): Matrix2d;
    // (undocumented)
    static Identity(): Matrix2d;
    // (undocumented)
    identity(): this;
    // (undocumented)
    static Inverse(m: Matrix2dModel): Matrix2dModel;
    // (undocumented)
    invert(): this;
    // (undocumented)
    static Multiply(m1: Matrix2dModel, m2: Matrix2dModel): Matrix2dModel;
    // (undocumented)
    multiply(m: Matrix2d | Matrix2dModel): this;
    // (undocumented)
    static Rotate(r: number, cx?: number, cy?: number): Matrix2d;
    // (undocumented)
    rotate(r: number, cx?: number, cy?: number): Matrix2d;
    // (undocumented)
    static Scale: {
        (x: number, y: number): Matrix2dModel;
        (x: number, y: number, cx: number, cy: number): Matrix2dModel;
    };
    // (undocumented)
    scale(x: number, y: number): this;
    // (undocumented)
    setTo(model: Matrix2dModel): this;
    // (undocumented)
    static Smooth(m: MatLike, precision?: number): MatLike;
    // (undocumented)
    toCssString(): string;
    // (undocumented)
    static toCssString(m: MatLike): string;
    // (undocumented)
    static Translate(x: number, y: number): Matrix2d;
    // (undocumented)
    translate(x: number, y: number): Matrix2d;
}

// @public (undocumented)
export interface Matrix2dModel {
    // (undocumented)
    a: number;
    // (undocumented)
    b: number;
    // (undocumented)
    c: number;
    // (undocumented)
    d: number;
    // (undocumented)
    e: number;
    // (undocumented)
    f: number;
}

// @public (undocumented)
export interface MatrixInfo {
    // (undocumented)
    rotation: number;
    // (undocumented)
    scaleX: number;
    // (undocumented)
    scaleY: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public
export function perimeterOfEllipse(rx: number, ry: number): number;

// @public (undocumented)
export const PI: number;

// @public (undocumented)
export const PI2: number;

// @public
export function pointInBounds(A: VecLike, b: Box2d): boolean;

// @public
export function pointInCircle(A: VecLike, C: VecLike, r: number): boolean;

// @public
export function pointInEllipse(A: VecLike, C: VecLike, rx: number, ry: number, rotation?: number): boolean;

// @public
export function pointInPolygon(A: VecLike, points: VecLike[]): boolean;

// @public
export function pointInPolyline(A: VecLike, points: VecLike[], distance?: number): boolean;

// @public
export function pointInRect(A: VecLike, point: VecLike, size: VecLike): boolean;

// @public
export function pointNearToLineSegment(A: VecLike, p1: VecLike, p2: VecLike, distance?: number): boolean;

// @public
export function pointNearToPolyline(A: VecLike, points: VecLike[], distance?: number): boolean;

// @public (undocumented)
export function polygonsIntersect(a: VecLike[], b: VecLike[]): boolean;

// @public (undocumented)
export class Polyline2d extends BaseSpline2d<LineSegment2dModel> {
    constructor(points: VecLike[], k?: number, p?: number);
    // (undocumented)
    static FromPoints(points: VecLike[]): Polyline2d;
    // (undocumented)
    getSegmentsFromPoints(points: VecLike[], p?: number): LineSegment2d[];
    // (undocumented)
    segments: LineSegment2d[];
}

// @public
export function radiansToDegrees(r: number): number;

// @public
export function rangeIntersection(a0: number, a1: number, b0: number, b1: number): [number, number] | null;

// @public (undocumented)
export function rangesOverlap(a0: number, a1: number, b0: number, b1: number): boolean;

// @public (undocumented)
export const ROTATE_CORNER_TO_SELECTION_CORNER: {
    readonly top_left_rotate: "top_left";
    readonly top_right_rotate: "top_right";
    readonly bottom_right_rotate: "bottom_right";
    readonly bottom_left_rotate: "bottom_left";
    readonly mobile_rotate: "top_left";
};

// @public (undocumented)
export type RotateCorner = 'bottom_left_rotate' | 'bottom_right_rotate' | 'mobile_rotate' | 'top_left_rotate' | 'top_right_rotate';

// @public (undocumented)
export function rotateSelectionHandle(handle: SelectionHandle, rotation: number): SelectionHandle;

// @public (undocumented)
export type SelectionCorner = 'bottom_left' | 'bottom_right' | 'top_left' | 'top_right';

// @public (undocumented)
export type SelectionEdge = 'bottom' | 'left' | 'right' | 'top';

// @public (undocumented)
export type SelectionHandle = SelectionCorner | SelectionEdge;

// @public (undocumented)
export function setStrokePointRadii(strokePoints: StrokePoint[], options: StrokeOptions): StrokePoint[];

// @public
export function shortAngleDist(a0: number, a1: number): number;

// @public
export function simplify(points: VecLike[], tolerance?: number): VecLike[];

// @public (undocumented)
export function simplify2(points: VecLike[], tolerance?: number): VecLike[];

// @public (undocumented)
export const SIN: (x: number) => number;

// @public
export function snapAngle(r: number, segments: number): number;

// @public
export interface StrokeOptions {
    easing?: (pressure: number) => number;
    end?: {
        cap?: boolean;
        taper?: boolean | number;
        easing?: (distance: number) => number;
    };
    last?: boolean;
    simulatePressure?: boolean;
    size?: number;
    smoothing?: number;
    start?: {
        cap?: boolean;
        taper?: boolean | number;
        easing?: (distance: number) => number;
    };
    // (undocumented)
    streamline?: number;
    thinning?: number;
}

// @public
export interface StrokePoint {
    // (undocumented)
    distance: number;
    // (undocumented)
    input: Vec2d;
    // (undocumented)
    point: Vec2d;
    // (undocumented)
    pressure: number;
    // (undocumented)
    radius: number;
    // (undocumented)
    runningLength: number;
    // (undocumented)
    vector: Vec2d;
}

// @public (undocumented)
export const TAU: number;

// @public
export function toDomPrecision(v: number): number;

// @public
export function toPrecision(n: number, precision?: number): number;

// @public (undocumented)
export class Vec2d {
    constructor(x?: number, y?: number, z?: number);
    // (undocumented)
    static Abs(A: VecLike): Vec2d;
    // (undocumented)
    abs(): this;
    // (undocumented)
    static Add(A: VecLike, B: VecLike): Vec2d;
    // (undocumented)
    add(V: VecLike): this;
    // (undocumented)
    static AddScalar(A: VecLike, n: number): Vec2d;
    // (undocumented)
    addScalar(n: number): this;
    // (undocumented)
    static AddXY(A: VecLike, x: number, y: number): Vec2d;
    // (undocumented)
    addXY(x: number, y: number): this;
    // (undocumented)
    static Angle(A: VecLike, B: VecLike): number;
    // (undocumented)
    angle(B: VecLike): number;
    // (undocumented)
    static Average(arr: VecLike[]): Vec2d;
    // (undocumented)
    static Cast(A: VecLike): Vec2d;
    // (undocumented)
    static Clamp(A: Vec2d, min: number, max?: number): Vec2d;
    // (undocumented)
    clamp(min: number, max?: number): this;
    // (undocumented)
    static Clockwise(A: VecLike, B: VecLike, C: VecLike): boolean;
    // (undocumented)
    clone(): Vec2d;
    // (undocumented)
    static Cpr(A: VecLike, B: VecLike): number;
    // (undocumented)
    cpr(V: VecLike): number;
    // (undocumented)
    static Cross(A: VecLike, V: VecLike): Vec2d;
    // (undocumented)
    cross(V: VecLike): this;
    // (undocumented)
    static Dist(A: VecLike, B: VecLike): number;
    // (undocumented)
    dist(V: VecLike): number;
    // (undocumented)
    static Dist2(A: VecLike, B: VecLike): number;
    // (undocumented)
    static DistanceToLineSegment(A: VecLike, B: VecLike, P: VecLike, clamp?: boolean): number;
    // (undocumented)
    distanceToLineSegment(A: VecLike, B: VecLike): number;
    // (undocumented)
    static DistanceToLineThroughPoint(A: VecLike, u: VecLike, P: VecLike): number;
    // (undocumented)
    static Div(A: VecLike, t: number): Vec2d;
    // (undocumented)
    div(t: number): this;
    // (undocumented)
    static DivV(A: VecLike, B: VecLike): Vec2d;
    // (undocumented)
    divV(V: VecLike): this;
    // (undocumented)
    static Dpr(A: VecLike, B: VecLike): number;
    // (undocumented)
    dpr(V: VecLike): number;
    // (undocumented)
    static Equals(A: VecLike, B: VecLike): boolean;
    // (undocumented)
    equals(B: VecLike): boolean;
    // (undocumented)
    static EqualsXY(A: VecLike, x: number, y: number): boolean;
    // (undocumented)
    equalsXY(x: number, y: number): boolean;
    // (undocumented)
    static From({ x, y, z }: Vec2dModel): Vec2d;
    // (undocumented)
    static FromArray(v: number[]): Vec2d;
    // (undocumented)
    static Len(A: VecLike): number;
    // (undocumented)
    len(): number;
    // (undocumented)
    static Len2(A: VecLike): number;
    // (undocumented)
    len2(): number;
    // (undocumented)
    static Lrp(A: VecLike, B: VecLike, t: number): Vec2d;
    // (undocumented)
    lrp(B: VecLike, t: number): Vec2d;
    // (undocumented)
    static Max(A: VecLike, B: VecLike): Vec2d;
    // (undocumented)
    static Med(A: VecLike, B: VecLike): Vec2d;
    // (undocumented)
    static Min(A: VecLike, B: VecLike): Vec2d;
    // (undocumented)
    static Mul(A: VecLike, t: number): Vec2d;
    // (undocumented)
    mul(t: number): this;
    // (undocumented)
    static MulV(A: VecLike, B: VecLike): Vec2d;
    // (undocumented)
    mulV(V: VecLike): this;
    // (undocumented)
    static NearestPointOnLineSegment(A: VecLike, B: VecLike, P: VecLike, clamp?: boolean): Vec2d;
    static NearestPointOnLineThroughPoint(A: VecLike, u: VecLike, P: VecLike): Vec2d;
    // (undocumented)
    static Neg(A: VecLike): Vec2d;
    // (undocumented)
    neg(): this;
    // (undocumented)
    norm(): this;
    // (undocumented)
    static Nudge(A: VecLike, B: VecLike, distance: number): Vec2d;
    // (undocumented)
    nudge(B: VecLike, distance: number): this;
    // (undocumented)
    static Per(A: VecLike): Vec2d;
    // (undocumented)
    per(): this;
    static PointsBetween(A: Vec2dModel, B: Vec2dModel, steps?: number): Vec2d[];
    // (undocumented)
    get pressure(): number;
    // (undocumented)
    static Pry(A: VecLike, B: VecLike): number;
    // (undocumented)
    pry(V: VecLike): number;
    // (undocumented)
    static Rescale(A: VecLike, n: number): Vec2d;
    // (undocumented)
    static Rot(A: VecLike, r?: number): Vec2d;
    // (undocumented)
    rot(r: number): this;
    // (undocumented)
    static RotWith(A: VecLike, C: VecLike, r: number): Vec2d;
    // (undocumented)
    rotWith(C: VecLike, r: number): this;
    // (undocumented)
    static ScaleWithOrigin(A: VecLike, scale: number, origin: VecLike): Vec2d;
    // (undocumented)
    set(x?: number, y?: number, z?: number): this;
    // (undocumented)
    setTo({ x, y, z }: VecLike): this;
    // (undocumented)
    static Slope(A: VecLike, B: VecLike): number;
    // (undocumented)
    slope(B: VecLike): number;
    // (undocumented)
    static Snap(A: VecLike, step?: number): Vec2d;
    // (undocumented)
    static SnapToGrid(A: VecLike, gridSize?: number): Vec2d;
    // (undocumented)
    snapToGrid(gridSize: number): this;
    // (undocumented)
    static Sub(A: VecLike, B: VecLike): Vec2d;
    // (undocumented)
    sub(V: VecLike): this;
    // (undocumented)
    static SubScalar(A: VecLike, n: number): Vec2d;
    // (undocumented)
    subScalar(n: number): this;
    // (undocumented)
    static SubXY(A: VecLike, x: number, y: number): Vec2d;
    // (undocumented)
    subXY(x: number, y: number): this;
    // (undocumented)
    static Tan(A: VecLike, B: VecLike): Vec2d;
    // (undocumented)
    tan(V: VecLike): Vec2d;
    // (undocumented)
    static ToAngle(A: VecLike): number;
    // (undocumented)
    toAngle(): number;
    // (undocumented)
    static ToArray(A: VecLike): number[];
    // (undocumented)
    toArray(): number[];
    // (undocumented)
    static ToFixed(A: VecLike, n?: number): Vec2d;
    // (undocumented)
    toFixed(): Vec2d;
    // (undocumented)
    static ToJson(A: VecLike): {
        x: number;
        y: number;
        z: number | undefined;
    };
    // (undocumented)
    toJson(): Vec2dModel;
    // (undocumented)
    static ToString(A: VecLike): string;
    // (undocumented)
    toString(): string;
    // (undocumented)
    static Uni(A: VecLike): Vec2d;
    // (undocumented)
    uni(): Vec2d;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    z: number;
}

// @public (undocumented)
export type VecLike = Vec2d | Vec2dModel;

// (No @packageDocumentation comment for this package)

```
